{"version":3,"names":[],"mappings":"","sources":["app.js"],"sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],2:[function(require,module,exports){\n/*\n * Copyright 2012-2013 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define, location) {\n\t'use strict';\n\n\tvar undef;\n\n\tdefine(function (require) {\n\n\t\tvar mixin, origin, urlRE, absoluteUrlRE, fullyQualifiedUrlRE;\n\n\t\tmixin = require('./util/mixin');\n\n\t\turlRE = /([a-z][a-z0-9\\+\\-\\.]*:)\\/\\/([^@]+@)?(([^:\\/]+)(:([0-9]+))?)?(\\/[^?#]*)?(\\?[^#]*)?(#\\S*)?/i;\n\t\tabsoluteUrlRE = /^([a-z][a-z0-9\\-\\+\\.]*:\\/\\/|\\/)/i;\n\t\tfullyQualifiedUrlRE = /([a-z][a-z0-9\\+\\-\\.]*:)\\/\\/([^@]+@)?(([^:\\/]+)(:([0-9]+))?)?\\//i;\n\n\t\t/**\n\t\t * Apply params to the template to create a URL.\n\t\t *\n\t\t * Parameters that are not applied directly to the template, are appended\n\t\t * to the URL as query string parameters.\n\t\t *\n\t\t * @param {string} template the URI template\n\t\t * @param {Object} params parameters to apply to the template\n\t\t * @return {string} the resulting URL\n\t\t */\n\t\tfunction buildUrl(template, params) {\n\t\t\t// internal builder to convert template with params.\n\t\t\tvar url, name, queryStringParams, re;\n\n\t\t\turl = template;\n\t\t\tqueryStringParams = {};\n\n\t\t\tif (params) {\n\t\t\t\tfor (name in params) {\n\t\t\t\t\t/*jshint forin:false */\n\t\t\t\t\tre = new RegExp('\\\\{' + name + '\\\\}');\n\t\t\t\t\tif (re.test(url)) {\n\t\t\t\t\t\turl = url.replace(re, encodeURIComponent(params[name]), 'g');\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tqueryStringParams[name] = params[name];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (name in queryStringParams) {\n\t\t\t\t\turl += url.indexOf('?') === -1 ? '?' : '&';\n\t\t\t\t\turl += encodeURIComponent(name);\n\t\t\t\t\tif (queryStringParams[name] !== null && queryStringParams[name] !== undefined) {\n\t\t\t\t\t\turl += '=';\n\t\t\t\t\t\turl += encodeURIComponent(queryStringParams[name]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn url;\n\t\t}\n\n\t\tfunction startsWith(str, test) {\n\t\t\treturn str.indexOf(test) === 0;\n\t\t}\n\n\t\t/**\n\t\t * Create a new URL Builder\n\t\t *\n\t\t * @param {string|UrlBuilder} template the base template to build from, may be another UrlBuilder\n\t\t * @param {Object} [params] base parameters\n\t\t * @constructor\n\t\t */\n\t\tfunction UrlBuilder(template, params) {\n\t\t\tif (!(this instanceof UrlBuilder)) {\n\t\t\t\t// invoke as a constructor\n\t\t\t\treturn new UrlBuilder(template, params);\n\t\t\t}\n\n\t\t\tif (template instanceof UrlBuilder) {\n\t\t\t\tthis._template = template.template;\n\t\t\t\tthis._params = mixin({}, this._params, params);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis._template = (template || '').toString();\n\t\t\t\tthis._params = params || {};\n\t\t\t}\n\t\t}\n\n\t\tUrlBuilder.prototype = {\n\n\t\t\t/**\n\t\t\t * Create a new UrlBuilder instance that extends the current builder.\n\t\t\t * The current builder is unmodified.\n\t\t\t *\n\t\t\t * @param {string} [template] URL template to append to the current template\n\t\t\t * @param {Object} [params] params to combine with current params.  New params override existing params\n\t\t\t * @return {UrlBuilder} the new builder\n\t\t\t */\n\t\t\tappend: function (template,  params) {\n\t\t\t\t// TODO consider query strings and fragments\n\t\t\t\treturn new UrlBuilder(this._template + template, mixin({}, this._params, params));\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Create a new UrlBuilder with a fully qualified URL based on the\n\t\t\t * window's location or base href and the current templates relative URL.\n\t\t\t *\n\t\t\t * Path variables are preserved.\n\t\t\t *\n\t\t\t * *Browser only*\n\t\t\t *\n\t\t\t * @return {UrlBuilder} the fully qualified URL template\n\t\t\t */\n\t\t\tfullyQualify: function () {\n\t\t\t\tif (!location) { return this; }\n\t\t\t\tif (this.isFullyQualified()) { return this; }\n\n\t\t\t\tvar template = this._template;\n\n\t\t\t\tif (startsWith(template, '//')) {\n\t\t\t\t\ttemplate = origin.protocol + template;\n\t\t\t\t}\n\t\t\t\telse if (startsWith(template, '/')) {\n\t\t\t\t\ttemplate = origin.origin + template;\n\t\t\t\t}\n\t\t\t\telse if (!this.isAbsolute()) {\n\t\t\t\t\ttemplate = origin.origin + origin.pathname.substring(0, origin.pathname.lastIndexOf('/') + 1);\n\t\t\t\t}\n\n\t\t\t\tif (template.indexOf('/', 8) === -1) {\n\t\t\t\t\t// default the pathname to '/'\n\t\t\t\t\ttemplate = template + '/';\n\t\t\t\t}\n\n\t\t\t\treturn new UrlBuilder(template, this._params);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * True if the URL is absolute\n\t\t\t *\n\t\t\t * @return {boolean}\n\t\t\t */\n\t\t\tisAbsolute: function () {\n\t\t\t\treturn absoluteUrlRE.test(this.build());\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * True if the URL is fully qualified\n\t\t\t *\n\t\t\t * @return {boolean}\n\t\t\t */\n\t\t\tisFullyQualified: function () {\n\t\t\t\treturn fullyQualifiedUrlRE.test(this.build());\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * True if the URL is cross origin. The protocol, host and port must not be\n\t\t\t * the same in order to be cross origin,\n\t\t\t *\n\t\t\t * @return {boolean}\n\t\t\t */\n\t\t\tisCrossOrigin: function () {\n\t\t\t\tif (!origin) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tvar url = this.parts();\n\t\t\t\treturn url.protocol !== origin.protocol ||\n\t\t\t\t       url.hostname !== origin.hostname ||\n\t\t\t\t       url.port !== origin.port;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Split a URL into its consituent parts following the naming convention of\n\t\t\t * 'window.location'. One difference is that the port will contain the\n\t\t\t * protocol default if not specified.\n\t\t\t *\n\t\t\t * @see https://developer.mozilla.org/en-US/docs/DOM/window.location\n\t\t\t *\n\t\t\t * @returns {Object} a 'window.location'-like object\n\t\t\t */\n\t\t\tparts: function () {\n\t\t\t\t/*jshint maxcomplexity:20 */\n\t\t\t\tvar url, parts;\n\t\t\t\turl = this.fullyQualify().build().match(urlRE);\n\t\t\t\tparts = {\n\t\t\t\t\thref: url[0],\n\t\t\t\t\tprotocol: url[1],\n\t\t\t\t\thost: url[3] || '',\n\t\t\t\t\thostname: url[4] || '',\n\t\t\t\t\tport: url[6],\n\t\t\t\t\tpathname: url[7] || '',\n\t\t\t\t\tsearch: url[8] || '',\n\t\t\t\t\thash: url[9] || ''\n\t\t\t\t};\n\t\t\t\tparts.origin = parts.protocol + '//' + parts.host;\n\t\t\t\tparts.port = parts.port || (parts.protocol === 'https:' ? '443' : parts.protocol === 'http:' ? '80' : '');\n\t\t\t\treturn parts;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Expand the template replacing path variables with parameters\n\t\t\t *\n\t\t\t * @param {Object} [params] params to combine with current params.  New params override existing params\n\t\t\t * @return {string} the expanded URL\n\t\t\t */\n\t\t\tbuild: function (params) {\n\t\t\t\treturn buildUrl(this._template, mixin({}, this._params, params));\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * @see build\n\t\t\t */\n\t\t\ttoString: function () {\n\t\t\t\treturn this.build();\n\t\t\t}\n\n\t\t};\n\n\t\torigin = location ? new UrlBuilder(location.href).parts() : undef;\n\n\t\treturn UrlBuilder;\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); },\n\ttypeof window !== 'undefined' ? window.location : void 0\n\t// Boilerplate for AMD and Node\n));\n\n},{\"./util/mixin\":40}],3:[function(require,module,exports){\n/*\n * Copyright 2014 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (require) {\n\n\t\tvar rest = require('./client/default'),\n\t\t    browser = require('./client/xhr');\n\n\t\trest.setPlatformDefaultClient(browser);\n\n\t\treturn rest;\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{\"./client/default\":5,\"./client/xhr\":6}],4:[function(require,module,exports){\n/*\n * Copyright 2014 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (/* require */) {\n\n\t\t/**\n\t\t * Add common helper methods to a client impl\n\t\t *\n\t\t * @param {function} impl the client implementation\n\t\t * @param {Client} [target] target of this client, used when wrapping other clients\n\t\t * @returns {Client} the client impl with additional methods\n\t\t */\n\t\treturn function client(impl, target) {\n\n\t\t\tif (target) {\n\n\t\t\t\t/**\n\t\t\t\t * @returns {Client} the target client\n\t\t\t\t */\n\t\t\t\timpl.skip = function skip() {\n\t\t\t\t\treturn target;\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Allow a client to easily be wrapped by an interceptor\n\t\t\t *\n\t\t\t * @param {Interceptor} interceptor the interceptor to wrap this client with\n\t\t\t * @param [config] configuration for the interceptor\n\t\t\t * @returns {Client} the newly wrapped client\n\t\t\t */\n\t\t\timpl.wrap = function wrap(interceptor, config) {\n\t\t\t\treturn interceptor(impl, config);\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * @deprecated\n\t\t\t */\n\t\t\timpl.chain = function chain() {\n\t\t\t\tif (typeof console !== 'undefined') {\n\t\t\t\t\tconsole.log('rest.js: client.chain() is deprecated, use client.wrap() instead');\n\t\t\t\t}\n\n\t\t\t\treturn impl.wrap.apply(this, arguments);\n\t\t\t};\n\n\t\t\treturn impl;\n\n\t\t};\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{}],5:[function(require,module,exports){\n/*\n * Copyright 2014 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tvar undef;\n\n\tdefine(function (require) {\n\n\t\t/**\n\t\t * Plain JS Object containing properties that represent an HTTP request.\n\t\t *\n\t\t * Depending on the capabilities of the underlying client, a request\n\t\t * may be cancelable. If a request may be canceled, the client will add\n\t\t * a canceled flag and cancel function to the request object. Canceling\n\t\t * the request will put the response into an error state.\n\t\t *\n\t\t * @field {string} [method='GET'] HTTP method, commonly GET, POST, PUT, DELETE or HEAD\n\t\t * @field {string|UrlBuilder} [path=''] path template with optional path variables\n\t\t * @field {Object} [params] parameters for the path template and query string\n\t\t * @field {Object} [headers] custom HTTP headers to send, in addition to the clients default headers\n\t\t * @field [entity] the HTTP entity, common for POST or PUT requests\n\t\t * @field {boolean} [canceled] true if the request has been canceled, set by the client\n\t\t * @field {Function} [cancel] cancels the request if invoked, provided by the client\n\t\t * @field {Client} [originator] the client that first handled this request, provided by the interceptor\n\t\t *\n\t\t * @class Request\n\t\t */\n\n\t\t/**\n\t\t * Plain JS Object containing properties that represent an HTTP response\n\t\t *\n\t\t * @field {Object} [request] the request object as received by the root client\n\t\t * @field {Object} [raw] the underlying request object, like XmlHttpRequest in a browser\n\t\t * @field {number} [status.code] status code of the response (i.e. 200, 404)\n\t\t * @field {string} [status.text] status phrase of the response\n\t\t * @field {Object] [headers] response headers hash of normalized name, value pairs\n\t\t * @field [entity] the response body\n\t\t *\n\t\t * @class Response\n\t\t */\n\n\t\t/**\n\t\t * HTTP client particularly suited for RESTful operations.\n\t\t *\n\t\t * @field {function} wrap wraps this client with a new interceptor returning the wrapped client\n\t\t *\n\t\t * @param {Request} the HTTP request\n\t\t * @returns {ResponsePromise<Response>} a promise the resolves to the HTTP response\n\t\t *\n\t\t * @class Client\n\t\t */\n\n\t\t /**\n\t\t  * Extended when.js Promises/A+ promise with HTTP specific helpers\n\t\t  *q\n\t\t  * @method entity promise for the HTTP entity\n\t\t  * @method status promise for the HTTP status code\n\t\t  * @method headers promise for the HTTP response headers\n\t\t  * @method header promise for a specific HTTP response header\n\t\t  *\n\t\t  * @class ResponsePromise\n\t\t  * @extends Promise\n\t\t  */\n\n\t\tvar client, target, platformDefault;\n\n\t\tclient = require('../client');\n\n\t\t/**\n\t\t * Make a request with the default client\n\t\t * @param {Request} the HTTP request\n\t\t * @returns {Promise<Response>} a promise the resolves to the HTTP response\n\t\t */\n\t\tfunction defaultClient() {\n\t\t\treturn target.apply(undef, arguments);\n\t\t}\n\n\t\t/**\n\t\t * Change the default client\n\t\t * @param {Client} client the new default client\n\t\t */\n\t\tdefaultClient.setDefaultClient = function setDefaultClient(client) {\n\t\t\ttarget = client;\n\t\t};\n\n\t\t/**\n\t\t * Obtain a direct reference to the current default client\n\t\t * @returns {Client} the default client\n\t\t */\n\t\tdefaultClient.getDefaultClient = function getDefaultClient() {\n\t\t\treturn target;\n\t\t};\n\n\t\t/**\n\t\t * Reset the default client to the platform default\n\t\t */\n\t\tdefaultClient.resetDefaultClient = function resetDefaultClient() {\n\t\t\ttarget = platformDefault;\n\t\t};\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tdefaultClient.setPlatformDefaultClient = function setPlatformDefaultClient(client) {\n\t\t\tif (platformDefault) {\n\t\t\t\tthrow new Error('Unable to redefine platformDefaultClient');\n\t\t\t}\n\t\t\ttarget = platformDefault = client;\n\t\t};\n\n\t\treturn client(defaultClient);\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{\"../client\":4}],6:[function(require,module,exports){\n/*\n * Copyright 2012-2014 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define, global) {\n\t'use strict';\n\n\tdefine(function (require) {\n\n\t\tvar when, UrlBuilder, normalizeHeaderName, responsePromise, client, headerSplitRE;\n\n\t\twhen = require('when');\n\t\tUrlBuilder = require('../UrlBuilder');\n\t\tnormalizeHeaderName = require('../util/normalizeHeaderName');\n\t\tresponsePromise = require('../util/responsePromise');\n\t\tclient = require('../client');\n\n\t\t// according to the spec, the line break is '\\r\\n', but doesn't hold true in practice\n\t\theaderSplitRE = /[\\r|\\n]+/;\n\n\t\tfunction parseHeaders(raw) {\n\t\t\t// Note: Set-Cookie will be removed by the browser\n\t\t\tvar headers = {};\n\n\t\t\tif (!raw) { return headers; }\n\n\t\t\traw.trim().split(headerSplitRE).forEach(function (header) {\n\t\t\t\tvar boundary, name, value;\n\t\t\t\tboundary = header.indexOf(':');\n\t\t\t\tname = normalizeHeaderName(header.substring(0, boundary).trim());\n\t\t\t\tvalue = header.substring(boundary + 1).trim();\n\t\t\t\tif (headers[name]) {\n\t\t\t\t\tif (Array.isArray(headers[name])) {\n\t\t\t\t\t\t// add to an existing array\n\t\t\t\t\t\theaders[name].push(value);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// convert single value to array\n\t\t\t\t\t\theaders[name] = [headers[name], value];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// new, single value\n\t\t\t\t\theaders[name] = value;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn headers;\n\t\t}\n\n\t\tfunction safeMixin(target, source) {\n\t\t\tObject.keys(source || {}).forEach(function (prop) {\n\t\t\t\t// make sure the property already exists as\n\t\t\t\t// IE 6 will blow up if we add a new prop\n\t\t\t\tif (source.hasOwnProperty(prop) && prop in target) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttarget[prop] = source[prop];\n\t\t\t\t\t}\n\t\t\t\t\tcatch (e) {\n\t\t\t\t\t\t// ignore, expected for some properties at some points in the request lifecycle\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn target;\n\t\t}\n\n\t\treturn client(function xhr(request) {\n\t\t\treturn responsePromise.promise(function (resolve, reject) {\n\t\t\t\t/*jshint maxcomplexity:20 */\n\n\t\t\t\tvar client, method, url, headers, entity, headerName, response, XMLHttpRequest;\n\n\t\t\t\trequest = typeof request === 'string' ? { path: request } : request || {};\n\t\t\t\tresponse = { request: request };\n\n\t\t\t\tif (request.canceled) {\n\t\t\t\t\tresponse.error = 'precanceled';\n\t\t\t\t\treject(response);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tentity = request.entity;\n\t\t\t\trequest.method = request.method || (entity ? 'POST' : 'GET');\n\t\t\t\tmethod = request.method;\n\t\t\t\turl = response.url = new UrlBuilder(request.path || '', request.params).build();\n\n\t\t\t\tXMLHttpRequest = request.engine || global.XMLHttpRequest;\n\t\t\t\tif (!XMLHttpRequest) {\n\t\t\t\t\treject({ request: request, url: url, error: 'xhr-not-available' });\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tclient = response.raw = new XMLHttpRequest();\n\n\t\t\t\t\t// mixin extra request properties before and after opening the request as some properties require being set at different phases of the request\n\t\t\t\t\tsafeMixin(client, request.mixin);\n\t\t\t\t\tclient.open(method, url, true);\n\t\t\t\t\tsafeMixin(client, request.mixin);\n\n\t\t\t\t\theaders = request.headers;\n\t\t\t\t\tfor (headerName in headers) {\n\t\t\t\t\t\t/*jshint forin:false */\n\t\t\t\t\t\tif (headerName === 'Content-Type' && headers[headerName] === 'multipart/form-data') {\n\t\t\t\t\t\t\t// XMLHttpRequest generates its own Content-Type header with the\n\t\t\t\t\t\t\t// appropriate multipart boundary when sending multipart/form-data.\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tclient.setRequestHeader(headerName, headers[headerName]);\n\t\t\t\t\t}\n\n\t\t\t\t\trequest.canceled = false;\n\t\t\t\t\trequest.cancel = function cancel() {\n\t\t\t\t\t\trequest.canceled = true;\n\t\t\t\t\t\tclient.abort();\n\t\t\t\t\t\treject(response);\n\t\t\t\t\t};\n\n\t\t\t\t\tclient.onreadystatechange = function (/* e */) {\n\t\t\t\t\t\tif (request.canceled) { return; }\n\t\t\t\t\t\tif (client.readyState === (XMLHttpRequest.DONE || 4)) {\n\t\t\t\t\t\t\tresponse.status = {\n\t\t\t\t\t\t\t\tcode: client.status,\n\t\t\t\t\t\t\t\ttext: client.statusText\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tresponse.headers = parseHeaders(client.getAllResponseHeaders());\n\t\t\t\t\t\t\tresponse.entity = client.responseText;\n\n\t\t\t\t\t\t\tif (response.status.code > 0) {\n\t\t\t\t\t\t\t\t// check status code as readystatechange fires before error event\n\t\t\t\t\t\t\t\tresolve(response);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// give the error callback a chance to fire before resolving\n\t\t\t\t\t\t\t\t// requests for file:// URLs do not have a status code\n\t\t\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\t\t\tresolve(response);\n\t\t\t\t\t\t\t\t}, 0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tclient.onerror = function (/* e */) {\n\t\t\t\t\t\t\tresponse.error = 'loaderror';\n\t\t\t\t\t\t\treject(response);\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tcatch (e) {\n\t\t\t\t\t\t// IE 6 will not support error handling\n\t\t\t\t\t}\n\n\t\t\t\t\tclient.send(entity);\n\t\t\t\t}\n\t\t\t\tcatch (e) {\n\t\t\t\t\tresponse.error = 'loaderror';\n\t\t\t\t\treject(response);\n\t\t\t\t}\n\n\t\t\t});\n\t\t});\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); },\n\ttypeof window !== 'undefined' ? window : void 0\n\t// Boilerplate for AMD and Node\n));\n\n},{\"../UrlBuilder\":2,\"../client\":4,\"../util/normalizeHeaderName\":41,\"../util/responsePromise\":42,\"when\":37}],7:[function(require,module,exports){\n/*\n * Copyright 2012-2015 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (require) {\n\n\t\tvar defaultClient, mixin, responsePromise, client, when;\n\n\t\tdefaultClient = require('./client/default');\n\t\tmixin = require('./util/mixin');\n\t\tresponsePromise = require('./util/responsePromise');\n\t\tclient = require('./client');\n\t\twhen = require('when');\n\n\t\t/**\n\t\t * Interceptors have the ability to intercept the request and/org response\n\t\t * objects.  They may augment, prune, transform or replace the\n\t\t * request/response as needed.  Clients may be composed by wrapping\n\t\t * together multiple interceptors.\n\t\t *\n\t\t * Configured interceptors are functional in nature.  Wrapping a client in\n\t\t * an interceptor will not affect the client, merely the data that flows in\n\t\t * and out of that client.  A common configuration can be created once and\n\t\t * shared; specialization can be created by further wrapping that client\n\t\t * with custom interceptors.\n\t\t *\n\t\t * @param {Client} [target] client to wrap\n\t\t * @param {Object} [config] configuration for the interceptor, properties will be specific to the interceptor implementation\n\t\t * @returns {Client} A client wrapped with the interceptor\n\t\t *\n\t\t * @class Interceptor\n\t\t */\n\n\t\tfunction defaultInitHandler(config) {\n\t\t\treturn config;\n\t\t}\n\n\t\tfunction defaultRequestHandler(request /*, config, meta */) {\n\t\t\treturn request;\n\t\t}\n\n\t\tfunction defaultResponseHandler(response /*, config, meta */) {\n\t\t\treturn response;\n\t\t}\n\n\t\tfunction race(promisesOrValues) {\n\t\t\t// this function is different than when.any as the first to reject also wins\n\t\t\treturn when.promise(function (resolve, reject) {\n\t\t\t\tpromisesOrValues.forEach(function (promiseOrValue) {\n\t\t\t\t\twhen(promiseOrValue, resolve, reject);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Alternate return type for the request handler that allows for more complex interactions.\n\t\t *\n\t\t * @param properties.request the traditional request return object\n\t\t * @param {Promise} [properties.abort] promise that resolves if/when the request is aborted\n\t\t * @param {Client} [properties.client] override the defined client with an alternate client\n\t\t * @param [properties.response] response for the request, short circuit the request\n\t\t */\n\t\tfunction ComplexRequest(properties) {\n\t\t\tif (!(this instanceof ComplexRequest)) {\n\t\t\t\t// in case users forget the 'new' don't mix into the interceptor\n\t\t\t\treturn new ComplexRequest(properties);\n\t\t\t}\n\t\t\tmixin(this, properties);\n\t\t}\n\n\t\t/**\n\t\t * Create a new interceptor for the provided handlers.\n\t\t *\n\t\t * @param {Function} [handlers.init] one time intialization, must return the config object\n\t\t * @param {Function} [handlers.request] request handler\n\t\t * @param {Function} [handlers.response] response handler regardless of error state\n\t\t * @param {Function} [handlers.success] response handler when the request is not in error\n\t\t * @param {Function} [handlers.error] response handler when the request is in error, may be used to 'unreject' an error state\n\t\t * @param {Function} [handlers.client] the client to use if otherwise not specified, defaults to platform default client\n\t\t *\n\t\t * @returns {Interceptor}\n\t\t */\n\t\tfunction interceptor(handlers) {\n\n\t\t\tvar initHandler, requestHandler, successResponseHandler, errorResponseHandler;\n\n\t\t\thandlers = handlers || {};\n\n\t\t\tinitHandler            = handlers.init    || defaultInitHandler;\n\t\t\trequestHandler         = handlers.request || defaultRequestHandler;\n\t\t\tsuccessResponseHandler = handlers.success || handlers.response || defaultResponseHandler;\n\t\t\terrorResponseHandler   = handlers.error   || function () {\n\t\t\t\t// Propagate the rejection, with the result of the handler\n\t\t\t\treturn when((handlers.response || defaultResponseHandler).apply(this, arguments), when.reject, when.reject);\n\t\t\t};\n\n\t\t\treturn function (target, config) {\n\n\t\t\t\tif (typeof target === 'object') {\n\t\t\t\t\tconfig = target;\n\t\t\t\t}\n\t\t\t\tif (typeof target !== 'function') {\n\t\t\t\t\ttarget = handlers.client || defaultClient;\n\t\t\t\t}\n\n\t\t\t\tconfig = initHandler(config || {});\n\n\t\t\t\tfunction interceptedClient(request) {\n\t\t\t\t\tvar context, meta;\n\t\t\t\t\tcontext = {};\n\t\t\t\t\tmeta = { 'arguments': Array.prototype.slice.call(arguments), client: interceptedClient };\n\t\t\t\t\trequest = typeof request === 'string' ? { path: request } : request || {};\n\t\t\t\t\trequest.originator = request.originator || interceptedClient;\n\t\t\t\t\treturn responsePromise(\n\t\t\t\t\t\trequestHandler.call(context, request, config, meta),\n\t\t\t\t\t\tfunction (request) {\n\t\t\t\t\t\t\tvar response, abort, next;\n\t\t\t\t\t\t\tnext = target;\n\t\t\t\t\t\t\tif (request instanceof ComplexRequest) {\n\t\t\t\t\t\t\t\t// unpack request\n\t\t\t\t\t\t\t\tabort = request.abort;\n\t\t\t\t\t\t\t\tnext = request.client || next;\n\t\t\t\t\t\t\t\tresponse = request.response;\n\t\t\t\t\t\t\t\t// normalize request, must be last\n\t\t\t\t\t\t\t\trequest = request.request;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresponse = response || when(request, function (request) {\n\t\t\t\t\t\t\t\treturn when(\n\t\t\t\t\t\t\t\t\tnext(request),\n\t\t\t\t\t\t\t\t\tfunction (response) {\n\t\t\t\t\t\t\t\t\t\treturn successResponseHandler.call(context, response, config, meta);\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tfunction (response) {\n\t\t\t\t\t\t\t\t\t\treturn errorResponseHandler.call(context, response, config, meta);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\treturn abort ? race([response, abort]) : response;\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfunction (error) {\n\t\t\t\t\t\t\treturn when.reject({ request: request, error: error });\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn client(interceptedClient, target);\n\t\t\t};\n\t\t}\n\n\t\tinterceptor.ComplexRequest = ComplexRequest;\n\n\t\treturn interceptor;\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{\"./client\":4,\"./client/default\":5,\"./util/mixin\":40,\"./util/responsePromise\":42,\"when\":37}],8:[function(require,module,exports){\n/*\n * Copyright 2013 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (require) {\n\n\t\tvar interceptor, mixinUtil, defaulter;\n\n\t\tinterceptor = require('../interceptor');\n\t\tmixinUtil = require('../util/mixin');\n\n\t\tdefaulter = (function () {\n\n\t\t\tfunction mixin(prop, target, defaults) {\n\t\t\t\tif (prop in target || prop in defaults) {\n\t\t\t\t\ttarget[prop] = mixinUtil({}, defaults[prop], target[prop]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction copy(prop, target, defaults) {\n\t\t\t\tif (prop in defaults && !(prop in target)) {\n\t\t\t\t\ttarget[prop] = defaults[prop];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar mappings = {\n\t\t\t\tmethod: copy,\n\t\t\t\tpath: copy,\n\t\t\t\tparams: mixin,\n\t\t\t\theaders: mixin,\n\t\t\t\tentity: copy,\n\t\t\t\tmixin: mixin\n\t\t\t};\n\n\t\t\treturn function (target, defaults) {\n\t\t\t\tfor (var prop in mappings) {\n\t\t\t\t\t/*jshint forin: false */\n\t\t\t\t\tmappings[prop](prop, target, defaults);\n\t\t\t\t}\n\t\t\t\treturn target;\n\t\t\t};\n\n\t\t}());\n\n\t\t/**\n\t\t * Provide default values for a request. These values will be applied to the\n\t\t * request if the request object does not already contain an explicit value.\n\t\t *\n\t\t * For 'params', 'headers', and 'mixin', individual values are mixed in with the\n\t\t * request's values. The result is a new object representiing the combined\n\t\t * request and config values. Neither input object is mutated.\n\t\t *\n\t\t * @param {Client} [client] client to wrap\n\t\t * @param {string} [config.method] the default method\n\t\t * @param {string} [config.path] the default path\n\t\t * @param {Object} [config.params] the default params, mixed with the request's existing params\n\t\t * @param {Object} [config.headers] the default headers, mixed with the request's existing headers\n\t\t * @param {Object} [config.mixin] the default \"mixins\" (http/https options), mixed with the request's existing \"mixins\"\n\t\t *\n\t\t * @returns {Client}\n\t\t */\n\t\treturn interceptor({\n\t\t\trequest: function handleRequest(request, config) {\n\t\t\t\treturn defaulter(request, config);\n\t\t\t}\n\t\t});\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{\"../interceptor\":7,\"../util/mixin\":40}],9:[function(require,module,exports){\n/*\n * Copyright 2012-2013 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (require) {\n\n\t\tvar interceptor, when;\n\n\t\tinterceptor = require('../interceptor');\n\t\twhen = require('when');\n\n\t\t/**\n\t\t * Rejects the response promise based on the status code.\n\t\t *\n\t\t * Codes greater than or equal to the provided value are rejected.  Default\n\t\t * value 400.\n\t\t *\n\t\t * @param {Client} [client] client to wrap\n\t\t * @param {number} [config.code=400] code to indicate a rejection\n\t\t *\n\t\t * @returns {Client}\n\t\t */\n\t\treturn interceptor({\n\t\t\tinit: function (config) {\n\t\t\t\tconfig.code = config.code || 400;\n\t\t\t\treturn config;\n\t\t\t},\n\t\t\tresponse: function (response, config) {\n\t\t\t\tif (response.status && response.status.code >= config.code) {\n\t\t\t\t\treturn when.reject(response);\n\t\t\t\t}\n\t\t\t\treturn response;\n\t\t\t}\n\t\t});\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{\"../interceptor\":7,\"when\":37}],10:[function(require,module,exports){\n/*\n * Copyright 2012-2014 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (require) {\n\n\t\tvar interceptor, mime, registry, noopConverter, when;\n\n\t\tinterceptor = require('../interceptor');\n\t\tmime = require('../mime');\n\t\tregistry = require('../mime/registry');\n\t\twhen = require('when');\n\n\t\tnoopConverter = {\n\t\t\tread: function (obj) { return obj; },\n\t\t\twrite: function (obj) { return obj; }\n\t\t};\n\n\t\t/**\n\t\t * MIME type support for request and response entities.  Entities are\n\t\t * (de)serialized using the converter for the MIME type.\n\t\t *\n\t\t * Request entities are converted using the desired converter and the\n\t\t * 'Accept' request header prefers this MIME.\n\t\t *\n\t\t * Response entities are converted based on the Content-Type response header.\n\t\t *\n\t\t * @param {Client} [client] client to wrap\n\t\t * @param {string} [config.mime='text/plain'] MIME type to encode the request\n\t\t *   entity\n\t\t * @param {string} [config.accept] Accept header for the request\n\t\t * @param {Client} [config.client=<request.originator>] client passed to the\n\t\t *   converter, defaults to the client originating the request\n\t\t * @param {Registry} [config.registry] MIME registry, defaults to the root\n\t\t *   registry\n\t\t * @param {boolean} [config.permissive] Allow an unkown request MIME type\n\t\t *\n\t\t * @returns {Client}\n\t\t */\n\t\treturn interceptor({\n\t\t\tinit: function (config) {\n\t\t\t\tconfig.registry = config.registry || registry;\n\t\t\t\treturn config;\n\t\t\t},\n\t\t\trequest: function (request, config) {\n\t\t\t\tvar type, headers;\n\n\t\t\t\theaders = request.headers || (request.headers = {});\n\t\t\t\ttype = mime.parse(headers['Content-Type'] = headers['Content-Type'] || config.mime || 'text/plain');\n\t\t\t\theaders.Accept = headers.Accept || config.accept || type.raw + ', application/json;q=0.8, text/plain;q=0.5, */*;q=0.2';\n\n\t\t\t\tif (!('entity' in request)) {\n\t\t\t\t\treturn request;\n\t\t\t\t}\n\n\t\t\t\treturn config.registry.lookup(type).otherwise(function () {\n\t\t\t\t\t// failed to resolve converter\n\t\t\t\t\tif (config.permissive) {\n\t\t\t\t\t\treturn noopConverter;\n\t\t\t\t\t}\n\t\t\t\t\tthrow 'mime-unknown';\n\t\t\t\t}).then(function (converter) {\n\t\t\t\t\tvar client = config.client || request.originator;\n\n\t\t\t\t\treturn when.attempt(converter.write, request.entity, { client: client, request: request, mime: type, registry: config.registry })\n\t\t\t\t\t\t.otherwise(function() {\n\t\t\t\t\t\t\tthrow 'mime-serialization';\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.then(function(entity) {\n\t\t\t\t\t\t\trequest.entity = entity;\n\t\t\t\t\t\t\treturn request;\n\t\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t},\n\t\t\tresponse: function (response, config) {\n\t\t\t\tif (!(response.headers && response.headers['Content-Type'] && response.entity)) {\n\t\t\t\t\treturn response;\n\t\t\t\t}\n\n\t\t\t\tvar type = mime.parse(response.headers['Content-Type']);\n\n\t\t\t\treturn config.registry.lookup(type).otherwise(function () { return noopConverter; }).then(function (converter) {\n\t\t\t\t\tvar client = config.client || response.request && response.request.originator;\n\n\t\t\t\t\treturn when.attempt(converter.read, response.entity, { client: client, response: response, mime: type, registry: config.registry })\n\t\t\t\t\t\t.otherwise(function (e) {\n\t\t\t\t\t\t\tresponse.error = 'mime-deserialization';\n\t\t\t\t\t\t\tresponse.cause = e;\n\t\t\t\t\t\t\tthrow response;\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.then(function (entity) {\n\t\t\t\t\t\t\tresponse.entity = entity;\n\t\t\t\t\t\t\treturn response;\n\t\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{\"../interceptor\":7,\"../mime\":13,\"../mime/registry\":14,\"when\":37}],11:[function(require,module,exports){\n/*\n * Copyright 2012-2013 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (require) {\n\n\t\tvar interceptor, UrlBuilder;\n\n\t\tinterceptor = require('../interceptor');\n\t\tUrlBuilder = require('../UrlBuilder');\n\n\t\tfunction startsWith(str, prefix) {\n\t\t\treturn str.indexOf(prefix) === 0;\n\t\t}\n\n\t\tfunction endsWith(str, suffix) {\n\t\t\treturn str.lastIndexOf(suffix) + suffix.length === str.length;\n\t\t}\n\n\t\t/**\n\t\t * Prefixes the request path with a common value.\n\t\t *\n\t\t * @param {Client} [client] client to wrap\n\t\t * @param {number} [config.prefix] path prefix\n\t\t *\n\t\t * @returns {Client}\n\t\t */\n\t\treturn interceptor({\n\t\t\trequest: function (request, config) {\n\t\t\t\tvar path;\n\n\t\t\t\tif (config.prefix && !(new UrlBuilder(request.path).isFullyQualified())) {\n\t\t\t\t\tpath = config.prefix;\n\t\t\t\t\tif (request.path) {\n\t\t\t\t\t\tif (!endsWith(path, '/') && !startsWith(request.path, '/')) {\n\t\t\t\t\t\t\t// add missing '/' between path sections\n\t\t\t\t\t\t\tpath += '/';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpath += request.path;\n\t\t\t\t\t}\n\t\t\t\t\trequest.path = path;\n\t\t\t\t}\n\n\t\t\t\treturn request;\n\t\t\t}\n\t\t});\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{\"../UrlBuilder\":2,\"../interceptor\":7}],12:[function(require,module,exports){\n/*\n * Copyright 2015 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (require) {\n\n\t\tvar interceptor, uriTemplate, mixin;\n\n\t\tinterceptor = require('../interceptor');\n\t\turiTemplate = require('../util/uriTemplate');\n\t\tmixin = require('../util/mixin');\n\n\t\t/**\n\t\t * Applies request params to the path as a URI Template\n\t\t *\n\t\t * Params are removed from the request object, as they have been consumed.\n\t\t *\n\t\t * @see https://tools.ietf.org/html/rfc6570\n\t\t *\n\t\t * @param {Client} [client] client to wrap\n\t\t * @param {Object} [config.params] default param values\n\t\t * @param {string} [config.template] default template\n\t\t *\n\t\t * @returns {Client}\n\t\t */\n\t\treturn interceptor({\n\t\t\tinit: function (config) {\n\t\t\t\tconfig.params = config.params || {};\n\t\t\t\tconfig.template = config.template || '';\n\t\t\t\treturn config;\n\t\t\t},\n\t\t\trequest: function (request, config) {\n\t\t\t\tvar template, params;\n\n\t\t\t\ttemplate = request.path || config.template;\n\t\t\t\tparams = mixin({}, request.params, config.params);\n\n\t\t\t\trequest.path = uriTemplate.expand(template, params);\n\t\t\t\tdelete request.params;\n\n\t\t\t\treturn request;\n\t\t\t}\n\t\t});\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{\"../interceptor\":7,\"../util/mixin\":40,\"../util/uriTemplate\":44}],13:[function(require,module,exports){\n/*\n* Copyright 2014 the original author or authors\n* @license MIT, see LICENSE.txt for details\n*\n* @author Scott Andrews\n*/\n\n(function (define) {\n\t'use strict';\n\n\tvar undef;\n\n\tdefine(function (/* require */) {\n\n\t\t/**\n\t\t * Parse a MIME type into it's constituent parts\n\t\t *\n\t\t * @param {string} mime MIME type to parse\n\t\t * @return {{\n\t\t *   {string} raw the original MIME type\n\t\t *   {string} type the type and subtype\n\t\t *   {string} [suffix] mime suffix, including the plus, if any\n\t\t *   {Object} params key/value pair of attributes\n\t\t * }}\n\t\t */\n\t\tfunction parse(mime) {\n\t\t\tvar params, type;\n\n\t\t\tparams = mime.split(';');\n\t\t\ttype = params[0].trim().split('+');\n\n\t\t\treturn {\n\t\t\t\traw: mime,\n\t\t\t\ttype: type[0],\n\t\t\t\tsuffix: type[1] ? '+' + type[1] : '',\n\t\t\t\tparams: params.slice(1).reduce(function (params, pair) {\n\t\t\t\t\tpair = pair.split('=');\n\t\t\t\t\tparams[pair[0].trim()] = pair[1] ? pair[1].trim() : undef;\n\t\t\t\t\treturn params;\n\t\t\t\t}, {})\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tparse: parse\n\t\t};\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{}],14:[function(require,module,exports){\n/*\n * Copyright 2012-2014 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (require) {\n\n\t\tvar mime, when, registry;\n\n\t\tmime = require('../mime');\n\t\twhen = require('when');\n\n\t\tfunction Registry(mimes) {\n\n\t\t\t/**\n\t\t\t * Lookup the converter for a MIME type\n\t\t\t *\n\t\t\t * @param {string} type the MIME type\n\t\t\t * @return a promise for the converter\n\t\t\t */\n\t\t\tthis.lookup = function lookup(type) {\n\t\t\t\tvar parsed;\n\n\t\t\t\tparsed = typeof type === 'string' ? mime.parse(type) : type;\n\n\t\t\t\tif (mimes[parsed.raw]) {\n\t\t\t\t\treturn mimes[parsed.raw];\n\t\t\t\t}\n\t\t\t\tif (mimes[parsed.type + parsed.suffix]) {\n\t\t\t\t\treturn mimes[parsed.type + parsed.suffix];\n\t\t\t\t}\n\t\t\t\tif (mimes[parsed.type]) {\n\t\t\t\t\treturn mimes[parsed.type];\n\t\t\t\t}\n\t\t\t\tif (mimes[parsed.suffix]) {\n\t\t\t\t\treturn mimes[parsed.suffix];\n\t\t\t\t}\n\n\t\t\t\treturn when.reject(new Error('Unable to locate converter for mime \"' + parsed.raw + '\"'));\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Create a late dispatched proxy to the target converter.\n\t\t\t *\n\t\t\t * Common when a converter is registered under multiple names and\n\t\t\t * should be kept in sync if updated.\n\t\t\t *\n\t\t\t * @param {string} type mime converter to dispatch to\n\t\t\t * @returns converter whose read/write methods target the desired mime converter\n\t\t\t */\n\t\t\tthis.delegate = function delegate(type) {\n\t\t\t\treturn {\n\t\t\t\t\tread: function () {\n\t\t\t\t\t\tvar args = arguments;\n\t\t\t\t\t\treturn this.lookup(type).then(function (converter) {\n\t\t\t\t\t\t\treturn converter.read.apply(this, args);\n\t\t\t\t\t\t}.bind(this));\n\t\t\t\t\t}.bind(this),\n\t\t\t\t\twrite: function () {\n\t\t\t\t\t\tvar args = arguments;\n\t\t\t\t\t\treturn this.lookup(type).then(function (converter) {\n\t\t\t\t\t\t\treturn converter.write.apply(this, args);\n\t\t\t\t\t\t}.bind(this));\n\t\t\t\t\t}.bind(this)\n\t\t\t\t};\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Register a custom converter for a MIME type\n\t\t\t *\n\t\t\t * @param {string} type the MIME type\n\t\t\t * @param converter the converter for the MIME type\n\t\t\t * @return a promise for the converter\n\t\t\t */\n\t\t\tthis.register = function register(type, converter) {\n\t\t\t\tmimes[type] = when(converter);\n\t\t\t\treturn mimes[type];\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Create a child registry whoes registered converters remain local, while\n\t\t\t * able to lookup converters from its parent.\n\t\t\t *\n\t\t\t * @returns child MIME registry\n\t\t\t */\n\t\t\tthis.child = function child() {\n\t\t\t\treturn new Registry(Object.create(mimes));\n\t\t\t};\n\n\t\t}\n\n\t\tregistry = new Registry({});\n\n\t\t// include provided serializers\n\t\tregistry.register('application/hal', require('./type/application/hal'));\n\t\tregistry.register('application/json', require('./type/application/json'));\n\t\tregistry.register('application/x-www-form-urlencoded', require('./type/application/x-www-form-urlencoded'));\n\t\tregistry.register('multipart/form-data', require('./type/multipart/form-data'));\n\t\tregistry.register('text/plain', require('./type/text/plain'));\n\n\t\tregistry.register('+json', registry.delegate('application/json'));\n\n\t\treturn registry;\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{\"../mime\":13,\"./type/application/hal\":15,\"./type/application/json\":16,\"./type/application/x-www-form-urlencoded\":17,\"./type/multipart/form-data\":18,\"./type/text/plain\":19,\"when\":37}],15:[function(require,module,exports){\n/*\n * Copyright 2013-2015 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (require) {\n\n\t\tvar pathPrefix, template, find, lazyPromise, responsePromise, when;\n\n\t\tpathPrefix = require('../../../interceptor/pathPrefix');\n\t\ttemplate = require('../../../interceptor/template');\n\t\tfind = require('../../../util/find');\n\t\tlazyPromise = require('../../../util/lazyPromise');\n\t\tresponsePromise = require('../../../util/responsePromise');\n\t\twhen = require('when');\n\n\t\tfunction defineProperty(obj, name, value) {\n\t\t\tObject.defineProperty(obj, name, {\n\t\t\t\tvalue: value,\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: false,\n\t\t\t\twriteable: true\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Hypertext Application Language serializer\n\t\t *\n\t\t * Implemented to https://tools.ietf.org/html/draft-kelly-json-hal-06\n\t\t *\n\t\t * As the spec is still a draft, this implementation will be updated as the\n\t\t * spec evolves\n\t\t *\n\t\t * Objects are read as HAL indexing links and embedded objects on to the\n\t\t * resource. Objects are written as plain JSON.\n\t\t *\n\t\t * Embedded relationships are indexed onto the resource by the relationship\n\t\t * as a promise for the related resource.\n\t\t *\n\t\t * Links are indexed onto the resource as a lazy promise that will GET the\n\t\t * resource when a handler is first registered on the promise.\n\t\t *\n\t\t * A `requestFor` method is added to the entity to make a request for the\n\t\t * relationship.\n\t\t *\n\t\t * A `clientFor` method is added to the entity to get a full Client for a\n\t\t * relationship.\n\t\t *\n\t\t * The `_links` and `_embedded` properties on the resource are made\n\t\t * non-enumerable.\n\t\t */\n\t\treturn {\n\n\t\t\tread: function (str, opts) {\n\t\t\t\tvar client, console;\n\n\t\t\t\topts = opts || {};\n\t\t\t\tclient = opts.client;\n\t\t\t\tconsole = opts.console || console;\n\n\t\t\t\tfunction deprecationWarning(relationship, deprecation) {\n\t\t\t\t\tif (deprecation && console && console.warn || console.log) {\n\t\t\t\t\t\t(console.warn || console.log).call(console, 'Relationship \\'' + relationship + '\\' is deprecated, see ' + deprecation);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn opts.registry.lookup(opts.mime.suffix).then(function (converter) {\n\t\t\t\t\treturn when(converter.read(str, opts)).then(function (root) {\n\n\t\t\t\t\t\tfind.findProperties(root, '_embedded', function (embedded, resource, name) {\n\t\t\t\t\t\t\tObject.keys(embedded).forEach(function (relationship) {\n\t\t\t\t\t\t\t\tif (relationship in resource) { return; }\n\t\t\t\t\t\t\t\tvar related = responsePromise({\n\t\t\t\t\t\t\t\t\tentity: embedded[relationship]\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tdefineProperty(resource, relationship, related);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tdefineProperty(resource, name, embedded);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfind.findProperties(root, '_links', function (links, resource, name) {\n\t\t\t\t\t\t\tObject.keys(links).forEach(function (relationship) {\n\t\t\t\t\t\t\t\tvar link = links[relationship];\n\t\t\t\t\t\t\t\tif (relationship in resource) { return; }\n\t\t\t\t\t\t\t\tdefineProperty(resource, relationship, responsePromise.make(lazyPromise(function () {\n\t\t\t\t\t\t\t\t\tif (link.deprecation) { deprecationWarning(relationship, link.deprecation); }\n\t\t\t\t\t\t\t\t\tif (link.templated === true) {\n\t\t\t\t\t\t\t\t\t\treturn template(client)({ path: link.href });\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn client({ path: link.href });\n\t\t\t\t\t\t\t\t})));\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tdefineProperty(resource, name, links);\n\t\t\t\t\t\t\tdefineProperty(resource, 'clientFor', function (relationship, clientOverride) {\n\t\t\t\t\t\t\t\tvar link = links[relationship];\n\t\t\t\t\t\t\t\tif (!link) {\n\t\t\t\t\t\t\t\t\tthrow new Error('Unknown relationship: ' + relationship);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (link.deprecation) { deprecationWarning(relationship, link.deprecation); }\n\t\t\t\t\t\t\t\tif (link.templated === true) {\n\t\t\t\t\t\t\t\t\treturn template(\n\t\t\t\t\t\t\t\t\t\tclientOverride || client,\n\t\t\t\t\t\t\t\t\t\t{ template: link.href }\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn pathPrefix(\n\t\t\t\t\t\t\t\t\tclientOverride || client,\n\t\t\t\t\t\t\t\t\t{ prefix: link.href }\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tdefineProperty(resource, 'requestFor', function (relationship, request, clientOverride) {\n\t\t\t\t\t\t\t\tvar client = this.clientFor(relationship, clientOverride);\n\t\t\t\t\t\t\t\treturn client(request);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn root;\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t},\n\n\t\t\twrite: function (obj, opts) {\n\t\t\t\treturn opts.registry.lookup(opts.mime.suffix).then(function (converter) {\n\t\t\t\t\treturn converter.write(obj, opts);\n\t\t\t\t});\n\t\t\t}\n\n\t\t};\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{\"../../../interceptor/pathPrefix\":11,\"../../../interceptor/template\":12,\"../../../util/find\":38,\"../../../util/lazyPromise\":39,\"../../../util/responsePromise\":42,\"when\":37}],16:[function(require,module,exports){\n/*\n * Copyright 2012-2015 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (/* require */) {\n\n\t\t/**\n\t\t * Create a new JSON converter with custom reviver/replacer.\n\t\t *\n\t\t * The extended converter must be published to a MIME registry in order\n\t\t * to be used. The existing converter will not be modified.\n\t\t *\n\t\t * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON\n\t\t *\n\t\t * @param {function} [reviver=undefined] custom JSON.parse reviver\n\t\t * @param {function|Array} [replacer=undefined] custom JSON.stringify replacer\n\t\t */\n\t\tfunction createConverter(reviver, replacer) {\n\t\t\treturn {\n\n\t\t\t\tread: function (str) {\n\t\t\t\t\treturn JSON.parse(str, reviver);\n\t\t\t\t},\n\n\t\t\t\twrite: function (obj) {\n\t\t\t\t\treturn JSON.stringify(obj, replacer);\n\t\t\t\t},\n\n\t\t\t\textend: createConverter\n\n\t\t\t};\n\t\t}\n\n\t\treturn createConverter();\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{}],17:[function(require,module,exports){\n/*\n * Copyright 2012 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (/* require */) {\n\n\t\tvar encodedSpaceRE, urlEncodedSpaceRE;\n\n\t\tencodedSpaceRE = /%20/g;\n\t\turlEncodedSpaceRE = /\\+/g;\n\n\t\tfunction urlEncode(str) {\n\t\t\tstr = encodeURIComponent(str);\n\t\t\t// spec says space should be encoded as '+'\n\t\t\treturn str.replace(encodedSpaceRE, '+');\n\t\t}\n\n\t\tfunction urlDecode(str) {\n\t\t\t// spec says space should be encoded as '+'\n\t\t\tstr = str.replace(urlEncodedSpaceRE, ' ');\n\t\t\treturn decodeURIComponent(str);\n\t\t}\n\n\t\tfunction append(str, name, value) {\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\tvalue.forEach(function (value) {\n\t\t\t\t\tstr = append(str, name, value);\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (str.length > 0) {\n\t\t\t\t\tstr += '&';\n\t\t\t\t}\n\t\t\t\tstr += urlEncode(name);\n\t\t\t\tif (value !== undefined && value !== null) {\n\t\t\t\t\tstr += '=' + urlEncode(value);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\n\t\treturn {\n\n\t\t\tread: function (str) {\n\t\t\t\tvar obj = {};\n\t\t\t\tstr.split('&').forEach(function (entry) {\n\t\t\t\t\tvar pair, name, value;\n\t\t\t\t\tpair = entry.split('=');\n\t\t\t\t\tname = urlDecode(pair[0]);\n\t\t\t\t\tif (pair.length === 2) {\n\t\t\t\t\t\tvalue = urlDecode(pair[1]);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tvalue = null;\n\t\t\t\t\t}\n\t\t\t\t\tif (name in obj) {\n\t\t\t\t\t\tif (!Array.isArray(obj[name])) {\n\t\t\t\t\t\t\t// convert to an array, perserving currnent value\n\t\t\t\t\t\t\tobj[name] = [obj[name]];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tobj[name].push(value);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tobj[name] = value;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn obj;\n\t\t\t},\n\n\t\t\twrite: function (obj) {\n\t\t\t\tvar str = '';\n\t\t\t\tObject.keys(obj).forEach(function (name) {\n\t\t\t\t\tstr = append(str, name, obj[name]);\n\t\t\t\t});\n\t\t\t\treturn str;\n\t\t\t}\n\n\t\t};\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{}],18:[function(require,module,exports){\n/*\n * Copyright 2014 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Michael Jackson\n */\n\n/* global FormData, File, Blob */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (/* require */) {\n\n\t\tfunction isFormElement(object) {\n\t\t\treturn object &&\n\t\t\t\tobject.nodeType === 1 && // Node.ELEMENT_NODE\n\t\t\t\tobject.tagName === 'FORM';\n\t\t}\n\n\t\tfunction createFormDataFromObject(object) {\n\t\t\tvar formData = new FormData();\n\n\t\t\tvar value;\n\t\t\tfor (var property in object) {\n\t\t\t\tif (object.hasOwnProperty(property)) {\n\t\t\t\t\tvalue = object[property];\n\n\t\t\t\t\tif (value instanceof File) {\n\t\t\t\t\t\tformData.append(property, value, value.name);\n\t\t\t\t\t} else if (value instanceof Blob) {\n\t\t\t\t\t\tformData.append(property, value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tformData.append(property, String(value));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn formData;\n\t\t}\n\n\t\treturn {\n\n\t\t\twrite: function (object) {\n\t\t\t\tif (typeof FormData === 'undefined') {\n\t\t\t\t\tthrow new Error('The multipart/form-data mime serializer requires FormData support');\n\t\t\t\t}\n\n\t\t\t\t// Support FormData directly.\n\t\t\t\tif (object instanceof FormData) {\n\t\t\t\t\treturn object;\n\t\t\t\t}\n\n\t\t\t\t// Support <form> elements.\n\t\t\t\tif (isFormElement(object)) {\n\t\t\t\t\treturn new FormData(object);\n\t\t\t\t}\n\n\t\t\t\t// Support plain objects, may contain File/Blob as value.\n\t\t\t\tif (typeof object === 'object' && object !== null) {\n\t\t\t\t\treturn createFormDataFromObject(object);\n\t\t\t\t}\n\n\t\t\t\tthrow new Error('Unable to create FormData from object ' + object);\n\t\t\t}\n\n\t\t};\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{}],19:[function(require,module,exports){\n/*\n * Copyright 2012 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (/* require */) {\n\n\t\treturn {\n\n\t\t\tread: function (str) {\n\t\t\t\treturn str;\n\t\t\t},\n\n\t\t\twrite: function (obj) {\n\t\t\t\treturn obj.toString();\n\t\t\t}\n\n\t\t};\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{}],20:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function (require) {\n\n\tvar makePromise = require('./makePromise');\n\tvar Scheduler = require('./Scheduler');\n\tvar async = require('./env').asap;\n\n\treturn makePromise({\n\t\tscheduler: new Scheduler(async)\n\t});\n\n});\n})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });\n\n},{\"./Scheduler\":21,\"./env\":33,\"./makePromise\":35}],21:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\t// Credit to Twisol (https://github.com/Twisol) for suggesting\n\t// this type of extensible queue + trampoline approach for next-tick conflation.\n\n\t/**\n\t * Async task scheduler\n\t * @param {function} async function to schedule a single async function\n\t * @constructor\n\t */\n\tfunction Scheduler(async) {\n\t\tthis._async = async;\n\t\tthis._running = false;\n\n\t\tthis._queue = this;\n\t\tthis._queueLen = 0;\n\t\tthis._afterQueue = {};\n\t\tthis._afterQueueLen = 0;\n\n\t\tvar self = this;\n\t\tthis.drain = function() {\n\t\t\tself._drain();\n\t\t};\n\t}\n\n\t/**\n\t * Enqueue a task\n\t * @param {{ run:function }} task\n\t */\n\tScheduler.prototype.enqueue = function(task) {\n\t\tthis._queue[this._queueLen++] = task;\n\t\tthis.run();\n\t};\n\n\t/**\n\t * Enqueue a task to run after the main task queue\n\t * @param {{ run:function }} task\n\t */\n\tScheduler.prototype.afterQueue = function(task) {\n\t\tthis._afterQueue[this._afterQueueLen++] = task;\n\t\tthis.run();\n\t};\n\n\tScheduler.prototype.run = function() {\n\t\tif (!this._running) {\n\t\t\tthis._running = true;\n\t\t\tthis._async(this.drain);\n\t\t}\n\t};\n\n\t/**\n\t * Drain the handler queue entirely, and then the after queue\n\t */\n\tScheduler.prototype._drain = function() {\n\t\tvar i = 0;\n\t\tfor (; i < this._queueLen; ++i) {\n\t\t\tthis._queue[i].run();\n\t\t\tthis._queue[i] = void 0;\n\t\t}\n\n\t\tthis._queueLen = 0;\n\t\tthis._running = false;\n\n\t\tfor (i = 0; i < this._afterQueueLen; ++i) {\n\t\t\tthis._afterQueue[i].run();\n\t\t\tthis._afterQueue[i] = void 0;\n\t\t}\n\n\t\tthis._afterQueueLen = 0;\n\t};\n\n\treturn Scheduler;\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n},{}],22:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\t/**\n\t * Custom error type for promises rejected by promise.timeout\n\t * @param {string} message\n\t * @constructor\n\t */\n\tfunction TimeoutError (message) {\n\t\tError.call(this);\n\t\tthis.message = message;\n\t\tthis.name = TimeoutError.name;\n\t\tif (typeof Error.captureStackTrace === 'function') {\n\t\t\tError.captureStackTrace(this, TimeoutError);\n\t\t}\n\t}\n\n\tTimeoutError.prototype = Object.create(Error.prototype);\n\tTimeoutError.prototype.constructor = TimeoutError;\n\n\treturn TimeoutError;\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n},{}],23:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\tmakeApply.tryCatchResolve = tryCatchResolve;\n\n\treturn makeApply;\n\n\tfunction makeApply(Promise, call) {\n\t\tif(arguments.length < 2) {\n\t\t\tcall = tryCatchResolve;\n\t\t}\n\n\t\treturn apply;\n\n\t\tfunction apply(f, thisArg, args) {\n\t\t\tvar p = Promise._defer();\n\t\t\tvar l = args.length;\n\t\t\tvar params = new Array(l);\n\t\t\tcallAndResolve({ f:f, thisArg:thisArg, args:args, params:params, i:l-1, call:call }, p._handler);\n\n\t\t\treturn p;\n\t\t}\n\n\t\tfunction callAndResolve(c, h) {\n\t\t\tif(c.i < 0) {\n\t\t\t\treturn call(c.f, c.thisArg, c.params, h);\n\t\t\t}\n\n\t\t\tvar handler = Promise._handler(c.args[c.i]);\n\t\t\thandler.fold(callAndResolveNext, c, void 0, h);\n\t\t}\n\n\t\tfunction callAndResolveNext(c, x, h) {\n\t\t\tc.params[c.i] = x;\n\t\t\tc.i -= 1;\n\t\t\tcallAndResolve(c, h);\n\t\t}\n\t}\n\n\tfunction tryCatchResolve(f, thisArg, args, resolver) {\n\t\ttry {\n\t\t\tresolver.resolve(f.apply(thisArg, args));\n\t\t} catch(e) {\n\t\t\tresolver.reject(e);\n\t\t}\n\t}\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n\n\n},{}],24:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function(require) {\n\n\tvar state = require('../state');\n\tvar applier = require('../apply');\n\n\treturn function array(Promise) {\n\n\t\tvar applyFold = applier(Promise);\n\t\tvar toPromise = Promise.resolve;\n\t\tvar all = Promise.all;\n\n\t\tvar ar = Array.prototype.reduce;\n\t\tvar arr = Array.prototype.reduceRight;\n\t\tvar slice = Array.prototype.slice;\n\n\t\t// Additional array combinators\n\n\t\tPromise.any = any;\n\t\tPromise.some = some;\n\t\tPromise.settle = settle;\n\n\t\tPromise.map = map;\n\t\tPromise.filter = filter;\n\t\tPromise.reduce = reduce;\n\t\tPromise.reduceRight = reduceRight;\n\n\t\t/**\n\t\t * When this promise fulfills with an array, do\n\t\t * onFulfilled.apply(void 0, array)\n\t\t * @param {function} onFulfilled function to apply\n\t\t * @returns {Promise} promise for the result of applying onFulfilled\n\t\t */\n\t\tPromise.prototype.spread = function(onFulfilled) {\n\t\t\treturn this.then(all).then(function(array) {\n\t\t\t\treturn onFulfilled.apply(this, array);\n\t\t\t});\n\t\t};\n\n\t\treturn Promise;\n\n\t\t/**\n\t\t * One-winner competitive race.\n\t\t * Return a promise that will fulfill when one of the promises\n\t\t * in the input array fulfills, or will reject when all promises\n\t\t * have rejected.\n\t\t * @param {array} promises\n\t\t * @returns {Promise} promise for the first fulfilled value\n\t\t */\n\t\tfunction any(promises) {\n\t\t\tvar p = Promise._defer();\n\t\t\tvar resolver = p._handler;\n\t\t\tvar l = promises.length>>>0;\n\n\t\t\tvar pending = l;\n\t\t\tvar errors = [];\n\n\t\t\tfor (var h, x, i = 0; i < l; ++i) {\n\t\t\t\tx = promises[i];\n\t\t\t\tif(x === void 0 && !(i in promises)) {\n\t\t\t\t\t--pending;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\th = Promise._handler(x);\n\t\t\t\tif(h.state() > 0) {\n\t\t\t\t\tresolver.become(h);\n\t\t\t\t\tPromise._visitRemaining(promises, i, h);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\th.visit(resolver, handleFulfill, handleReject);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(pending === 0) {\n\t\t\t\tresolver.reject(new RangeError('any(): array must not be empty'));\n\t\t\t}\n\n\t\t\treturn p;\n\n\t\t\tfunction handleFulfill(x) {\n\t\t\t\t/*jshint validthis:true*/\n\t\t\t\terrors = null;\n\t\t\t\tthis.resolve(x); // this === resolver\n\t\t\t}\n\n\t\t\tfunction handleReject(e) {\n\t\t\t\t/*jshint validthis:true*/\n\t\t\t\tif(this.resolved) { // this === resolver\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\terrors.push(e);\n\t\t\t\tif(--pending === 0) {\n\t\t\t\t\tthis.reject(errors);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * N-winner competitive race\n\t\t * Return a promise that will fulfill when n input promises have\n\t\t * fulfilled, or will reject when it becomes impossible for n\n\t\t * input promises to fulfill (ie when promises.length - n + 1\n\t\t * have rejected)\n\t\t * @param {array} promises\n\t\t * @param {number} n\n\t\t * @returns {Promise} promise for the earliest n fulfillment values\n\t\t *\n\t\t * @deprecated\n\t\t */\n\t\tfunction some(promises, n) {\n\t\t\t/*jshint maxcomplexity:7*/\n\t\t\tvar p = Promise._defer();\n\t\t\tvar resolver = p._handler;\n\n\t\t\tvar results = [];\n\t\t\tvar errors = [];\n\n\t\t\tvar l = promises.length>>>0;\n\t\t\tvar nFulfill = 0;\n\t\t\tvar nReject;\n\t\t\tvar x, i; // reused in both for() loops\n\n\t\t\t// First pass: count actual array items\n\t\t\tfor(i=0; i<l; ++i) {\n\t\t\t\tx = promises[i];\n\t\t\t\tif(x === void 0 && !(i in promises)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t++nFulfill;\n\t\t\t}\n\n\t\t\t// Compute actual goals\n\t\t\tn = Math.max(n, 0);\n\t\t\tnReject = (nFulfill - n + 1);\n\t\t\tnFulfill = Math.min(n, nFulfill);\n\n\t\t\tif(n > nFulfill) {\n\t\t\t\tresolver.reject(new RangeError('some(): array must contain at least '\n\t\t\t\t+ n + ' item(s), but had ' + nFulfill));\n\t\t\t} else if(nFulfill === 0) {\n\t\t\t\tresolver.resolve(results);\n\t\t\t}\n\n\t\t\t// Second pass: observe each array item, make progress toward goals\n\t\t\tfor(i=0; i<l; ++i) {\n\t\t\t\tx = promises[i];\n\t\t\t\tif(x === void 0 && !(i in promises)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tPromise._handler(x).visit(resolver, fulfill, reject, resolver.notify);\n\t\t\t}\n\n\t\t\treturn p;\n\n\t\t\tfunction fulfill(x) {\n\t\t\t\t/*jshint validthis:true*/\n\t\t\t\tif(this.resolved) { // this === resolver\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tresults.push(x);\n\t\t\t\tif(--nFulfill === 0) {\n\t\t\t\t\terrors = null;\n\t\t\t\t\tthis.resolve(results);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction reject(e) {\n\t\t\t\t/*jshint validthis:true*/\n\t\t\t\tif(this.resolved) { // this === resolver\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\terrors.push(e);\n\t\t\t\tif(--nReject === 0) {\n\t\t\t\t\tresults = null;\n\t\t\t\t\tthis.reject(errors);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Apply f to the value of each promise in a list of promises\n\t\t * and return a new list containing the results.\n\t\t * @param {array} promises\n\t\t * @param {function(x:*, index:Number):*} f mapping function\n\t\t * @returns {Promise}\n\t\t */\n\t\tfunction map(promises, f) {\n\t\t\treturn Promise._traverse(f, promises);\n\t\t}\n\n\t\t/**\n\t\t * Filter the provided array of promises using the provided predicate.  Input may\n\t\t * contain promises and values\n\t\t * @param {Array} promises array of promises and values\n\t\t * @param {function(x:*, index:Number):boolean} predicate filtering predicate.\n\t\t *  Must return truthy (or promise for truthy) for items to retain.\n\t\t * @returns {Promise} promise that will fulfill with an array containing all items\n\t\t *  for which predicate returned truthy.\n\t\t */\n\t\tfunction filter(promises, predicate) {\n\t\t\tvar a = slice.call(promises);\n\t\t\treturn Promise._traverse(predicate, a).then(function(keep) {\n\t\t\t\treturn filterSync(a, keep);\n\t\t\t});\n\t\t}\n\n\t\tfunction filterSync(promises, keep) {\n\t\t\t// Safe because we know all promises have fulfilled if we've made it this far\n\t\t\tvar l = keep.length;\n\t\t\tvar filtered = new Array(l);\n\t\t\tfor(var i=0, j=0; i<l; ++i) {\n\t\t\t\tif(keep[i]) {\n\t\t\t\t\tfiltered[j++] = Promise._handler(promises[i]).value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfiltered.length = j;\n\t\t\treturn filtered;\n\n\t\t}\n\n\t\t/**\n\t\t * Return a promise that will always fulfill with an array containing\n\t\t * the outcome states of all input promises.  The returned promise\n\t\t * will never reject.\n\t\t * @param {Array} promises\n\t\t * @returns {Promise} promise for array of settled state descriptors\n\t\t */\n\t\tfunction settle(promises) {\n\t\t\treturn all(promises.map(settleOne));\n\t\t}\n\n\t\tfunction settleOne(p) {\n\t\t\tvar h = Promise._handler(p);\n\t\t\tif(h.state() === 0) {\n\t\t\t\treturn toPromise(p).then(state.fulfilled, state.rejected);\n\t\t\t}\n\n\t\t\th._unreport();\n\t\t\treturn state.inspect(h);\n\t\t}\n\n\t\t/**\n\t\t * Traditional reduce function, similar to `Array.prototype.reduce()`, but\n\t\t * input may contain promises and/or values, and reduceFunc\n\t\t * may return either a value or a promise, *and* initialValue may\n\t\t * be a promise for the starting value.\n\t\t * @param {Array|Promise} promises array or promise for an array of anything,\n\t\t *      may contain a mix of promises and values.\n\t\t * @param {function(accumulated:*, x:*, index:Number):*} f reduce function\n\t\t * @returns {Promise} that will resolve to the final reduced value\n\t\t */\n\t\tfunction reduce(promises, f /*, initialValue */) {\n\t\t\treturn arguments.length > 2 ? ar.call(promises, liftCombine(f), arguments[2])\n\t\t\t\t\t: ar.call(promises, liftCombine(f));\n\t\t}\n\n\t\t/**\n\t\t * Traditional reduce function, similar to `Array.prototype.reduceRight()`, but\n\t\t * input may contain promises and/or values, and reduceFunc\n\t\t * may return either a value or a promise, *and* initialValue may\n\t\t * be a promise for the starting value.\n\t\t * @param {Array|Promise} promises array or promise for an array of anything,\n\t\t *      may contain a mix of promises and values.\n\t\t * @param {function(accumulated:*, x:*, index:Number):*} f reduce function\n\t\t * @returns {Promise} that will resolve to the final reduced value\n\t\t */\n\t\tfunction reduceRight(promises, f /*, initialValue */) {\n\t\t\treturn arguments.length > 2 ? arr.call(promises, liftCombine(f), arguments[2])\n\t\t\t\t\t: arr.call(promises, liftCombine(f));\n\t\t}\n\n\t\tfunction liftCombine(f) {\n\t\t\treturn function(z, x, i) {\n\t\t\t\treturn applyFold(f, void 0, [z,x,i]);\n\t\t\t};\n\t\t}\n\t};\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n\n},{\"../apply\":23,\"../state\":36}],25:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn function flow(Promise) {\n\n\t\tvar resolve = Promise.resolve;\n\t\tvar reject = Promise.reject;\n\t\tvar origCatch = Promise.prototype['catch'];\n\n\t\t/**\n\t\t * Handle the ultimate fulfillment value or rejection reason, and assume\n\t\t * responsibility for all errors.  If an error propagates out of result\n\t\t * or handleFatalError, it will be rethrown to the host, resulting in a\n\t\t * loud stack track on most platforms and a crash on some.\n\t\t * @param {function?} onResult\n\t\t * @param {function?} onError\n\t\t * @returns {undefined}\n\t\t */\n\t\tPromise.prototype.done = function(onResult, onError) {\n\t\t\tthis._handler.visit(this._handler.receiver, onResult, onError);\n\t\t};\n\n\t\t/**\n\t\t * Add Error-type and predicate matching to catch.  Examples:\n\t\t * promise.catch(TypeError, handleTypeError)\n\t\t *   .catch(predicate, handleMatchedErrors)\n\t\t *   .catch(handleRemainingErrors)\n\t\t * @param onRejected\n\t\t * @returns {*}\n\t\t */\n\t\tPromise.prototype['catch'] = Promise.prototype.otherwise = function(onRejected) {\n\t\t\tif (arguments.length < 2) {\n\t\t\t\treturn origCatch.call(this, onRejected);\n\t\t\t}\n\n\t\t\tif(typeof onRejected !== 'function') {\n\t\t\t\treturn this.ensure(rejectInvalidPredicate);\n\t\t\t}\n\n\t\t\treturn origCatch.call(this, createCatchFilter(arguments[1], onRejected));\n\t\t};\n\n\t\t/**\n\t\t * Wraps the provided catch handler, so that it will only be called\n\t\t * if the predicate evaluates truthy\n\t\t * @param {?function} handler\n\t\t * @param {function} predicate\n\t\t * @returns {function} conditional catch handler\n\t\t */\n\t\tfunction createCatchFilter(handler, predicate) {\n\t\t\treturn function(e) {\n\t\t\t\treturn evaluatePredicate(e, predicate)\n\t\t\t\t\t? handler.call(this, e)\n\t\t\t\t\t: reject(e);\n\t\t\t};\n\t\t}\n\n\t\t/**\n\t\t * Ensures that onFulfilledOrRejected will be called regardless of whether\n\t\t * this promise is fulfilled or rejected.  onFulfilledOrRejected WILL NOT\n\t\t * receive the promises' value or reason.  Any returned value will be disregarded.\n\t\t * onFulfilledOrRejected may throw or return a rejected promise to signal\n\t\t * an additional error.\n\t\t * @param {function} handler handler to be called regardless of\n\t\t *  fulfillment or rejection\n\t\t * @returns {Promise}\n\t\t */\n\t\tPromise.prototype['finally'] = Promise.prototype.ensure = function(handler) {\n\t\t\tif(typeof handler !== 'function') {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\treturn this.then(function(x) {\n\t\t\t\treturn runSideEffect(handler, this, identity, x);\n\t\t\t}, function(e) {\n\t\t\t\treturn runSideEffect(handler, this, reject, e);\n\t\t\t});\n\t\t};\n\n\t\tfunction runSideEffect (handler, thisArg, propagate, value) {\n\t\t\tvar result = handler.call(thisArg);\n\t\t\treturn maybeThenable(result)\n\t\t\t\t? propagateValue(result, propagate, value)\n\t\t\t\t: propagate(value);\n\t\t}\n\n\t\tfunction propagateValue (result, propagate, x) {\n\t\t\treturn resolve(result).then(function () {\n\t\t\t\treturn propagate(x);\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Recover from a failure by returning a defaultValue.  If defaultValue\n\t\t * is a promise, it's fulfillment value will be used.  If defaultValue is\n\t\t * a promise that rejects, the returned promise will reject with the\n\t\t * same reason.\n\t\t * @param {*} defaultValue\n\t\t * @returns {Promise} new promise\n\t\t */\n\t\tPromise.prototype['else'] = Promise.prototype.orElse = function(defaultValue) {\n\t\t\treturn this.then(void 0, function() {\n\t\t\t\treturn defaultValue;\n\t\t\t});\n\t\t};\n\n\t\t/**\n\t\t * Shortcut for .then(function() { return value; })\n\t\t * @param  {*} value\n\t\t * @return {Promise} a promise that:\n\t\t *  - is fulfilled if value is not a promise, or\n\t\t *  - if value is a promise, will fulfill with its value, or reject\n\t\t *    with its reason.\n\t\t */\n\t\tPromise.prototype['yield'] = function(value) {\n\t\t\treturn this.then(function() {\n\t\t\t\treturn value;\n\t\t\t});\n\t\t};\n\n\t\t/**\n\t\t * Runs a side effect when this promise fulfills, without changing the\n\t\t * fulfillment value.\n\t\t * @param {function} onFulfilledSideEffect\n\t\t * @returns {Promise}\n\t\t */\n\t\tPromise.prototype.tap = function(onFulfilledSideEffect) {\n\t\t\treturn this.then(onFulfilledSideEffect)['yield'](this);\n\t\t};\n\n\t\treturn Promise;\n\t};\n\n\tfunction rejectInvalidPredicate() {\n\t\tthrow new TypeError('catch predicate must be a function');\n\t}\n\n\tfunction evaluatePredicate(e, predicate) {\n\t\treturn isError(predicate) ? e instanceof predicate : predicate(e);\n\t}\n\n\tfunction isError(predicate) {\n\t\treturn predicate === Error\n\t\t\t|| (predicate != null && predicate.prototype instanceof Error);\n\t}\n\n\tfunction maybeThenable(x) {\n\t\treturn (typeof x === 'object' || typeof x === 'function') && x !== null;\n\t}\n\n\tfunction identity(x) {\n\t\treturn x;\n\t}\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n},{}],26:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n/** @author Jeff Escalante */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn function fold(Promise) {\n\n\t\tPromise.prototype.fold = function(f, z) {\n\t\t\tvar promise = this._beget();\n\n\t\t\tthis._handler.fold(function(z, x, to) {\n\t\t\t\tPromise._handler(z).fold(function(x, z, to) {\n\t\t\t\t\tto.resolve(f.call(this, z, x));\n\t\t\t\t}, x, this, to);\n\t\t\t}, z, promise._handler.receiver, promise._handler);\n\n\t\t\treturn promise;\n\t\t};\n\n\t\treturn Promise;\n\t};\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n},{}],27:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function(require) {\n\n\tvar inspect = require('../state').inspect;\n\n\treturn function inspection(Promise) {\n\n\t\tPromise.prototype.inspect = function() {\n\t\t\treturn inspect(Promise._handler(this));\n\t\t};\n\n\t\treturn Promise;\n\t};\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n\n},{\"../state\":36}],28:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn function generate(Promise) {\n\n\t\tvar resolve = Promise.resolve;\n\n\t\tPromise.iterate = iterate;\n\t\tPromise.unfold = unfold;\n\n\t\treturn Promise;\n\n\t\t/**\n\t\t * @deprecated Use github.com/cujojs/most streams and most.iterate\n\t\t * Generate a (potentially infinite) stream of promised values:\n\t\t * x, f(x), f(f(x)), etc. until condition(x) returns true\n\t\t * @param {function} f function to generate a new x from the previous x\n\t\t * @param {function} condition function that, given the current x, returns\n\t\t *  truthy when the iterate should stop\n\t\t * @param {function} handler function to handle the value produced by f\n\t\t * @param {*|Promise} x starting value, may be a promise\n\t\t * @return {Promise} the result of the last call to f before\n\t\t *  condition returns true\n\t\t */\n\t\tfunction iterate(f, condition, handler, x) {\n\t\t\treturn unfold(function(x) {\n\t\t\t\treturn [x, f(x)];\n\t\t\t}, condition, handler, x);\n\t\t}\n\n\t\t/**\n\t\t * @deprecated Use github.com/cujojs/most streams and most.unfold\n\t\t * Generate a (potentially infinite) stream of promised values\n\t\t * by applying handler(generator(seed)) iteratively until\n\t\t * condition(seed) returns true.\n\t\t * @param {function} unspool function that generates a [value, newSeed]\n\t\t *  given a seed.\n\t\t * @param {function} condition function that, given the current seed, returns\n\t\t *  truthy when the unfold should stop\n\t\t * @param {function} handler function to handle the value produced by unspool\n\t\t * @param x {*|Promise} starting value, may be a promise\n\t\t * @return {Promise} the result of the last value produced by unspool before\n\t\t *  condition returns true\n\t\t */\n\t\tfunction unfold(unspool, condition, handler, x) {\n\t\t\treturn resolve(x).then(function(seed) {\n\t\t\t\treturn resolve(condition(seed)).then(function(done) {\n\t\t\t\t\treturn done ? seed : resolve(unspool(seed)).spread(next);\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tfunction next(item, newSeed) {\n\t\t\t\treturn resolve(handler(item)).then(function() {\n\t\t\t\t\treturn unfold(unspool, condition, handler, newSeed);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t};\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n},{}],29:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn function progress(Promise) {\n\n\t\t/**\n\t\t * @deprecated\n\t\t * Register a progress handler for this promise\n\t\t * @param {function} onProgress\n\t\t * @returns {Promise}\n\t\t */\n\t\tPromise.prototype.progress = function(onProgress) {\n\t\t\treturn this.then(void 0, void 0, onProgress);\n\t\t};\n\n\t\treturn Promise;\n\t};\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n},{}],30:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function(require) {\n\n\tvar env = require('../env');\n\tvar TimeoutError = require('../TimeoutError');\n\n\tfunction setTimeout(f, ms, x, y) {\n\t\treturn env.setTimer(function() {\n\t\t\tf(x, y, ms);\n\t\t}, ms);\n\t}\n\n\treturn function timed(Promise) {\n\t\t/**\n\t\t * Return a new promise whose fulfillment value is revealed only\n\t\t * after ms milliseconds\n\t\t * @param {number} ms milliseconds\n\t\t * @returns {Promise}\n\t\t */\n\t\tPromise.prototype.delay = function(ms) {\n\t\t\tvar p = this._beget();\n\t\t\tthis._handler.fold(handleDelay, ms, void 0, p._handler);\n\t\t\treturn p;\n\t\t};\n\n\t\tfunction handleDelay(ms, x, h) {\n\t\t\tsetTimeout(resolveDelay, ms, x, h);\n\t\t}\n\n\t\tfunction resolveDelay(x, h) {\n\t\t\th.resolve(x);\n\t\t}\n\n\t\t/**\n\t\t * Return a new promise that rejects after ms milliseconds unless\n\t\t * this promise fulfills earlier, in which case the returned promise\n\t\t * fulfills with the same value.\n\t\t * @param {number} ms milliseconds\n\t\t * @param {Error|*=} reason optional rejection reason to use, defaults\n\t\t *   to a TimeoutError if not provided\n\t\t * @returns {Promise}\n\t\t */\n\t\tPromise.prototype.timeout = function(ms, reason) {\n\t\t\tvar p = this._beget();\n\t\t\tvar h = p._handler;\n\n\t\t\tvar t = setTimeout(onTimeout, ms, reason, p._handler);\n\n\t\t\tthis._handler.visit(h,\n\t\t\t\tfunction onFulfill(x) {\n\t\t\t\t\tenv.clearTimer(t);\n\t\t\t\t\tthis.resolve(x); // this = h\n\t\t\t\t},\n\t\t\t\tfunction onReject(x) {\n\t\t\t\t\tenv.clearTimer(t);\n\t\t\t\t\tthis.reject(x); // this = h\n\t\t\t\t},\n\t\t\t\th.notify);\n\n\t\t\treturn p;\n\t\t};\n\n\t\tfunction onTimeout(reason, h, ms) {\n\t\t\tvar e = typeof reason === 'undefined'\n\t\t\t\t? new TimeoutError('timed out after ' + ms + 'ms')\n\t\t\t\t: reason;\n\t\t\th.reject(e);\n\t\t}\n\n\t\treturn Promise;\n\t};\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n\n},{\"../TimeoutError\":22,\"../env\":33}],31:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function(require) {\n\n\tvar setTimer = require('../env').setTimer;\n\tvar format = require('../format');\n\n\treturn function unhandledRejection(Promise) {\n\n\t\tvar logError = noop;\n\t\tvar logInfo = noop;\n\t\tvar localConsole;\n\n\t\tif(typeof console !== 'undefined') {\n\t\t\t// Alias console to prevent things like uglify's drop_console option from\n\t\t\t// removing console.log/error. Unhandled rejections fall into the same\n\t\t\t// category as uncaught exceptions, and build tools shouldn't silence them.\n\t\t\tlocalConsole = console;\n\t\t\tlogError = typeof localConsole.error !== 'undefined'\n\t\t\t\t? function (e) { localConsole.error(e); }\n\t\t\t\t: function (e) { localConsole.log(e); };\n\n\t\t\tlogInfo = typeof localConsole.info !== 'undefined'\n\t\t\t\t? function (e) { localConsole.info(e); }\n\t\t\t\t: function (e) { localConsole.log(e); };\n\t\t}\n\n\t\tPromise.onPotentiallyUnhandledRejection = function(rejection) {\n\t\t\tenqueue(report, rejection);\n\t\t};\n\n\t\tPromise.onPotentiallyUnhandledRejectionHandled = function(rejection) {\n\t\t\tenqueue(unreport, rejection);\n\t\t};\n\n\t\tPromise.onFatalRejection = function(rejection) {\n\t\t\tenqueue(throwit, rejection.value);\n\t\t};\n\n\t\tvar tasks = [];\n\t\tvar reported = [];\n\t\tvar running = null;\n\n\t\tfunction report(r) {\n\t\t\tif(!r.handled) {\n\t\t\t\treported.push(r);\n\t\t\t\tlogError('Potentially unhandled rejection [' + r.id + '] ' + format.formatError(r.value));\n\t\t\t}\n\t\t}\n\n\t\tfunction unreport(r) {\n\t\t\tvar i = reported.indexOf(r);\n\t\t\tif(i >= 0) {\n\t\t\t\treported.splice(i, 1);\n\t\t\t\tlogInfo('Handled previous rejection [' + r.id + '] ' + format.formatObject(r.value));\n\t\t\t}\n\t\t}\n\n\t\tfunction enqueue(f, x) {\n\t\t\ttasks.push(f, x);\n\t\t\tif(running === null) {\n\t\t\t\trunning = setTimer(flush, 0);\n\t\t\t}\n\t\t}\n\n\t\tfunction flush() {\n\t\t\trunning = null;\n\t\t\twhile(tasks.length > 0) {\n\t\t\t\ttasks.shift()(tasks.shift());\n\t\t\t}\n\t\t}\n\n\t\treturn Promise;\n\t};\n\n\tfunction throwit(e) {\n\t\tthrow e;\n\t}\n\n\tfunction noop() {}\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n\n},{\"../env\":33,\"../format\":34}],32:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn function addWith(Promise) {\n\t\t/**\n\t\t * Returns a promise whose handlers will be called with `this` set to\n\t\t * the supplied receiver.  Subsequent promises derived from the\n\t\t * returned promise will also have their handlers called with receiver\n\t\t * as `this`. Calling `with` with undefined or no arguments will return\n\t\t * a promise whose handlers will again be called in the usual Promises/A+\n\t\t * way (no `this`) thus safely undoing any previous `with` in the\n\t\t * promise chain.\n\t\t *\n\t\t * WARNING: Promises returned from `with`/`withThis` are NOT Promises/A+\n\t\t * compliant, specifically violating 2.2.5 (http://promisesaplus.com/#point-41)\n\t\t *\n\t\t * @param {object} receiver `this` value for all handlers attached to\n\t\t *  the returned promise.\n\t\t * @returns {Promise}\n\t\t */\n\t\tPromise.prototype['with'] = Promise.prototype.withThis = function(receiver) {\n\t\t\tvar p = this._beget();\n\t\t\tvar child = p._handler;\n\t\t\tchild.receiver = receiver;\n\t\t\tthis._handler.chain(child, receiver);\n\t\t\treturn p;\n\t\t};\n\n\t\treturn Promise;\n\t};\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n\n},{}],33:[function(require,module,exports){\n(function (process){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n/*global process,document,setTimeout,clearTimeout,MutationObserver,WebKitMutationObserver*/\n(function(define) { 'use strict';\ndefine(function(require) {\n\t/*jshint maxcomplexity:6*/\n\n\t// Sniff \"best\" async scheduling option\n\t// Prefer process.nextTick or MutationObserver, then check for\n\t// setTimeout, and finally vertx, since its the only env that doesn't\n\t// have setTimeout\n\n\tvar MutationObs;\n\tvar capturedSetTimeout = typeof setTimeout !== 'undefined' && setTimeout;\n\n\t// Default env\n\tvar setTimer = function(f, ms) { return setTimeout(f, ms); };\n\tvar clearTimer = function(t) { return clearTimeout(t); };\n\tvar asap = function (f) { return capturedSetTimeout(f, 0); };\n\n\t// Detect specific env\n\tif (isNode()) { // Node\n\t\tasap = function (f) { return process.nextTick(f); };\n\n\t} else if (MutationObs = hasMutationObserver()) { // Modern browser\n\t\tasap = initMutationObserver(MutationObs);\n\n\t} else if (!capturedSetTimeout) { // vert.x\n\t\tvar vertxRequire = require;\n\t\tvar vertx = vertxRequire('vertx');\n\t\tsetTimer = function (f, ms) { return vertx.setTimer(ms, f); };\n\t\tclearTimer = vertx.cancelTimer;\n\t\tasap = vertx.runOnLoop || vertx.runOnContext;\n\t}\n\n\treturn {\n\t\tsetTimer: setTimer,\n\t\tclearTimer: clearTimer,\n\t\tasap: asap\n\t};\n\n\tfunction isNode () {\n\t\treturn typeof process !== 'undefined' &&\n\t\t\tObject.prototype.toString.call(process) === '[object process]';\n\t}\n\n\tfunction hasMutationObserver () {\n\t\treturn (typeof MutationObserver === 'function' && MutationObserver) ||\n\t\t\t(typeof WebKitMutationObserver === 'function' && WebKitMutationObserver);\n\t}\n\n\tfunction initMutationObserver(MutationObserver) {\n\t\tvar scheduled;\n\t\tvar node = document.createTextNode('');\n\t\tvar o = new MutationObserver(run);\n\t\to.observe(node, { characterData: true });\n\n\t\tfunction run() {\n\t\t\tvar f = scheduled;\n\t\t\tscheduled = void 0;\n\t\t\tf();\n\t\t}\n\n\t\tvar i = 0;\n\t\treturn function (f) {\n\t\t\tscheduled = f;\n\t\t\tnode.data = (i ^= 1);\n\t\t};\n\t}\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n\n}).call(this,require('_process'))\n\n},{\"_process\":1}],34:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn {\n\t\tformatError: formatError,\n\t\tformatObject: formatObject,\n\t\ttryStringify: tryStringify\n\t};\n\n\t/**\n\t * Format an error into a string.  If e is an Error and has a stack property,\n\t * it's returned.  Otherwise, e is formatted using formatObject, with a\n\t * warning added about e not being a proper Error.\n\t * @param {*} e\n\t * @returns {String} formatted string, suitable for output to developers\n\t */\n\tfunction formatError(e) {\n\t\tvar s = typeof e === 'object' && e !== null && (e.stack || e.message) ? e.stack || e.message : formatObject(e);\n\t\treturn e instanceof Error ? s : s + ' (WARNING: non-Error used)';\n\t}\n\n\t/**\n\t * Format an object, detecting \"plain\" objects and running them through\n\t * JSON.stringify if possible.\n\t * @param {Object} o\n\t * @returns {string}\n\t */\n\tfunction formatObject(o) {\n\t\tvar s = String(o);\n\t\tif(s === '[object Object]' && typeof JSON !== 'undefined') {\n\t\t\ts = tryStringify(o, s);\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t * Try to return the result of JSON.stringify(x).  If that fails, return\n\t * defaultValue\n\t * @param {*} x\n\t * @param {*} defaultValue\n\t * @returns {String|*} JSON.stringify(x) or defaultValue\n\t */\n\tfunction tryStringify(x, defaultValue) {\n\t\ttry {\n\t\t\treturn JSON.stringify(x);\n\t\t} catch(e) {\n\t\t\treturn defaultValue;\n\t\t}\n\t}\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n},{}],35:[function(require,module,exports){\n(function (process){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn function makePromise(environment) {\n\n\t\tvar tasks = environment.scheduler;\n\t\tvar emitRejection = initEmitRejection();\n\n\t\tvar objectCreate = Object.create ||\n\t\t\tfunction(proto) {\n\t\t\t\tfunction Child() {}\n\t\t\t\tChild.prototype = proto;\n\t\t\t\treturn new Child();\n\t\t\t};\n\n\t\t/**\n\t\t * Create a promise whose fate is determined by resolver\n\t\t * @constructor\n\t\t * @returns {Promise} promise\n\t\t * @name Promise\n\t\t */\n\t\tfunction Promise(resolver, handler) {\n\t\t\tthis._handler = resolver === Handler ? handler : init(resolver);\n\t\t}\n\n\t\t/**\n\t\t * Run the supplied resolver\n\t\t * @param resolver\n\t\t * @returns {Pending}\n\t\t */\n\t\tfunction init(resolver) {\n\t\t\tvar handler = new Pending();\n\n\t\t\ttry {\n\t\t\t\tresolver(promiseResolve, promiseReject, promiseNotify);\n\t\t\t} catch (e) {\n\t\t\t\tpromiseReject(e);\n\t\t\t}\n\n\t\t\treturn handler;\n\n\t\t\t/**\n\t\t\t * Transition from pre-resolution state to post-resolution state, notifying\n\t\t\t * all listeners of the ultimate fulfillment or rejection\n\t\t\t * @param {*} x resolution value\n\t\t\t */\n\t\t\tfunction promiseResolve (x) {\n\t\t\t\thandler.resolve(x);\n\t\t\t}\n\t\t\t/**\n\t\t\t * Reject this promise with reason, which will be used verbatim\n\t\t\t * @param {Error|*} reason rejection reason, strongly suggested\n\t\t\t *   to be an Error type\n\t\t\t */\n\t\t\tfunction promiseReject (reason) {\n\t\t\t\thandler.reject(reason);\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * @deprecated\n\t\t\t * Issue a progress event, notifying all progress listeners\n\t\t\t * @param {*} x progress event payload to pass to all listeners\n\t\t\t */\n\t\t\tfunction promiseNotify (x) {\n\t\t\t\thandler.notify(x);\n\t\t\t}\n\t\t}\n\n\t\t// Creation\n\n\t\tPromise.resolve = resolve;\n\t\tPromise.reject = reject;\n\t\tPromise.never = never;\n\n\t\tPromise._defer = defer;\n\t\tPromise._handler = getHandler;\n\n\t\t/**\n\t\t * Returns a trusted promise. If x is already a trusted promise, it is\n\t\t * returned, otherwise returns a new trusted Promise which follows x.\n\t\t * @param  {*} x\n\t\t * @return {Promise} promise\n\t\t */\n\t\tfunction resolve(x) {\n\t\t\treturn isPromise(x) ? x\n\t\t\t\t: new Promise(Handler, new Async(getHandler(x)));\n\t\t}\n\n\t\t/**\n\t\t * Return a reject promise with x as its reason (x is used verbatim)\n\t\t * @param {*} x\n\t\t * @returns {Promise} rejected promise\n\t\t */\n\t\tfunction reject(x) {\n\t\t\treturn new Promise(Handler, new Async(new Rejected(x)));\n\t\t}\n\n\t\t/**\n\t\t * Return a promise that remains pending forever\n\t\t * @returns {Promise} forever-pending promise.\n\t\t */\n\t\tfunction never() {\n\t\t\treturn foreverPendingPromise; // Should be frozen\n\t\t}\n\n\t\t/**\n\t\t * Creates an internal {promise, resolver} pair\n\t\t * @private\n\t\t * @returns {Promise}\n\t\t */\n\t\tfunction defer() {\n\t\t\treturn new Promise(Handler, new Pending());\n\t\t}\n\n\t\t// Transformation and flow control\n\n\t\t/**\n\t\t * Transform this promise's fulfillment value, returning a new Promise\n\t\t * for the transformed result.  If the promise cannot be fulfilled, onRejected\n\t\t * is called with the reason.  onProgress *may* be called with updates toward\n\t\t * this promise's fulfillment.\n\t\t * @param {function=} onFulfilled fulfillment handler\n\t\t * @param {function=} onRejected rejection handler\n\t\t * @param {function=} onProgress @deprecated progress handler\n\t\t * @return {Promise} new promise\n\t\t */\n\t\tPromise.prototype.then = function(onFulfilled, onRejected, onProgress) {\n\t\t\tvar parent = this._handler;\n\t\t\tvar state = parent.join().state();\n\n\t\t\tif ((typeof onFulfilled !== 'function' && state > 0) ||\n\t\t\t\t(typeof onRejected !== 'function' && state < 0)) {\n\t\t\t\t// Short circuit: value will not change, simply share handler\n\t\t\t\treturn new this.constructor(Handler, parent);\n\t\t\t}\n\n\t\t\tvar p = this._beget();\n\t\t\tvar child = p._handler;\n\n\t\t\tparent.chain(child, parent.receiver, onFulfilled, onRejected, onProgress);\n\n\t\t\treturn p;\n\t\t};\n\n\t\t/**\n\t\t * If this promise cannot be fulfilled due to an error, call onRejected to\n\t\t * handle the error. Shortcut for .then(undefined, onRejected)\n\t\t * @param {function?} onRejected\n\t\t * @return {Promise}\n\t\t */\n\t\tPromise.prototype['catch'] = function(onRejected) {\n\t\t\treturn this.then(void 0, onRejected);\n\t\t};\n\n\t\t/**\n\t\t * Creates a new, pending promise of the same type as this promise\n\t\t * @private\n\t\t * @returns {Promise}\n\t\t */\n\t\tPromise.prototype._beget = function() {\n\t\t\treturn begetFrom(this._handler, this.constructor);\n\t\t};\n\n\t\tfunction begetFrom(parent, Promise) {\n\t\t\tvar child = new Pending(parent.receiver, parent.join().context);\n\t\t\treturn new Promise(Handler, child);\n\t\t}\n\n\t\t// Array combinators\n\n\t\tPromise.all = all;\n\t\tPromise.race = race;\n\t\tPromise._traverse = traverse;\n\n\t\t/**\n\t\t * Return a promise that will fulfill when all promises in the\n\t\t * input array have fulfilled, or will reject when one of the\n\t\t * promises rejects.\n\t\t * @param {array} promises array of promises\n\t\t * @returns {Promise} promise for array of fulfillment values\n\t\t */\n\t\tfunction all(promises) {\n\t\t\treturn traverseWith(snd, null, promises);\n\t\t}\n\n\t\t/**\n\t\t * Array<Promise<X>> -> Promise<Array<f(X)>>\n\t\t * @private\n\t\t * @param {function} f function to apply to each promise's value\n\t\t * @param {Array} promises array of promises\n\t\t * @returns {Promise} promise for transformed values\n\t\t */\n\t\tfunction traverse(f, promises) {\n\t\t\treturn traverseWith(tryCatch2, f, promises);\n\t\t}\n\n\t\tfunction traverseWith(tryMap, f, promises) {\n\t\t\tvar handler = typeof f === 'function' ? mapAt : settleAt;\n\n\t\t\tvar resolver = new Pending();\n\t\t\tvar pending = promises.length >>> 0;\n\t\t\tvar results = new Array(pending);\n\n\t\t\tfor (var i = 0, x; i < promises.length && !resolver.resolved; ++i) {\n\t\t\t\tx = promises[i];\n\n\t\t\t\tif (x === void 0 && !(i in promises)) {\n\t\t\t\t\t--pending;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttraverseAt(promises, handler, i, x, resolver);\n\t\t\t}\n\n\t\t\tif(pending === 0) {\n\t\t\t\tresolver.become(new Fulfilled(results));\n\t\t\t}\n\n\t\t\treturn new Promise(Handler, resolver);\n\n\t\t\tfunction mapAt(i, x, resolver) {\n\t\t\t\tif(!resolver.resolved) {\n\t\t\t\t\ttraverseAt(promises, settleAt, i, tryMap(f, x, i), resolver);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction settleAt(i, x, resolver) {\n\t\t\t\tresults[i] = x;\n\t\t\t\tif(--pending === 0) {\n\t\t\t\t\tresolver.become(new Fulfilled(results));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction traverseAt(promises, handler, i, x, resolver) {\n\t\t\tif (maybeThenable(x)) {\n\t\t\t\tvar h = getHandlerMaybeThenable(x);\n\t\t\t\tvar s = h.state();\n\n\t\t\t\tif (s === 0) {\n\t\t\t\t\th.fold(handler, i, void 0, resolver);\n\t\t\t\t} else if (s > 0) {\n\t\t\t\t\thandler(i, h.value, resolver);\n\t\t\t\t} else {\n\t\t\t\t\tresolver.become(h);\n\t\t\t\t\tvisitRemaining(promises, i+1, h);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\thandler(i, x, resolver);\n\t\t\t}\n\t\t}\n\n\t\tPromise._visitRemaining = visitRemaining;\n\t\tfunction visitRemaining(promises, start, handler) {\n\t\t\tfor(var i=start; i<promises.length; ++i) {\n\t\t\t\tmarkAsHandled(getHandler(promises[i]), handler);\n\t\t\t}\n\t\t}\n\n\t\tfunction markAsHandled(h, handler) {\n\t\t\tif(h === handler) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar s = h.state();\n\t\t\tif(s === 0) {\n\t\t\t\th.visit(h, void 0, h._unreport);\n\t\t\t} else if(s < 0) {\n\t\t\t\th._unreport();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Fulfill-reject competitive race. Return a promise that will settle\n\t\t * to the same state as the earliest input promise to settle.\n\t\t *\n\t\t * WARNING: The ES6 Promise spec requires that race()ing an empty array\n\t\t * must return a promise that is pending forever.  This implementation\n\t\t * returns a singleton forever-pending promise, the same singleton that is\n\t\t * returned by Promise.never(), thus can be checked with ===\n\t\t *\n\t\t * @param {array} promises array of promises to race\n\t\t * @returns {Promise} if input is non-empty, a promise that will settle\n\t\t * to the same outcome as the earliest input promise to settle. if empty\n\t\t * is empty, returns a promise that will never settle.\n\t\t */\n\t\tfunction race(promises) {\n\t\t\tif(typeof promises !== 'object' || promises === null) {\n\t\t\t\treturn reject(new TypeError('non-iterable passed to race()'));\n\t\t\t}\n\n\t\t\t// Sigh, race([]) is untestable unless we return *something*\n\t\t\t// that is recognizable without calling .then() on it.\n\t\t\treturn promises.length === 0 ? never()\n\t\t\t\t : promises.length === 1 ? resolve(promises[0])\n\t\t\t\t : runRace(promises);\n\t\t}\n\n\t\tfunction runRace(promises) {\n\t\t\tvar resolver = new Pending();\n\t\t\tvar i, x, h;\n\t\t\tfor(i=0; i<promises.length; ++i) {\n\t\t\t\tx = promises[i];\n\t\t\t\tif (x === void 0 && !(i in promises)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\th = getHandler(x);\n\t\t\t\tif(h.state() !== 0) {\n\t\t\t\t\tresolver.become(h);\n\t\t\t\t\tvisitRemaining(promises, i+1, h);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\th.visit(resolver, resolver.resolve, resolver.reject);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new Promise(Handler, resolver);\n\t\t}\n\n\t\t// Promise internals\n\t\t// Below this, everything is @private\n\n\t\t/**\n\t\t * Get an appropriate handler for x, without checking for cycles\n\t\t * @param {*} x\n\t\t * @returns {object} handler\n\t\t */\n\t\tfunction getHandler(x) {\n\t\t\tif(isPromise(x)) {\n\t\t\t\treturn x._handler.join();\n\t\t\t}\n\t\t\treturn maybeThenable(x) ? getHandlerUntrusted(x) : new Fulfilled(x);\n\t\t}\n\n\t\t/**\n\t\t * Get a handler for thenable x.\n\t\t * NOTE: You must only call this if maybeThenable(x) == true\n\t\t * @param {object|function|Promise} x\n\t\t * @returns {object} handler\n\t\t */\n\t\tfunction getHandlerMaybeThenable(x) {\n\t\t\treturn isPromise(x) ? x._handler.join() : getHandlerUntrusted(x);\n\t\t}\n\n\t\t/**\n\t\t * Get a handler for potentially untrusted thenable x\n\t\t * @param {*} x\n\t\t * @returns {object} handler\n\t\t */\n\t\tfunction getHandlerUntrusted(x) {\n\t\t\ttry {\n\t\t\t\tvar untrustedThen = x.then;\n\t\t\t\treturn typeof untrustedThen === 'function'\n\t\t\t\t\t? new Thenable(untrustedThen, x)\n\t\t\t\t\t: new Fulfilled(x);\n\t\t\t} catch(e) {\n\t\t\t\treturn new Rejected(e);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Handler for a promise that is pending forever\n\t\t * @constructor\n\t\t */\n\t\tfunction Handler() {}\n\n\t\tHandler.prototype.when\n\t\t\t= Handler.prototype.become\n\t\t\t= Handler.prototype.notify // deprecated\n\t\t\t= Handler.prototype.fail\n\t\t\t= Handler.prototype._unreport\n\t\t\t= Handler.prototype._report\n\t\t\t= noop;\n\n\t\tHandler.prototype._state = 0;\n\n\t\tHandler.prototype.state = function() {\n\t\t\treturn this._state;\n\t\t};\n\n\t\t/**\n\t\t * Recursively collapse handler chain to find the handler\n\t\t * nearest to the fully resolved value.\n\t\t * @returns {object} handler nearest the fully resolved value\n\t\t */\n\t\tHandler.prototype.join = function() {\n\t\t\tvar h = this;\n\t\t\twhile(h.handler !== void 0) {\n\t\t\t\th = h.handler;\n\t\t\t}\n\t\t\treturn h;\n\t\t};\n\n\t\tHandler.prototype.chain = function(to, receiver, fulfilled, rejected, progress) {\n\t\t\tthis.when({\n\t\t\t\tresolver: to,\n\t\t\t\treceiver: receiver,\n\t\t\t\tfulfilled: fulfilled,\n\t\t\t\trejected: rejected,\n\t\t\t\tprogress: progress\n\t\t\t});\n\t\t};\n\n\t\tHandler.prototype.visit = function(receiver, fulfilled, rejected, progress) {\n\t\t\tthis.chain(failIfRejected, receiver, fulfilled, rejected, progress);\n\t\t};\n\n\t\tHandler.prototype.fold = function(f, z, c, to) {\n\t\t\tthis.when(new Fold(f, z, c, to));\n\t\t};\n\n\t\t/**\n\t\t * Handler that invokes fail() on any handler it becomes\n\t\t * @constructor\n\t\t */\n\t\tfunction FailIfRejected() {}\n\n\t\tinherit(Handler, FailIfRejected);\n\n\t\tFailIfRejected.prototype.become = function(h) {\n\t\t\th.fail();\n\t\t};\n\n\t\tvar failIfRejected = new FailIfRejected();\n\n\t\t/**\n\t\t * Handler that manages a queue of consumers waiting on a pending promise\n\t\t * @constructor\n\t\t */\n\t\tfunction Pending(receiver, inheritedContext) {\n\t\t\tPromise.createContext(this, inheritedContext);\n\n\t\t\tthis.consumers = void 0;\n\t\t\tthis.receiver = receiver;\n\t\t\tthis.handler = void 0;\n\t\t\tthis.resolved = false;\n\t\t}\n\n\t\tinherit(Handler, Pending);\n\n\t\tPending.prototype._state = 0;\n\n\t\tPending.prototype.resolve = function(x) {\n\t\t\tthis.become(getHandler(x));\n\t\t};\n\n\t\tPending.prototype.reject = function(x) {\n\t\t\tif(this.resolved) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.become(new Rejected(x));\n\t\t};\n\n\t\tPending.prototype.join = function() {\n\t\t\tif (!this.resolved) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tvar h = this;\n\n\t\t\twhile (h.handler !== void 0) {\n\t\t\t\th = h.handler;\n\t\t\t\tif (h === this) {\n\t\t\t\t\treturn this.handler = cycle();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn h;\n\t\t};\n\n\t\tPending.prototype.run = function() {\n\t\t\tvar q = this.consumers;\n\t\t\tvar handler = this.handler;\n\t\t\tthis.handler = this.handler.join();\n\t\t\tthis.consumers = void 0;\n\n\t\t\tfor (var i = 0; i < q.length; ++i) {\n\t\t\t\thandler.when(q[i]);\n\t\t\t}\n\t\t};\n\n\t\tPending.prototype.become = function(handler) {\n\t\t\tif(this.resolved) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.resolved = true;\n\t\t\tthis.handler = handler;\n\t\t\tif(this.consumers !== void 0) {\n\t\t\t\ttasks.enqueue(this);\n\t\t\t}\n\n\t\t\tif(this.context !== void 0) {\n\t\t\t\thandler._report(this.context);\n\t\t\t}\n\t\t};\n\n\t\tPending.prototype.when = function(continuation) {\n\t\t\tif(this.resolved) {\n\t\t\t\ttasks.enqueue(new ContinuationTask(continuation, this.handler));\n\t\t\t} else {\n\t\t\t\tif(this.consumers === void 0) {\n\t\t\t\t\tthis.consumers = [continuation];\n\t\t\t\t} else {\n\t\t\t\t\tthis.consumers.push(continuation);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * @deprecated\n\t\t */\n\t\tPending.prototype.notify = function(x) {\n\t\t\tif(!this.resolved) {\n\t\t\t\ttasks.enqueue(new ProgressTask(x, this));\n\t\t\t}\n\t\t};\n\n\t\tPending.prototype.fail = function(context) {\n\t\t\tvar c = typeof context === 'undefined' ? this.context : context;\n\t\t\tthis.resolved && this.handler.join().fail(c);\n\t\t};\n\n\t\tPending.prototype._report = function(context) {\n\t\t\tthis.resolved && this.handler.join()._report(context);\n\t\t};\n\n\t\tPending.prototype._unreport = function() {\n\t\t\tthis.resolved && this.handler.join()._unreport();\n\t\t};\n\n\t\t/**\n\t\t * Wrap another handler and force it into a future stack\n\t\t * @param {object} handler\n\t\t * @constructor\n\t\t */\n\t\tfunction Async(handler) {\n\t\t\tthis.handler = handler;\n\t\t}\n\n\t\tinherit(Handler, Async);\n\n\t\tAsync.prototype.when = function(continuation) {\n\t\t\ttasks.enqueue(new ContinuationTask(continuation, this));\n\t\t};\n\n\t\tAsync.prototype._report = function(context) {\n\t\t\tthis.join()._report(context);\n\t\t};\n\n\t\tAsync.prototype._unreport = function() {\n\t\t\tthis.join()._unreport();\n\t\t};\n\n\t\t/**\n\t\t * Handler that wraps an untrusted thenable and assimilates it in a future stack\n\t\t * @param {function} then\n\t\t * @param {{then: function}} thenable\n\t\t * @constructor\n\t\t */\n\t\tfunction Thenable(then, thenable) {\n\t\t\tPending.call(this);\n\t\t\ttasks.enqueue(new AssimilateTask(then, thenable, this));\n\t\t}\n\n\t\tinherit(Pending, Thenable);\n\n\t\t/**\n\t\t * Handler for a fulfilled promise\n\t\t * @param {*} x fulfillment value\n\t\t * @constructor\n\t\t */\n\t\tfunction Fulfilled(x) {\n\t\t\tPromise.createContext(this);\n\t\t\tthis.value = x;\n\t\t}\n\n\t\tinherit(Handler, Fulfilled);\n\n\t\tFulfilled.prototype._state = 1;\n\n\t\tFulfilled.prototype.fold = function(f, z, c, to) {\n\t\t\trunContinuation3(f, z, this, c, to);\n\t\t};\n\n\t\tFulfilled.prototype.when = function(cont) {\n\t\t\trunContinuation1(cont.fulfilled, this, cont.receiver, cont.resolver);\n\t\t};\n\n\t\tvar errorId = 0;\n\n\t\t/**\n\t\t * Handler for a rejected promise\n\t\t * @param {*} x rejection reason\n\t\t * @constructor\n\t\t */\n\t\tfunction Rejected(x) {\n\t\t\tPromise.createContext(this);\n\n\t\t\tthis.id = ++errorId;\n\t\t\tthis.value = x;\n\t\t\tthis.handled = false;\n\t\t\tthis.reported = false;\n\n\t\t\tthis._report();\n\t\t}\n\n\t\tinherit(Handler, Rejected);\n\n\t\tRejected.prototype._state = -1;\n\n\t\tRejected.prototype.fold = function(f, z, c, to) {\n\t\t\tto.become(this);\n\t\t};\n\n\t\tRejected.prototype.when = function(cont) {\n\t\t\tif(typeof cont.rejected === 'function') {\n\t\t\t\tthis._unreport();\n\t\t\t}\n\t\t\trunContinuation1(cont.rejected, this, cont.receiver, cont.resolver);\n\t\t};\n\n\t\tRejected.prototype._report = function(context) {\n\t\t\ttasks.afterQueue(new ReportTask(this, context));\n\t\t};\n\n\t\tRejected.prototype._unreport = function() {\n\t\t\tif(this.handled) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.handled = true;\n\t\t\ttasks.afterQueue(new UnreportTask(this));\n\t\t};\n\n\t\tRejected.prototype.fail = function(context) {\n\t\t\tthis.reported = true;\n\t\t\temitRejection('unhandledRejection', this);\n\t\t\tPromise.onFatalRejection(this, context === void 0 ? this.context : context);\n\t\t};\n\n\t\tfunction ReportTask(rejection, context) {\n\t\t\tthis.rejection = rejection;\n\t\t\tthis.context = context;\n\t\t}\n\n\t\tReportTask.prototype.run = function() {\n\t\t\tif(!this.rejection.handled && !this.rejection.reported) {\n\t\t\t\tthis.rejection.reported = true;\n\t\t\t\temitRejection('unhandledRejection', this.rejection) ||\n\t\t\t\t\tPromise.onPotentiallyUnhandledRejection(this.rejection, this.context);\n\t\t\t}\n\t\t};\n\n\t\tfunction UnreportTask(rejection) {\n\t\t\tthis.rejection = rejection;\n\t\t}\n\n\t\tUnreportTask.prototype.run = function() {\n\t\t\tif(this.rejection.reported) {\n\t\t\t\temitRejection('rejectionHandled', this.rejection) ||\n\t\t\t\t\tPromise.onPotentiallyUnhandledRejectionHandled(this.rejection);\n\t\t\t}\n\t\t};\n\n\t\t// Unhandled rejection hooks\n\t\t// By default, everything is a noop\n\n\t\tPromise.createContext\n\t\t\t= Promise.enterContext\n\t\t\t= Promise.exitContext\n\t\t\t= Promise.onPotentiallyUnhandledRejection\n\t\t\t= Promise.onPotentiallyUnhandledRejectionHandled\n\t\t\t= Promise.onFatalRejection\n\t\t\t= noop;\n\n\t\t// Errors and singletons\n\n\t\tvar foreverPendingHandler = new Handler();\n\t\tvar foreverPendingPromise = new Promise(Handler, foreverPendingHandler);\n\n\t\tfunction cycle() {\n\t\t\treturn new Rejected(new TypeError('Promise cycle'));\n\t\t}\n\n\t\t// Task runners\n\n\t\t/**\n\t\t * Run a single consumer\n\t\t * @constructor\n\t\t */\n\t\tfunction ContinuationTask(continuation, handler) {\n\t\t\tthis.continuation = continuation;\n\t\t\tthis.handler = handler;\n\t\t}\n\n\t\tContinuationTask.prototype.run = function() {\n\t\t\tthis.handler.join().when(this.continuation);\n\t\t};\n\n\t\t/**\n\t\t * Run a queue of progress handlers\n\t\t * @constructor\n\t\t */\n\t\tfunction ProgressTask(value, handler) {\n\t\t\tthis.handler = handler;\n\t\t\tthis.value = value;\n\t\t}\n\n\t\tProgressTask.prototype.run = function() {\n\t\t\tvar q = this.handler.consumers;\n\t\t\tif(q === void 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (var c, i = 0; i < q.length; ++i) {\n\t\t\t\tc = q[i];\n\t\t\t\trunNotify(c.progress, this.value, this.handler, c.receiver, c.resolver);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Assimilate a thenable, sending it's value to resolver\n\t\t * @param {function} then\n\t\t * @param {object|function} thenable\n\t\t * @param {object} resolver\n\t\t * @constructor\n\t\t */\n\t\tfunction AssimilateTask(then, thenable, resolver) {\n\t\t\tthis._then = then;\n\t\t\tthis.thenable = thenable;\n\t\t\tthis.resolver = resolver;\n\t\t}\n\n\t\tAssimilateTask.prototype.run = function() {\n\t\t\tvar h = this.resolver;\n\t\t\ttryAssimilate(this._then, this.thenable, _resolve, _reject, _notify);\n\n\t\t\tfunction _resolve(x) { h.resolve(x); }\n\t\t\tfunction _reject(x)  { h.reject(x); }\n\t\t\tfunction _notify(x)  { h.notify(x); }\n\t\t};\n\n\t\tfunction tryAssimilate(then, thenable, resolve, reject, notify) {\n\t\t\ttry {\n\t\t\t\tthen.call(thenable, resolve, reject, notify);\n\t\t\t} catch (e) {\n\t\t\t\treject(e);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Fold a handler value with z\n\t\t * @constructor\n\t\t */\n\t\tfunction Fold(f, z, c, to) {\n\t\t\tthis.f = f; this.z = z; this.c = c; this.to = to;\n\t\t\tthis.resolver = failIfRejected;\n\t\t\tthis.receiver = this;\n\t\t}\n\n\t\tFold.prototype.fulfilled = function(x) {\n\t\t\tthis.f.call(this.c, this.z, x, this.to);\n\t\t};\n\n\t\tFold.prototype.rejected = function(x) {\n\t\t\tthis.to.reject(x);\n\t\t};\n\n\t\tFold.prototype.progress = function(x) {\n\t\t\tthis.to.notify(x);\n\t\t};\n\n\t\t// Other helpers\n\n\t\t/**\n\t\t * @param {*} x\n\t\t * @returns {boolean} true iff x is a trusted Promise\n\t\t */\n\t\tfunction isPromise(x) {\n\t\t\treturn x instanceof Promise;\n\t\t}\n\n\t\t/**\n\t\t * Test just enough to rule out primitives, in order to take faster\n\t\t * paths in some code\n\t\t * @param {*} x\n\t\t * @returns {boolean} false iff x is guaranteed *not* to be a thenable\n\t\t */\n\t\tfunction maybeThenable(x) {\n\t\t\treturn (typeof x === 'object' || typeof x === 'function') && x !== null;\n\t\t}\n\n\t\tfunction runContinuation1(f, h, receiver, next) {\n\t\t\tif(typeof f !== 'function') {\n\t\t\t\treturn next.become(h);\n\t\t\t}\n\n\t\t\tPromise.enterContext(h);\n\t\t\ttryCatchReject(f, h.value, receiver, next);\n\t\t\tPromise.exitContext();\n\t\t}\n\n\t\tfunction runContinuation3(f, x, h, receiver, next) {\n\t\t\tif(typeof f !== 'function') {\n\t\t\t\treturn next.become(h);\n\t\t\t}\n\n\t\t\tPromise.enterContext(h);\n\t\t\ttryCatchReject3(f, x, h.value, receiver, next);\n\t\t\tPromise.exitContext();\n\t\t}\n\n\t\t/**\n\t\t * @deprecated\n\t\t */\n\t\tfunction runNotify(f, x, h, receiver, next) {\n\t\t\tif(typeof f !== 'function') {\n\t\t\t\treturn next.notify(x);\n\t\t\t}\n\n\t\t\tPromise.enterContext(h);\n\t\t\ttryCatchReturn(f, x, receiver, next);\n\t\t\tPromise.exitContext();\n\t\t}\n\n\t\tfunction tryCatch2(f, a, b) {\n\t\t\ttry {\n\t\t\t\treturn f(a, b);\n\t\t\t} catch(e) {\n\t\t\t\treturn reject(e);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Return f.call(thisArg, x), or if it throws return a rejected promise for\n\t\t * the thrown exception\n\t\t */\n\t\tfunction tryCatchReject(f, x, thisArg, next) {\n\t\t\ttry {\n\t\t\t\tnext.become(getHandler(f.call(thisArg, x)));\n\t\t\t} catch(e) {\n\t\t\t\tnext.become(new Rejected(e));\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Same as above, but includes the extra argument parameter.\n\t\t */\n\t\tfunction tryCatchReject3(f, x, y, thisArg, next) {\n\t\t\ttry {\n\t\t\t\tf.call(thisArg, x, y, next);\n\t\t\t} catch(e) {\n\t\t\t\tnext.become(new Rejected(e));\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @deprecated\n\t\t * Return f.call(thisArg, x), or if it throws, *return* the exception\n\t\t */\n\t\tfunction tryCatchReturn(f, x, thisArg, next) {\n\t\t\ttry {\n\t\t\t\tnext.notify(f.call(thisArg, x));\n\t\t\t} catch(e) {\n\t\t\t\tnext.notify(e);\n\t\t\t}\n\t\t}\n\n\t\tfunction inherit(Parent, Child) {\n\t\t\tChild.prototype = objectCreate(Parent.prototype);\n\t\t\tChild.prototype.constructor = Child;\n\t\t}\n\n\t\tfunction snd(x, y) {\n\t\t\treturn y;\n\t\t}\n\n\t\tfunction noop() {}\n\n\t\tfunction initEmitRejection() {\n\t\t\t/*global process, self, CustomEvent*/\n\t\t\tif(typeof process !== 'undefined' && process !== null\n\t\t\t\t&& typeof process.emit === 'function') {\n\t\t\t\t// Returning falsy here means to call the default\n\t\t\t\t// onPotentiallyUnhandledRejection API.  This is safe even in\n\t\t\t\t// browserify since process.emit always returns falsy in browserify:\n\t\t\t\t// https://github.com/defunctzombie/node-process/blob/master/browser.js#L40-L46\n\t\t\t\treturn function(type, rejection) {\n\t\t\t\t\treturn type === 'unhandledRejection'\n\t\t\t\t\t\t? process.emit(type, rejection.value, rejection)\n\t\t\t\t\t\t: process.emit(type, rejection);\n\t\t\t\t};\n\t\t\t} else if(typeof self !== 'undefined' && typeof CustomEvent === 'function') {\n\t\t\t\treturn (function(noop, self, CustomEvent) {\n\t\t\t\t\tvar hasCustomEvent = false;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar ev = new CustomEvent('unhandledRejection');\n\t\t\t\t\t\thasCustomEvent = ev instanceof CustomEvent;\n\t\t\t\t\t} catch (e) {}\n\n\t\t\t\t\treturn !hasCustomEvent ? noop : function(type, rejection) {\n\t\t\t\t\t\tvar ev = new CustomEvent(type, {\n\t\t\t\t\t\t\tdetail: {\n\t\t\t\t\t\t\t\treason: rejection.value,\n\t\t\t\t\t\t\t\tkey: rejection\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tbubbles: false,\n\t\t\t\t\t\t\tcancelable: true\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn !self.dispatchEvent(ev);\n\t\t\t\t\t};\n\t\t\t\t}(noop, self, CustomEvent));\n\t\t\t}\n\n\t\t\treturn noop;\n\t\t}\n\n\t\treturn Promise;\n\t};\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n}).call(this,require('_process'))\n\n},{\"_process\":1}],36:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn {\n\t\tpending: toPendingState,\n\t\tfulfilled: toFulfilledState,\n\t\trejected: toRejectedState,\n\t\tinspect: inspect\n\t};\n\n\tfunction toPendingState() {\n\t\treturn { state: 'pending' };\n\t}\n\n\tfunction toRejectedState(e) {\n\t\treturn { state: 'rejected', reason: e };\n\t}\n\n\tfunction toFulfilledState(x) {\n\t\treturn { state: 'fulfilled', value: x };\n\t}\n\n\tfunction inspect(handler) {\n\t\tvar state = handler.state();\n\t\treturn state === 0 ? toPendingState()\n\t\t\t : state > 0   ? toFulfilledState(handler.value)\n\t\t\t               : toRejectedState(handler.value);\n\t}\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n},{}],37:[function(require,module,exports){\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n\n/**\n * Promises/A+ and when() implementation\n * when is part of the cujoJS family of libraries (http://cujojs.com/)\n * @author Brian Cavalier\n * @author John Hann\n */\n(function(define) { 'use strict';\ndefine(function (require) {\n\n\tvar timed = require('./lib/decorators/timed');\n\tvar array = require('./lib/decorators/array');\n\tvar flow = require('./lib/decorators/flow');\n\tvar fold = require('./lib/decorators/fold');\n\tvar inspect = require('./lib/decorators/inspect');\n\tvar generate = require('./lib/decorators/iterate');\n\tvar progress = require('./lib/decorators/progress');\n\tvar withThis = require('./lib/decorators/with');\n\tvar unhandledRejection = require('./lib/decorators/unhandledRejection');\n\tvar TimeoutError = require('./lib/TimeoutError');\n\n\tvar Promise = [array, flow, fold, generate, progress,\n\t\tinspect, withThis, timed, unhandledRejection]\n\t\t.reduce(function(Promise, feature) {\n\t\t\treturn feature(Promise);\n\t\t}, require('./lib/Promise'));\n\n\tvar apply = require('./lib/apply')(Promise);\n\n\t// Public API\n\n\twhen.promise     = promise;              // Create a pending promise\n\twhen.resolve     = Promise.resolve;      // Create a resolved promise\n\twhen.reject      = Promise.reject;       // Create a rejected promise\n\n\twhen.lift        = lift;                 // lift a function to return promises\n\twhen['try']      = attempt;              // call a function and return a promise\n\twhen.attempt     = attempt;              // alias for when.try\n\n\twhen.iterate     = Promise.iterate;      // DEPRECATED (use cujojs/most streams) Generate a stream of promises\n\twhen.unfold      = Promise.unfold;       // DEPRECATED (use cujojs/most streams) Generate a stream of promises\n\n\twhen.join        = join;                 // Join 2 or more promises\n\n\twhen.all         = all;                  // Resolve a list of promises\n\twhen.settle      = settle;               // Settle a list of promises\n\n\twhen.any         = lift(Promise.any);    // One-winner race\n\twhen.some        = lift(Promise.some);   // Multi-winner race\n\twhen.race        = lift(Promise.race);   // First-to-settle race\n\n\twhen.map         = map;                  // Array.map() for promises\n\twhen.filter      = filter;               // Array.filter() for promises\n\twhen.reduce      = lift(Promise.reduce);       // Array.reduce() for promises\n\twhen.reduceRight = lift(Promise.reduceRight);  // Array.reduceRight() for promises\n\n\twhen.isPromiseLike = isPromiseLike;      // Is something promise-like, aka thenable\n\n\twhen.Promise     = Promise;              // Promise constructor\n\twhen.defer       = defer;                // Create a {promise, resolve, reject} tuple\n\n\t// Error types\n\n\twhen.TimeoutError = TimeoutError;\n\n\t/**\n\t * Get a trusted promise for x, or by transforming x with onFulfilled\n\t *\n\t * @param {*} x\n\t * @param {function?} onFulfilled callback to be called when x is\n\t *   successfully fulfilled.  If promiseOrValue is an immediate value, callback\n\t *   will be invoked immediately.\n\t * @param {function?} onRejected callback to be called when x is\n\t *   rejected.\n\t * @param {function?} onProgress callback to be called when progress updates\n\t *   are issued for x. @deprecated\n\t * @returns {Promise} a new promise that will fulfill with the return\n\t *   value of callback or errback or the completion value of promiseOrValue if\n\t *   callback and/or errback is not supplied.\n\t */\n\tfunction when(x, onFulfilled, onRejected, onProgress) {\n\t\tvar p = Promise.resolve(x);\n\t\tif (arguments.length < 2) {\n\t\t\treturn p;\n\t\t}\n\n\t\treturn p.then(onFulfilled, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Creates a new promise whose fate is determined by resolver.\n\t * @param {function} resolver function(resolve, reject, notify)\n\t * @returns {Promise} promise whose fate is determine by resolver\n\t */\n\tfunction promise(resolver) {\n\t\treturn new Promise(resolver);\n\t}\n\n\t/**\n\t * Lift the supplied function, creating a version of f that returns\n\t * promises, and accepts promises as arguments.\n\t * @param {function} f\n\t * @returns {Function} version of f that returns promises\n\t */\n\tfunction lift(f) {\n\t\treturn function() {\n\t\t\tfor(var i=0, l=arguments.length, a=new Array(l); i<l; ++i) {\n\t\t\t\ta[i] = arguments[i];\n\t\t\t}\n\t\t\treturn apply(f, this, a);\n\t\t};\n\t}\n\n\t/**\n\t * Call f in a future turn, with the supplied args, and return a promise\n\t * for the result.\n\t * @param {function} f\n\t * @returns {Promise}\n\t */\n\tfunction attempt(f /*, args... */) {\n\t\t/*jshint validthis:true */\n\t\tfor(var i=0, l=arguments.length-1, a=new Array(l); i<l; ++i) {\n\t\t\ta[i] = arguments[i+1];\n\t\t}\n\t\treturn apply(f, this, a);\n\t}\n\n\t/**\n\t * Creates a {promise, resolver} pair, either or both of which\n\t * may be given out safely to consumers.\n\t * @return {{promise: Promise, resolve: function, reject: function, notify: function}}\n\t */\n\tfunction defer() {\n\t\treturn new Deferred();\n\t}\n\n\tfunction Deferred() {\n\t\tvar p = Promise._defer();\n\n\t\tfunction resolve(x) { p._handler.resolve(x); }\n\t\tfunction reject(x) { p._handler.reject(x); }\n\t\tfunction notify(x) { p._handler.notify(x); }\n\n\t\tthis.promise = p;\n\t\tthis.resolve = resolve;\n\t\tthis.reject = reject;\n\t\tthis.notify = notify;\n\t\tthis.resolver = { resolve: resolve, reject: reject, notify: notify };\n\t}\n\n\t/**\n\t * Determines if x is promise-like, i.e. a thenable object\n\t * NOTE: Will return true for *any thenable object*, and isn't truly\n\t * safe, since it may attempt to access the `then` property of x (i.e.\n\t *  clever/malicious getters may do weird things)\n\t * @param {*} x anything\n\t * @returns {boolean} true if x is promise-like\n\t */\n\tfunction isPromiseLike(x) {\n\t\treturn x && typeof x.then === 'function';\n\t}\n\n\t/**\n\t * Return a promise that will resolve only once all the supplied arguments\n\t * have resolved. The resolution value of the returned promise will be an array\n\t * containing the resolution values of each of the arguments.\n\t * @param {...*} arguments may be a mix of promises and values\n\t * @returns {Promise}\n\t */\n\tfunction join(/* ...promises */) {\n\t\treturn Promise.all(arguments);\n\t}\n\n\t/**\n\t * Return a promise that will fulfill once all input promises have\n\t * fulfilled, or reject when any one input promise rejects.\n\t * @param {array|Promise} promises array (or promise for an array) of promises\n\t * @returns {Promise}\n\t */\n\tfunction all(promises) {\n\t\treturn when(promises, Promise.all);\n\t}\n\n\t/**\n\t * Return a promise that will always fulfill with an array containing\n\t * the outcome states of all input promises.  The returned promise\n\t * will only reject if `promises` itself is a rejected promise.\n\t * @param {array|Promise} promises array (or promise for an array) of promises\n\t * @returns {Promise} promise for array of settled state descriptors\n\t */\n\tfunction settle(promises) {\n\t\treturn when(promises, Promise.settle);\n\t}\n\n\t/**\n\t * Promise-aware array map function, similar to `Array.prototype.map()`,\n\t * but input array may contain promises or values.\n\t * @param {Array|Promise} promises array of anything, may contain promises and values\n\t * @param {function(x:*, index:Number):*} mapFunc map function which may\n\t *  return a promise or value\n\t * @returns {Promise} promise that will fulfill with an array of mapped values\n\t *  or reject if any input promise rejects.\n\t */\n\tfunction map(promises, mapFunc) {\n\t\treturn when(promises, function(promises) {\n\t\t\treturn Promise.map(promises, mapFunc);\n\t\t});\n\t}\n\n\t/**\n\t * Filter the provided array of promises using the provided predicate.  Input may\n\t * contain promises and values\n\t * @param {Array|Promise} promises array of promises and values\n\t * @param {function(x:*, index:Number):boolean} predicate filtering predicate.\n\t *  Must return truthy (or promise for truthy) for items to retain.\n\t * @returns {Promise} promise that will fulfill with an array containing all items\n\t *  for which predicate returned truthy.\n\t */\n\tfunction filter(promises, predicate) {\n\t\treturn when(promises, function(promises) {\n\t\t\treturn Promise.filter(promises, predicate);\n\t\t});\n\t}\n\n\treturn when;\n});\n})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });\n\n},{\"./lib/Promise\":20,\"./lib/TimeoutError\":22,\"./lib/apply\":23,\"./lib/decorators/array\":24,\"./lib/decorators/flow\":25,\"./lib/decorators/fold\":26,\"./lib/decorators/inspect\":27,\"./lib/decorators/iterate\":28,\"./lib/decorators/progress\":29,\"./lib/decorators/timed\":30,\"./lib/decorators/unhandledRejection\":31,\"./lib/decorators/with\":32}],38:[function(require,module,exports){\n/*\n * Copyright 2013 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (/* require */) {\n\n\t\treturn {\n\n\t\t\t/**\n\t\t\t * Find objects within a graph the contain a property of a certain name.\n\t\t\t *\n\t\t\t * NOTE: this method will not discover object graph cycles.\n\t\t\t *\n\t\t\t * @param {*} obj object to search on\n\t\t\t * @param {string} prop name of the property to search for\n\t\t\t * @param {Function} callback function to receive the found properties and their parent\n\t\t\t */\n\t\t\tfindProperties: function findProperties(obj, prop, callback) {\n\t\t\t\tif (typeof obj !== 'object' || obj === null) { return; }\n\t\t\t\tif (prop in obj) {\n\t\t\t\t\tcallback(obj[prop], obj, prop);\n\t\t\t\t}\n\t\t\t\tObject.keys(obj).forEach(function (key) {\n\t\t\t\t\tfindProperties(obj[key], prop, callback);\n\t\t\t\t});\n\t\t\t}\n\n\t\t};\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{}],39:[function(require,module,exports){\n/*\n * Copyright 2013 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (require) {\n\n\t\tvar when;\n\n\t\twhen = require('when');\n\n\t\t/**\n\t\t * Create a promise whose work is started only when a handler is registered.\n\t\t *\n\t\t * The work function will be invoked at most once. Thrown values will result\n\t\t * in promise rejection.\n\t\t *\n\t\t * @param {Function} work function whose ouput is used to resolve the\n\t\t *   returned promise.\n\t\t * @returns {Promise} a lazy promise\n\t\t */\n\t\tfunction lazyPromise(work) {\n\t\t\tvar defer, started, resolver, promise, then;\n\n\t\t\tdefer = when.defer();\n\t\t\tstarted = false;\n\n\t\t\tresolver = defer.resolver;\n\t\t\tpromise = defer.promise;\n\t\t\tthen = promise.then;\n\n\t\t\tpromise.then = function () {\n\t\t\t\tif (!started) {\n\t\t\t\t\tstarted = true;\n\t\t\t\t\twhen.attempt(work).then(resolver.resolve, resolver.reject);\n\t\t\t\t}\n\t\t\t\treturn then.apply(promise, arguments);\n\t\t\t};\n\n\t\t\treturn promise;\n\t\t}\n\n\t\treturn lazyPromise;\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{\"when\":37}],40:[function(require,module,exports){\n/*\n * Copyright 2012-2013 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\t// derived from dojo.mixin\n\tdefine(function (/* require */) {\n\n\t\tvar empty = {};\n\n\t\t/**\n\t\t * Mix the properties from the source object into the destination object.\n\t\t * When the same property occurs in more then one object, the right most\n\t\t * value wins.\n\t\t *\n\t\t * @param {Object} dest the object to copy properties to\n\t\t * @param {Object} sources the objects to copy properties from.  May be 1 to N arguments, but not an Array.\n\t\t * @return {Object} the destination object\n\t\t */\n\t\tfunction mixin(dest /*, sources... */) {\n\t\t\tvar i, l, source, name;\n\n\t\t\tif (!dest) { dest = {}; }\n\t\t\tfor (i = 1, l = arguments.length; i < l; i += 1) {\n\t\t\t\tsource = arguments[i];\n\t\t\t\tfor (name in source) {\n\t\t\t\t\tif (!(name in dest) || (dest[name] !== source[name] && (!(name in empty) || empty[name] !== source[name]))) {\n\t\t\t\t\t\tdest[name] = source[name];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn dest; // Object\n\t\t}\n\n\t\treturn mixin;\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{}],41:[function(require,module,exports){\n/*\n * Copyright 2012 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (/* require */) {\n\n\t\t/**\n\t\t * Normalize HTTP header names using the pseudo camel case.\n\t\t *\n\t\t * For example:\n\t\t *   content-type         -> Content-Type\n\t\t *   accepts              -> Accepts\n\t\t *   x-custom-header-name -> X-Custom-Header-Name\n\t\t *\n\t\t * @param {string} name the raw header name\n\t\t * @return {string} the normalized header name\n\t\t */\n\t\tfunction normalizeHeaderName(name) {\n\t\t\treturn name.toLowerCase()\n\t\t\t\t.split('-')\n\t\t\t\t.map(function (chunk) { return chunk.charAt(0).toUpperCase() + chunk.slice(1); })\n\t\t\t\t.join('-');\n\t\t}\n\n\t\treturn normalizeHeaderName;\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{}],42:[function(require,module,exports){\n/*\n * Copyright 2014-2015 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (require) {\n\n\t\tvar when = require('when'),\n\t\t\tnormalizeHeaderName = require('./normalizeHeaderName');\n\n\t\tfunction property(promise, name) {\n\t\t\treturn promise.then(\n\t\t\t\tfunction (value) {\n\t\t\t\t\treturn value && value[name];\n\t\t\t\t},\n\t\t\t\tfunction (value) {\n\t\t\t\t\treturn when.reject(value && value[name]);\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\t/**\n\t\t * Obtain the response entity\n\t\t *\n\t\t * @returns {Promise} for the response entity\n\t\t */\n\t\tfunction entity() {\n\t\t\t/*jshint validthis:true */\n\t\t\treturn property(this, 'entity');\n\t\t}\n\n\t\t/**\n\t\t * Obtain the response status\n\t\t *\n\t\t * @returns {Promise} for the response status\n\t\t */\n\t\tfunction status() {\n\t\t\t/*jshint validthis:true */\n\t\t\treturn property(property(this, 'status'), 'code');\n\t\t}\n\n\t\t/**\n\t\t * Obtain the response headers map\n\t\t *\n\t\t * @returns {Promise} for the response headers map\n\t\t */\n\t\tfunction headers() {\n\t\t\t/*jshint validthis:true */\n\t\t\treturn property(this, 'headers');\n\t\t}\n\n\t\t/**\n\t\t * Obtain a specific response header\n\t\t *\n\t\t * @param {String} headerName the header to retrieve\n\t\t * @returns {Promise} for the response header's value\n\t\t */\n\t\tfunction header(headerName) {\n\t\t\t/*jshint validthis:true */\n\t\t\theaderName = normalizeHeaderName(headerName);\n\t\t\treturn property(this.headers(), headerName);\n\t\t}\n\n\t\t/**\n\t\t * Follow a related resource\n\t\t *\n\t\t * The relationship to follow may be define as a plain string, an object\n\t\t * with the rel and params, or an array containing one or more entries\n\t\t * with the previous forms.\n\t\t *\n\t\t * Examples:\n\t\t *   response.follow('next')\n\t\t *\n\t\t *   response.follow({ rel: 'next', params: { pageSize: 100 } })\n\t\t *\n\t\t *   response.follow([\n\t\t *       { rel: 'items', params: { projection: 'noImages' } },\n\t\t *       'search',\n\t\t *       { rel: 'findByGalleryIsNull', params: { projection: 'noImages' } },\n\t\t *       'items'\n\t\t *   ])\n\t\t *\n\t\t * @param {String|Object|Array} rels one, or more, relationships to follow\n\t\t * @returns ResponsePromise<Response> related resource\n\t\t */\n\t\tfunction follow(rels) {\n\t\t\t/*jshint validthis:true */\n\t\t\trels = [].concat(rels);\n\t\t\treturn make(when.reduce(rels, function (response, rel) {\n\t\t\t\tif (typeof rel === 'string') {\n\t\t\t\t\trel = { rel: rel };\n\t\t\t\t}\n\t\t\t\tif (typeof response.entity.clientFor !== 'function') {\n\t\t\t\t\tthrow new Error('Hypermedia response expected');\n\t\t\t\t}\n\t\t\t\tvar client = response.entity.clientFor(rel.rel);\n\t\t\t\treturn client({ params: rel.params });\n\t\t\t}, this));\n\t\t}\n\n\t\t/**\n\t\t * Wrap a Promise as an ResponsePromise\n\t\t *\n\t\t * @param {Promise<Response>} promise the promise for an HTTP Response\n\t\t * @returns {ResponsePromise<Response>} wrapped promise for Response with additional helper methods\n\t\t */\n\t\tfunction make(promise) {\n\t\t\tpromise.status = status;\n\t\t\tpromise.headers = headers;\n\t\t\tpromise.header = header;\n\t\t\tpromise.entity = entity;\n\t\t\tpromise.follow = follow;\n\t\t\treturn promise;\n\t\t}\n\n\t\tfunction responsePromise() {\n\t\t\treturn make(when.apply(when, arguments));\n\t\t}\n\n\t\tresponsePromise.make = make;\n\t\tresponsePromise.reject = function (val) {\n\t\t\treturn make(when.reject(val));\n\t\t};\n\t\tresponsePromise.promise = function (func) {\n\t\t\treturn make(when.promise(func));\n\t\t};\n\n\t\treturn responsePromise;\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{\"./normalizeHeaderName\":41,\"when\":37}],43:[function(require,module,exports){\n/*\n * Copyright 2015 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (/* require */) {\n\n\t\tvar charMap;\n\n\t\tcharMap = (function () {\n\t\t\tvar strings = {\n\t\t\t\talpha: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n\t\t\t\tdigit: '0123456789'\n\t\t\t};\n\n\t\t\tstrings.genDelims = ':/?#[]@';\n\t\t\tstrings.subDelims = '!$&\\'()*+,;=';\n\t\t\tstrings.reserved = strings.genDelims + strings.subDelims;\n\t\t\tstrings.unreserved = strings.alpha + strings.digit + '-._~';\n\t\t\tstrings.url = strings.reserved + strings.unreserved;\n\t\t\tstrings.scheme = strings.alpha + strings.digit + '+-.';\n\t\t\tstrings.userinfo = strings.unreserved + strings.subDelims + ':';\n\t\t\tstrings.host = strings.unreserved + strings.subDelims;\n\t\t\tstrings.port = strings.digit;\n\t\t\tstrings.pchar = strings.unreserved + strings.subDelims + ':@';\n\t\t\tstrings.segment = strings.pchar;\n\t\t\tstrings.path = strings.segment + '/';\n\t\t\tstrings.query = strings.pchar + '/?';\n\t\t\tstrings.fragment = strings.pchar + '/?';\n\n\t\t\treturn Object.keys(strings).reduce(function (charMap, set) {\n\t\t\t\tcharMap[set] = strings[set].split('').reduce(function (chars, myChar) {\n\t\t\t\t\tchars[myChar] = true;\n\t\t\t\t\treturn chars;\n\t\t\t\t}, {});\n\t\t\t\treturn charMap;\n\t\t\t}, {});\n\t\t}());\n\n\t\tfunction encode(str, allowed) {\n\t\t\tif (typeof str !== 'string') {\n\t\t\t\tthrow new Error('String required for URL encoding');\n\t\t\t}\n\t\t\treturn str.split('').map(function (myChar) {\n\t\t\t\tif (allowed.hasOwnProperty(myChar)) {\n\t\t\t\t\treturn myChar;\n\t\t\t\t}\n\t\t\t\tvar code = myChar.charCodeAt(0);\n\t\t\t\tif (code <= 127) {\n\t\t\t\t\tvar encoded = code.toString(16).toUpperCase();\n\t\t\t\t\treturn '%' + (encoded.length % 2 === 1 ? '0' : '') + encoded;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn encodeURIComponent(myChar).toUpperCase();\n\t\t\t\t}\n\t\t\t}).join('');\n\t\t}\n\n\t\tfunction makeEncoder(allowed) {\n\t\t\tallowed = allowed || charMap.unreserved;\n\t\t\treturn function (str) {\n\t\t\t\treturn encode(str, allowed);\n\t\t\t};\n\t\t}\n\n\t\tfunction decode(str) {\n\t\t\treturn decodeURIComponent(str);\n\t\t}\n\n\t\treturn {\n\n\t\t\t/*\n\t\t\t * Decode URL encoded strings\n\t\t\t *\n\t\t\t * @param {string} URL encoded string\n\t\t\t * @returns {string} URL decoded string\n\t\t\t */\n\t\t\tdecode: decode,\n\n\t\t\t/*\n\t\t\t * URL encode a string\n\t\t\t *\n\t\t\t * All but alpha-numerics and a very limited set of punctuation - . _ ~ are\n\t\t\t * encoded.\n\t\t\t *\n\t\t\t * @param {string} string to encode\n\t\t\t * @returns {string} URL encoded string\n\t\t\t */\n\t\t\tencode: makeEncoder(),\n\n\t\t\t/*\n\t\t\t* URL encode a URL\n\t\t\t*\n\t\t\t* All character permitted anywhere in a URL are left unencoded even\n\t\t\t* if that character is not permitted in that portion of a URL.\n\t\t\t*\n\t\t\t* Note: This method is typically not what you want.\n\t\t\t*\n\t\t\t* @param {string} string to encode\n\t\t\t* @returns {string} URL encoded string\n\t\t\t*/\n\t\t\tencodeURL: makeEncoder(charMap.url),\n\n\t\t\t/*\n\t\t\t * URL encode the scheme portion of a URL\n\t\t\t *\n\t\t\t * @param {string} string to encode\n\t\t\t * @returns {string} URL encoded string\n\t\t\t */\n\t\t\tencodeScheme: makeEncoder(charMap.scheme),\n\n\t\t\t/*\n\t\t\t * URL encode the user info portion of a URL\n\t\t\t *\n\t\t\t * @param {string} string to encode\n\t\t\t * @returns {string} URL encoded string\n\t\t\t */\n\t\t\tencodeUserInfo: makeEncoder(charMap.userinfo),\n\n\t\t\t/*\n\t\t\t * URL encode the host portion of a URL\n\t\t\t *\n\t\t\t * @param {string} string to encode\n\t\t\t * @returns {string} URL encoded string\n\t\t\t */\n\t\t\tencodeHost: makeEncoder(charMap.host),\n\n\t\t\t/*\n\t\t\t * URL encode the port portion of a URL\n\t\t\t *\n\t\t\t * @param {string} string to encode\n\t\t\t * @returns {string} URL encoded string\n\t\t\t */\n\t\t\tencodePort: makeEncoder(charMap.port),\n\n\t\t\t/*\n\t\t\t * URL encode a path segment portion of a URL\n\t\t\t *\n\t\t\t * @param {string} string to encode\n\t\t\t * @returns {string} URL encoded string\n\t\t\t */\n\t\t\tencodePathSegment: makeEncoder(charMap.segment),\n\n\t\t\t/*\n\t\t\t * URL encode the path portion of a URL\n\t\t\t *\n\t\t\t * @param {string} string to encode\n\t\t\t * @returns {string} URL encoded string\n\t\t\t */\n\t\t\tencodePath: makeEncoder(charMap.path),\n\n\t\t\t/*\n\t\t\t * URL encode the query portion of a URL\n\t\t\t *\n\t\t\t * @param {string} string to encode\n\t\t\t * @returns {string} URL encoded string\n\t\t\t */\n\t\t\tencodeQuery: makeEncoder(charMap.query),\n\n\t\t\t/*\n\t\t\t * URL encode the fragment portion of a URL\n\t\t\t *\n\t\t\t * @param {string} string to encode\n\t\t\t * @returns {string} URL encoded string\n\t\t\t */\n\t\t\tencodeFragment: makeEncoder(charMap.fragment)\n\n\t\t};\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{}],44:[function(require,module,exports){\n/*\n * Copyright 2015 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tvar undef;\n\n\tdefine(function (require) {\n\n\t\tvar uriEncoder, operations, prefixRE;\n\n\t\turiEncoder = require('./uriEncoder');\n\n\t\tprefixRE = /^([^:]*):([0-9]+)$/;\n\t\toperations = {\n\t\t\t'':  { first: '',  separator: ',', named: false, empty: '',  encoder: uriEncoder.encode },\n\t\t\t'+': { first: '',  separator: ',', named: false, empty: '',  encoder: uriEncoder.encodeURL },\n\t\t\t'#': { first: '#', separator: ',', named: false, empty: '',  encoder: uriEncoder.encodeURL },\n\t\t\t'.': { first: '.', separator: '.', named: false, empty: '',  encoder: uriEncoder.encode },\n\t\t\t'/': { first: '/', separator: '/', named: false, empty: '',  encoder: uriEncoder.encode },\n\t\t\t';': { first: ';', separator: ';', named: true,  empty: '',  encoder: uriEncoder.encode },\n\t\t\t'?': { first: '?', separator: '&', named: true,  empty: '=', encoder: uriEncoder.encode },\n\t\t\t'&': { first: '&', separator: '&', named: true,  empty: '=', encoder: uriEncoder.encode },\n\t\t\t'=': { reserved: true },\n\t\t\t',': { reserved: true },\n\t\t\t'!': { reserved: true },\n\t\t\t'@': { reserved: true },\n\t\t\t'|': { reserved: true }\n\t\t};\n\n\t\tfunction apply(operation, expression, params) {\n\t\t\t/*jshint maxcomplexity:11 */\n\t\t\treturn expression.split(',').reduce(function (result, variable) {\n\t\t\t\tvar opts, value;\n\n\t\t\t\topts = {};\n\t\t\t\tif (variable.slice(-1) === '*') {\n\t\t\t\t\tvariable = variable.slice(0, -1);\n\t\t\t\t\topts.explode = true;\n\t\t\t\t}\n\t\t\t\tif (prefixRE.test(variable)) {\n\t\t\t\t\tvar prefix = prefixRE.exec(variable);\n\t\t\t\t\tvariable = prefix[1];\n\t\t\t\t\topts.maxLength = parseInt(prefix[2]);\n\t\t\t\t}\n\n\t\t\t\tvariable = uriEncoder.decode(variable);\n\t\t\t\tvalue = params[variable];\n\n\t\t\t\tif (value === undef || value === null) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\tresult += value.reduce(function (result, value) {\n\t\t\t\t\t\tif (result.length) {\n\t\t\t\t\t\t\tresult += opts.explode ? operation.separator : ',';\n\t\t\t\t\t\t\tif (operation.named && opts.explode) {\n\t\t\t\t\t\t\t\tresult += operation.encoder(variable);\n\t\t\t\t\t\t\t\tresult += value.length ? '=' : operation.empty;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tresult += operation.first;\n\t\t\t\t\t\t\tif (operation.named) {\n\t\t\t\t\t\t\t\tresult += operation.encoder(variable);\n\t\t\t\t\t\t\t\tresult += value.length ? '=' : operation.empty;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult += operation.encoder(value);\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}, '');\n\t\t\t\t}\n\t\t\t\telse if (typeof value === 'object') {\n\t\t\t\t\tresult += Object.keys(value).reduce(function (result, name) {\n\t\t\t\t\t\tif (result.length) {\n\t\t\t\t\t\t\tresult += opts.explode ? operation.separator : ',';\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tresult += operation.first;\n\t\t\t\t\t\t\tif (operation.named && !opts.explode) {\n\t\t\t\t\t\t\t\tresult += operation.encoder(variable);\n\t\t\t\t\t\t\t\tresult += value[name].length ? '=' : operation.empty;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult += operation.encoder(name);\n\t\t\t\t\t\tresult += opts.explode ? '=' : ',';\n\t\t\t\t\t\tresult += operation.encoder(value[name]);\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}, '');\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvalue = String(value);\n\t\t\t\t\tif (opts.maxLength) {\n\t\t\t\t\t\tvalue = value.slice(0, opts.maxLength);\n\t\t\t\t\t}\n\t\t\t\t\tresult += result.length ? operation.separator : operation.first;\n\t\t\t\t\tif (operation.named) {\n\t\t\t\t\t\tresult += operation.encoder(variable);\n\t\t\t\t\t\tresult += value.length ? '=' : operation.empty;\n\t\t\t\t\t}\n\t\t\t\t\tresult += operation.encoder(value);\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}, '');\n\t\t}\n\n\t\tfunction expandExpression(expression, params) {\n\t\t\tvar operation;\n\n\t\t\toperation = operations[expression.slice(0,1)];\n\t\t\tif (operation) {\n\t\t\t\texpression = expression.slice(1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\toperation = operations[''];\n\t\t\t}\n\n\t\t\tif (operation.reserved) {\n\t\t\t\tthrow new Error('Reserved expression operations are not supported');\n\t\t\t}\n\n\t\t\treturn apply(operation, expression, params);\n\t\t}\n\n\t\tfunction expandTemplate(template, params) {\n\t\t\tvar start, end, uri;\n\n\t\t\turi = '';\n\t\t\tend = 0;\n\t\t\twhile (true) {\n\t\t\t\tstart = template.indexOf('{', end);\n\t\t\t\tif (start === -1) {\n\t\t\t\t\t// no more expressions\n\t\t\t\t\turi += template.slice(end);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\turi += template.slice(end, start);\n\t\t\t\tend = template.indexOf('}', start) + 1;\n\t\t\t\turi += expandExpression(template.slice(start + 1, end - 1), params);\n\t\t\t}\n\n\t\t\treturn uri;\n\t\t}\n\n\t\treturn {\n\n\t\t\t/**\n\t\t\t * Expand a URI Template with parameters to form a URI.\n\t\t\t *\n\t\t\t * Full implementation (level 4) of rfc6570.\n\t\t\t * @see https://tools.ietf.org/html/rfc6570\n\t\t\t *\n\t\t\t * @param {string} template URI template\n\t\t\t * @param {Object} [params] params to apply to the template durring expantion\n\t\t\t * @returns {string} expanded URI\n\t\t\t */\n\t\t\texpand: expandTemplate\n\n\t\t};\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n\n},{\"./uriEncoder\":43}],45:[function(require,module,exports){\n;/*! showdown 19-10-2015 */\r\n(function(){\r\n/**\r\n * Created by Tivie on 13-07-2015.\r\n */\r\n\r\nfunction getDefaultOpts(simple) {\r\n  'use strict';\r\n\r\n  var defaultOptions = {\r\n    omitExtraWLInCodeBlocks: {\r\n      default: false,\r\n      describe: 'Omit the default extra whiteline added to code blocks',\r\n      type: 'boolean'\r\n    },\r\n    noHeaderId: {\r\n      default: false,\r\n      describe: 'Turn on/off generated header id',\r\n      type: 'boolean'\r\n    },\r\n    prefixHeaderId: {\r\n      default: false,\r\n      describe: 'Specify a prefix to generated header ids',\r\n      type: 'string'\r\n    },\r\n    headerLevelStart: {\r\n      default: false,\r\n      describe: 'The header blocks level start',\r\n      type: 'integer'\r\n    },\r\n    parseImgDimensions: {\r\n      default: false,\r\n      describe: 'Turn on/off image dimension parsing',\r\n      type: 'boolean'\r\n    },\r\n    simplifiedAutoLink: {\r\n      default: false,\r\n      describe: 'Turn on/off GFM autolink style',\r\n      type: 'boolean'\r\n    },\r\n    literalMidWordUnderscores: {\r\n      default: false,\r\n      describe: 'Parse midword underscores as literal underscores',\r\n      type: 'boolean'\r\n    },\r\n    strikethrough: {\r\n      default: false,\r\n      describe: 'Turn on/off strikethrough support',\r\n      type: 'boolean'\r\n    },\r\n    tables: {\r\n      default: false,\r\n      describe: 'Turn on/off tables support',\r\n      type: 'boolean'\r\n    },\r\n    tablesHeaderId: {\r\n      default: false,\r\n      describe: 'Add an id to table headers',\r\n      type: 'boolean'\r\n    },\r\n    ghCodeBlocks: {\r\n      default: true,\r\n      describe: 'Turn on/off GFM fenced code blocks support',\r\n      type: 'boolean'\r\n    },\r\n    tasklists: {\r\n      default: false,\r\n      describe: 'Turn on/off GFM tasklist support',\r\n      type: 'boolean'\r\n    },\r\n    smoothLivePreview: {\r\n      default: false,\r\n      describe: 'Prevents weird effects in live previews due to incomplete input',\r\n      type: 'boolean'\r\n    }\r\n  };\r\n  if (simple === false) {\r\n    return JSON.parse(JSON.stringify(defaultOptions));\r\n  }\r\n  var ret = {};\r\n  for (var opt in defaultOptions) {\r\n    if (defaultOptions.hasOwnProperty(opt)) {\r\n      ret[opt] = defaultOptions[opt].default;\r\n    }\r\n  }\r\n  return ret;\r\n}\r\n\r\n/**\r\n * Created by Tivie on 06-01-2015.\r\n */\r\n\r\n// Private properties\r\nvar showdown = {},\r\n    parsers = {},\r\n    extensions = {},\r\n    globalOptions = getDefaultOpts(true),\r\n    flavor = {\r\n      github: {\r\n        omitExtraWLInCodeBlocks:   true,\r\n        prefixHeaderId:            'user-content-',\r\n        simplifiedAutoLink:        true,\r\n        literalMidWordUnderscores: true,\r\n        strikethrough:             true,\r\n        tables:                    true,\r\n        tablesHeaderId:            true,\r\n        ghCodeBlocks:              true,\r\n        tasklists:                 true\r\n      },\r\n      vanilla: getDefaultOpts(true)\r\n    };\r\n\r\n/**\r\n * helper namespace\r\n * @type {{}}\r\n */\r\nshowdown.helper = {};\r\n\r\n/**\r\n * TODO LEGACY SUPPORT CODE\r\n * @type {{}}\r\n */\r\nshowdown.extensions = {};\r\n\r\n/**\r\n * Set a global option\r\n * @static\r\n * @param {string} key\r\n * @param {*} value\r\n * @returns {showdown}\r\n */\r\nshowdown.setOption = function (key, value) {\r\n  'use strict';\r\n  globalOptions[key] = value;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Get a global option\r\n * @static\r\n * @param {string} key\r\n * @returns {*}\r\n */\r\nshowdown.getOption = function (key) {\r\n  'use strict';\r\n  return globalOptions[key];\r\n};\r\n\r\n/**\r\n * Get the global options\r\n * @static\r\n * @returns {{}}\r\n */\r\nshowdown.getOptions = function () {\r\n  'use strict';\r\n  return globalOptions;\r\n};\r\n\r\n/**\r\n * Reset global options to the default values\r\n * @static\r\n */\r\nshowdown.resetOptions = function () {\r\n  'use strict';\r\n  globalOptions = getDefaultOpts(true);\r\n};\r\n\r\n/**\r\n * Set the flavor showdown should use as default\r\n * @param {string} name\r\n */\r\nshowdown.setFlavor = function (name) {\r\n  'use strict';\r\n  if (flavor.hasOwnProperty(name)) {\r\n    var preset = flavor[name];\r\n    for (var option in preset) {\r\n      if (preset.hasOwnProperty(option)) {\r\n        globalOptions[option] = preset[option];\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Get the default options\r\n * @static\r\n * @param {boolean} [simple=true]\r\n * @returns {{}}\r\n */\r\nshowdown.getDefaultOptions = function (simple) {\r\n  'use strict';\r\n  return getDefaultOpts(simple);\r\n};\r\n\r\n/**\r\n * Get or set a subParser\r\n *\r\n * subParser(name)       - Get a registered subParser\r\n * subParser(name, func) - Register a subParser\r\n * @static\r\n * @param {string} name\r\n * @param {function} [func]\r\n * @returns {*}\r\n */\r\nshowdown.subParser = function (name, func) {\r\n  'use strict';\r\n  if (showdown.helper.isString(name)) {\r\n    if (typeof func !== 'undefined') {\r\n      parsers[name] = func;\r\n    } else {\r\n      if (parsers.hasOwnProperty(name)) {\r\n        return parsers[name];\r\n      } else {\r\n        throw Error('SubParser named ' + name + ' not registered!');\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Gets or registers an extension\r\n * @static\r\n * @param {string} name\r\n * @param {object|function=} ext\r\n * @returns {*}\r\n */\r\nshowdown.extension = function (name, ext) {\r\n  'use strict';\r\n\r\n  if (!showdown.helper.isString(name)) {\r\n    throw Error('Extension \\'name\\' must be a string');\r\n  }\r\n\r\n  name = showdown.helper.stdExtName(name);\r\n\r\n  // Getter\r\n  if (showdown.helper.isUndefined(ext)) {\r\n    if (!extensions.hasOwnProperty(name)) {\r\n      throw Error('Extension named ' + name + ' is not registered!');\r\n    }\r\n    return extensions[name];\r\n\r\n    // Setter\r\n  } else {\r\n    // Expand extension if it's wrapped in a function\r\n    if (typeof ext === 'function') {\r\n      ext = ext();\r\n    }\r\n\r\n    // Ensure extension is an array\r\n    if (!showdown.helper.isArray(ext)) {\r\n      ext = [ext];\r\n    }\r\n\r\n    var validExtension = validate(ext, name);\r\n\r\n    if (validExtension.valid) {\r\n      extensions[name] = ext;\r\n    } else {\r\n      throw Error(validExtension.error);\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Gets all extensions registered\r\n * @returns {{}}\r\n */\r\nshowdown.getAllExtensions = function () {\r\n  'use strict';\r\n  return extensions;\r\n};\r\n\r\n/**\r\n * Remove an extension\r\n * @param {string} name\r\n */\r\nshowdown.removeExtension = function (name) {\r\n  'use strict';\r\n  delete extensions[name];\r\n};\r\n\r\n/**\r\n * Removes all extensions\r\n */\r\nshowdown.resetExtensions = function () {\r\n  'use strict';\r\n  extensions = {};\r\n};\r\n\r\n/**\r\n * Validate extension\r\n * @param {array} extension\r\n * @param {string} name\r\n * @returns {{valid: boolean, error: string}}\r\n */\r\nfunction validate(extension, name) {\r\n  'use strict';\r\n\r\n  var errMsg = (name) ? 'Error in ' + name + ' extension->' : 'Error in unnamed extension',\r\n    ret = {\r\n      valid: true,\r\n      error: ''\r\n    };\r\n\r\n  if (!showdown.helper.isArray(extension)) {\r\n    extension = [extension];\r\n  }\r\n\r\n  for (var i = 0; i < extension.length; ++i) {\r\n    var baseMsg = errMsg + ' sub-extension ' + i + ': ',\r\n        ext = extension[i];\r\n    if (typeof ext !== 'object') {\r\n      ret.valid = false;\r\n      ret.error = baseMsg + 'must be an object, but ' + typeof ext + ' given';\r\n      return ret;\r\n    }\r\n\r\n    if (!showdown.helper.isString(ext.type)) {\r\n      ret.valid = false;\r\n      ret.error = baseMsg + 'property \"type\" must be a string, but ' + typeof ext.type + ' given';\r\n      return ret;\r\n    }\r\n\r\n    var type = ext.type = ext.type.toLowerCase();\r\n\r\n    // normalize extension type\r\n    if (type === 'language') {\r\n      type = ext.type = 'lang';\r\n    }\r\n\r\n    if (type === 'html') {\r\n      type = ext.type = 'output';\r\n    }\r\n\r\n    if (type !== 'lang' && type !== 'output' && type !== 'listener') {\r\n      ret.valid = false;\r\n      ret.error = baseMsg + 'type ' + type + ' is not recognized. Valid values: \"lang/language\", \"output/html\" or \"listener\"';\r\n      return ret;\r\n    }\r\n\r\n    if (type === 'listener') {\r\n      if (showdown.helper.isUndefined(ext.listeners)) {\r\n        ret.valid = false;\r\n        ret.error = baseMsg + '. Extensions of type \"listener\" must have a property called \"listeners\"';\r\n        return ret;\r\n      }\r\n    } else {\r\n      if (showdown.helper.isUndefined(ext.filter) && showdown.helper.isUndefined(ext.regex)) {\r\n        ret.valid = false;\r\n        ret.error = baseMsg + type + ' extensions must define either a \"regex\" property or a \"filter\" method';\r\n        return ret;\r\n      }\r\n    }\r\n\r\n    if (ext.listeners) {\r\n      if (typeof ext.listeners !== 'object') {\r\n        ret.valid = false;\r\n        ret.error = baseMsg + '\"listeners\" property must be an object but ' + typeof ext.listeners + ' given';\r\n        return ret;\r\n      }\r\n      for (var ln in ext.listeners) {\r\n        if (ext.listeners.hasOwnProperty(ln)) {\r\n          if (typeof ext.listeners[ln] !== 'function') {\r\n            ret.valid = false;\r\n            ret.error = baseMsg + '\"listeners\" property must be an hash of [event name]: [callback]. listeners.' + ln +\r\n              ' must be a function but ' + typeof ext.listeners[ln] + ' given';\r\n            return ret;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (ext.filter) {\r\n      if (typeof ext.filter !== 'function') {\r\n        ret.valid = false;\r\n        ret.error = baseMsg + '\"filter\" must be a function, but ' + typeof ext.filter + ' given';\r\n        return ret;\r\n      }\r\n    } else if (ext.regex) {\r\n      if (showdown.helper.isString(ext.regex)) {\r\n        ext.regex = new RegExp(ext.regex, 'g');\r\n      }\r\n      if (!ext.regex instanceof RegExp) {\r\n        ret.valid = false;\r\n        ret.error = baseMsg + '\"regex\" property must either be a string or a RegExp object, but ' + typeof ext.regex + ' given';\r\n        return ret;\r\n      }\r\n      if (showdown.helper.isUndefined(ext.replace)) {\r\n        ret.valid = false;\r\n        ret.error = baseMsg + '\"regex\" extensions must implement a replace string or function';\r\n        return ret;\r\n      }\r\n    }\r\n  }\r\n  return ret;\r\n}\r\n\r\n/**\r\n * Validate extension\r\n * @param {object} ext\r\n * @returns {boolean}\r\n */\r\nshowdown.validateExtension = function (ext) {\r\n  'use strict';\r\n\r\n  var validateExtension = validate(ext, null);\r\n  if (!validateExtension.valid) {\r\n    console.warn(validateExtension.error);\r\n    return false;\r\n  }\r\n  return true;\r\n};\r\n\r\n/**\r\n * showdownjs helper functions\r\n */\r\n\r\nif (!showdown.hasOwnProperty('helper')) {\r\n  showdown.helper = {};\r\n}\r\n\r\n/**\r\n * Check if var is string\r\n * @static\r\n * @param {string} a\r\n * @returns {boolean}\r\n */\r\nshowdown.helper.isString = function isString(a) {\r\n  'use strict';\r\n  return (typeof a === 'string' || a instanceof String);\r\n};\r\n\r\n/**\r\n * ForEach helper function\r\n * @static\r\n * @param {*} obj\r\n * @param {function} callback\r\n */\r\nshowdown.helper.forEach = function forEach(obj, callback) {\r\n  'use strict';\r\n  if (typeof obj.forEach === 'function') {\r\n    obj.forEach(callback);\r\n  } else {\r\n    for (var i = 0; i < obj.length; i++) {\r\n      callback(obj[i], i, obj);\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * isArray helper function\r\n * @static\r\n * @param {*} a\r\n * @returns {boolean}\r\n */\r\nshowdown.helper.isArray = function isArray(a) {\r\n  'use strict';\r\n  return a.constructor === Array;\r\n};\r\n\r\n/**\r\n * Check if value is undefined\r\n * @static\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\r\n */\r\nshowdown.helper.isUndefined = function isUndefined(value) {\r\n  'use strict';\r\n  return typeof value === 'undefined';\r\n};\r\n\r\n/**\r\n * Standardidize extension name\r\n * @static\r\n * @param {string} s extension name\r\n * @returns {string}\r\n */\r\nshowdown.helper.stdExtName = function (s) {\r\n  'use strict';\r\n  return s.replace(/[_-]||\\s/g, '').toLowerCase();\r\n};\r\n\r\nfunction escapeCharactersCallback(wholeMatch, m1) {\r\n  'use strict';\r\n  var charCodeToEscape = m1.charCodeAt(0);\r\n  return '~E' + charCodeToEscape + 'E';\r\n}\r\n\r\n/**\r\n * Callback used to escape characters when passing through String.replace\r\n * @static\r\n * @param {string} wholeMatch\r\n * @param {string} m1\r\n * @returns {string}\r\n */\r\nshowdown.helper.escapeCharactersCallback = escapeCharactersCallback;\r\n\r\n/**\r\n * Escape characters in a string\r\n * @static\r\n * @param {string} text\r\n * @param {string} charsToEscape\r\n * @param {boolean} afterBackslash\r\n * @returns {XML|string|void|*}\r\n */\r\nshowdown.helper.escapeCharacters = function escapeCharacters(text, charsToEscape, afterBackslash) {\r\n  'use strict';\r\n  // First we have to escape the escape characters so that\r\n  // we can build a character class out of them\r\n  var regexString = '([' + charsToEscape.replace(/([\\[\\]\\\\])/g, '\\\\$1') + '])';\r\n\r\n  if (afterBackslash) {\r\n    regexString = '\\\\\\\\' + regexString;\r\n  }\r\n\r\n  var regex = new RegExp(regexString, 'g');\r\n  text = text.replace(regex, escapeCharactersCallback);\r\n\r\n  return text;\r\n};\r\n\r\n/**\r\n * matchRecursiveRegExp\r\n *\r\n * (c) 2007 Steven Levithan <stevenlevithan.com>\r\n * MIT License\r\n *\r\n * Accepts a string to search, a left and right format delimiter\r\n * as regex patterns, and optional regex flags. Returns an array\r\n * of matches, allowing nested instances of left/right delimiters.\r\n * Use the \"g\" flag to return all matches, otherwise only the\r\n * first is returned. Be careful to ensure that the left and\r\n * right format delimiters produce mutually exclusive matches.\r\n * Backreferences are not supported within the right delimiter\r\n * due to how it is internally combined with the left delimiter.\r\n * When matching strings whose format delimiters are unbalanced\r\n * to the left or right, the output is intentionally as a\r\n * conventional regex library with recursion support would\r\n * produce, e.g. \"<<x>\" and \"<x>>\" both produce [\"x\"] when using\r\n * \"<\" and \">\" as the delimiters (both strings contain a single,\r\n * balanced instance of \"<x>\").\r\n *\r\n * examples:\r\n * matchRecursiveRegExp(\"test\", \"\\\\(\", \"\\\\)\")\r\n * returns: []\r\n * matchRecursiveRegExp(\"<t<<e>><s>>t<>\", \"<\", \">\", \"g\")\r\n * returns: [\"t<<e>><s>\", \"\"]\r\n * matchRecursiveRegExp(\"<div id=\\\"x\\\">test</div>\", \"<div\\\\b[^>]*>\", \"</div>\", \"gi\")\r\n * returns: [\"test\"]\r\n */\r\nshowdown.helper.matchRecursiveRegExp = function (str, left, right, flags) {\r\n  'use strict';\r\n  var\tf = flags || '',\r\n    g = f.indexOf('g') > -1,\r\n    x = new RegExp(left + '|' + right, f),\r\n    l = new RegExp(left, f.replace(/g/g, '')),\r\n    a = [],\r\n    t, s, m, start, end;\r\n\r\n  do {\r\n    t = 0;\r\n    while ((m = x.exec(str))) {\r\n      if (l.test(m[0])) {\r\n        if (!(t++)) {\r\n          start = m[0];\r\n          s = x.lastIndex;\r\n        }\r\n      } else if (t) {\r\n        if (!--t) {\r\n          end = m[0];\r\n          var match = str.slice(s, m.index);\r\n          a.push([start + match + end, match]);\r\n          if (!g) {\r\n            return a;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  } while (t && (x.lastIndex = s));\r\n\r\n  return a;\r\n};\r\n\r\n/**\r\n * POLYFILLS\r\n */\r\nif (showdown.helper.isUndefined(console)) {\r\n  console = {\r\n    warn: function (msg) {\r\n      'use strict';\r\n      alert(msg);\r\n    },\r\n    log: function (msg) {\r\n      'use strict';\r\n      alert(msg);\r\n    },\r\n    error: function (msg) {\r\n      'use strict';\r\n      throw msg;\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Created by Estevao on 31-05-2015.\r\n */\r\n\r\n/**\r\n * Showdown Converter class\r\n * @class\r\n * @param {object} [converterOptions]\r\n * @returns {Converter}\r\n */\r\nshowdown.Converter = function (converterOptions) {\r\n  'use strict';\r\n\r\n  var\r\n      /**\r\n       * Options used by this converter\r\n       * @private\r\n       * @type {{}}\r\n       */\r\n      options = {},\r\n\r\n      /**\r\n       * Language extensions used by this converter\r\n       * @private\r\n       * @type {Array}\r\n       */\r\n      langExtensions = [],\r\n\r\n      /**\r\n       * Output modifiers extensions used by this converter\r\n       * @private\r\n       * @type {Array}\r\n       */\r\n      outputModifiers = [],\r\n\r\n      /**\r\n       * Event listeners\r\n       * @private\r\n       * @type {{}}\r\n       */\r\n      listeners = {};\r\n\r\n  _constructor();\r\n\r\n  /**\r\n   * Converter constructor\r\n   * @private\r\n   */\r\n  function _constructor() {\r\n    converterOptions = converterOptions || {};\r\n\r\n    for (var gOpt in globalOptions) {\r\n      if (globalOptions.hasOwnProperty(gOpt)) {\r\n        options[gOpt] = globalOptions[gOpt];\r\n      }\r\n    }\r\n\r\n    // Merge options\r\n    if (typeof converterOptions === 'object') {\r\n      for (var opt in converterOptions) {\r\n        if (converterOptions.hasOwnProperty(opt)) {\r\n          options[opt] = converterOptions[opt];\r\n        }\r\n      }\r\n    } else {\r\n      throw Error('Converter expects the passed parameter to be an object, but ' + typeof converterOptions +\r\n      ' was passed instead.');\r\n    }\r\n\r\n    if (options.extensions) {\r\n      showdown.helper.forEach(options.extensions, _parseExtension);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parse extension\r\n   * @param {*} ext\r\n   * @param {string} [name='']\r\n   * @private\r\n   */\r\n  function _parseExtension(ext, name) {\r\n\r\n    name = name || null;\r\n    // If it's a string, the extension was previously loaded\r\n    if (showdown.helper.isString(ext)) {\r\n      ext = showdown.helper.stdExtName(ext);\r\n      name = ext;\r\n\r\n      // LEGACY_SUPPORT CODE\r\n      if (showdown.extensions[ext]) {\r\n        console.warn('DEPRECATION WARNING: ' + ext + ' is an old extension that uses a deprecated loading method.' +\r\n          'Please inform the developer that the extension should be updated!');\r\n        legacyExtensionLoading(showdown.extensions[ext], ext);\r\n        return;\r\n      // END LEGACY SUPPORT CODE\r\n\r\n      } else if (!showdown.helper.isUndefined(extensions[ext])) {\r\n        ext = extensions[ext];\r\n\r\n      } else {\r\n        throw Error('Extension \"' + ext + '\" could not be loaded. It was either not found or is not a valid extension.');\r\n      }\r\n    }\r\n\r\n    if (typeof ext === 'function') {\r\n      ext = ext();\r\n    }\r\n\r\n    if (!showdown.helper.isArray(ext)) {\r\n      ext = [ext];\r\n    }\r\n\r\n    var validExt = validate(ext, name);\r\n    if (!validExt.valid) {\r\n      throw Error(validExt.error);\r\n    }\r\n\r\n    for (var i = 0; i < ext.length; ++i) {\r\n      switch (ext[i].type) {\r\n\r\n        case 'lang':\r\n          langExtensions.push(ext[i]);\r\n          break;\r\n\r\n        case 'output':\r\n          outputModifiers.push(ext[i]);\r\n          break;\r\n      }\r\n      if (ext[i].hasOwnProperty(listeners)) {\r\n        for (var ln in ext[i].listeners) {\r\n          if (ext[i].listeners.hasOwnProperty(ln)) {\r\n            listen(ln, ext[i].listeners[ln]);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * LEGACY_SUPPORT\r\n   * @param {*} ext\r\n   * @param {string} name\r\n   */\r\n  function legacyExtensionLoading(ext, name) {\r\n    if (typeof ext === 'function') {\r\n      ext = ext(new showdown.Converter());\r\n    }\r\n    if (!showdown.helper.isArray(ext)) {\r\n      ext = [ext];\r\n    }\r\n    var valid = validate(ext, name);\r\n\r\n    if (!valid.valid) {\r\n      throw Error(valid.error);\r\n    }\r\n\r\n    for (var i = 0; i < ext.length; ++i) {\r\n      switch (ext[i].type) {\r\n        case 'lang':\r\n          langExtensions.push(ext[i]);\r\n          break;\r\n        case 'output':\r\n          outputModifiers.push(ext[i]);\r\n          break;\r\n        default:// should never reach here\r\n          throw Error('Extension loader error: Type unrecognized!!!');\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Listen to an event\r\n   * @param {string} name\r\n   * @param {function} callback\r\n   */\r\n  function listen(name, callback) {\r\n    if (!showdown.helper.isString(name)) {\r\n      throw Error('Invalid argument in converter.listen() method: name must be a string, but ' + typeof name + ' given');\r\n    }\r\n\r\n    if (typeof callback !== 'function') {\r\n      throw Error('Invalid argument in converter.listen() method: callback must be a function, but ' + typeof callback + ' given');\r\n    }\r\n\r\n    if (!listeners.hasOwnProperty(name)) {\r\n      listeners[name] = [];\r\n    }\r\n    listeners[name].push(callback);\r\n  }\r\n\r\n  /**\r\n   * Dispatch an event\r\n   * @private\r\n   * @param {string} evtName Event name\r\n   * @param {string} text Text\r\n   * @param {{}} options Converter Options\r\n   * @returns {string}\r\n   */\r\n  this._dispatch = function dispatch (evtName, text, options) {\r\n    if (listeners.hasOwnProperty(evtName)) {\r\n      for (var ei = 0; ei < listeners[evtName].length; ++ei) {\r\n        var nText = listeners[evtName][ei](evtName, text, this, options);\r\n        if (nText && typeof nText !== 'undefined') {\r\n          text = nText;\r\n        }\r\n      }\r\n    }\r\n    return text;\r\n  };\r\n\r\n  /**\r\n   * Listen to an event\r\n   * @param {string} name\r\n   * @param {function} callback\r\n   * @returns {showdown.Converter}\r\n   */\r\n  this.listen = function (name, callback) {\r\n    listen(name, callback);\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Converts a markdown string into HTML\r\n   * @param {string} text\r\n   * @returns {*}\r\n   */\r\n  this.makeHtml = function (text) {\r\n    //check if text is not falsy\r\n    if (!text) {\r\n      return text;\r\n    }\r\n\r\n    var globals = {\r\n      gHtmlBlocks:     [],\r\n      gHtmlSpans:      [],\r\n      gUrls:           {},\r\n      gTitles:         {},\r\n      gDimensions:     {},\r\n      gListLevel:      0,\r\n      hashLinkCounts:  {},\r\n      langExtensions:  langExtensions,\r\n      outputModifiers: outputModifiers,\r\n      converter:       this\r\n    };\r\n\r\n    // attacklab: Replace ~ with ~T\r\n    // This lets us use tilde as an escape char to avoid md5 hashes\r\n    // The choice of character is arbitrary; anything that isn't\r\n    // magic in Markdown will work.\r\n    text = text.replace(/~/g, '~T');\r\n\r\n    // attacklab: Replace $ with ~D\r\n    // RegExp interprets $ as a special character\r\n    // when it's in a replacement string\r\n    text = text.replace(/\\$/g, '~D');\r\n\r\n    // Standardize line endings\r\n    text = text.replace(/\\r\\n/g, '\\n'); // DOS to Unix\r\n    text = text.replace(/\\r/g, '\\n'); // Mac to Unix\r\n\r\n    // Make sure text begins and ends with a couple of newlines:\r\n    text = '\\n\\n' + text + '\\n\\n';\r\n\r\n    // detab\r\n    text = showdown.subParser('detab')(text, options, globals);\r\n\r\n    // stripBlankLines\r\n    text = showdown.subParser('stripBlankLines')(text, options, globals);\r\n\r\n    //run languageExtensions\r\n    showdown.helper.forEach(langExtensions, function (ext) {\r\n      text = showdown.subParser('runExtension')(ext, text, options, globals);\r\n    });\r\n\r\n    // run the sub parsers\r\n    text = showdown.subParser('githubCodeBlocks')(text, options, globals);\r\n    text = showdown.subParser('hashHTMLBlocks')(text, options, globals);\r\n    text = showdown.subParser('hashHTMLSpans')(text, options, globals);\r\n    text = showdown.subParser('stripLinkDefinitions')(text, options, globals);\r\n    text = showdown.subParser('blockGamut')(text, options, globals);\r\n    text = showdown.subParser('unhashHTMLSpans')(text, options, globals);\r\n    text = showdown.subParser('unescapeSpecialChars')(text, options, globals);\r\n\r\n    // attacklab: Restore dollar signs\r\n    text = text.replace(/~D/g, '$$');\r\n\r\n    // attacklab: Restore tildes\r\n    text = text.replace(/~T/g, '~');\r\n\r\n    // Run output modifiers\r\n    showdown.helper.forEach(outputModifiers, function (ext) {\r\n      text = showdown.subParser('runExtension')(ext, text, options, globals);\r\n    });\r\n\r\n    return text;\r\n  };\r\n\r\n  /**\r\n   * Set an option of this Converter instance\r\n   * @param {string} key\r\n   * @param {*} value\r\n   */\r\n  this.setOption = function (key, value) {\r\n    options[key] = value;\r\n  };\r\n\r\n  /**\r\n   * Get the option of this Converter instance\r\n   * @param {string} key\r\n   * @returns {*}\r\n   */\r\n  this.getOption = function (key) {\r\n    return options[key];\r\n  };\r\n\r\n  /**\r\n   * Get the options of this Converter instance\r\n   * @returns {{}}\r\n   */\r\n  this.getOptions = function () {\r\n    return options;\r\n  };\r\n\r\n  /**\r\n   * Add extension to THIS converter\r\n   * @param {{}} extension\r\n   * @param {string} [name=null]\r\n   */\r\n  this.addExtension = function (extension, name) {\r\n    name = name || null;\r\n    _parseExtension(extension, name);\r\n  };\r\n\r\n  /**\r\n   * Use a global registered extension with THIS converter\r\n   * @param {string} extensionName Name of the previously registered extension\r\n   */\r\n  this.useExtension = function (extensionName) {\r\n    _parseExtension(extensionName);\r\n  };\r\n\r\n  /**\r\n   * Set the flavor THIS converter should use\r\n   * @param {string} name\r\n   */\r\n  this.setFlavor = function (name) {\r\n    if (flavor.hasOwnProperty(name)) {\r\n      var preset = flavor[name];\r\n      for (var option in preset) {\r\n        if (preset.hasOwnProperty(option)) {\r\n          options[option] = preset[option];\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Remove an extension from THIS converter.\r\n   * Note: This is a costly operation. It's better to initialize a new converter\r\n   * and specify the extensions you wish to use\r\n   * @param {Array} extension\r\n   */\r\n  this.removeExtension = function (extension) {\r\n    if (!showdown.helper.isArray(extension)) {\r\n      extension = [extension];\r\n    }\r\n    for (var a = 0; a < extension.length; ++a) {\r\n      var ext = extension[a];\r\n      for (var i = 0; i < langExtensions.length; ++i) {\r\n        if (langExtensions[i] === ext) {\r\n          langExtensions[i].splice(i, 1);\r\n        }\r\n      }\r\n      for (var ii = 0; ii < outputModifiers.length; ++i) {\r\n        if (outputModifiers[ii] === ext) {\r\n          outputModifiers[ii].splice(i, 1);\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Get all extension of THIS converter\r\n   * @returns {{language: Array, output: Array}}\r\n   */\r\n  this.getAllExtensions = function () {\r\n    return {\r\n      language: langExtensions,\r\n      output: outputModifiers\r\n    };\r\n  };\r\n};\r\n\r\n/**\r\n * Turn Markdown link shortcuts into XHTML <a> tags.\r\n */\r\nshowdown.subParser('anchors', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  text = globals.converter._dispatch('anchors.before', text, options);\r\n\r\n  var writeAnchorTag = function (wholeMatch, m1, m2, m3, m4, m5, m6, m7) {\r\n    if (showdown.helper.isUndefined(m7)) {\r\n      m7 = '';\r\n    }\r\n    wholeMatch = m1;\r\n    var linkText = m2,\r\n        linkId = m3.toLowerCase(),\r\n        url = m4,\r\n        title = m7;\r\n\r\n    if (!url) {\r\n      if (!linkId) {\r\n        // lower-case and turn embedded newlines into spaces\r\n        linkId = linkText.toLowerCase().replace(/ ?\\n/g, ' ');\r\n      }\r\n      url = '#' + linkId;\r\n\r\n      if (!showdown.helper.isUndefined(globals.gUrls[linkId])) {\r\n        url = globals.gUrls[linkId];\r\n        if (!showdown.helper.isUndefined(globals.gTitles[linkId])) {\r\n          title = globals.gTitles[linkId];\r\n        }\r\n      } else {\r\n        if (wholeMatch.search(/\\(\\s*\\)$/m) > -1) {\r\n          // Special case for explicit empty url\r\n          url = '';\r\n        } else {\r\n          return wholeMatch;\r\n        }\r\n      }\r\n    }\r\n\r\n    url = showdown.helper.escapeCharacters(url, '*_', false);\r\n    var result = '<a href=\"' + url + '\"';\r\n\r\n    if (title !== '' && title !== null) {\r\n      title = title.replace(/\"/g, '&quot;');\r\n      title = showdown.helper.escapeCharacters(title, '*_', false);\r\n      result += ' title=\"' + title + '\"';\r\n    }\r\n\r\n    result += '>' + linkText + '</a>';\r\n\r\n    return result;\r\n  };\r\n\r\n  // First, handle reference-style links: [link text] [id]\r\n  /*\r\n   text = text.replace(/\r\n   (\t\t\t\t\t\t\t// wrap whole match in $1\r\n   \\[\r\n   (\r\n   (?:\r\n   \\[[^\\]]*\\]\t\t// allow brackets nested one level\r\n   |\r\n   [^\\[]\t\t\t// or anything else\r\n   )*\r\n   )\r\n   \\]\r\n\r\n   [ ]?\t\t\t\t\t// one optional space\r\n   (?:\\n[ ]*)?\t\t\t\t// one optional newline followed by spaces\r\n\r\n   \\[\r\n   (.*?)\t\t\t\t\t// id = $3\r\n   \\]\r\n   )()()()()\t\t\t\t\t// pad remaining backreferences\r\n   /g,_DoAnchors_callback);\r\n   */\r\n  text = text.replace(/(\\[((?:\\[[^\\]]*]|[^\\[\\]])*)][ ]?(?:\\n[ ]*)?\\[(.*?)])()()()()/g, writeAnchorTag);\r\n\r\n  //\r\n  // Next, inline-style links: [link text](url \"optional title\")\r\n  //\r\n\r\n  /*\r\n   text = text.replace(/\r\n   (\t\t\t\t\t\t// wrap whole match in $1\r\n   \\[\r\n   (\r\n   (?:\r\n   \\[[^\\]]*\\]\t// allow brackets nested one level\r\n   |\r\n   [^\\[\\]]\t\t\t// or anything else\r\n   )\r\n   )\r\n   \\]\r\n   \\(\t\t\t\t\t\t// literal paren\r\n   [ \\t]*\r\n   ()\t\t\t\t\t\t// no id, so leave $3 empty\r\n   <?(.*?)>?\t\t\t\t// href = $4\r\n   [ \\t]*\r\n   (\t\t\t\t\t\t// $5\r\n   (['\"])\t\t\t\t// quote char = $6\r\n   (.*?)\t\t\t\t// Title = $7\r\n   \\6\t\t\t\t\t// matching quote\r\n   [ \\t]*\t\t\t\t// ignore any spaces/tabs between closing quote and )\r\n   )?\t\t\t\t\t\t// title is optional\r\n   \\)\r\n   )\r\n   /g,writeAnchorTag);\r\n   */\r\n  text = text.replace(/(\\[((?:\\[[^\\]]*]|[^\\[\\]])*)]\\([ \\t]*()<?(.*?(?:\\(.*?\\).*?)?)>?[ \\t]*((['\"])(.*?)\\6[ \\t]*)?\\))/g,\r\n                      writeAnchorTag);\r\n\r\n  //\r\n  // Last, handle reference-style shortcuts: [link text]\r\n  // These must come last in case you've also got [link test][1]\r\n  // or [link test](/foo)\r\n  //\r\n\r\n  /*\r\n   text = text.replace(/\r\n   (                // wrap whole match in $1\r\n   \\[\r\n   ([^\\[\\]]+)       // link text = $2; can't contain '[' or ']'\r\n   \\]\r\n   )()()()()()      // pad rest of backreferences\r\n   /g, writeAnchorTag);\r\n   */\r\n  text = text.replace(/(\\[([^\\[\\]]+)])()()()()()/g, writeAnchorTag);\r\n\r\n  text = globals.converter._dispatch('anchors.after', text, options);\r\n  return text;\r\n});\r\n\r\nshowdown.subParser('autoLinks', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  text = globals.converter._dispatch('autoLinks.before', text, options);\r\n\r\n  var simpleURLRegex  = /\\b(((https?|ftp|dict):\\/\\/|www\\.)[^'\">\\s]+\\.[^'\">\\s]+)(?=\\s|$)(?![\"<>])/gi,\r\n      delimUrlRegex   = /<(((https?|ftp|dict):\\/\\/|www\\.)[^'\">\\s]+)>/gi,\r\n      simpleMailRegex = /(?:^|[ \\n\\t])([A-Za-z0-9!#$%&'*+-/=?^_`\\{|}~\\.]+@[-a-z0-9]+(\\.[-a-z0-9]+)*\\.[a-z]+)(?:$|[ \\n\\t])/gi,\r\n      delimMailRegex  = /<(?:mailto:)?([-.\\w]+@[-a-z0-9]+(\\.[-a-z0-9]+)*\\.[a-z]+)>/gi;\r\n\r\n  text = text.replace(delimUrlRegex, '<a href=\\\"$1\\\">$1</a>');\r\n  text = text.replace(delimMailRegex, replaceMail);\r\n  //simpleURLRegex  = /\\b(((https?|ftp|dict):\\/\\/|www\\.)[-.+~:?#@!$&'()*,;=[\\]\\w]+)\\b/gi,\r\n  // Email addresses: <address@domain.foo>\r\n\r\n  if (options.simplifiedAutoLink) {\r\n    text = text.replace(simpleURLRegex, '<a href=\\\"$1\\\">$1</a>');\r\n    text = text.replace(simpleMailRegex, replaceMail);\r\n  }\r\n\r\n  function replaceMail(wholeMatch, m1) {\r\n    var unescapedStr = showdown.subParser('unescapeSpecialChars')(m1);\r\n    return showdown.subParser('encodeEmailAddress')(unescapedStr);\r\n  }\r\n\r\n  text = globals.converter._dispatch('autoLinks.after', text, options);\r\n\r\n  return text;\r\n});\r\n\r\n/**\r\n * These are all the transformations that form block-level\r\n * tags like paragraphs, headers, and list items.\r\n */\r\nshowdown.subParser('blockGamut', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  text = globals.converter._dispatch('blockGamut.before', text, options);\r\n\r\n  // we parse blockquotes first so that we can have headings and hrs\r\n  // inside blockquotes\r\n  text = showdown.subParser('blockQuotes')(text, options, globals);\r\n  text = showdown.subParser('headers')(text, options, globals);\r\n\r\n  // Do Horizontal Rules:\r\n  var key = showdown.subParser('hashBlock')('<hr />', options, globals);\r\n  text = text.replace(/^[ ]{0,2}([ ]?\\*[ ]?){3,}[ \\t]*$/gm, key);\r\n  text = text.replace(/^[ ]{0,2}([ ]?\\-[ ]?){3,}[ \\t]*$/gm, key);\r\n  text = text.replace(/^[ ]{0,2}([ ]?_[ ]?){3,}[ \\t]*$/gm, key);\r\n\r\n  text = showdown.subParser('lists')(text, options, globals);\r\n  text = showdown.subParser('codeBlocks')(text, options, globals);\r\n  text = showdown.subParser('tables')(text, options, globals);\r\n\r\n  // We already ran _HashHTMLBlocks() before, in Markdown(), but that\r\n  // was to escape raw HTML in the original Markdown source. This time,\r\n  // we're escaping the markup we've just created, so that we don't wrap\r\n  // <p> tags around block-level tags.\r\n  text = showdown.subParser('hashHTMLBlocks')(text, options, globals);\r\n  text = showdown.subParser('paragraphs')(text, options, globals);\r\n\r\n  text = globals.converter._dispatch('blockGamut.after', text, options);\r\n\r\n  return text;\r\n});\r\n\r\nshowdown.subParser('blockQuotes', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  text = globals.converter._dispatch('blockQuotes.before', text, options);\r\n  /*\r\n   text = text.replace(/\r\n   (\t\t\t\t\t\t\t\t// Wrap whole match in $1\r\n   (\r\n   ^[ \\t]*>[ \\t]?\t\t\t// '>' at the start of a line\r\n   .+\\n\t\t\t\t\t// rest of the first line\r\n   (.+\\n)*\t\t\t\t\t// subsequent consecutive lines\r\n   \\n*\t\t\t\t\t\t// blanks\r\n   )+\r\n   )\r\n   /gm, function(){...});\r\n   */\r\n\r\n  text = text.replace(/((^[ \\t]{0,3}>[ \\t]?.+\\n(.+\\n)*\\n*)+)/gm, function (wholeMatch, m1) {\r\n    var bq = m1;\r\n\r\n    // attacklab: hack around Konqueror 3.5.4 bug:\r\n    // \"----------bug\".replace(/^-/g,\"\") == \"bug\"\r\n    bq = bq.replace(/^[ \\t]*>[ \\t]?/gm, '~0'); // trim one level of quoting\r\n\r\n    // attacklab: clean up hack\r\n    bq = bq.replace(/~0/g, '');\r\n\r\n    bq = bq.replace(/^[ \\t]+$/gm, ''); // trim whitespace-only lines\r\n    bq = showdown.subParser('githubCodeBlocks')(bq, options, globals);\r\n    bq = showdown.subParser('blockGamut')(bq, options, globals); // recurse\r\n\r\n    bq = bq.replace(/(^|\\n)/g, '$1  ');\r\n    // These leading spaces screw with <pre> content, so we need to fix that:\r\n    bq = bq.replace(/(\\s*<pre>[^\\r]+?<\\/pre>)/gm, function (wholeMatch, m1) {\r\n      var pre = m1;\r\n      // attacklab: hack around Konqueror 3.5.4 bug:\r\n      pre = pre.replace(/^  /mg, '~0');\r\n      pre = pre.replace(/~0/g, '');\r\n      return pre;\r\n    });\r\n\r\n    return showdown.subParser('hashBlock')('<blockquote>\\n' + bq + '\\n</blockquote>', options, globals);\r\n  });\r\n\r\n  text = globals.converter._dispatch('blockQuotes.after', text, options);\r\n  return text;\r\n});\r\n\r\n/**\r\n * Process Markdown `<pre><code>` blocks.\r\n */\r\nshowdown.subParser('codeBlocks', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  text = globals.converter._dispatch('codeBlocks.before', text, options);\r\n  /*\r\n   text = text.replace(text,\r\n   /(?:\\n\\n|^)\r\n   (\t\t\t\t\t\t\t\t// $1 = the code block -- one or more lines, starting with a space/tab\r\n   (?:\r\n   (?:[ ]{4}|\\t)\t\t\t// Lines must start with a tab or a tab-width of spaces - attacklab: g_tab_width\r\n   .*\\n+\r\n   )+\r\n   )\r\n   (\\n*[ ]{0,3}[^ \\t\\n]|(?=~0))\t// attacklab: g_tab_width\r\n   /g,function(){...});\r\n   */\r\n\r\n  // attacklab: sentinel workarounds for lack of \\A and \\Z, safari\\khtml bug\r\n  text += '~0';\r\n\r\n  var pattern = /(?:\\n\\n|^)((?:(?:[ ]{4}|\\t).*\\n+)+)(\\n*[ ]{0,3}[^ \\t\\n]|(?=~0))/g;\r\n  text = text.replace(pattern, function (wholeMatch, m1, m2) {\r\n    var codeblock = m1,\r\n        nextChar = m2,\r\n        end = '\\n';\r\n\r\n    codeblock = showdown.subParser('outdent')(codeblock);\r\n    codeblock = showdown.subParser('encodeCode')(codeblock);\r\n    codeblock = showdown.subParser('detab')(codeblock);\r\n    codeblock = codeblock.replace(/^\\n+/g, ''); // trim leading newlines\r\n    codeblock = codeblock.replace(/\\n+$/g, ''); // trim trailing newlines\r\n\r\n    if (options.omitExtraWLInCodeBlocks) {\r\n      end = '';\r\n    }\r\n\r\n    codeblock = '<pre><code>' + codeblock + end + '</code></pre>';\r\n\r\n    return showdown.subParser('hashBlock')(codeblock, options, globals) + nextChar;\r\n  });\r\n\r\n  // attacklab: strip sentinel\r\n  text = text.replace(/~0/, '');\r\n\r\n  text = globals.converter._dispatch('codeBlocks.after', text, options);\r\n  return text;\r\n});\r\n\r\n/**\r\n *\r\n *   *  Backtick quotes are used for <code></code> spans.\r\n *\r\n *   *  You can use multiple backticks as the delimiters if you want to\r\n *     include literal backticks in the code span. So, this input:\r\n *\r\n *         Just type ``foo `bar` baz`` at the prompt.\r\n *\r\n *       Will translate to:\r\n *\r\n *         <p>Just type <code>foo `bar` baz</code> at the prompt.</p>\r\n *\r\n *    There's no arbitrary limit to the number of backticks you\r\n *    can use as delimters. If you need three consecutive backticks\r\n *    in your code, use four for delimiters, etc.\r\n *\r\n *  *  You can use spaces to get literal backticks at the edges:\r\n *\r\n *         ... type `` `bar` `` ...\r\n *\r\n *       Turns to:\r\n *\r\n *         ... type <code>`bar`</code> ...\r\n */\r\nshowdown.subParser('codeSpans', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  text = globals.converter._dispatch('codeSpans.before', text, options);\r\n\r\n  /*\r\n   text = text.replace(/\r\n   (^|[^\\\\])\t\t\t\t\t// Character before opening ` can't be a backslash\r\n   (`+)\t\t\t\t\t\t// $2 = Opening run of `\r\n   (\t\t\t\t\t\t\t// $3 = The code block\r\n   [^\\r]*?\r\n   [^`]\t\t\t\t\t// attacklab: work around lack of lookbehind\r\n   )\r\n   \\2\t\t\t\t\t\t\t// Matching closer\r\n   (?!`)\r\n   /gm, function(){...});\r\n   */\r\n  text = text.replace(/(^|[^\\\\])(`+)([^\\r]*?[^`])\\2(?!`)/gm,\r\n    function (wholeMatch, m1, m2, m3) {\r\n      var c = m3;\r\n      c = c.replace(/^([ \\t]*)/g, '');\t// leading whitespace\r\n      c = c.replace(/[ \\t]*$/g, '');\t// trailing whitespace\r\n      c = showdown.subParser('encodeCode')(c);\r\n      return m1 + '<code>' + c + '</code>';\r\n    }\r\n  );\r\n\r\n  text = globals.converter._dispatch('codeSpans.after', text, options);\r\n  return text;\r\n});\r\n\r\n/**\r\n * Convert all tabs to spaces\r\n */\r\nshowdown.subParser('detab', function (text) {\r\n  'use strict';\r\n\r\n  // expand first n-1 tabs\r\n  text = text.replace(/\\t(?=\\t)/g, '    '); // g_tab_width\r\n\r\n  // replace the nth with two sentinels\r\n  text = text.replace(/\\t/g, '~A~B');\r\n\r\n  // use the sentinel to anchor our regex so it doesn't explode\r\n  text = text.replace(/~B(.+?)~A/g, function (wholeMatch, m1) {\r\n    var leadingText = m1,\r\n        numSpaces = 4 - leadingText.length % 4;  // g_tab_width\r\n\r\n    // there *must* be a better way to do this:\r\n    for (var i = 0; i < numSpaces; i++) {\r\n      leadingText += ' ';\r\n    }\r\n\r\n    return leadingText;\r\n  });\r\n\r\n  // clean up sentinels\r\n  text = text.replace(/~A/g, '    ');  // g_tab_width\r\n  text = text.replace(/~B/g, '');\r\n\r\n  return text;\r\n\r\n});\r\n\r\n/**\r\n * Smart processing for ampersands and angle brackets that need to be encoded.\r\n */\r\nshowdown.subParser('encodeAmpsAndAngles', function (text) {\r\n  'use strict';\r\n  // Ampersand-encoding based entirely on Nat Irons's Amputator MT plugin:\r\n  // http://bumppo.net/projects/amputator/\r\n  text = text.replace(/&(?!#?[xX]?(?:[0-9a-fA-F]+|\\w+);)/g, '&amp;');\r\n\r\n  // Encode naked <'s\r\n  text = text.replace(/<(?![a-z\\/?\\$!])/gi, '&lt;');\r\n\r\n  return text;\r\n});\r\n\r\n/**\r\n * Returns the string, with after processing the following backslash escape sequences.\r\n *\r\n * attacklab: The polite way to do this is with the new escapeCharacters() function:\r\n *\r\n *    text = escapeCharacters(text,\"\\\\\",true);\r\n *    text = escapeCharacters(text,\"`*_{}[]()>#+-.!\",true);\r\n *\r\n * ...but we're sidestepping its use of the (slow) RegExp constructor\r\n * as an optimization for Firefox.  This function gets called a LOT.\r\n */\r\nshowdown.subParser('encodeBackslashEscapes', function (text) {\r\n  'use strict';\r\n  text = text.replace(/\\\\(\\\\)/g, showdown.helper.escapeCharactersCallback);\r\n  text = text.replace(/\\\\([`*_{}\\[\\]()>#+-.!])/g, showdown.helper.escapeCharactersCallback);\r\n  return text;\r\n});\r\n\r\n/**\r\n * Encode/escape certain characters inside Markdown code runs.\r\n * The point is that in code, these characters are literals,\r\n * and lose their special Markdown meanings.\r\n */\r\nshowdown.subParser('encodeCode', function (text) {\r\n  'use strict';\r\n\r\n  // Encode all ampersands; HTML entities are not\r\n  // entities within a Markdown code span.\r\n  text = text.replace(/&/g, '&amp;');\r\n\r\n  // Do the angle bracket song and dance:\r\n  text = text.replace(/</g, '&lt;');\r\n  text = text.replace(/>/g, '&gt;');\r\n\r\n  // Now, escape characters that are magic in Markdown:\r\n  text = showdown.helper.escapeCharacters(text, '*_{}[]\\\\', false);\r\n\r\n  // jj the line above breaks this:\r\n  //---\r\n  //* Item\r\n  //   1. Subitem\r\n  //            special char: *\r\n  // ---\r\n\r\n  return text;\r\n});\r\n\r\n/**\r\n *  Input: an email address, e.g. \"foo@example.com\"\r\n *\r\n *  Output: the email address as a mailto link, with each character\r\n *    of the address encoded as either a decimal or hex entity, in\r\n *    the hopes of foiling most address harvesting spam bots. E.g.:\r\n *\r\n *    <a href=\"&#x6D;&#97;&#105;&#108;&#x74;&#111;:&#102;&#111;&#111;&#64;&#101;\r\n *       x&#x61;&#109;&#x70;&#108;&#x65;&#x2E;&#99;&#111;&#109;\">&#102;&#111;&#111;\r\n *       &#64;&#101;x&#x61;&#109;&#x70;&#108;&#x65;&#x2E;&#99;&#111;&#109;</a>\r\n *\r\n *  Based on a filter by Matthew Wickline, posted to the BBEdit-Talk\r\n *  mailing list: <http://tinyurl.com/yu7ue>\r\n *\r\n */\r\nshowdown.subParser('encodeEmailAddress', function (addr) {\r\n  'use strict';\r\n\r\n  var encode = [\r\n    function (ch) {\r\n      return '&#' + ch.charCodeAt(0) + ';';\r\n    },\r\n    function (ch) {\r\n      return '&#x' + ch.charCodeAt(0).toString(16) + ';';\r\n    },\r\n    function (ch) {\r\n      return ch;\r\n    }\r\n  ];\r\n\r\n  addr = 'mailto:' + addr;\r\n\r\n  addr = addr.replace(/./g, function (ch) {\r\n    if (ch === '@') {\r\n      // this *must* be encoded. I insist.\r\n      ch = encode[Math.floor(Math.random() * 2)](ch);\r\n    } else if (ch !== ':') {\r\n      // leave ':' alone (to spot mailto: later)\r\n      var r = Math.random();\r\n      // roughly 10% raw, 45% hex, 45% dec\r\n      ch = (\r\n        r > 0.9 ? encode[2](ch) : r > 0.45 ? encode[1](ch) : encode[0](ch)\r\n      );\r\n    }\r\n    return ch;\r\n  });\r\n\r\n  addr = '<a href=\"' + addr + '\">' + addr + '</a>';\r\n  addr = addr.replace(/\">.+:/g, '\">'); // strip the mailto: from the visible part\r\n\r\n  return addr;\r\n});\r\n\r\n/**\r\n * Within tags -- meaning between < and > -- encode [\\ ` * _] so they\r\n * don't conflict with their use in Markdown for code, italics and strong.\r\n */\r\nshowdown.subParser('escapeSpecialCharsWithinTagAttributes', function (text) {\r\n  'use strict';\r\n\r\n  // Build a regex to find HTML tags and comments.  See Friedl's\r\n  // \"Mastering Regular Expressions\", 2nd Ed., pp. 200-201.\r\n  var regex = /(<[a-z\\/!$](\"[^\"]*\"|'[^']*'|[^'\">])*>|<!(--.*?--\\s*)+>)/gi;\r\n\r\n  text = text.replace(regex, function (wholeMatch) {\r\n    var tag = wholeMatch.replace(/(.)<\\/?code>(?=.)/g, '$1`');\r\n    tag = showdown.helper.escapeCharacters(tag, '\\\\`*_', false);\r\n    return tag;\r\n  });\r\n\r\n  return text;\r\n});\r\n\r\n/**\r\n * Handle github codeblocks prior to running HashHTML so that\r\n * HTML contained within the codeblock gets escaped properly\r\n * Example:\r\n * ```ruby\r\n *     def hello_world(x)\r\n *       puts \"Hello, #{x}\"\r\n *     end\r\n * ```\r\n */\r\nshowdown.subParser('githubCodeBlocks', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  // early exit if option is not enabled\r\n  if (!options.ghCodeBlocks) {\r\n    return text;\r\n  }\r\n\r\n  text = globals.converter._dispatch('githubCodeBlocks.before', text, options);\r\n\r\n  text += '~0';\r\n\r\n  text = text.replace(/(?:^|\\n)```(.*)\\n([\\s\\S]*?)\\n```/g, function (wholeMatch, language, codeblock) {\r\n    var end = (options.omitExtraWLInCodeBlocks) ? '' : '\\n';\r\n\r\n    codeblock = showdown.subParser('encodeCode')(codeblock);\r\n    codeblock = showdown.subParser('detab')(codeblock);\r\n    codeblock = codeblock.replace(/^\\n+/g, ''); // trim leading newlines\r\n    codeblock = codeblock.replace(/\\n+$/g, ''); // trim trailing whitespace\r\n\r\n    codeblock = '<pre><code' + (language ? ' class=\"' + language + ' language-' + language + '\"' : '') + '>' + codeblock + end + '</code></pre>';\r\n\r\n    return showdown.subParser('hashBlock')(codeblock, options, globals);\r\n  });\r\n\r\n  // attacklab: strip sentinel\r\n  text = text.replace(/~0/, '');\r\n\r\n  text = globals.converter._dispatch('githubCodeBlocks.after', text, options);\r\n\r\n  return text;\r\n});\r\n\r\nshowdown.subParser('hashBlock', function (text, options, globals) {\r\n  'use strict';\r\n  text = text.replace(/(^\\n+|\\n+$)/g, '');\r\n  return '\\n\\n~K' + (globals.gHtmlBlocks.push(text) - 1) + 'K\\n\\n';\r\n});\r\n\r\nshowdown.subParser('hashElement', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  return function (wholeMatch, m1) {\r\n    var blockText = m1;\r\n\r\n    // Undo double lines\r\n    blockText = blockText.replace(/\\n\\n/g, '\\n');\r\n    blockText = blockText.replace(/^\\n/, '');\r\n\r\n    // strip trailing blank lines\r\n    blockText = blockText.replace(/\\n+$/g, '');\r\n\r\n    // Replace the element text with a marker (\"~KxK\" where x is its key)\r\n    blockText = '\\n\\n~K' + (globals.gHtmlBlocks.push(blockText) - 1) + 'K\\n\\n';\r\n\r\n    return blockText;\r\n  };\r\n});\r\n\r\nshowdown.subParser('hashHTMLBlocks', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  // attacklab: Double up blank lines to reduce lookaround\r\n  text = text.replace(/\\n/g, '\\n\\n');\r\n\r\n  // Hashify HTML blocks:\r\n  // We only want to do this for block-level HTML tags, such as headers,\r\n  // lists, and tables. That's because we still want to wrap <p>s around\r\n  // \"paragraphs\" that are wrapped in non-block-level tags, such as anchors,\r\n  // phrase emphasis, and spans. The list of tags we're looking for is\r\n  // hard-coded:\r\n  //var block_tags_a =\r\n  // 'p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|ins|del|style|section|header|footer|nav|article|aside';\r\n  // var block_tags_b =\r\n  // 'p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|style|section|header|footer|nav|article|aside';\r\n\r\n  // First, look for nested blocks, e.g.:\r\n  //   <div>\r\n  //     <div>\r\n  //     tags for inner block must be indented.\r\n  //     </div>\r\n  //   </div>\r\n  //\r\n  // The outermost tags must start at the left margin for this to match, and\r\n  // the inner nested divs must be indented.\r\n  // We need to do this before the next, more liberal match, because the next\r\n  // match will start at the first `<div>` and stop at the first `</div>`.\r\n\r\n  // attacklab: This regex can be expensive when it fails.\r\n  /*\r\n   var text = text.replace(/\r\n   (\t\t\t\t\t\t// save in $1\r\n   ^\t\t\t\t\t// start of line  (with /m)\r\n   <($block_tags_a)\t// start tag = $2\r\n   \\b\t\t\t\t\t// word break\r\n   // attacklab: hack around khtml/pcre bug...\r\n   [^\\r]*?\\n\t\t\t// any number of lines, minimally matching\r\n   </\\2>\t\t\t\t// the matching end tag\r\n   [ \\t]*\t\t\t\t// trailing spaces/tabs\r\n   (?=\\n+)\t\t\t\t// followed by a newline\r\n   )\t\t\t\t\t\t// attacklab: there are sentinel newlines at end of document\r\n   /gm,function(){...}};\r\n   */\r\n  text = text.replace(/^(<(p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|ins|del)\\b[^\\r]*?\\n<\\/\\2>[ \\t]*(?=\\n+))/gm,\r\n                      showdown.subParser('hashElement')(text, options, globals));\r\n\r\n  //\r\n  // Now match more liberally, simply from `\\n<tag>` to `</tag>\\n`\r\n  //\r\n\r\n  /*\r\n   var text = text.replace(/\r\n   (\t\t\t\t\t\t// save in $1\r\n   ^\t\t\t\t\t// start of line  (with /m)\r\n   <($block_tags_b)\t// start tag = $2\r\n   \\b\t\t\t\t\t// word break\r\n   // attacklab: hack around khtml/pcre bug...\r\n   [^\\r]*?\t\t\t\t// any number of lines, minimally matching\r\n   </\\2>\t\t\t\t// the matching end tag\r\n   [ \\t]*\t\t\t\t// trailing spaces/tabs\r\n   (?=\\n+)\t\t\t\t// followed by a newline\r\n   )\t\t\t\t\t\t// attacklab: there are sentinel newlines at end of document\r\n   /gm,function(){...}};\r\n   */\r\n  text = text.replace(/^(<(p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|style|section|header|footer|nav|article|aside|address|audio|canvas|figure|hgroup|output|video)\\b[^\\r]*?<\\/\\2>[ \\t]*(?=\\n+)\\n)/gm,\r\n                      showdown.subParser('hashElement')(text, options, globals));\r\n\r\n  // Special case just for <hr />. It was easier to make a special case than\r\n  // to make the other regex more complicated.\r\n\r\n  /*\r\n   text = text.replace(/\r\n   (\t\t\t\t\t\t// save in $1\r\n   \\n\\n\t\t\t\t// Starting after a blank line\r\n   [ ]{0,3}\r\n   (<(hr)\t\t\t\t// start tag = $2\r\n   \\b\t\t\t\t\t// word break\r\n   ([^<>])*?\t\t\t//\r\n   \\/?>)\t\t\t\t// the matching end tag\r\n   [ \\t]*\r\n   (?=\\n{2,})\t\t\t// followed by a blank line\r\n   )\r\n   /g,showdown.subParser('hashElement')(text, options, globals));\r\n   */\r\n  text = text.replace(/(\\n[ ]{0,3}(<(hr)\\b([^<>])*?\\/?>)[ \\t]*(?=\\n{2,}))/g,\r\n                      showdown.subParser('hashElement')(text, options, globals));\r\n\r\n  // Special case for standalone HTML comments:\r\n\r\n  /*\r\n   text = text.replace(/\r\n   (\t\t\t\t\t\t// save in $1\r\n   \\n\\n\t\t\t\t// Starting after a blank line\r\n   [ ]{0,3}\t\t\t// attacklab: g_tab_width - 1\r\n   <!\r\n   (--[^\\r]*?--\\s*)+\r\n   >\r\n   [ \\t]*\r\n   (?=\\n{2,})\t\t\t// followed by a blank line\r\n   )\r\n   /g,showdown.subParser('hashElement')(text, options, globals));\r\n   */\r\n  text = text.replace(/(\\n\\n[ ]{0,3}<!(--[^\\r]*?--\\s*)+>[ \\t]*(?=\\n{2,}))/g,\r\n                      showdown.subParser('hashElement')(text, options, globals));\r\n\r\n  // PHP and ASP-style processor instructions (<?...?> and <%...%>)\r\n\r\n  /*\r\n   text = text.replace(/\r\n   (?:\r\n   \\n\\n\t\t\t\t// Starting after a blank line\r\n   )\r\n   (\t\t\t\t\t\t// save in $1\r\n   [ ]{0,3}\t\t\t// attacklab: g_tab_width - 1\r\n   (?:\r\n   <([?%])\t\t\t// $2\r\n   [^\\r]*?\r\n   \\2>\r\n   )\r\n   [ \\t]*\r\n   (?=\\n{2,})\t\t\t// followed by a blank line\r\n   )\r\n   /g,showdown.subParser('hashElement')(text, options, globals));\r\n   */\r\n  text = text.replace(/(?:\\n\\n)([ ]{0,3}(?:<([?%])[^\\r]*?\\2>)[ \\t]*(?=\\n{2,}))/g,\r\n                      showdown.subParser('hashElement')(text, options, globals));\r\n\r\n  // attacklab: Undo double lines (see comment at top of this function)\r\n  text = text.replace(/\\n\\n/g, '\\n');\r\n  return text;\r\n\r\n});\r\n\r\n/**\r\n * Hash span elements that should not be parsed as markdown\r\n */\r\nshowdown.subParser('hashHTMLSpans', function (text, config, globals) {\r\n  'use strict';\r\n\r\n  var matches = showdown.helper.matchRecursiveRegExp(text, '<code\\\\b[^>]*>', '</code>', 'gi');\r\n\r\n  for (var i = 0; i < matches.length; ++i) {\r\n    text = text.replace(matches[i][0], '~L' + (globals.gHtmlSpans.push(matches[i][0]) - 1) + 'L');\r\n  }\r\n  return text;\r\n});\r\n\r\n/**\r\n * Unhash HTML spans\r\n */\r\nshowdown.subParser('unhashHTMLSpans', function (text, config, globals) {\r\n  'use strict';\r\n\r\n  for (var i = 0; i < globals.gHtmlSpans.length; ++i) {\r\n    text = text.replace('~L' + i + 'L', globals.gHtmlSpans[i]);\r\n  }\r\n\r\n  return text;\r\n});\r\n\r\nshowdown.subParser('headers', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  text = globals.converter._dispatch('headers.before', text, options);\r\n\r\n  var prefixHeader = options.prefixHeaderId,\r\n      headerLevelStart = (isNaN(parseInt(options.headerLevelStart))) ? 1 : parseInt(options.headerLevelStart),\r\n\r\n  // Set text-style headers:\r\n  //\tHeader 1\r\n  //\t========\r\n  //\r\n  //\tHeader 2\r\n  //\t--------\r\n  //\r\n      setextRegexH1 = (options.smoothLivePreview) ? /^(.+)[ \\t]*\\n={2,}[ \\t]*\\n+/gm : /^(.+)[ \\t]*\\n=+[ \\t]*\\n+/gm,\r\n      setextRegexH2 = (options.smoothLivePreview) ? /^(.+)[ \\t]*\\n-{2,}[ \\t]*\\n+/gm : /^(.+)[ \\t]*\\n-+[ \\t]*\\n+/gm;\r\n\r\n  text = text.replace(setextRegexH1, function (wholeMatch, m1) {\r\n\r\n    var spanGamut = showdown.subParser('spanGamut')(m1, options, globals),\r\n        hID = (options.noHeaderId) ? '' : ' id=\"' + headerId(m1) + '\"',\r\n        hLevel = headerLevelStart,\r\n        hashBlock = '<h' + hLevel + hID + '>' + spanGamut + '</h' + hLevel + '>';\r\n    return showdown.subParser('hashBlock')(hashBlock, options, globals);\r\n  });\r\n\r\n  text = text.replace(setextRegexH2, function (matchFound, m1) {\r\n    var spanGamut = showdown.subParser('spanGamut')(m1, options, globals),\r\n        hID = (options.noHeaderId) ? '' : ' id=\"' + headerId(m1) + '\"',\r\n        hLevel = headerLevelStart + 1,\r\n      hashBlock = '<h' + hLevel + hID + '>' + spanGamut + '</h' + hLevel + '>';\r\n    return showdown.subParser('hashBlock')(hashBlock, options, globals);\r\n  });\r\n\r\n  // atx-style headers:\r\n  //  # Header 1\r\n  //  ## Header 2\r\n  //  ## Header 2 with closing hashes ##\r\n  //  ...\r\n  //  ###### Header 6\r\n  //\r\n  text = text.replace(/^(#{1,6})[ \\t]*(.+?)[ \\t]*#*\\n+/gm, function (wholeMatch, m1, m2) {\r\n    var span = showdown.subParser('spanGamut')(m2, options, globals),\r\n        hID = (options.noHeaderId) ? '' : ' id=\"' + headerId(m2) + '\"',\r\n        hLevel = headerLevelStart - 1 + m1.length,\r\n        header = '<h' + hLevel + hID + '>' + span + '</h' + hLevel + '>';\r\n\r\n    return showdown.subParser('hashBlock')(header, options, globals);\r\n  });\r\n\r\n  function headerId(m) {\r\n    var title, escapedId = m.replace(/[^\\w]/g, '').toLowerCase();\r\n\r\n    if (globals.hashLinkCounts[escapedId]) {\r\n      title = escapedId + '-' + (globals.hashLinkCounts[escapedId]++);\r\n    } else {\r\n      title = escapedId;\r\n      globals.hashLinkCounts[escapedId] = 1;\r\n    }\r\n\r\n    // Prefix id to prevent causing inadvertent pre-existing style matches.\r\n    if (prefixHeader === true) {\r\n      prefixHeader = 'section';\r\n    }\r\n\r\n    if (showdown.helper.isString(prefixHeader)) {\r\n      return prefixHeader + title;\r\n    }\r\n    return title;\r\n  }\r\n\r\n  text = globals.converter._dispatch('headers.after', text, options);\r\n  return text;\r\n});\r\n\r\n/**\r\n * Turn Markdown image shortcuts into <img> tags.\r\n */\r\nshowdown.subParser('images', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  text = globals.converter._dispatch('images.before', text, options);\r\n\r\n  var inlineRegExp    = /!\\[(.*?)]\\s?\\([ \\t]*()<?(\\S+?)>?(?: =([*\\d]+[A-Za-z%]{0,4})x([*\\d]+[A-Za-z%]{0,4}))?[ \\t]*(?:(['\"])(.*?)\\6[ \\t]*)?\\)/g,\r\n      referenceRegExp = /!\\[(.*?)][ ]?(?:\\n[ ]*)?\\[(.*?)]()()()()()/g;\r\n\r\n  function writeImageTag (wholeMatch, altText, linkId, url, width, height, m5, title) {\r\n\r\n    var gUrls   = globals.gUrls,\r\n        gTitles = globals.gTitles,\r\n        gDims   = globals.gDimensions;\r\n\r\n    linkId = linkId.toLowerCase();\r\n\r\n    if (!title) {\r\n      title = '';\r\n    }\r\n\r\n    if (url === '' || url === null) {\r\n      if (linkId === '' || linkId === null) {\r\n        // lower-case and turn embedded newlines into spaces\r\n        linkId = altText.toLowerCase().replace(/ ?\\n/g, ' ');\r\n      }\r\n      url = '#' + linkId;\r\n\r\n      if (!showdown.helper.isUndefined(gUrls[linkId])) {\r\n        url = gUrls[linkId];\r\n        if (!showdown.helper.isUndefined(gTitles[linkId])) {\r\n          title = gTitles[linkId];\r\n        }\r\n        if (!showdown.helper.isUndefined(gDims[linkId])) {\r\n          width = gDims[linkId].width;\r\n          height = gDims[linkId].height;\r\n        }\r\n      } else {\r\n        return wholeMatch;\r\n      }\r\n    }\r\n\r\n    altText = altText.replace(/\"/g, '&quot;');\r\n    altText = showdown.helper.escapeCharacters(altText, '*_', false);\r\n    url = showdown.helper.escapeCharacters(url, '*_', false);\r\n    var result = '<img src=\"' + url + '\" alt=\"' + altText + '\"';\r\n\r\n    if (title) {\r\n      title = title.replace(/\"/g, '&quot;');\r\n      title = showdown.helper.escapeCharacters(title, '*_', false);\r\n      result += ' title=\"' + title + '\"';\r\n    }\r\n\r\n    if (width && height) {\r\n      width  = (width === '*') ? 'auto' : width;\r\n      height = (height === '*') ? 'auto' : height;\r\n\r\n      result += ' width=\"' + width + '\"';\r\n      result += ' height=\"' + height + '\"';\r\n    }\r\n\r\n    result += ' />';\r\n\r\n    return result;\r\n  }\r\n\r\n  // First, handle reference-style labeled images: ![alt text][id]\r\n  text = text.replace(referenceRegExp, writeImageTag);\r\n\r\n  // Next, handle inline images:  ![alt text](url =<width>x<height> \"optional title\")\r\n  text = text.replace(inlineRegExp, writeImageTag);\r\n\r\n  text = globals.converter._dispatch('images.after', text, options);\r\n  return text;\r\n});\r\n\r\nshowdown.subParser('italicsAndBold', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  text = globals.converter._dispatch('italicsAndBold.before', text, options);\r\n\r\n  if (options.literalMidWordUnderscores) {\r\n    //underscores\r\n    // Since we are consuming a \\s character, we need to add it\r\n    text = text.replace(/(^|\\s|>|\\b)__(?=\\S)([^]+?)__(?=\\b|<|\\s|$)/gm, '$1<strong>$2</strong>');\r\n    text = text.replace(/(^|\\s|>|\\b)_(?=\\S)([^]+?)_(?=\\b|<|\\s|$)/gm, '$1<em>$2</em>');\r\n    //asterisks\r\n    text = text.replace(/(\\*\\*)(?=\\S)([^\\r]*?\\S[*]*)\\1/g, '<strong>$2</strong>');\r\n    text = text.replace(/(\\*)(?=\\S)([^\\r]*?\\S)\\1/g, '<em>$2</em>');\r\n\r\n  } else {\r\n    // <strong> must go first:\r\n    text = text.replace(/(\\*\\*|__)(?=\\S)([^\\r]*?\\S[*_]*)\\1/g, '<strong>$2</strong>');\r\n    text = text.replace(/(\\*|_)(?=\\S)([^\\r]*?\\S)\\1/g, '<em>$2</em>');\r\n  }\r\n\r\n  text = globals.converter._dispatch('italicsAndBold.after', text, options);\r\n  return text;\r\n});\r\n\r\n/**\r\n * Form HTML ordered (numbered) and unordered (bulleted) lists.\r\n */\r\nshowdown.subParser('lists', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  text = globals.converter._dispatch('lists.before', text, options);\r\n  /**\r\n   * Process the contents of a single ordered or unordered list, splitting it\r\n   * into individual list items.\r\n   * @param {string} listStr\r\n   * @param {boolean} trimTrailing\r\n   * @returns {string}\r\n   */\r\n  function processListItems (listStr, trimTrailing) {\r\n    // The $g_list_level global keeps track of when we're inside a list.\r\n    // Each time we enter a list, we increment it; when we leave a list,\r\n    // we decrement. If it's zero, we're not in a list anymore.\r\n    //\r\n    // We do this because when we're not inside a list, we want to treat\r\n    // something like this:\r\n    //\r\n    //    I recommend upgrading to version\r\n    //    8. Oops, now this line is treated\r\n    //    as a sub-list.\r\n    //\r\n    // As a single paragraph, despite the fact that the second line starts\r\n    // with a digit-period-space sequence.\r\n    //\r\n    // Whereas when we're inside a list (or sub-list), that line will be\r\n    // treated as the start of a sub-list. What a kludge, huh? This is\r\n    // an aspect of Markdown's syntax that's hard to parse perfectly\r\n    // without resorting to mind-reading. Perhaps the solution is to\r\n    // change the syntax rules such that sub-lists must start with a\r\n    // starting cardinal number; e.g. \"1.\" or \"a.\".\r\n    globals.gListLevel++;\r\n\r\n    // trim trailing blank lines:\r\n    listStr = listStr.replace(/\\n{2,}$/, '\\n');\r\n\r\n    // attacklab: add sentinel to emulate \\z\r\n    listStr += '~0';\r\n\r\n    var rgx = /(\\n)?(^[ \\t]*)([*+-]|\\d+[.])[ \\t]+((\\[(x| )?])?[ \\t]*[^\\r]+?(\\n{1,2}))(?=\\n*(~0|\\2([*+-]|\\d+[.])[ \\t]+))/gm,\r\n        isParagraphed = (/\\n[ \\t]*\\n(?!~0)/.test(listStr));\r\n\r\n    listStr = listStr.replace(rgx, function (wholeMatch, m1, m2, m3, m4, taskbtn, checked) {\r\n      checked = (checked && checked.trim() !== '');\r\n      var item = showdown.subParser('outdent')(m4, options, globals),\r\n          bulletStyle = '';\r\n\r\n      // Support for github tasklists\r\n      if (taskbtn && options.tasklists) {\r\n        bulletStyle = ' class=\"task-list-item\" style=\"list-style-type: none;\"';\r\n        item = item.replace(/^[ \\t]*\\[(x| )?]/m, function () {\r\n          var otp = '<input type=\"checkbox\" disabled style=\"margin: 0px 0.35em 0.25em -1.6em; vertical-align: middle;\"';\r\n          if (checked) {\r\n            otp += ' checked';\r\n          }\r\n          otp += '>';\r\n          return otp;\r\n        });\r\n      }\r\n      // m1 - Leading line or\r\n      // Has a double return (multi paragraph) or\r\n      // Has sublist\r\n      if (m1 || (item.search(/\\n{2,}/) > -1)) {\r\n        item = showdown.subParser('githubCodeBlocks')(item, options, globals);\r\n        item = showdown.subParser('blockGamut')(item, options, globals);\r\n      } else {\r\n        // Recursion for sub-lists:\r\n        item = showdown.subParser('lists')(item, options, globals);\r\n        item = item.replace(/\\n$/, ''); // chomp(item)\r\n        if (isParagraphed) {\r\n          item = showdown.subParser('paragraphs')(item, options, globals);\r\n        } else {\r\n          item = showdown.subParser('spanGamut')(item, options, globals);\r\n        }\r\n      }\r\n      item =  '\\n<li' + bulletStyle + '>' + item + '</li>\\n';\r\n      return item;\r\n    });\r\n\r\n    // attacklab: strip sentinel\r\n    listStr = listStr.replace(/~0/g, '');\r\n\r\n    globals.gListLevel--;\r\n\r\n    if (trimTrailing) {\r\n      listStr = listStr.replace(/\\s+$/, '');\r\n    }\r\n\r\n    return listStr;\r\n  }\r\n\r\n  /**\r\n   * Check and parse consecutive lists (better fix for issue #142)\r\n   * @param {string} list\r\n   * @param {string} listType\r\n   * @param {boolean} trimTrailing\r\n   * @returns {string}\r\n   */\r\n  function parseConsecutiveLists(list, listType, trimTrailing) {\r\n    // check if we caught 2 or more consecutive lists by mistake\r\n    // we use the counterRgx, meaning if listType is UL we look for UL and vice versa\r\n    var counterRxg = (listType === 'ul') ? /^ {0,2}\\d+\\.[ \\t]/gm : /^ {0,2}[*+-][ \\t]/gm,\r\n      subLists = [],\r\n      result = '';\r\n\r\n    if (list.search(counterRxg) !== -1) {\r\n      (function parseCL(txt) {\r\n        var pos = txt.search(counterRxg);\r\n        if (pos !== -1) {\r\n          // slice\r\n          result += '\\n\\n<' + listType + '>' + processListItems(txt.slice(0, pos), !!trimTrailing) + '</' + listType + '>\\n\\n';\r\n\r\n          // invert counterType and listType\r\n          listType = (listType === 'ul') ? 'ol' : 'ul';\r\n          counterRxg = (listType === 'ul') ? /^ {0,2}\\d+\\.[ \\t]/gm : /^ {0,2}[*+-][ \\t]/gm;\r\n\r\n          //recurse\r\n          parseCL(txt.slice(pos));\r\n        } else {\r\n          result += '\\n\\n<' + listType + '>' + processListItems(txt, !!trimTrailing) + '</' + listType + '>\\n\\n';\r\n        }\r\n      })(list);\r\n      for (var i = 0; i < subLists.length; ++i) {\r\n\r\n      }\r\n    } else {\r\n      result = '\\n\\n<' + listType + '>' + processListItems(list, !!trimTrailing) + '</' + listType + '>\\n\\n';\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  // attacklab: add sentinel to hack around khtml/safari bug:\r\n  // http://bugs.webkit.org/show_bug.cgi?id=11231\r\n  text += '~0';\r\n\r\n  // Re-usable pattern to match any entire ul or ol list:\r\n  var wholeList = /^(([ ]{0,3}([*+-]|\\d+[.])[ \\t]+)[^\\r]+?(~0|\\n{2,}(?=\\S)(?![ \\t]*(?:[*+-]|\\d+[.])[ \\t]+)))/gm;\r\n\r\n  if (globals.gListLevel) {\r\n    text = text.replace(wholeList, function (wholeMatch, list, m2) {\r\n      var listType = (m2.search(/[*+-]/g) > -1) ? 'ul' : 'ol';\r\n      return parseConsecutiveLists(list, listType, true);\r\n    });\r\n  } else {\r\n    wholeList = /(\\n\\n|^\\n?)(([ ]{0,3}([*+-]|\\d+[.])[ \\t]+)[^\\r]+?(~0|\\n{2,}(?=\\S)(?![ \\t]*(?:[*+-]|\\d+[.])[ \\t]+)))/gm;\r\n    //wholeList = /(\\n\\n|^\\n?)( {0,3}([*+-]|\\d+\\.)[ \\t]+[\\s\\S]+?)(?=(~0)|(\\n\\n(?!\\t| {2,}| {0,3}([*+-]|\\d+\\.)[ \\t])))/g;\r\n    text = text.replace(wholeList, function (wholeMatch, m1, list, m3) {\r\n\r\n      var listType = (m3.search(/[*+-]/g) > -1) ? 'ul' : 'ol';\r\n      return parseConsecutiveLists(list, listType);\r\n    });\r\n  }\r\n\r\n  // attacklab: strip sentinel\r\n  text = text.replace(/~0/, '');\r\n\r\n  text = globals.converter._dispatch('lists.after', text, options);\r\n  return text;\r\n});\r\n\r\n/**\r\n * Remove one level of line-leading tabs or spaces\r\n */\r\nshowdown.subParser('outdent', function (text) {\r\n  'use strict';\r\n\r\n  // attacklab: hack around Konqueror 3.5.4 bug:\r\n  // \"----------bug\".replace(/^-/g,\"\") == \"bug\"\r\n  text = text.replace(/^(\\t|[ ]{1,4})/gm, '~0'); // attacklab: g_tab_width\r\n\r\n  // attacklab: clean up hack\r\n  text = text.replace(/~0/g, '');\r\n\r\n  return text;\r\n});\r\n\r\n/**\r\n *\r\n */\r\nshowdown.subParser('paragraphs', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  text = globals.converter._dispatch('paragraphs.before', text, options);\r\n  // Strip leading and trailing lines:\r\n  text = text.replace(/^\\n+/g, '');\r\n  text = text.replace(/\\n+$/g, '');\r\n\r\n  var grafs = text.split(/\\n{2,}/g),\r\n      grafsOut = [],\r\n      end = grafs.length; // Wrap <p> tags\r\n\r\n  for (var i = 0; i < end; i++) {\r\n    var str = grafs[i];\r\n\r\n    // if this is an HTML marker, copy it\r\n    if (str.search(/~K(\\d+)K/g) >= 0) {\r\n      grafsOut.push(str);\r\n    } else if (str.search(/\\S/) >= 0) {\r\n      str = showdown.subParser('spanGamut')(str, options, globals);\r\n      str = str.replace(/^([ \\t]*)/g, '<p>');\r\n      str += '</p>';\r\n      grafsOut.push(str);\r\n    }\r\n  }\r\n\r\n  /** Unhashify HTML blocks */\r\n  end = grafsOut.length;\r\n  for (i = 0; i < end; i++) {\r\n    // if this is a marker for an html block...\r\n    while (grafsOut[i].search(/~K(\\d+)K/) >= 0) {\r\n      var blockText = globals.gHtmlBlocks[RegExp.$1];\r\n      blockText = blockText.replace(/\\$/g, '$$$$'); // Escape any dollar signs\r\n      grafsOut[i] = grafsOut[i].replace(/~K\\d+K/, blockText);\r\n    }\r\n  }\r\n\r\n  text = globals.converter._dispatch('paragraphs.after', text, options);\r\n  return grafsOut.join('\\n\\n');\r\n});\r\n\r\n/**\r\n * Run extension\r\n */\r\nshowdown.subParser('runExtension', function (ext, text, options, globals) {\r\n  'use strict';\r\n\r\n  if (ext.filter) {\r\n    text = ext.filter(text, globals.converter, options);\r\n\r\n  } else if (ext.regex) {\r\n    // TODO remove this when old extension loading mechanism is deprecated\r\n    var re = ext.regex;\r\n    if (!re instanceof RegExp) {\r\n      re = new RegExp(re, 'g');\r\n    }\r\n    text = text.replace(re, ext.replace);\r\n  }\r\n\r\n  return text;\r\n});\r\n\r\n/**\r\n * These are all the transformations that occur *within* block-level\r\n * tags like paragraphs, headers, and list items.\r\n */\r\nshowdown.subParser('spanGamut', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  text = globals.converter._dispatch('spanGamut.before', text, options);\r\n  text = showdown.subParser('codeSpans')(text, options, globals);\r\n  text = showdown.subParser('escapeSpecialCharsWithinTagAttributes')(text, options, globals);\r\n  text = showdown.subParser('encodeBackslashEscapes')(text, options, globals);\r\n\r\n  // Process anchor and image tags. Images must come first,\r\n  // because ![foo][f] looks like an anchor.\r\n  text = showdown.subParser('images')(text, options, globals);\r\n  text = showdown.subParser('anchors')(text, options, globals);\r\n\r\n  // Make links out of things like `<http://example.com/>`\r\n  // Must come after _DoAnchors(), because you can use < and >\r\n  // delimiters in inline links like [this](<url>).\r\n  text = showdown.subParser('autoLinks')(text, options, globals);\r\n  text = showdown.subParser('encodeAmpsAndAngles')(text, options, globals);\r\n  text = showdown.subParser('italicsAndBold')(text, options, globals);\r\n  text = showdown.subParser('strikethrough')(text, options, globals);\r\n\r\n  // Do hard breaks:\r\n  text = text.replace(/  +\\n/g, ' <br />\\n');\r\n\r\n  text = globals.converter._dispatch('spanGamut.after', text, options);\r\n  return text;\r\n});\r\n\r\nshowdown.subParser('strikethrough', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  if (options.strikethrough) {\r\n    text = globals.converter._dispatch('strikethrough.before', text, options);\r\n    text = text.replace(/(?:~T){2}([^~]+)(?:~T){2}/g, '<del>$1</del>');\r\n    text = globals.converter._dispatch('strikethrough.after', text, options);\r\n  }\r\n\r\n  return text;\r\n});\r\n\r\n/**\r\n * Strip any lines consisting only of spaces and tabs.\r\n * This makes subsequent regexs easier to write, because we can\r\n * match consecutive blank lines with /\\n+/ instead of something\r\n * contorted like /[ \\t]*\\n+/\r\n */\r\nshowdown.subParser('stripBlankLines', function (text) {\r\n  'use strict';\r\n  return text.replace(/^[ \\t]+$/mg, '');\r\n});\r\n\r\n/**\r\n * Strips link definitions from text, stores the URLs and titles in\r\n * hash references.\r\n * Link defs are in the form: ^[id]: url \"optional title\"\r\n *\r\n * ^[ ]{0,3}\\[(.+)\\]: // id = $1  attacklab: g_tab_width - 1\r\n * [ \\t]*\r\n * \\n?                  // maybe *one* newline\r\n * [ \\t]*\r\n * <?(\\S+?)>?          // url = $2\r\n * [ \\t]*\r\n * \\n?                // maybe one newline\r\n * [ \\t]*\r\n * (?:\r\n * (\\n*)              // any lines skipped = $3 attacklab: lookbehind removed\r\n * [\"(]\r\n * (.+?)              // title = $4\r\n * [\")]\r\n * [ \\t]*\r\n * )?                 // title is optional\r\n * (?:\\n+|$)\r\n * /gm,\r\n * function(){...});\r\n *\r\n */\r\nshowdown.subParser('stripLinkDefinitions', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  var regex = /^ {0,3}\\[(.+)]:[ \\t]*\\n?[ \\t]*<?(\\S+?)>?(?: =([*\\d]+[A-Za-z%]{0,4})x([*\\d]+[A-Za-z%]{0,4}))?[ \\t]*\\n?[ \\t]*(?:(\\n*)[\"|'(](.+?)[\"|')][ \\t]*)?(?:\\n+|(?=~0))/gm;\r\n\r\n  // attacklab: sentinel workarounds for lack of \\A and \\Z, safari\\khtml bug\r\n  text += '~0';\r\n\r\n  text = text.replace(regex, function (wholeMatch, linkId, url, width, height, blankLines, title) {\r\n    linkId = linkId.toLowerCase();\r\n    globals.gUrls[linkId] = showdown.subParser('encodeAmpsAndAngles')(url);  // Link IDs are case-insensitive\r\n\r\n    if (blankLines) {\r\n      // Oops, found blank lines, so it's not a title.\r\n      // Put back the parenthetical statement we stole.\r\n      return blankLines + title;\r\n\r\n    } else {\r\n      if (title) {\r\n        globals.gTitles[linkId] = title.replace(/\"|'/g, '&quot;');\r\n      }\r\n      if (options.parseImgDimensions && width && height) {\r\n        globals.gDimensions[linkId] = {\r\n          width:  width,\r\n          height: height\r\n        };\r\n      }\r\n    }\r\n    // Completely remove the definition from the text\r\n    return '';\r\n  });\r\n\r\n  // attacklab: strip sentinel\r\n  text = text.replace(/~0/, '');\r\n\r\n  return text;\r\n});\r\n\r\nshowdown.subParser('tables', function (text, options, globals) {\r\n  'use strict';\r\n\r\n  var table = function () {\r\n\r\n    var tables = {},\r\n        filter;\r\n\r\n    tables.th = function (header, style) {\r\n      var id = '';\r\n      header = header.trim();\r\n      if (header === '') {\r\n        return '';\r\n      }\r\n      if (options.tableHeaderId) {\r\n        id = ' id=\"' + header.replace(/ /g, '_').toLowerCase() + '\"';\r\n      }\r\n      header = showdown.subParser('spanGamut')(header, options, globals);\r\n      if (!style || style.trim() === '') {\r\n        style = '';\r\n      } else {\r\n        style = ' style=\"' + style + '\"';\r\n      }\r\n      return '<th' + id + style + '>' + header + '</th>';\r\n    };\r\n\r\n    tables.td = function (cell, style) {\r\n      var subText = showdown.subParser('spanGamut')(cell.trim(), options, globals);\r\n      if (!style || style.trim() === '') {\r\n        style = '';\r\n      } else {\r\n        style = ' style=\"' + style + '\"';\r\n      }\r\n      return '<td' + style + '>' + subText + '</td>';\r\n    };\r\n\r\n    tables.ths = function () {\r\n      var out = '',\r\n          i = 0,\r\n          hs = [].slice.apply(arguments[0]),\r\n          style = [].slice.apply(arguments[1]);\r\n\r\n      for (i; i < hs.length; i += 1) {\r\n        out += tables.th(hs[i], style[i]) + '\\n';\r\n      }\r\n\r\n      return out;\r\n    };\r\n\r\n    tables.tds = function () {\r\n      var out = '',\r\n          i = 0,\r\n          ds = [].slice.apply(arguments[0]),\r\n          style = [].slice.apply(arguments[1]);\r\n\r\n      for (i; i < ds.length; i += 1) {\r\n        out += tables.td(ds[i], style[i]) + '\\n';\r\n      }\r\n      return out;\r\n    };\r\n\r\n    tables.thead = function () {\r\n      var out,\r\n          hs = [].slice.apply(arguments[0]),\r\n          style = [].slice.apply(arguments[1]);\r\n\r\n      out = '<thead>\\n';\r\n      out += '<tr>\\n';\r\n      out += tables.ths.apply(this, [hs, style]);\r\n      out += '</tr>\\n';\r\n      out += '</thead>\\n';\r\n      return out;\r\n    };\r\n\r\n    tables.tr = function () {\r\n      var out,\r\n        cs = [].slice.apply(arguments[0]),\r\n        style = [].slice.apply(arguments[1]);\r\n\r\n      out = '<tr>\\n';\r\n      out += tables.tds.apply(this, [cs, style]);\r\n      out += '</tr>\\n';\r\n      return out;\r\n    };\r\n\r\n    filter = function (text) {\r\n      var i = 0,\r\n        lines = text.split('\\n'),\r\n        line,\r\n        hs,\r\n        out = [];\r\n\r\n      for (i; i < lines.length; i += 1) {\r\n        line = lines[i];\r\n        // looks like a table heading\r\n        if (line.trim().match(/^[|].*[|]$/)) {\r\n          line = line.trim();\r\n\r\n          var tbl = [],\r\n              align = lines[i + 1].trim(),\r\n              styles = [],\r\n              j = 0;\r\n\r\n          if (align.match(/^[|][-=|: ]+[|]$/)) {\r\n            styles = align.substring(1, align.length - 1).split('|');\r\n            for (j = 0; j < styles.length; ++j) {\r\n              styles[j] = styles[j].trim();\r\n              if (styles[j].match(/^[:][-=| ]+[:]$/)) {\r\n                styles[j] = 'text-align:center;';\r\n\r\n              } else if (styles[j].match(/^[-=| ]+[:]$/)) {\r\n                styles[j] = 'text-align:right;';\r\n\r\n              } else if (styles[j].match(/^[:][-=| ]+$/)) {\r\n                styles[j] = 'text-align:left;';\r\n              } else {\r\n                styles[j] = '';\r\n              }\r\n            }\r\n          }\r\n          tbl.push('<table>');\r\n          hs = line.substring(1, line.length - 1).split('|');\r\n\r\n          if (styles.length === 0) {\r\n            for (j = 0; j < hs.length; ++j) {\r\n              styles.push('text-align:left');\r\n            }\r\n          }\r\n          tbl.push(tables.thead.apply(this, [hs, styles]));\r\n          line = lines[++i];\r\n          if (!line.trim().match(/^[|][-=|: ]+[|]$/)) {\r\n            // not a table rolling back\r\n            line = lines[--i];\r\n          } else {\r\n            line = lines[++i];\r\n            tbl.push('<tbody>');\r\n            while (line.trim().match(/^[|].*[|]$/)) {\r\n              line = line.trim();\r\n              tbl.push(tables.tr.apply(this, [line.substring(1, line.length - 1).split('|'), styles]));\r\n              line = lines[++i];\r\n            }\r\n            tbl.push('</tbody>');\r\n            tbl.push('</table>');\r\n            // we are done with this table and we move along\r\n            out.push(tbl.join('\\n'));\r\n            continue;\r\n          }\r\n        }\r\n        out.push(line);\r\n      }\r\n      return out.join('\\n');\r\n    };\r\n    return {parse: filter};\r\n  };\r\n\r\n  if (options.tables) {\r\n    text = globals.converter._dispatch('tables.before', text, options);\r\n    var tableParser = table();\r\n    text = tableParser.parse(text);\r\n    text = globals.converter._dispatch('tables.after', text, options);\r\n  }\r\n\r\n  return text;\r\n});\r\n\r\n/**\r\n * Swap back in all the special characters we've hidden.\r\n */\r\nshowdown.subParser('unescapeSpecialChars', function (text) {\r\n  'use strict';\r\n\r\n  text = text.replace(/~E(\\d+)E/g, function (wholeMatch, m1) {\r\n    var charCodeToReplace = parseInt(m1);\r\n    return String.fromCharCode(charCodeToReplace);\r\n  });\r\n  return text;\r\n});\r\n\r\nvar root = this;\r\n\r\n// CommonJS/nodeJS Loader\r\nif (typeof module !== 'undefined' && module.exports) {\r\n  module.exports = showdown;\r\n\r\n// AMD Loader\r\n} else if (typeof define === 'function' && define.amd) {\r\n  define('showdown', function () {\r\n    'use strict';\r\n    return showdown;\r\n  });\r\n\r\n// Regular Browser loader\r\n} else {\r\n  root.showdown = showdown;\r\n}\r\n}).call(this);\r\n\n\r\n\n},{}],46:[function(require,module,exports){\nvar Vue // late bind\nvar map = Object.create(null)\nvar shimmed = false\nvar isBrowserify = false\n\n/**\n * Determine compatibility and apply patch.\n *\n * @param {Function} vue\n * @param {Boolean} browserify\n */\n\nexports.install = function (vue, browserify) {\n  if (shimmed) return\n  shimmed = true\n\n  Vue = vue\n  isBrowserify = browserify\n\n  exports.compatible = !!Vue.internalDirectives\n  if (!exports.compatible) {\n    console.warn(\n      '[HMR] vue-loader hot reload is only compatible with ' +\n      'Vue.js 1.0.0+.'\n    )\n    return\n  }\n\n  // patch view directive\n  patchView(Vue.internalDirectives.component)\n  console.log('[HMR] Vue component hot reload shim applied.')\n  // shim router-view if present\n  var routerView = Vue.elementDirective('router-view')\n  if (routerView) {\n    patchView(routerView)\n    console.log('[HMR] vue-router <router-view> hot reload shim applied.')\n  }\n}\n\n/**\n * Shim the view directive (component or router-view).\n *\n * @param {Object} View\n */\n\nfunction patchView (View) {\n  var unbuild = View.unbuild\n  View.unbuild = function (defer) {\n    if (!this.hotUpdating) {\n      var prevComponent = this.childVM && this.childVM.constructor\n      removeView(prevComponent, this)\n      // defer = true means we are transitioning to a new\n      // Component. Register this new component to the list.\n      if (defer) {\n        addView(this.Component, this)\n      }\n    }\n    // call original\n    return unbuild.call(this, defer)\n  }\n}\n\n/**\n * Add a component view to a Component's hot list\n *\n * @param {Function} Component\n * @param {Directive} view - view directive instance\n */\n\nfunction addView (Component, view) {\n  var id = Component && Component.options.hotID\n  if (id) {\n    if (!map[id]) {\n      map[id] = {\n        Component: Component,\n        views: [],\n        instances: []\n      }\n    }\n    map[id].views.push(view)\n  }\n}\n\n/**\n * Remove a component view from a Component's hot list\n *\n * @param {Function} Component\n * @param {Directive} view - view directive instance\n */\n\nfunction removeView (Component, view) {\n  var id = Component && Component.options.hotID\n  if (id) {\n    map[id].views.$remove(view)\n  }\n}\n\n/**\n * Create a record for a hot module, which keeps track of its construcotr,\n * instnaces and views (component directives or router-views).\n *\n * @param {String} id\n * @param {Object} options\n */\n\nexports.createRecord = function (id, options) {\n  if (typeof options === 'function') {\n    options = options.options\n  }\n  if (typeof options.el !== 'string' && typeof options.data !== 'object') {\n    makeOptionsHot(id, options)\n    map[id] = {\n      Component: null,\n      views: [],\n      instances: []\n    }\n  }\n}\n\n/**\n * Make a Component options object hot.\n *\n * @param {String} id\n * @param {Object} options\n */\n\nfunction makeOptionsHot (id, options) {\n  options.hotID = id\n  injectHook(options, 'created', function () {\n    var record = map[id]\n    if (!record.Component) {\n      record.Component = this.constructor\n    }\n    record.instances.push(this)\n  })\n  injectHook(options, 'beforeDestroy', function () {\n    map[id].instances.$remove(this)\n  })\n}\n\n/**\n * Inject a hook to a hot reloadable component so that\n * we can keep track of it.\n *\n * @param {Object} options\n * @param {String} name\n * @param {Function} hook\n */\n\nfunction injectHook (options, name, hook) {\n  var existing = options[name]\n  options[name] = existing\n    ? Array.isArray(existing)\n      ? existing.concat(hook)\n      : [existing, hook]\n    : [hook]\n}\n\n/**\n * Update a hot component.\n *\n * @param {String} id\n * @param {Object|null} newOptions\n * @param {String|null} newTemplate\n */\n\nexports.update = function (id, newOptions, newTemplate) {\n  var record = map[id]\n  // force full-reload if an instance of the component is active but is not\n  // managed by a view\n  if (!record || (record.instances.length && !record.views.length)) {\n    console.log('[HMR] Root or manually-mounted instance modified. Full reload may be required.')\n    if (!isBrowserify) {\n      window.location.reload()\n    } else {\n      // browserify-hmr somehow sends incomplete bundle if we reload here\n      return\n    }\n  }\n  if (!isBrowserify) {\n    // browserify-hmr already logs this\n    console.log('[HMR] Updating component: ' + format(id))\n  }\n  var Component = record.Component\n  // update constructor\n  if (newOptions) {\n    // in case the user exports a constructor\n    Component = record.Component = typeof newOptions === 'function'\n      ? newOptions\n      : Vue.extend(newOptions)\n    makeOptionsHot(id, Component.options)\n  }\n  if (newTemplate) {\n    Component.options.template = newTemplate\n  }\n  // handle recursive lookup\n  if (Component.options.name) {\n    Component.options.components[Component.options.name] = Component\n  }\n  // reset constructor cached linker\n  Component.linker = null\n  // reload all views\n  record.views.forEach(function (view) {\n    updateView(view, Component)\n  })\n  // flush devtools\n  if (window.__VUE_DEVTOOLS_GLOBAL_HOOK__) {\n    window.__VUE_DEVTOOLS_GLOBAL_HOOK__.emit('flush')\n  }\n}\n\n/**\n * Update a component view instance\n *\n * @param {Directive} view\n * @param {Function} Component\n */\n\nfunction updateView (view, Component) {\n  if (!view._bound) {\n    return\n  }\n  view.Component = Component\n  view.hotUpdating = true\n  // disable transitions\n  view.vm._isCompiled = false\n  // save state\n  var state = extractState(view.childVM)\n  // remount, make sure to disable keep-alive\n  var keepAlive = view.keepAlive\n  view.keepAlive = false\n  view.mountComponent()\n  view.keepAlive = keepAlive\n  // restore state\n  restoreState(view.childVM, state, true)\n  // re-eanble transitions\n  view.vm._isCompiled = true\n  view.hotUpdating = false\n}\n\n/**\n * Extract state from a Vue instance.\n *\n * @param {Vue} vm\n * @return {Object}\n */\n\nfunction extractState (vm) {\n  return {\n    cid: vm.constructor.cid,\n    data: vm.$data,\n    children: vm.$children.map(extractState)\n  }\n}\n\n/**\n * Restore state to a reloaded Vue instance.\n *\n * @param {Vue} vm\n * @param {Object} state\n */\n\nfunction restoreState (vm, state, isRoot) {\n  var oldAsyncConfig\n  if (isRoot) {\n    // set Vue into sync mode during state rehydration\n    oldAsyncConfig = Vue.config.async\n    Vue.config.async = false\n  }\n  // actual restore\n  if (isRoot || !vm._props) {\n    vm.$data = state.data\n  } else {\n    Object.keys(state.data).forEach(function (key) {\n      if (!vm._props[key]) {\n        // for non-root, only restore non-props fields\n        vm.$data[key] = state.data[key]\n      }\n    })\n  }\n  // verify child consistency\n  var hasSameChildren = vm.$children.every(function (c, i) {\n    return state.children[i] && state.children[i].cid === c.constructor.cid\n  })\n  if (hasSameChildren) {\n    // rehydrate children\n    vm.$children.forEach(function (c, i) {\n      restoreState(c, state.children[i])\n    })\n  }\n  if (isRoot) {\n    Vue.config.async = oldAsyncConfig\n  }\n}\n\nfunction format (id) {\n  return id.match(/[^\\/]+\\.vue$/)[0]\n}\n\n},{}],47:[function(require,module,exports){\nmodule.exports = {\r\n    template: '<nav class=\" {{navClass}} \">' +\r\n        '<ul class=\"pagination {{size}} \">' +\r\n            '<li v-if=\"pagination.current_page > 1\">' +\r\n                '<a href=\"#\" aria-label=\"Previous\" @click.prevent=\"changePage(1)\">' +\r\n                    '<span aria-hidden=\"true\">First</span>' +\r\n                '</a>' +\r\n            '</li>' +\r\n            '<li v-if=\"pagination.current_page > 1\">' +\r\n                '<a href=\"#\" aria-label=\"Previous\" @click.prevent=\"changePage(pagination.current_page - 1)\">' +\r\n                    '<span aria-hidden=\"true\">&laquo;</span>' +\r\n                '</a>' +\r\n            '</li>' +\r\n            '<li v-if=\"pagination.current_page > 1\">' +\r\n                '<a href=\"#\" aria-label=\"Next\" @click.prevent=\"changePage(from)\">' +\r\n                    '<span aria-hidden=\"true\">...</span>' +\r\n                '</a>' +\r\n            '</li>' +\r\n            '<li v-for=\"num in data\" :class=\"{\\'active\\': num == pagination.current_page}\">' +\r\n                '<a href=\"#\" @click.prevent=\"changePage(num)\">{{ num }}</a>' +\r\n            '</li>' +\r\n            '<li v-if=\"pagination.current_page < pagination.total_pages\">' +\r\n                '<a href=\"#\" aria-label=\"Next\" @click.prevent=\"changePage(to)\">' +\r\n                    '<span aria-hidden=\"true\">...</span>' +\r\n                '</a>' +\r\n            '</li>' +\r\n            '<li v-if=\"pagination.current_page < pagination.total_pages\">' +\r\n                '<a href=\"#\" aria-label=\"Next\" @click.prevent=\"changePage(pagination.current_page + 1)\">' +\r\n                    '<span aria-hidden=\"true\">&raquo;</span>' +\r\n                '</a>' +\r\n            '</li>' +\r\n            '<li v-if=\"pagination.current_page < pagination.total_pages\">' +\r\n                '<a href=\"#\" aria-label=\"Next\" @click.prevent=\"changePage(pagination.total_pages)\">' +\r\n                    '<span aria-hidden=\"true\">Last</span>' +\r\n                '</a>' +\r\n            '</li>' +\r\n        '</ul>' +\r\n    '</nav>',\r\n\r\n    data: function(){\r\n        return {\r\n            to : 0,\r\n            from: 0\r\n        }\r\n    },\r\n    props: {\r\n        pagination: {\r\n            type: Object,\r\n            required: true\r\n        },\r\n        callback: {\r\n            type: Function,\r\n            required: true\r\n        },\r\n        size: {\r\n            type: String,\r\n            default: \"\"\r\n        },\r\n        navClass: {\r\n            type: String,\r\n            default: \"\"\r\n        },\r\n        offset: {\r\n            type: Number,\r\n            default: 4\r\n        }\r\n    },\r\n    computed: {\r\n        data: function () {\r\n            var from = this.pagination.current_page - this.offset;\r\n            if(from < 1) {\r\n                from = 1;\r\n            }\r\n\r\n            var to = from + (this.offset * 2);\r\n            if(to >= this.pagination.total_pages) {\r\n                to = this.pagination.total_pages;\r\n            }\r\n            this.from = from;\r\n            this.to = to;\r\n\r\n            var arr = [];\r\n            while (from <=to) {\r\n                arr.push(from);\r\n                from++;\r\n            }\r\n\r\n            return arr;\r\n        }\r\n    },\r\n    watch: {\r\n        'pagination.per_page': function () {\r\n            this.callback();\r\n        }\r\n    },\r\n    methods: {\r\n        changePage: function (page) {\r\n            this.$set('pagination.current_page', page);\r\n            this.callback();\r\n        }\r\n    }\r\n};\r\n\n},{}],48:[function(require,module,exports){\n/**\n * Before Interceptor.\n */\n\nvar _ = require('../util');\n\nmodule.exports = {\n\n    request: function (request) {\n\n        if (_.isFunction(request.beforeSend)) {\n            request.beforeSend.call(this, request);\n        }\n\n        return request;\n    }\n\n};\n\n},{\"../util\":71}],49:[function(require,module,exports){\n/**\n * Base client.\n */\n\nvar _ = require('../../util');\nvar Promise = require('../../promise');\nvar xhrClient = require('./xhr');\n\nmodule.exports = function (request) {\n\n    var response = (request.client || xhrClient)(request);\n\n    return Promise.resolve(response).then(function (response) {\n\n        if (response.headers) {\n\n            var headers = parseHeaders(response.headers);\n\n            response.headers = function (name) {\n\n                if (name) {\n                    return headers[_.toLower(name)];\n                }\n\n                return headers;\n            };\n\n        }\n\n        response.ok = response.status >= 200 && response.status < 300;\n\n        return response;\n    });\n\n};\n\nfunction parseHeaders(str) {\n\n    var headers = {}, value, name, i;\n\n    if (_.isString(str)) {\n        _.each(str.split('\\n'), function (row) {\n\n            i = row.indexOf(':');\n            name = _.trim(_.toLower(row.slice(0, i)));\n            value = _.trim(row.slice(i + 1));\n\n            if (headers[name]) {\n\n                if (_.isArray(headers[name])) {\n                    headers[name].push(value);\n                } else {\n                    headers[name] = [headers[name], value];\n                }\n\n            } else {\n\n                headers[name] = value;\n            }\n\n        });\n    }\n\n    return headers;\n}\n\n},{\"../../promise\":64,\"../../util\":71,\"./xhr\":52}],50:[function(require,module,exports){\n/**\n * JSONP client.\n */\n\nvar _ = require('../../util');\nvar Promise = require('../../promise');\n\nmodule.exports = function (request) {\n    return new Promise(function (resolve) {\n\n        var callback = '_jsonp' + Math.random().toString(36).substr(2), response = {request: request, data: null}, handler, script;\n\n        request.params[request.jsonp] = callback;\n        request.cancel = function () {\n            handler({type: 'cancel'});\n        };\n\n        script = document.createElement('script');\n        script.src = _.url(request);\n        script.type = 'text/javascript';\n        script.async = true;\n\n        window[callback] = function (data) {\n            response.data = data;\n        };\n\n        handler = function (event) {\n\n            if (event.type === 'load' && response.data !== null) {\n                response.status = 200;\n            } else if (event.type === 'error') {\n                response.status = 404;\n            } else {\n                response.status = 0;\n            }\n\n            resolve(response);\n\n            delete window[callback];\n            document.body.removeChild(script);\n        };\n\n        script.onload = handler;\n        script.onerror = handler;\n\n        document.body.appendChild(script);\n    });\n};\n\n},{\"../../promise\":64,\"../../util\":71}],51:[function(require,module,exports){\n/**\n * XDomain client (Internet Explorer).\n */\n\nvar _ = require('../../util');\nvar Promise = require('../../promise');\n\nmodule.exports = function (request) {\n    return new Promise(function (resolve) {\n\n        var xdr = new XDomainRequest(), response = {request: request}, handler;\n\n        request.cancel = function () {\n            xdr.abort();\n        };\n\n        xdr.open(request.method, _.url(request), true);\n\n        handler = function (event) {\n\n            response.data = xdr.responseText;\n            response.status = xdr.status;\n            response.statusText = xdr.statusText;\n\n            resolve(response);\n        };\n\n        xdr.timeout = 0;\n        xdr.onload = handler;\n        xdr.onabort = handler;\n        xdr.onerror = handler;\n        xdr.ontimeout = function () {};\n        xdr.onprogress = function () {};\n\n        xdr.send(request.data);\n    });\n};\n\n},{\"../../promise\":64,\"../../util\":71}],52:[function(require,module,exports){\n/**\n * XMLHttp client.\n */\n\nvar _ = require('../../util');\nvar Promise = require('../../promise');\n\nmodule.exports = function (request) {\n    return new Promise(function (resolve) {\n\n        var xhr = new XMLHttpRequest(), response = {request: request}, handler;\n\n        request.cancel = function () {\n            xhr.abort();\n        };\n\n        xhr.open(request.method, _.url(request), true);\n\n        handler = function (event) {\n\n            response.data = xhr.responseText;\n            response.status = xhr.status;\n            response.statusText = xhr.statusText;\n            response.headers = xhr.getAllResponseHeaders();\n\n            resolve(response);\n        };\n\n        xhr.timeout = 0;\n        xhr.onload = handler;\n        xhr.onabort = handler;\n        xhr.onerror = handler;\n        xhr.ontimeout = function () {};\n        xhr.onprogress = function () {};\n\n        if (_.isPlainObject(request.xhr)) {\n            _.extend(xhr, request.xhr);\n        }\n\n        if (_.isPlainObject(request.upload)) {\n            _.extend(xhr.upload, request.upload);\n        }\n\n        _.each(request.headers || {}, function (value, header) {\n            xhr.setRequestHeader(header, value);\n        });\n\n        xhr.send(request.data);\n    });\n};\n\n},{\"../../promise\":64,\"../../util\":71}],53:[function(require,module,exports){\n/**\n * CORS Interceptor.\n */\n\nvar _ = require('../util');\nvar xdrClient = require('./client/xdr');\nvar xhrCors = 'withCredentials' in new XMLHttpRequest();\nvar originUrl = _.url.parse(location.href);\n\nmodule.exports = {\n\n    request: function (request) {\n\n        if (request.crossOrigin === null) {\n            request.crossOrigin = crossOrigin(request);\n        }\n\n        if (request.crossOrigin) {\n\n            if (!xhrCors) {\n                request.client = xdrClient;\n            }\n\n            request.emulateHTTP = false;\n        }\n\n        return request;\n    }\n\n};\n\nfunction crossOrigin(request) {\n\n    var requestUrl = _.url.parse(_.url(request));\n\n    return (requestUrl.protocol !== originUrl.protocol || requestUrl.host !== originUrl.host);\n}\n\n},{\"../util\":71,\"./client/xdr\":51}],54:[function(require,module,exports){\n/**\n * Header Interceptor.\n */\n\nvar _ = require('../util');\n\nmodule.exports = {\n\n    request: function (request) {\n\n        request.method = request.method.toUpperCase();\n        request.headers = _.extend({}, _.http.headers.common,\n            !request.crossOrigin ? _.http.headers.custom : {},\n            _.http.headers[request.method.toLowerCase()],\n            request.headers\n        );\n\n        if (_.isPlainObject(request.data) && /^(GET|JSONP)$/i.test(request.method)) {\n            _.extend(request.params, request.data);\n            delete request.data;\n        }\n\n        return request;\n    }\n\n};\n\n},{\"../util\":71}],55:[function(require,module,exports){\n/**\n * Service for sending network requests.\n */\n\nvar _ = require('../util');\nvar Client = require('./client');\nvar Promise = require('../promise');\nvar interceptor = require('./interceptor');\nvar jsonType = {'Content-Type': 'application/json'};\n\nfunction Http(url, options) {\n\n    var client = Client, request, promise;\n\n    Http.interceptors.forEach(function (handler) {\n        client = interceptor(handler, this.$vm)(client);\n    }, this);\n\n    options = _.isObject(url) ? url : _.extend({url: url}, options);\n    request = _.merge({}, Http.options, this.$options, options);\n    promise = client(request).bind(this.$vm).then(function (response) {\n\n        return response.ok ? response : Promise.reject(response);\n\n    }, function (response) {\n\n        if (response instanceof Error) {\n            _.error(response);\n        }\n\n        return Promise.reject(response);\n    });\n\n    if (request.success) {\n        promise.success(request.success);\n    }\n\n    if (request.error) {\n        promise.error(request.error);\n    }\n\n    return promise;\n}\n\nHttp.options = {\n    method: 'get',\n    data: '',\n    params: {},\n    headers: {},\n    xhr: null,\n    upload: null,\n    jsonp: 'callback',\n    beforeSend: null,\n    crossOrigin: null,\n    emulateHTTP: false,\n    emulateJSON: false,\n    timeout: 0\n};\n\nHttp.interceptors = [\n    require('./before'),\n    require('./timeout'),\n    require('./jsonp'),\n    require('./method'),\n    require('./mime'),\n    require('./header'),\n    require('./cors')\n];\n\nHttp.headers = {\n    put: jsonType,\n    post: jsonType,\n    patch: jsonType,\n    delete: jsonType,\n    common: {'Accept': 'application/json, text/plain, */*'},\n    custom: {'X-Requested-With': 'XMLHttpRequest'}\n};\n\n['get', 'put', 'post', 'patch', 'delete', 'jsonp'].forEach(function (method) {\n\n    Http[method] = function (url, data, success, options) {\n\n        if (_.isFunction(data)) {\n            options = success;\n            success = data;\n            data = undefined;\n        }\n\n        if (_.isObject(success)) {\n            options = success;\n            success = undefined;\n        }\n\n        return this(url, _.extend({method: method, data: data, success: success}, options));\n    };\n});\n\nmodule.exports = _.http = Http;\n\n},{\"../promise\":64,\"../util\":71,\"./before\":48,\"./client\":49,\"./cors\":53,\"./header\":54,\"./interceptor\":56,\"./jsonp\":57,\"./method\":58,\"./mime\":59,\"./timeout\":60}],56:[function(require,module,exports){\n/**\n * Interceptor factory.\n */\n\nvar _ = require('../util');\nvar Promise = require('../promise');\n\nmodule.exports = function (handler, vm) {\n\n    return function (client) {\n\n        if (_.isFunction(handler)) {\n            handler = handler.call(vm, Promise);\n        }\n\n        return function (request) {\n\n            if (_.isFunction(handler.request)) {\n                request = handler.request.call(vm, request);\n            }\n\n            return when(request, function (request) {\n                return when(client(request), function (response) {\n\n                    if (_.isFunction(handler.response)) {\n                        response = handler.response.call(vm, response);\n                    }\n\n                    return response;\n                });\n            });\n        };\n    };\n};\n\nfunction when(value, fulfilled, rejected) {\n\n    var promise = Promise.resolve(value);\n\n    if (arguments.length < 2) {\n        return promise;\n    }\n\n    return promise.then(fulfilled, rejected);\n}\n\n},{\"../promise\":64,\"../util\":71}],57:[function(require,module,exports){\n/**\n * JSONP Interceptor.\n */\n\nvar jsonpClient = require('./client/jsonp');\n\nmodule.exports = {\n\n    request: function (request) {\n\n        if (request.method == 'JSONP') {\n            request.client = jsonpClient;\n        }\n\n        return request;\n    }\n\n};\n\n},{\"./client/jsonp\":50}],58:[function(require,module,exports){\n/**\n * HTTP method override Interceptor.\n */\n\nmodule.exports = {\n\n    request: function (request) {\n\n        if (request.emulateHTTP && /^(PUT|PATCH|DELETE)$/i.test(request.method)) {\n            request.headers['X-HTTP-Method-Override'] = request.method;\n            request.method = 'POST';\n        }\n\n        return request;\n    }\n\n};\n\n},{}],59:[function(require,module,exports){\n/**\n * Mime Interceptor.\n */\n\nvar _ = require('../util');\n\nmodule.exports = {\n\n    request: function (request) {\n\n        if (request.emulateJSON && _.isPlainObject(request.data)) {\n            request.headers['Content-Type'] = 'application/x-www-form-urlencoded';\n            request.data = _.url.params(request.data);\n        }\n\n        if (_.isObject(request.data) && /FormData/i.test(request.data.toString())) {\n            delete request.headers['Content-Type'];\n        }\n\n        if (_.isPlainObject(request.data)) {\n            request.data = JSON.stringify(request.data);\n        }\n\n        return request;\n    },\n\n    response: function (response) {\n\n        try {\n            response.data = JSON.parse(response.data);\n        } catch (e) {}\n\n        return response;\n    }\n\n};\n\n},{\"../util\":71}],60:[function(require,module,exports){\n/**\n * Timeout Interceptor.\n */\n\nmodule.exports = function () {\n\n    var timeout;\n\n    return {\n\n        request: function (request) {\n\n            if (request.timeout) {\n                timeout = setTimeout(function () {\n                    request.cancel();\n                }, request.timeout);\n            }\n\n            return request;\n        },\n\n        response: function (response) {\n\n            clearTimeout(timeout);\n\n            return response;\n        }\n\n    };\n};\n\n},{}],61:[function(require,module,exports){\n/**\n * Install plugin.\n */\n\nfunction install(Vue) {\n\n    var _ = require('./util');\n\n    _.config = Vue.config;\n    _.warning = Vue.util.warn;\n    _.nextTick = Vue.util.nextTick;\n\n    Vue.url = require('./url');\n    Vue.http = require('./http');\n    Vue.resource = require('./resource');\n    Vue.Promise = require('./promise');\n\n    Object.defineProperties(Vue.prototype, {\n\n        $url: {\n            get: function () {\n                return _.options(Vue.url, this, this.$options.url);\n            }\n        },\n\n        $http: {\n            get: function () {\n                return _.options(Vue.http, this, this.$options.http);\n            }\n        },\n\n        $resource: {\n            get: function () {\n                return Vue.resource.bind(this);\n            }\n        },\n\n        $promise: {\n            get: function () {\n                return function (executor) {\n                    return new Vue.Promise(executor, this);\n                }.bind(this);\n            }\n        }\n\n    });\n}\n\nif (window.Vue) {\n    Vue.use(install);\n}\n\nmodule.exports = install;\n\n},{\"./http\":55,\"./promise\":64,\"./resource\":65,\"./url\":66,\"./util\":71}],62:[function(require,module,exports){\n/**\n * Promises/A+ polyfill v1.1.4 (https://github.com/bramstein/promis)\n */\n\nvar _ = require('../util');\n\nvar RESOLVED = 0;\nvar REJECTED = 1;\nvar PENDING  = 2;\n\nfunction Promise(executor) {\n\n    this.state = PENDING;\n    this.value = undefined;\n    this.deferred = [];\n\n    var promise = this;\n\n    try {\n        executor(function (x) {\n            promise.resolve(x);\n        }, function (r) {\n            promise.reject(r);\n        });\n    } catch (e) {\n        promise.reject(e);\n    }\n}\n\nPromise.reject = function (r) {\n    return new Promise(function (resolve, reject) {\n        reject(r);\n    });\n};\n\nPromise.resolve = function (x) {\n    return new Promise(function (resolve, reject) {\n        resolve(x);\n    });\n};\n\nPromise.all = function all(iterable) {\n    return new Promise(function (resolve, reject) {\n        var count = 0, result = [];\n\n        if (iterable.length === 0) {\n            resolve(result);\n        }\n\n        function resolver(i) {\n            return function (x) {\n                result[i] = x;\n                count += 1;\n\n                if (count === iterable.length) {\n                    resolve(result);\n                }\n            };\n        }\n\n        for (var i = 0; i < iterable.length; i += 1) {\n            Promise.resolve(iterable[i]).then(resolver(i), reject);\n        }\n    });\n};\n\nPromise.race = function race(iterable) {\n    return new Promise(function (resolve, reject) {\n        for (var i = 0; i < iterable.length; i += 1) {\n            Promise.resolve(iterable[i]).then(resolve, reject);\n        }\n    });\n};\n\nvar p = Promise.prototype;\n\np.resolve = function resolve(x) {\n    var promise = this;\n\n    if (promise.state === PENDING) {\n        if (x === promise) {\n            throw new TypeError('Promise settled with itself.');\n        }\n\n        var called = false;\n\n        try {\n            var then = x && x['then'];\n\n            if (x !== null && typeof x === 'object' && typeof then === 'function') {\n                then.call(x, function (x) {\n                    if (!called) {\n                        promise.resolve(x);\n                    }\n                    called = true;\n\n                }, function (r) {\n                    if (!called) {\n                        promise.reject(r);\n                    }\n                    called = true;\n                });\n                return;\n            }\n        } catch (e) {\n            if (!called) {\n                promise.reject(e);\n            }\n            return;\n        }\n\n        promise.state = RESOLVED;\n        promise.value = x;\n        promise.notify();\n    }\n};\n\np.reject = function reject(reason) {\n    var promise = this;\n\n    if (promise.state === PENDING) {\n        if (reason === promise) {\n            throw new TypeError('Promise settled with itself.');\n        }\n\n        promise.state = REJECTED;\n        promise.value = reason;\n        promise.notify();\n    }\n};\n\np.notify = function notify() {\n    var promise = this;\n\n    _.nextTick(function () {\n        if (promise.state !== PENDING) {\n            while (promise.deferred.length) {\n                var deferred = promise.deferred.shift(),\n                    onResolved = deferred[0],\n                    onRejected = deferred[1],\n                    resolve = deferred[2],\n                    reject = deferred[3];\n\n                try {\n                    if (promise.state === RESOLVED) {\n                        if (typeof onResolved === 'function') {\n                            resolve(onResolved.call(undefined, promise.value));\n                        } else {\n                            resolve(promise.value);\n                        }\n                    } else if (promise.state === REJECTED) {\n                        if (typeof onRejected === 'function') {\n                            resolve(onRejected.call(undefined, promise.value));\n                        } else {\n                            reject(promise.value);\n                        }\n                    }\n                } catch (e) {\n                    reject(e);\n                }\n            }\n        }\n    });\n};\n\np.then = function then(onResolved, onRejected) {\n    var promise = this;\n\n    return new Promise(function (resolve, reject) {\n        promise.deferred.push([onResolved, onRejected, resolve, reject]);\n        promise.notify();\n    });\n};\n\np.catch = function (onRejected) {\n    return this.then(undefined, onRejected);\n};\n\nmodule.exports = Promise;\n\n},{\"../util\":71}],63:[function(require,module,exports){\n/**\n * URL Template v2.0.6 (https://github.com/bramstein/url-template)\n */\n\nexports.expand = function (url, params, variables) {\n\n    var tmpl = this.parse(url), expanded = tmpl.expand(params);\n\n    if (variables) {\n        variables.push.apply(variables, tmpl.vars);\n    }\n\n    return expanded;\n};\n\nexports.parse = function (template) {\n\n    var operators = ['+', '#', '.', '/', ';', '?', '&'], variables = [];\n\n    return {\n        vars: variables,\n        expand: function (context) {\n            return template.replace(/\\{([^\\{\\}]+)\\}|([^\\{\\}]+)/g, function (_, expression, literal) {\n                if (expression) {\n\n                    var operator = null, values = [];\n\n                    if (operators.indexOf(expression.charAt(0)) !== -1) {\n                        operator = expression.charAt(0);\n                        expression = expression.substr(1);\n                    }\n\n                    expression.split(/,/g).forEach(function (variable) {\n                        var tmp = /([^:\\*]*)(?::(\\d+)|(\\*))?/.exec(variable);\n                        values.push.apply(values, exports.getValues(context, operator, tmp[1], tmp[2] || tmp[3]));\n                        variables.push(tmp[1]);\n                    });\n\n                    if (operator && operator !== '+') {\n\n                        var separator = ',';\n\n                        if (operator === '?') {\n                            separator = '&';\n                        } else if (operator !== '#') {\n                            separator = operator;\n                        }\n\n                        return (values.length !== 0 ? operator : '') + values.join(separator);\n                    } else {\n                        return values.join(',');\n                    }\n\n                } else {\n                    return exports.encodeReserved(literal);\n                }\n            });\n        }\n    };\n};\n\nexports.getValues = function (context, operator, key, modifier) {\n\n    var value = context[key], result = [];\n\n    if (this.isDefined(value) && value !== '') {\n        if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n            value = value.toString();\n\n            if (modifier && modifier !== '*') {\n                value = value.substring(0, parseInt(modifier, 10));\n            }\n\n            result.push(this.encodeValue(operator, value, this.isKeyOperator(operator) ? key : null));\n        } else {\n            if (modifier === '*') {\n                if (Array.isArray(value)) {\n                    value.filter(this.isDefined).forEach(function (value) {\n                        result.push(this.encodeValue(operator, value, this.isKeyOperator(operator) ? key : null));\n                    }, this);\n                } else {\n                    Object.keys(value).forEach(function (k) {\n                        if (this.isDefined(value[k])) {\n                            result.push(this.encodeValue(operator, value[k], k));\n                        }\n                    }, this);\n                }\n            } else {\n                var tmp = [];\n\n                if (Array.isArray(value)) {\n                    value.filter(this.isDefined).forEach(function (value) {\n                        tmp.push(this.encodeValue(operator, value));\n                    }, this);\n                } else {\n                    Object.keys(value).forEach(function (k) {\n                        if (this.isDefined(value[k])) {\n                            tmp.push(encodeURIComponent(k));\n                            tmp.push(this.encodeValue(operator, value[k].toString()));\n                        }\n                    }, this);\n                }\n\n                if (this.isKeyOperator(operator)) {\n                    result.push(encodeURIComponent(key) + '=' + tmp.join(','));\n                } else if (tmp.length !== 0) {\n                    result.push(tmp.join(','));\n                }\n            }\n        }\n    } else {\n        if (operator === ';') {\n            result.push(encodeURIComponent(key));\n        } else if (value === '' && (operator === '&' || operator === '?')) {\n            result.push(encodeURIComponent(key) + '=');\n        } else if (value === '') {\n            result.push('');\n        }\n    }\n\n    return result;\n};\n\nexports.isDefined = function (value) {\n    return value !== undefined && value !== null;\n};\n\nexports.isKeyOperator = function (operator) {\n    return operator === ';' || operator === '&' || operator === '?';\n};\n\nexports.encodeValue = function (operator, value, key) {\n\n    value = (operator === '+' || operator === '#') ? this.encodeReserved(value) : encodeURIComponent(value);\n\n    if (key) {\n        return encodeURIComponent(key) + '=' + value;\n    } else {\n        return value;\n    }\n};\n\nexports.encodeReserved = function (str) {\n    return str.split(/(%[0-9A-Fa-f]{2})/g).map(function (part) {\n        if (!/%[0-9A-Fa-f]/.test(part)) {\n            part = encodeURI(part);\n        }\n        return part;\n    }).join('');\n};\n\n},{}],64:[function(require,module,exports){\n/**\n * Promise adapter.\n */\n\nvar _ = require('./util');\nvar PromiseObj = window.Promise || require('./lib/promise');\n\nfunction Promise(executor, context) {\n\n    if (executor instanceof PromiseObj) {\n        this.promise = executor;\n    } else {\n        this.promise = new PromiseObj(executor.bind(context));\n    }\n\n    this.context = context;\n}\n\nPromise.all = function (iterable, context) {\n    return new Promise(PromiseObj.all(iterable), context);\n};\n\nPromise.resolve = function (value, context) {\n    return new Promise(PromiseObj.resolve(value), context);\n};\n\nPromise.reject = function (reason, context) {\n    return new Promise(PromiseObj.reject(reason), context);\n};\n\nPromise.race = function (iterable, context) {\n    return new Promise(PromiseObj.race(iterable), context);\n};\n\nvar p = Promise.prototype;\n\np.bind = function (context) {\n    this.context = context;\n    return this;\n};\n\np.then = function (fulfilled, rejected) {\n\n    if (fulfilled && fulfilled.bind && this.context) {\n        fulfilled = fulfilled.bind(this.context);\n    }\n\n    if (rejected && rejected.bind && this.context) {\n        rejected = rejected.bind(this.context);\n    }\n\n    this.promise = this.promise.then(fulfilled, rejected);\n\n    return this;\n};\n\np.catch = function (rejected) {\n\n    if (rejected && rejected.bind && this.context) {\n        rejected = rejected.bind(this.context);\n    }\n\n    this.promise = this.promise.catch(rejected);\n\n    return this;\n};\n\np.finally = function (callback) {\n\n    return this.then(function (value) {\n            callback.call(this);\n            return value;\n        }, function (reason) {\n            callback.call(this);\n            return PromiseObj.reject(reason);\n        }\n    );\n};\n\np.success = function (callback) {\n\n    _.warn('The `success` method has been deprecated. Use the `then` method instead.');\n\n    return this.then(function (response) {\n        return callback.call(this, response.data, response.status, response) || response;\n    });\n};\n\np.error = function (callback) {\n\n    _.warn('The `error` method has been deprecated. Use the `catch` method instead.');\n\n    return this.catch(function (response) {\n        return callback.call(this, response.data, response.status, response) || response;\n    });\n};\n\np.always = function (callback) {\n\n    _.warn('The `always` method has been deprecated. Use the `finally` method instead.');\n\n    var cb = function (response) {\n        return callback.call(this, response.data, response.status, response) || response;\n    };\n\n    return this.then(cb, cb);\n};\n\nmodule.exports = Promise;\n\n},{\"./lib/promise\":62,\"./util\":71}],65:[function(require,module,exports){\n/**\n * Service for interacting with RESTful services.\n */\n\nvar _ = require('./util');\n\nfunction Resource(url, params, actions, options) {\n\n    var self = this, resource = {};\n\n    actions = _.extend({},\n        Resource.actions,\n        actions\n    );\n\n    _.each(actions, function (action, name) {\n\n        action = _.merge({url: url, params: params || {}}, options, action);\n\n        resource[name] = function () {\n            return (self.$http || _.http)(opts(action, arguments));\n        };\n    });\n\n    return resource;\n}\n\nfunction opts(action, args) {\n\n    var options = _.extend({}, action), params = {}, data, success, error;\n\n    switch (args.length) {\n\n        case 4:\n\n            error = args[3];\n            success = args[2];\n\n        case 3:\n        case 2:\n\n            if (_.isFunction(args[1])) {\n\n                if (_.isFunction(args[0])) {\n\n                    success = args[0];\n                    error = args[1];\n\n                    break;\n                }\n\n                success = args[1];\n                error = args[2];\n\n            } else {\n\n                params = args[0];\n                data = args[1];\n                success = args[2];\n\n                break;\n            }\n\n        case 1:\n\n            if (_.isFunction(args[0])) {\n                success = args[0];\n            } else if (/^(POST|PUT|PATCH)$/i.test(options.method)) {\n                data = args[0];\n            } else {\n                params = args[0];\n            }\n\n            break;\n\n        case 0:\n\n            break;\n\n        default:\n\n            throw 'Expected up to 4 arguments [params, data, success, error], got ' + args.length + ' arguments';\n    }\n\n    options.data = data;\n    options.params = _.extend({}, options.params, params);\n\n    if (success) {\n        options.success = success;\n    }\n\n    if (error) {\n        options.error = error;\n    }\n\n    return options;\n}\n\nResource.actions = {\n\n    get: {method: 'GET'},\n    save: {method: 'POST'},\n    query: {method: 'GET'},\n    update: {method: 'PUT'},\n    remove: {method: 'DELETE'},\n    delete: {method: 'DELETE'}\n\n};\n\nmodule.exports = _.resource = Resource;\n\n},{\"./util\":71}],66:[function(require,module,exports){\n/**\n * Service for URL templating.\n */\n\nvar _ = require('../util');\nvar ie = document.documentMode;\nvar el = document.createElement('a');\n\nfunction Url(url, params) {\n\n    var options = url, transform;\n\n    if (_.isString(url)) {\n        options = {url: url, params: params};\n    }\n\n    options = _.merge({}, Url.options, this.$options, options);\n\n    Url.transforms.forEach(function (handler) {\n        transform = factory(handler, transform, this.$vm);\n    }, this);\n\n    return transform(options);\n};\n\n/**\n * Url options.\n */\n\nUrl.options = {\n    url: '',\n    root: null,\n    params: {}\n};\n\n/**\n * Url transforms.\n */\n\nUrl.transforms = [\n    require('./template'),\n    require('./legacy'),\n    require('./query'),\n    require('./root')\n];\n\n/**\n * Encodes a Url parameter string.\n *\n * @param {Object} obj\n */\n\nUrl.params = function (obj) {\n\n    var params = [], escape = encodeURIComponent;\n\n    params.add = function (key, value) {\n\n        if (_.isFunction(value)) {\n            value = value();\n        }\n\n        if (value === null) {\n            value = '';\n        }\n\n        this.push(escape(key) + '=' + escape(value));\n    };\n\n    serialize(params, obj);\n\n    return params.join('&').replace(/%20/g, '+');\n};\n\n/**\n * Parse a URL and return its components.\n *\n * @param {String} url\n */\n\nUrl.parse = function (url) {\n\n    if (ie) {\n        el.href = url;\n        url = el.href;\n    }\n\n    el.href = url;\n\n    return {\n        href: el.href,\n        protocol: el.protocol ? el.protocol.replace(/:$/, '') : '',\n        port: el.port,\n        host: el.host,\n        hostname: el.hostname,\n        pathname: el.pathname.charAt(0) === '/' ? el.pathname : '/' + el.pathname,\n        search: el.search ? el.search.replace(/^\\?/, '') : '',\n        hash: el.hash ? el.hash.replace(/^#/, '') : ''\n    };\n};\n\nfunction factory(handler, next, vm) {\n    return function (options) {\n        return handler.call(vm, options, next);\n    };\n}\n\nfunction serialize(params, obj, scope) {\n\n    var array = _.isArray(obj), plain = _.isPlainObject(obj), hash;\n\n    _.each(obj, function (value, key) {\n\n        hash = _.isObject(value) || _.isArray(value);\n\n        if (scope) {\n            key = scope + '[' + (plain || hash ? key : '') + ']';\n        }\n\n        if (!scope && array) {\n            params.add(value.name, value.value);\n        } else if (hash) {\n            serialize(params, value, key);\n        } else {\n            params.add(key, value);\n        }\n    });\n}\n\nmodule.exports = _.url = Url;\n\n},{\"../util\":71,\"./legacy\":67,\"./query\":68,\"./root\":69,\"./template\":70}],67:[function(require,module,exports){\n/**\n * Legacy Transform.\n */\n\nvar _ = require('../util');\n\nmodule.exports = function (options, next) {\n\n    var variables = [], url = next(options);\n\n    url = url.replace(/(\\/?):([a-z]\\w*)/gi, function (match, slash, name) {\n\n        _.warn('The `:' + name + '` parameter syntax has been deprecated. Use the `{' + name + '}` syntax instead.');\n\n        if (options.params[name]) {\n            variables.push(name);\n            return slash + encodeUriSegment(options.params[name]);\n        }\n\n        return '';\n    });\n\n    variables.forEach(function (key) {\n        delete options.params[key];\n    });\n\n    return url;\n};\n\nfunction encodeUriSegment(value) {\n\n    return encodeUriQuery(value, true).\n        replace(/%26/gi, '&').\n        replace(/%3D/gi, '=').\n        replace(/%2B/gi, '+');\n}\n\nfunction encodeUriQuery(value, spaces) {\n\n    return encodeURIComponent(value).\n        replace(/%40/gi, '@').\n        replace(/%3A/gi, ':').\n        replace(/%24/g, '$').\n        replace(/%2C/gi, ',').\n        replace(/%20/g, (spaces ? '%20' : '+'));\n}\n\n},{\"../util\":71}],68:[function(require,module,exports){\n/**\n * Query Parameter Transform.\n */\n\nvar _ = require('../util');\n\nmodule.exports = function (options, next) {\n\n    var urlParams = Object.keys(_.url.options.params), query = {}, url = next(options);\n\n   _.each(options.params, function (value, key) {\n        if (urlParams.indexOf(key) === -1) {\n            query[key] = value;\n        }\n    });\n\n    query = _.url.params(query);\n\n    if (query) {\n        url += (url.indexOf('?') == -1 ? '?' : '&') + query;\n    }\n\n    return url;\n};\n\n},{\"../util\":71}],69:[function(require,module,exports){\n/**\n * Root Prefix Transform.\n */\n\nvar _ = require('../util');\n\nmodule.exports = function (options, next) {\n\n    var url = next(options);\n\n    if (_.isString(options.root) && !url.match(/^(https?:)?\\//)) {\n        url = options.root + '/' + url;\n    }\n\n    return url;\n};\n\n},{\"../util\":71}],70:[function(require,module,exports){\n/**\n * URL Template (RFC 6570) Transform.\n */\n\nvar UrlTemplate = require('../lib/url-template');\n\nmodule.exports = function (options) {\n\n    var variables = [], url = UrlTemplate.expand(options.url, options.params, variables);\n\n    variables.forEach(function (key) {\n        delete options.params[key];\n    });\n\n    return url;\n};\n\n},{\"../lib/url-template\":63}],71:[function(require,module,exports){\n/**\n * Utility functions.\n */\n\nvar _ = exports, array = [], console = window.console;\n\n_.warn = function (msg) {\n    if (console && _.warning && (!_.config.silent || _.config.debug)) {\n        console.warn('[VueResource warn]: ' + msg);\n    }\n};\n\n_.error = function (msg) {\n    if (console) {\n        console.error(msg);\n    }\n};\n\n_.trim = function (str) {\n    return str.replace(/^\\s*|\\s*$/g, '');\n};\n\n_.toLower = function (str) {\n    return str ? str.toLowerCase() : '';\n};\n\n_.isArray = Array.isArray;\n\n_.isString = function (val) {\n    return typeof val === 'string';\n};\n\n_.isFunction = function (val) {\n    return typeof val === 'function';\n};\n\n_.isObject = function (obj) {\n    return obj !== null && typeof obj === 'object';\n};\n\n_.isPlainObject = function (obj) {\n    return _.isObject(obj) && Object.getPrototypeOf(obj) == Object.prototype;\n};\n\n_.options = function (fn, obj, options) {\n\n    options = options || {};\n\n    if (_.isFunction(options)) {\n        options = options.call(obj);\n    }\n\n    return _.merge(fn.bind({$vm: obj, $options: options}), fn, {$options: options});\n};\n\n_.each = function (obj, iterator) {\n\n    var i, key;\n\n    if (typeof obj.length == 'number') {\n        for (i = 0; i < obj.length; i++) {\n            iterator.call(obj[i], obj[i], i);\n        }\n    } else if (_.isObject(obj)) {\n        for (key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                iterator.call(obj[key], obj[key], key);\n            }\n        }\n    }\n\n    return obj;\n};\n\n_.defaults = function (target, source) {\n\n    for (var key in source) {\n        if (target[key] === undefined) {\n            target[key] = source[key];\n        }\n    }\n\n    return target;\n};\n\n_.extend = function (target) {\n\n    var args = array.slice.call(arguments, 1);\n\n    args.forEach(function (arg) {\n        merge(target, arg);\n    });\n\n    return target;\n};\n\n_.merge = function (target) {\n\n    var args = array.slice.call(arguments, 1);\n\n    args.forEach(function (arg) {\n        merge(target, arg, true);\n    });\n\n    return target;\n};\n\nfunction merge(target, source, deep) {\n    for (var key in source) {\n        if (deep && (_.isPlainObject(source[key]) || _.isArray(source[key]))) {\n            if (_.isPlainObject(source[key]) && !_.isPlainObject(target[key])) {\n                target[key] = {};\n            }\n            if (_.isArray(source[key]) && !_.isArray(target[key])) {\n                target[key] = [];\n            }\n            merge(target[key], source[key], deep);\n        } else if (source[key] !== undefined) {\n            target[key] = source[key];\n        }\n    }\n}\n\n},{}],72:[function(require,module,exports){\n/*!\n * vue-router v0.7.13\n * (c) 2016 Evan You\n * Released under the MIT License.\n */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  global.VueRouter = factory();\n}(this, function () { 'use strict';\n\n  var babelHelpers = {};\n\n  babelHelpers.classCallCheck = function (instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  };\n  function Target(path, matcher, delegate) {\n    this.path = path;\n    this.matcher = matcher;\n    this.delegate = delegate;\n  }\n\n  Target.prototype = {\n    to: function to(target, callback) {\n      var delegate = this.delegate;\n\n      if (delegate && delegate.willAddRoute) {\n        target = delegate.willAddRoute(this.matcher.target, target);\n      }\n\n      this.matcher.add(this.path, target);\n\n      if (callback) {\n        if (callback.length === 0) {\n          throw new Error(\"You must have an argument in the function passed to `to`\");\n        }\n        this.matcher.addChild(this.path, target, callback, this.delegate);\n      }\n      return this;\n    }\n  };\n\n  function Matcher(target) {\n    this.routes = {};\n    this.children = {};\n    this.target = target;\n  }\n\n  Matcher.prototype = {\n    add: function add(path, handler) {\n      this.routes[path] = handler;\n    },\n\n    addChild: function addChild(path, target, callback, delegate) {\n      var matcher = new Matcher(target);\n      this.children[path] = matcher;\n\n      var match = generateMatch(path, matcher, delegate);\n\n      if (delegate && delegate.contextEntered) {\n        delegate.contextEntered(target, match);\n      }\n\n      callback(match);\n    }\n  };\n\n  function generateMatch(startingPath, matcher, delegate) {\n    return function (path, nestedCallback) {\n      var fullPath = startingPath + path;\n\n      if (nestedCallback) {\n        nestedCallback(generateMatch(fullPath, matcher, delegate));\n      } else {\n        return new Target(startingPath + path, matcher, delegate);\n      }\n    };\n  }\n\n  function addRoute(routeArray, path, handler) {\n    var len = 0;\n    for (var i = 0, l = routeArray.length; i < l; i++) {\n      len += routeArray[i].path.length;\n    }\n\n    path = path.substr(len);\n    var route = { path: path, handler: handler };\n    routeArray.push(route);\n  }\n\n  function eachRoute(baseRoute, matcher, callback, binding) {\n    var routes = matcher.routes;\n\n    for (var path in routes) {\n      if (routes.hasOwnProperty(path)) {\n        var routeArray = baseRoute.slice();\n        addRoute(routeArray, path, routes[path]);\n\n        if (matcher.children[path]) {\n          eachRoute(routeArray, matcher.children[path], callback, binding);\n        } else {\n          callback.call(binding, routeArray);\n        }\n      }\n    }\n  }\n\n  function map (callback, addRouteCallback) {\n    var matcher = new Matcher();\n\n    callback(generateMatch(\"\", matcher, this.delegate));\n\n    eachRoute([], matcher, function (route) {\n      if (addRouteCallback) {\n        addRouteCallback(this, route);\n      } else {\n        this.add(route);\n      }\n    }, this);\n  }\n\n  var specials = ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\\\'];\n\n  var escapeRegex = new RegExp('(\\\\' + specials.join('|\\\\') + ')', 'g');\n\n  var noWarning = false;\n  function warn(msg) {\n    if (!noWarning && typeof console !== 'undefined') {\n      console.error('[vue-router] ' + msg);\n    }\n  }\n\n  function tryDecode(uri, asComponent) {\n    try {\n      return asComponent ? decodeURIComponent(uri) : decodeURI(uri);\n    } catch (e) {\n      warn('malformed URI' + (asComponent ? ' component: ' : ': ') + uri);\n    }\n  }\n\n  function isArray(test) {\n    return Object.prototype.toString.call(test) === \"[object Array]\";\n  }\n\n  // A Segment represents a segment in the original route description.\n  // Each Segment type provides an `eachChar` and `regex` method.\n  //\n  // The `eachChar` method invokes the callback with one or more character\n  // specifications. A character specification consumes one or more input\n  // characters.\n  //\n  // The `regex` method returns a regex fragment for the segment. If the\n  // segment is a dynamic of star segment, the regex fragment also includes\n  // a capture.\n  //\n  // A character specification contains:\n  //\n  // * `validChars`: a String with a list of all valid characters, or\n  // * `invalidChars`: a String with a list of all invalid characters\n  // * `repeat`: true if the character specification can repeat\n\n  function StaticSegment(string) {\n    this.string = string;\n  }\n  StaticSegment.prototype = {\n    eachChar: function eachChar(callback) {\n      var string = this.string,\n          ch;\n\n      for (var i = 0, l = string.length; i < l; i++) {\n        ch = string.charAt(i);\n        callback({ validChars: ch });\n      }\n    },\n\n    regex: function regex() {\n      return this.string.replace(escapeRegex, '\\\\$1');\n    },\n\n    generate: function generate() {\n      return this.string;\n    }\n  };\n\n  function DynamicSegment(name) {\n    this.name = name;\n  }\n  DynamicSegment.prototype = {\n    eachChar: function eachChar(callback) {\n      callback({ invalidChars: \"/\", repeat: true });\n    },\n\n    regex: function regex() {\n      return \"([^/]+)\";\n    },\n\n    generate: function generate(params) {\n      var val = params[this.name];\n      return val == null ? \":\" + this.name : val;\n    }\n  };\n\n  function StarSegment(name) {\n    this.name = name;\n  }\n  StarSegment.prototype = {\n    eachChar: function eachChar(callback) {\n      callback({ invalidChars: \"\", repeat: true });\n    },\n\n    regex: function regex() {\n      return \"(.+)\";\n    },\n\n    generate: function generate(params) {\n      var val = params[this.name];\n      return val == null ? \":\" + this.name : val;\n    }\n  };\n\n  function EpsilonSegment() {}\n  EpsilonSegment.prototype = {\n    eachChar: function eachChar() {},\n    regex: function regex() {\n      return \"\";\n    },\n    generate: function generate() {\n      return \"\";\n    }\n  };\n\n  function parse(route, names, specificity) {\n    // normalize route as not starting with a \"/\". Recognition will\n    // also normalize.\n    if (route.charAt(0) === \"/\") {\n      route = route.substr(1);\n    }\n\n    var segments = route.split(\"/\"),\n        results = [];\n\n    // A routes has specificity determined by the order that its different segments\n    // appear in. This system mirrors how the magnitude of numbers written as strings\n    // works.\n    // Consider a number written as: \"abc\". An example would be \"200\". Any other number written\n    // \"xyz\" will be smaller than \"abc\" so long as `a > z`. For instance, \"199\" is smaller\n    // then \"200\", even though \"y\" and \"z\" (which are both 9) are larger than \"0\" (the value\n    // of (`b` and `c`). This is because the leading symbol, \"2\", is larger than the other\n    // leading symbol, \"1\".\n    // The rule is that symbols to the left carry more weight than symbols to the right\n    // when a number is written out as a string. In the above strings, the leading digit\n    // represents how many 100's are in the number, and it carries more weight than the middle\n    // number which represents how many 10's are in the number.\n    // This system of number magnitude works well for route specificity, too. A route written as\n    // `a/b/c` will be more specific than `x/y/z` as long as `a` is more specific than\n    // `x`, irrespective of the other parts.\n    // Because of this similarity, we assign each type of segment a number value written as a\n    // string. We can find the specificity of compound routes by concatenating these strings\n    // together, from left to right. After we have looped through all of the segments,\n    // we convert the string to a number.\n    specificity.val = '';\n\n    for (var i = 0, l = segments.length; i < l; i++) {\n      var segment = segments[i],\n          match;\n\n      if (match = segment.match(/^:([^\\/]+)$/)) {\n        results.push(new DynamicSegment(match[1]));\n        names.push(match[1]);\n        specificity.val += '3';\n      } else if (match = segment.match(/^\\*([^\\/]+)$/)) {\n        results.push(new StarSegment(match[1]));\n        specificity.val += '2';\n        names.push(match[1]);\n      } else if (segment === \"\") {\n        results.push(new EpsilonSegment());\n        specificity.val += '1';\n      } else {\n        results.push(new StaticSegment(segment));\n        specificity.val += '4';\n      }\n    }\n\n    specificity.val = +specificity.val;\n\n    return results;\n  }\n\n  // A State has a character specification and (`charSpec`) and a list of possible\n  // subsequent states (`nextStates`).\n  //\n  // If a State is an accepting state, it will also have several additional\n  // properties:\n  //\n  // * `regex`: A regular expression that is used to extract parameters from paths\n  //   that reached this accepting state.\n  // * `handlers`: Information on how to convert the list of captures into calls\n  //   to registered handlers with the specified parameters\n  // * `types`: How many static, dynamic or star segments in this route. Used to\n  //   decide which route to use if multiple registered routes match a path.\n  //\n  // Currently, State is implemented naively by looping over `nextStates` and\n  // comparing a character specification against a character. A more efficient\n  // implementation would use a hash of keys pointing at one or more next states.\n\n  function State(charSpec) {\n    this.charSpec = charSpec;\n    this.nextStates = [];\n  }\n\n  State.prototype = {\n    get: function get(charSpec) {\n      var nextStates = this.nextStates;\n\n      for (var i = 0, l = nextStates.length; i < l; i++) {\n        var child = nextStates[i];\n\n        var isEqual = child.charSpec.validChars === charSpec.validChars;\n        isEqual = isEqual && child.charSpec.invalidChars === charSpec.invalidChars;\n\n        if (isEqual) {\n          return child;\n        }\n      }\n    },\n\n    put: function put(charSpec) {\n      var state;\n\n      // If the character specification already exists in a child of the current\n      // state, just return that state.\n      if (state = this.get(charSpec)) {\n        return state;\n      }\n\n      // Make a new state for the character spec\n      state = new State(charSpec);\n\n      // Insert the new state as a child of the current state\n      this.nextStates.push(state);\n\n      // If this character specification repeats, insert the new state as a child\n      // of itself. Note that this will not trigger an infinite loop because each\n      // transition during recognition consumes a character.\n      if (charSpec.repeat) {\n        state.nextStates.push(state);\n      }\n\n      // Return the new state\n      return state;\n    },\n\n    // Find a list of child states matching the next character\n    match: function match(ch) {\n      // DEBUG \"Processing `\" + ch + \"`:\"\n      var nextStates = this.nextStates,\n          child,\n          charSpec,\n          chars;\n\n      // DEBUG \"  \" + debugState(this)\n      var returned = [];\n\n      for (var i = 0, l = nextStates.length; i < l; i++) {\n        child = nextStates[i];\n\n        charSpec = child.charSpec;\n\n        if (typeof (chars = charSpec.validChars) !== 'undefined') {\n          if (chars.indexOf(ch) !== -1) {\n            returned.push(child);\n          }\n        } else if (typeof (chars = charSpec.invalidChars) !== 'undefined') {\n          if (chars.indexOf(ch) === -1) {\n            returned.push(child);\n          }\n        }\n      }\n\n      return returned;\n    }\n\n    /** IF DEBUG\n    , debug: function() {\n      var charSpec = this.charSpec,\n          debug = \"[\",\n          chars = charSpec.validChars || charSpec.invalidChars;\n       if (charSpec.invalidChars) { debug += \"^\"; }\n      debug += chars;\n      debug += \"]\";\n       if (charSpec.repeat) { debug += \"+\"; }\n       return debug;\n    }\n    END IF **/\n  };\n\n  /** IF DEBUG\n  function debug(log) {\n    console.log(log);\n  }\n\n  function debugState(state) {\n    return state.nextStates.map(function(n) {\n      if (n.nextStates.length === 0) { return \"( \" + n.debug() + \" [accepting] )\"; }\n      return \"( \" + n.debug() + \" <then> \" + n.nextStates.map(function(s) { return s.debug() }).join(\" or \") + \" )\";\n    }).join(\", \")\n  }\n  END IF **/\n\n  // Sort the routes by specificity\n  function sortSolutions(states) {\n    return states.sort(function (a, b) {\n      return b.specificity.val - a.specificity.val;\n    });\n  }\n\n  function recognizeChar(states, ch) {\n    var nextStates = [];\n\n    for (var i = 0, l = states.length; i < l; i++) {\n      var state = states[i];\n\n      nextStates = nextStates.concat(state.match(ch));\n    }\n\n    return nextStates;\n  }\n\n  var oCreate = Object.create || function (proto) {\n    function F() {}\n    F.prototype = proto;\n    return new F();\n  };\n\n  function RecognizeResults(queryParams) {\n    this.queryParams = queryParams || {};\n  }\n  RecognizeResults.prototype = oCreate({\n    splice: Array.prototype.splice,\n    slice: Array.prototype.slice,\n    push: Array.prototype.push,\n    length: 0,\n    queryParams: null\n  });\n\n  function findHandler(state, path, queryParams) {\n    var handlers = state.handlers,\n        regex = state.regex;\n    var captures = path.match(regex),\n        currentCapture = 1;\n    var result = new RecognizeResults(queryParams);\n\n    for (var i = 0, l = handlers.length; i < l; i++) {\n      var handler = handlers[i],\n          names = handler.names,\n          params = {};\n\n      for (var j = 0, m = names.length; j < m; j++) {\n        params[names[j]] = captures[currentCapture++];\n      }\n\n      result.push({ handler: handler.handler, params: params, isDynamic: !!names.length });\n    }\n\n    return result;\n  }\n\n  function addSegment(currentState, segment) {\n    segment.eachChar(function (ch) {\n      var state;\n\n      currentState = currentState.put(ch);\n    });\n\n    return currentState;\n  }\n\n  function decodeQueryParamPart(part) {\n    // http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.1\n    part = part.replace(/\\+/gm, '%20');\n    return tryDecode(part, true);\n  }\n\n  // The main interface\n\n  var RouteRecognizer = function RouteRecognizer() {\n    this.rootState = new State();\n    this.names = {};\n  };\n\n  RouteRecognizer.prototype = {\n    add: function add(routes, options) {\n      var currentState = this.rootState,\n          regex = \"^\",\n          specificity = {},\n          handlers = [],\n          allSegments = [],\n          name;\n\n      var isEmpty = true;\n\n      for (var i = 0, l = routes.length; i < l; i++) {\n        var route = routes[i],\n            names = [];\n\n        var segments = parse(route.path, names, specificity);\n\n        allSegments = allSegments.concat(segments);\n\n        for (var j = 0, m = segments.length; j < m; j++) {\n          var segment = segments[j];\n\n          if (segment instanceof EpsilonSegment) {\n            continue;\n          }\n\n          isEmpty = false;\n\n          // Add a \"/\" for the new segment\n          currentState = currentState.put({ validChars: \"/\" });\n          regex += \"/\";\n\n          // Add a representation of the segment to the NFA and regex\n          currentState = addSegment(currentState, segment);\n          regex += segment.regex();\n        }\n\n        var handler = { handler: route.handler, names: names };\n        handlers.push(handler);\n      }\n\n      if (isEmpty) {\n        currentState = currentState.put({ validChars: \"/\" });\n        regex += \"/\";\n      }\n\n      currentState.handlers = handlers;\n      currentState.regex = new RegExp(regex + \"$\");\n      currentState.specificity = specificity;\n\n      if (name = options && options.as) {\n        this.names[name] = {\n          segments: allSegments,\n          handlers: handlers\n        };\n      }\n    },\n\n    handlersFor: function handlersFor(name) {\n      var route = this.names[name],\n          result = [];\n      if (!route) {\n        throw new Error(\"There is no route named \" + name);\n      }\n\n      for (var i = 0, l = route.handlers.length; i < l; i++) {\n        result.push(route.handlers[i]);\n      }\n\n      return result;\n    },\n\n    hasRoute: function hasRoute(name) {\n      return !!this.names[name];\n    },\n\n    generate: function generate(name, params) {\n      var route = this.names[name],\n          output = \"\";\n      if (!route) {\n        throw new Error(\"There is no route named \" + name);\n      }\n\n      var segments = route.segments;\n\n      for (var i = 0, l = segments.length; i < l; i++) {\n        var segment = segments[i];\n\n        if (segment instanceof EpsilonSegment) {\n          continue;\n        }\n\n        output += \"/\";\n        output += segment.generate(params);\n      }\n\n      if (output.charAt(0) !== '/') {\n        output = '/' + output;\n      }\n\n      if (params && params.queryParams) {\n        output += this.generateQueryString(params.queryParams);\n      }\n\n      return output;\n    },\n\n    generateQueryString: function generateQueryString(params) {\n      var pairs = [];\n      var keys = [];\n      for (var key in params) {\n        if (params.hasOwnProperty(key)) {\n          keys.push(key);\n        }\n      }\n      keys.sort();\n      for (var i = 0, len = keys.length; i < len; i++) {\n        key = keys[i];\n        var value = params[key];\n        if (value == null) {\n          continue;\n        }\n        var pair = encodeURIComponent(key);\n        if (isArray(value)) {\n          for (var j = 0, l = value.length; j < l; j++) {\n            var arrayPair = key + '[]' + '=' + encodeURIComponent(value[j]);\n            pairs.push(arrayPair);\n          }\n        } else {\n          pair += \"=\" + encodeURIComponent(value);\n          pairs.push(pair);\n        }\n      }\n\n      if (pairs.length === 0) {\n        return '';\n      }\n\n      return \"?\" + pairs.join(\"&\");\n    },\n\n    parseQueryString: function parseQueryString(queryString) {\n      var pairs = queryString.split(\"&\"),\n          queryParams = {};\n      for (var i = 0; i < pairs.length; i++) {\n        var pair = pairs[i].split('='),\n            key = decodeQueryParamPart(pair[0]),\n            keyLength = key.length,\n            isArray = false,\n            value;\n        if (pair.length === 1) {\n          value = 'true';\n        } else {\n          //Handle arrays\n          if (keyLength > 2 && key.slice(keyLength - 2) === '[]') {\n            isArray = true;\n            key = key.slice(0, keyLength - 2);\n            if (!queryParams[key]) {\n              queryParams[key] = [];\n            }\n          }\n          value = pair[1] ? decodeQueryParamPart(pair[1]) : '';\n        }\n        if (isArray) {\n          queryParams[key].push(value);\n        } else {\n          queryParams[key] = value;\n        }\n      }\n      return queryParams;\n    },\n\n    recognize: function recognize(path, silent) {\n      noWarning = silent;\n      var states = [this.rootState],\n          pathLen,\n          i,\n          l,\n          queryStart,\n          queryParams = {},\n          isSlashDropped = false;\n\n      queryStart = path.indexOf('?');\n      if (queryStart !== -1) {\n        var queryString = path.substr(queryStart + 1, path.length);\n        path = path.substr(0, queryStart);\n        if (queryString) {\n          queryParams = this.parseQueryString(queryString);\n        }\n      }\n\n      path = tryDecode(path);\n      if (!path) return;\n\n      // DEBUG GROUP path\n\n      if (path.charAt(0) !== \"/\") {\n        path = \"/\" + path;\n      }\n\n      pathLen = path.length;\n      if (pathLen > 1 && path.charAt(pathLen - 1) === \"/\") {\n        path = path.substr(0, pathLen - 1);\n        isSlashDropped = true;\n      }\n\n      for (i = 0, l = path.length; i < l; i++) {\n        states = recognizeChar(states, path.charAt(i));\n        if (!states.length) {\n          break;\n        }\n      }\n\n      // END DEBUG GROUP\n\n      var solutions = [];\n      for (i = 0, l = states.length; i < l; i++) {\n        if (states[i].handlers) {\n          solutions.push(states[i]);\n        }\n      }\n\n      states = sortSolutions(solutions);\n\n      var state = solutions[0];\n\n      if (state && state.handlers) {\n        // if a trailing slash was dropped and a star segment is the last segment\n        // specified, put the trailing slash back\n        if (isSlashDropped && state.regex.source.slice(-5) === \"(.+)$\") {\n          path = path + \"/\";\n        }\n        return findHandler(state, path, queryParams);\n      }\n    }\n  };\n\n  RouteRecognizer.prototype.map = map;\n\n  var genQuery = RouteRecognizer.prototype.generateQueryString;\n\n  // export default for holding the Vue reference\n  var exports$1 = {};\n  /**\n   * Warn stuff.\n   *\n   * @param {String} msg\n   */\n\n  function warn$1(msg) {\n    /* istanbul ignore next */\n    if (typeof console !== 'undefined') {\n      console.error('[vue-router] ' + msg);\n    }\n  }\n\n  /**\n   * Resolve a relative path.\n   *\n   * @param {String} base\n   * @param {String} relative\n   * @param {Boolean} append\n   * @return {String}\n   */\n\n  function resolvePath(base, relative, append) {\n    var query = base.match(/(\\?.*)$/);\n    if (query) {\n      query = query[1];\n      base = base.slice(0, -query.length);\n    }\n    // a query!\n    if (relative.charAt(0) === '?') {\n      return base + relative;\n    }\n    var stack = base.split('/');\n    // remove trailing segment if:\n    // - not appending\n    // - appending to trailing slash (last segment is empty)\n    if (!append || !stack[stack.length - 1]) {\n      stack.pop();\n    }\n    // resolve relative path\n    var segments = relative.replace(/^\\//, '').split('/');\n    for (var i = 0; i < segments.length; i++) {\n      var segment = segments[i];\n      if (segment === '.') {\n        continue;\n      } else if (segment === '..') {\n        stack.pop();\n      } else {\n        stack.push(segment);\n      }\n    }\n    // ensure leading slash\n    if (stack[0] !== '') {\n      stack.unshift('');\n    }\n    return stack.join('/');\n  }\n\n  /**\n   * Forgiving check for a promise\n   *\n   * @param {Object} p\n   * @return {Boolean}\n   */\n\n  function isPromise(p) {\n    return p && typeof p.then === 'function';\n  }\n\n  /**\n   * Retrive a route config field from a component instance\n   * OR a component contructor.\n   *\n   * @param {Function|Vue} component\n   * @param {String} name\n   * @return {*}\n   */\n\n  function getRouteConfig(component, name) {\n    var options = component && (component.$options || component.options);\n    return options && options.route && options.route[name];\n  }\n\n  /**\n   * Resolve an async component factory. Have to do a dirty\n   * mock here because of Vue core's internal API depends on\n   * an ID check.\n   *\n   * @param {Object} handler\n   * @param {Function} cb\n   */\n\n  var resolver = undefined;\n\n  function resolveAsyncComponent(handler, cb) {\n    if (!resolver) {\n      resolver = {\n        resolve: exports$1.Vue.prototype._resolveComponent,\n        $options: {\n          components: {\n            _: handler.component\n          }\n        }\n      };\n    } else {\n      resolver.$options.components._ = handler.component;\n    }\n    resolver.resolve('_', function (Component) {\n      handler.component = Component;\n      cb(Component);\n    });\n  }\n\n  /**\n   * Map the dynamic segments in a path to params.\n   *\n   * @param {String} path\n   * @param {Object} params\n   * @param {Object} query\n   */\n\n  function mapParams(path, params, query) {\n    if (params === undefined) params = {};\n\n    path = path.replace(/:([^\\/]+)/g, function (_, key) {\n      var val = params[key];\n      /* istanbul ignore if */\n      if (!val) {\n        warn$1('param \"' + key + '\" not found when generating ' + 'path for \"' + path + '\" with params ' + JSON.stringify(params));\n      }\n      return val || '';\n    });\n    if (query) {\n      path += genQuery(query);\n    }\n    return path;\n  }\n\n  var hashRE = /#.*$/;\n\n  var HTML5History = (function () {\n    function HTML5History(_ref) {\n      var root = _ref.root;\n      var onChange = _ref.onChange;\n      babelHelpers.classCallCheck(this, HTML5History);\n\n      if (root && root !== '/') {\n        // make sure there's the starting slash\n        if (root.charAt(0) !== '/') {\n          root = '/' + root;\n        }\n        // remove trailing slash\n        this.root = root.replace(/\\/$/, '');\n        this.rootRE = new RegExp('^\\\\' + this.root);\n      } else {\n        this.root = null;\n      }\n      this.onChange = onChange;\n      // check base tag\n      var baseEl = document.querySelector('base');\n      this.base = baseEl && baseEl.getAttribute('href');\n    }\n\n    HTML5History.prototype.start = function start() {\n      var _this = this;\n\n      this.listener = function (e) {\n        var url = location.pathname + location.search;\n        if (_this.root) {\n          url = url.replace(_this.rootRE, '');\n        }\n        _this.onChange(url, e && e.state, location.hash);\n      };\n      window.addEventListener('popstate', this.listener);\n      this.listener();\n    };\n\n    HTML5History.prototype.stop = function stop() {\n      window.removeEventListener('popstate', this.listener);\n    };\n\n    HTML5History.prototype.go = function go(path, replace, append) {\n      var url = this.formatPath(path, append);\n      if (replace) {\n        history.replaceState({}, '', url);\n      } else {\n        // record scroll position by replacing current state\n        history.replaceState({\n          pos: {\n            x: window.pageXOffset,\n            y: window.pageYOffset\n          }\n        }, '', location.href);\n        // then push new state\n        history.pushState({}, '', url);\n      }\n      var hashMatch = path.match(hashRE);\n      var hash = hashMatch && hashMatch[0];\n      path = url\n      // strip hash so it doesn't mess up params\n      .replace(hashRE, '')\n      // remove root before matching\n      .replace(this.rootRE, '');\n      this.onChange(path, null, hash);\n    };\n\n    HTML5History.prototype.formatPath = function formatPath(path, append) {\n      return path.charAt(0) === '/'\n      // absolute path\n      ? this.root ? this.root + '/' + path.replace(/^\\//, '') : path : resolvePath(this.base || location.pathname, path, append);\n    };\n\n    return HTML5History;\n  })();\n\n  var HashHistory = (function () {\n    function HashHistory(_ref) {\n      var hashbang = _ref.hashbang;\n      var onChange = _ref.onChange;\n      babelHelpers.classCallCheck(this, HashHistory);\n\n      this.hashbang = hashbang;\n      this.onChange = onChange;\n    }\n\n    HashHistory.prototype.start = function start() {\n      var self = this;\n      this.listener = function () {\n        var path = location.hash;\n        var raw = path.replace(/^#!?/, '');\n        // always\n        if (raw.charAt(0) !== '/') {\n          raw = '/' + raw;\n        }\n        var formattedPath = self.formatPath(raw);\n        if (formattedPath !== path) {\n          location.replace(formattedPath);\n          return;\n        }\n        // determine query\n        // note it's possible to have queries in both the actual URL\n        // and the hash fragment itself.\n        var query = location.search && path.indexOf('?') > -1 ? '&' + location.search.slice(1) : location.search;\n        self.onChange(path.replace(/^#!?/, '') + query);\n      };\n      window.addEventListener('hashchange', this.listener);\n      this.listener();\n    };\n\n    HashHistory.prototype.stop = function stop() {\n      window.removeEventListener('hashchange', this.listener);\n    };\n\n    HashHistory.prototype.go = function go(path, replace, append) {\n      path = this.formatPath(path, append);\n      if (replace) {\n        location.replace(path);\n      } else {\n        location.hash = path;\n      }\n    };\n\n    HashHistory.prototype.formatPath = function formatPath(path, append) {\n      var isAbsoloute = path.charAt(0) === '/';\n      var prefix = '#' + (this.hashbang ? '!' : '');\n      return isAbsoloute ? prefix + path : prefix + resolvePath(location.hash.replace(/^#!?/, ''), path, append);\n    };\n\n    return HashHistory;\n  })();\n\n  var AbstractHistory = (function () {\n    function AbstractHistory(_ref) {\n      var onChange = _ref.onChange;\n      babelHelpers.classCallCheck(this, AbstractHistory);\n\n      this.onChange = onChange;\n      this.currentPath = '/';\n    }\n\n    AbstractHistory.prototype.start = function start() {\n      this.onChange('/');\n    };\n\n    AbstractHistory.prototype.stop = function stop() {\n      // noop\n    };\n\n    AbstractHistory.prototype.go = function go(path, replace, append) {\n      path = this.currentPath = this.formatPath(path, append);\n      this.onChange(path);\n    };\n\n    AbstractHistory.prototype.formatPath = function formatPath(path, append) {\n      return path.charAt(0) === '/' ? path : resolvePath(this.currentPath, path, append);\n    };\n\n    return AbstractHistory;\n  })();\n\n  /**\n   * Determine the reusability of an existing router view.\n   *\n   * @param {Directive} view\n   * @param {Object} handler\n   * @param {Transition} transition\n   */\n\n  function canReuse(view, handler, transition) {\n    var component = view.childVM;\n    if (!component || !handler) {\n      return false;\n    }\n    // important: check view.Component here because it may\n    // have been changed in activate hook\n    if (view.Component !== handler.component) {\n      return false;\n    }\n    var canReuseFn = getRouteConfig(component, 'canReuse');\n    return typeof canReuseFn === 'boolean' ? canReuseFn : canReuseFn ? canReuseFn.call(component, {\n      to: transition.to,\n      from: transition.from\n    }) : true; // defaults to true\n  }\n\n  /**\n   * Check if a component can deactivate.\n   *\n   * @param {Directive} view\n   * @param {Transition} transition\n   * @param {Function} next\n   */\n\n  function canDeactivate(view, transition, next) {\n    var fromComponent = view.childVM;\n    var hook = getRouteConfig(fromComponent, 'canDeactivate');\n    if (!hook) {\n      next();\n    } else {\n      transition.callHook(hook, fromComponent, next, {\n        expectBoolean: true\n      });\n    }\n  }\n\n  /**\n   * Check if a component can activate.\n   *\n   * @param {Object} handler\n   * @param {Transition} transition\n   * @param {Function} next\n   */\n\n  function canActivate(handler, transition, next) {\n    resolveAsyncComponent(handler, function (Component) {\n      // have to check due to async-ness\n      if (transition.aborted) {\n        return;\n      }\n      // determine if this component can be activated\n      var hook = getRouteConfig(Component, 'canActivate');\n      if (!hook) {\n        next();\n      } else {\n        transition.callHook(hook, null, next, {\n          expectBoolean: true\n        });\n      }\n    });\n  }\n\n  /**\n   * Call deactivate hooks for existing router-views.\n   *\n   * @param {Directive} view\n   * @param {Transition} transition\n   * @param {Function} next\n   */\n\n  function deactivate(view, transition, next) {\n    var component = view.childVM;\n    var hook = getRouteConfig(component, 'deactivate');\n    if (!hook) {\n      next();\n    } else {\n      transition.callHooks(hook, component, next);\n    }\n  }\n\n  /**\n   * Activate / switch component for a router-view.\n   *\n   * @param {Directive} view\n   * @param {Transition} transition\n   * @param {Number} depth\n   * @param {Function} [cb]\n   */\n\n  function activate(view, transition, depth, cb, reuse) {\n    var handler = transition.activateQueue[depth];\n    if (!handler) {\n      saveChildView(view);\n      if (view._bound) {\n        view.setComponent(null);\n      }\n      cb && cb();\n      return;\n    }\n\n    var Component = view.Component = handler.component;\n    var activateHook = getRouteConfig(Component, 'activate');\n    var dataHook = getRouteConfig(Component, 'data');\n    var waitForData = getRouteConfig(Component, 'waitForData');\n\n    view.depth = depth;\n    view.activated = false;\n\n    var component = undefined;\n    var loading = !!(dataHook && !waitForData);\n\n    // \"reuse\" is a flag passed down when the parent view is\n    // either reused via keep-alive or as a child of a kept-alive view.\n    // of course we can only reuse if the current kept-alive instance\n    // is of the correct type.\n    reuse = reuse && view.childVM && view.childVM.constructor === Component;\n\n    if (reuse) {\n      // just reuse\n      component = view.childVM;\n      component.$loadingRouteData = loading;\n    } else {\n      saveChildView(view);\n\n      // unbuild current component. this step also destroys\n      // and removes all nested child views.\n      view.unbuild(true);\n\n      // build the new component. this will also create the\n      // direct child view of the current one. it will register\n      // itself as view.childView.\n      component = view.build({\n        _meta: {\n          $loadingRouteData: loading\n        },\n        created: function created() {\n          this._routerView = view;\n        }\n      });\n\n      // handle keep-alive.\n      // when a kept-alive child vm is restored, we need to\n      // add its cached child views into the router's view list,\n      // and also properly update current view's child view.\n      if (view.keepAlive) {\n        component.$loadingRouteData = loading;\n        var cachedChildView = component._keepAliveRouterView;\n        if (cachedChildView) {\n          view.childView = cachedChildView;\n          component._keepAliveRouterView = null;\n        }\n      }\n    }\n\n    // cleanup the component in case the transition is aborted\n    // before the component is ever inserted.\n    var cleanup = function cleanup() {\n      component.$destroy();\n    };\n\n    // actually insert the component and trigger transition\n    var insert = function insert() {\n      if (reuse) {\n        cb && cb();\n        return;\n      }\n      var router = transition.router;\n      if (router._rendered || router._transitionOnLoad) {\n        view.transition(component);\n      } else {\n        // no transition on first render, manual transition\n        /* istanbul ignore if */\n        if (view.setCurrent) {\n          // 0.12 compat\n          view.setCurrent(component);\n        } else {\n          // 1.0\n          view.childVM = component;\n        }\n        component.$before(view.anchor, null, false);\n      }\n      cb && cb();\n    };\n\n    var afterData = function afterData() {\n      // activate the child view\n      if (view.childView) {\n        activate(view.childView, transition, depth + 1, null, reuse || view.keepAlive);\n      }\n      insert();\n    };\n\n    // called after activation hook is resolved\n    var afterActivate = function afterActivate() {\n      view.activated = true;\n      if (dataHook && waitForData) {\n        // wait until data loaded to insert\n        loadData(component, transition, dataHook, afterData, cleanup);\n      } else {\n        // load data and insert at the same time\n        if (dataHook) {\n          loadData(component, transition, dataHook);\n        }\n        afterData();\n      }\n    };\n\n    if (activateHook) {\n      transition.callHooks(activateHook, component, afterActivate, {\n        cleanup: cleanup,\n        postActivate: true\n      });\n    } else {\n      afterActivate();\n    }\n  }\n\n  /**\n   * Reuse a view, just reload data if necessary.\n   *\n   * @param {Directive} view\n   * @param {Transition} transition\n   */\n\n  function reuse(view, transition) {\n    var component = view.childVM;\n    var dataHook = getRouteConfig(component, 'data');\n    if (dataHook) {\n      loadData(component, transition, dataHook);\n    }\n  }\n\n  /**\n   * Asynchronously load and apply data to component.\n   *\n   * @param {Vue} component\n   * @param {Transition} transition\n   * @param {Function} hook\n   * @param {Function} cb\n   * @param {Function} cleanup\n   */\n\n  function loadData(component, transition, hook, cb, cleanup) {\n    component.$loadingRouteData = true;\n    transition.callHooks(hook, component, function () {\n      component.$loadingRouteData = false;\n      component.$emit('route-data-loaded', component);\n      cb && cb();\n    }, {\n      cleanup: cleanup,\n      postActivate: true,\n      processData: function processData(data) {\n        // handle promise sugar syntax\n        var promises = [];\n        if (isPlainObject(data)) {\n          Object.keys(data).forEach(function (key) {\n            var val = data[key];\n            if (isPromise(val)) {\n              promises.push(val.then(function (resolvedVal) {\n                component.$set(key, resolvedVal);\n              }));\n            } else {\n              component.$set(key, val);\n            }\n          });\n        }\n        if (promises.length) {\n          return promises[0].constructor.all(promises);\n        }\n      }\n    });\n  }\n\n  /**\n   * Save the child view for a kept-alive view so that\n   * we can restore it when it is switched back to.\n   *\n   * @param {Directive} view\n   */\n\n  function saveChildView(view) {\n    if (view.keepAlive && view.childVM && view.childView) {\n      view.childVM._keepAliveRouterView = view.childView;\n    }\n    view.childView = null;\n  }\n\n  /**\n   * Check plain object.\n   *\n   * @param {*} val\n   */\n\n  function isPlainObject(val) {\n    return Object.prototype.toString.call(val) === '[object Object]';\n  }\n\n  /**\n   * A RouteTransition object manages the pipeline of a\n   * router-view switching process. This is also the object\n   * passed into user route hooks.\n   *\n   * @param {Router} router\n   * @param {Route} to\n   * @param {Route} from\n   */\n\n  var RouteTransition = (function () {\n    function RouteTransition(router, to, from) {\n      babelHelpers.classCallCheck(this, RouteTransition);\n\n      this.router = router;\n      this.to = to;\n      this.from = from;\n      this.next = null;\n      this.aborted = false;\n      this.done = false;\n    }\n\n    /**\n     * Abort current transition and return to previous location.\n     */\n\n    RouteTransition.prototype.abort = function abort() {\n      if (!this.aborted) {\n        this.aborted = true;\n        // if the root path throws an error during validation\n        // on initial load, it gets caught in an infinite loop.\n        var abortingOnLoad = !this.from.path && this.to.path === '/';\n        if (!abortingOnLoad) {\n          this.router.replace(this.from.path || '/');\n        }\n      }\n    };\n\n    /**\n     * Abort current transition and redirect to a new location.\n     *\n     * @param {String} path\n     */\n\n    RouteTransition.prototype.redirect = function redirect(path) {\n      if (!this.aborted) {\n        this.aborted = true;\n        if (typeof path === 'string') {\n          path = mapParams(path, this.to.params, this.to.query);\n        } else {\n          path.params = path.params || this.to.params;\n          path.query = path.query || this.to.query;\n        }\n        this.router.replace(path);\n      }\n    };\n\n    /**\n     * A router view transition's pipeline can be described as\n     * follows, assuming we are transitioning from an existing\n     * <router-view> chain [Component A, Component B] to a new\n     * chain [Component A, Component C]:\n     *\n     *  A    A\n     *  | => |\n     *  B    C\n     *\n     * 1. Reusablity phase:\n     *   -> canReuse(A, A)\n     *   -> canReuse(B, C)\n     *   -> determine new queues:\n     *      - deactivation: [B]\n     *      - activation: [C]\n     *\n     * 2. Validation phase:\n     *   -> canDeactivate(B)\n     *   -> canActivate(C)\n     *\n     * 3. Activation phase:\n     *   -> deactivate(B)\n     *   -> activate(C)\n     *\n     * Each of these steps can be asynchronous, and any\n     * step can potentially abort the transition.\n     *\n     * @param {Function} cb\n     */\n\n    RouteTransition.prototype.start = function start(cb) {\n      var transition = this;\n\n      // determine the queue of views to deactivate\n      var deactivateQueue = [];\n      var view = this.router._rootView;\n      while (view) {\n        deactivateQueue.unshift(view);\n        view = view.childView;\n      }\n      var reverseDeactivateQueue = deactivateQueue.slice().reverse();\n\n      // determine the queue of route handlers to activate\n      var activateQueue = this.activateQueue = toArray(this.to.matched).map(function (match) {\n        return match.handler;\n      });\n\n      // 1. Reusability phase\n      var i = undefined,\n          reuseQueue = undefined;\n      for (i = 0; i < reverseDeactivateQueue.length; i++) {\n        if (!canReuse(reverseDeactivateQueue[i], activateQueue[i], transition)) {\n          break;\n        }\n      }\n      if (i > 0) {\n        reuseQueue = reverseDeactivateQueue.slice(0, i);\n        deactivateQueue = reverseDeactivateQueue.slice(i).reverse();\n        activateQueue = activateQueue.slice(i);\n      }\n\n      // 2. Validation phase\n      transition.runQueue(deactivateQueue, canDeactivate, function () {\n        transition.runQueue(activateQueue, canActivate, function () {\n          transition.runQueue(deactivateQueue, deactivate, function () {\n            // 3. Activation phase\n\n            // Update router current route\n            transition.router._onTransitionValidated(transition);\n\n            // trigger reuse for all reused views\n            reuseQueue && reuseQueue.forEach(function (view) {\n              return reuse(view, transition);\n            });\n\n            // the root of the chain that needs to be replaced\n            // is the top-most non-reusable view.\n            if (deactivateQueue.length) {\n              var _view = deactivateQueue[deactivateQueue.length - 1];\n              var depth = reuseQueue ? reuseQueue.length : 0;\n              activate(_view, transition, depth, cb);\n            } else {\n              cb();\n            }\n          });\n        });\n      });\n    };\n\n    /**\n     * Asynchronously and sequentially apply a function to a\n     * queue.\n     *\n     * @param {Array} queue\n     * @param {Function} fn\n     * @param {Function} cb\n     */\n\n    RouteTransition.prototype.runQueue = function runQueue(queue, fn, cb) {\n      var transition = this;\n      step(0);\n      function step(index) {\n        if (index >= queue.length) {\n          cb();\n        } else {\n          fn(queue[index], transition, function () {\n            step(index + 1);\n          });\n        }\n      }\n    };\n\n    /**\n     * Call a user provided route transition hook and handle\n     * the response (e.g. if the user returns a promise).\n     *\n     * If the user neither expects an argument nor returns a\n     * promise, the hook is assumed to be synchronous.\n     *\n     * @param {Function} hook\n     * @param {*} [context]\n     * @param {Function} [cb]\n     * @param {Object} [options]\n     *                 - {Boolean} expectBoolean\n     *                 - {Boolean} postActive\n     *                 - {Function} processData\n     *                 - {Function} cleanup\n     */\n\n    RouteTransition.prototype.callHook = function callHook(hook, context, cb) {\n      var _ref = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];\n\n      var _ref$expectBoolean = _ref.expectBoolean;\n      var expectBoolean = _ref$expectBoolean === undefined ? false : _ref$expectBoolean;\n      var _ref$postActivate = _ref.postActivate;\n      var postActivate = _ref$postActivate === undefined ? false : _ref$postActivate;\n      var processData = _ref.processData;\n      var cleanup = _ref.cleanup;\n\n      var transition = this;\n      var nextCalled = false;\n\n      // abort the transition\n      var abort = function abort() {\n        cleanup && cleanup();\n        transition.abort();\n      };\n\n      // handle errors\n      var onError = function onError(err) {\n        postActivate ? next() : abort();\n        if (err && !transition.router._suppress) {\n          warn$1('Uncaught error during transition: ');\n          throw err instanceof Error ? err : new Error(err);\n        }\n      };\n\n      // since promise swallows errors, we have to\n      // throw it in the next tick...\n      var onPromiseError = function onPromiseError(err) {\n        try {\n          onError(err);\n        } catch (e) {\n          setTimeout(function () {\n            throw e;\n          }, 0);\n        }\n      };\n\n      // advance the transition to the next step\n      var next = function next() {\n        if (nextCalled) {\n          warn$1('transition.next() should be called only once.');\n          return;\n        }\n        nextCalled = true;\n        if (transition.aborted) {\n          cleanup && cleanup();\n          return;\n        }\n        cb && cb();\n      };\n\n      var nextWithBoolean = function nextWithBoolean(res) {\n        if (typeof res === 'boolean') {\n          res ? next() : abort();\n        } else if (isPromise(res)) {\n          res.then(function (ok) {\n            ok ? next() : abort();\n          }, onPromiseError);\n        } else if (!hook.length) {\n          next();\n        }\n      };\n\n      var nextWithData = function nextWithData(data) {\n        var res = undefined;\n        try {\n          res = processData(data);\n        } catch (err) {\n          return onError(err);\n        }\n        if (isPromise(res)) {\n          res.then(next, onPromiseError);\n        } else {\n          next();\n        }\n      };\n\n      // expose a clone of the transition object, so that each\n      // hook gets a clean copy and prevent the user from\n      // messing with the internals.\n      var exposed = {\n        to: transition.to,\n        from: transition.from,\n        abort: abort,\n        next: processData ? nextWithData : next,\n        redirect: function redirect() {\n          transition.redirect.apply(transition, arguments);\n        }\n      };\n\n      // actually call the hook\n      var res = undefined;\n      try {\n        res = hook.call(context, exposed);\n      } catch (err) {\n        return onError(err);\n      }\n\n      if (expectBoolean) {\n        // boolean hooks\n        nextWithBoolean(res);\n      } else if (isPromise(res)) {\n        // promise\n        if (processData) {\n          res.then(nextWithData, onPromiseError);\n        } else {\n          res.then(next, onPromiseError);\n        }\n      } else if (processData && isPlainOjbect(res)) {\n        // data promise sugar\n        nextWithData(res);\n      } else if (!hook.length) {\n        next();\n      }\n    };\n\n    /**\n     * Call a single hook or an array of async hooks in series.\n     *\n     * @param {Array} hooks\n     * @param {*} context\n     * @param {Function} cb\n     * @param {Object} [options]\n     */\n\n    RouteTransition.prototype.callHooks = function callHooks(hooks, context, cb, options) {\n      var _this = this;\n\n      if (Array.isArray(hooks)) {\n        this.runQueue(hooks, function (hook, _, next) {\n          if (!_this.aborted) {\n            _this.callHook(hook, context, next, options);\n          }\n        }, cb);\n      } else {\n        this.callHook(hooks, context, cb, options);\n      }\n    };\n\n    return RouteTransition;\n  })();\n\n  function isPlainOjbect(val) {\n    return Object.prototype.toString.call(val) === '[object Object]';\n  }\n\n  function toArray(val) {\n    return val ? Array.prototype.slice.call(val) : [];\n  }\n\n  var internalKeysRE = /^(component|subRoutes|fullPath)$/;\n\n  /**\n   * Route Context Object\n   *\n   * @param {String} path\n   * @param {Router} router\n   */\n\n  var Route = function Route(path, router) {\n    var _this = this;\n\n    babelHelpers.classCallCheck(this, Route);\n\n    var matched = router._recognizer.recognize(path);\n    if (matched) {\n      // copy all custom fields from route configs\n      [].forEach.call(matched, function (match) {\n        for (var key in match.handler) {\n          if (!internalKeysRE.test(key)) {\n            _this[key] = match.handler[key];\n          }\n        }\n      });\n      // set query and params\n      this.query = matched.queryParams;\n      this.params = [].reduce.call(matched, function (prev, cur) {\n        if (cur.params) {\n          for (var key in cur.params) {\n            prev[key] = cur.params[key];\n          }\n        }\n        return prev;\n      }, {});\n    }\n    // expose path and router\n    this.path = path;\n    // for internal use\n    this.matched = matched || router._notFoundHandler;\n    // internal reference to router\n    Object.defineProperty(this, 'router', {\n      enumerable: false,\n      value: router\n    });\n    // Important: freeze self to prevent observation\n    Object.freeze(this);\n  };\n\n  function applyOverride (Vue) {\n    var _Vue$util = Vue.util;\n    var extend = _Vue$util.extend;\n    var isArray = _Vue$util.isArray;\n    var defineReactive = _Vue$util.defineReactive;\n\n    // override Vue's init and destroy process to keep track of router instances\n    var init = Vue.prototype._init;\n    Vue.prototype._init = function (options) {\n      options = options || {};\n      var root = options._parent || options.parent || this;\n      var router = root.$router;\n      var route = root.$route;\n      if (router) {\n        // expose router\n        this.$router = router;\n        router._children.push(this);\n        /* istanbul ignore if */\n        if (this._defineMeta) {\n          // 0.12\n          this._defineMeta('$route', route);\n        } else {\n          // 1.0\n          defineReactive(this, '$route', route);\n        }\n      }\n      init.call(this, options);\n    };\n\n    var destroy = Vue.prototype._destroy;\n    Vue.prototype._destroy = function () {\n      if (!this._isBeingDestroyed && this.$router) {\n        this.$router._children.$remove(this);\n      }\n      destroy.apply(this, arguments);\n    };\n\n    // 1.0 only: enable route mixins\n    var strats = Vue.config.optionMergeStrategies;\n    var hooksToMergeRE = /^(data|activate|deactivate)$/;\n\n    if (strats) {\n      strats.route = function (parentVal, childVal) {\n        if (!childVal) return parentVal;\n        if (!parentVal) return childVal;\n        var ret = {};\n        extend(ret, parentVal);\n        for (var key in childVal) {\n          var a = ret[key];\n          var b = childVal[key];\n          // for data, activate and deactivate, we need to merge them into\n          // arrays similar to lifecycle hooks.\n          if (a && hooksToMergeRE.test(key)) {\n            ret[key] = (isArray(a) ? a : [a]).concat(b);\n          } else {\n            ret[key] = b;\n          }\n        }\n        return ret;\n      };\n    }\n  }\n\n  function View (Vue) {\n\n    var _ = Vue.util;\n    var componentDef =\n    // 0.12\n    Vue.directive('_component') ||\n    // 1.0\n    Vue.internalDirectives.component;\n    // <router-view> extends the internal component directive\n    var viewDef = _.extend({}, componentDef);\n\n    // with some overrides\n    _.extend(viewDef, {\n\n      _isRouterView: true,\n\n      bind: function bind() {\n        var route = this.vm.$route;\n        /* istanbul ignore if */\n        if (!route) {\n          warn$1('<router-view> can only be used inside a ' + 'router-enabled app.');\n          return;\n        }\n        // force dynamic directive so v-component doesn't\n        // attempt to build right now\n        this._isDynamicLiteral = true;\n        // finally, init by delegating to v-component\n        componentDef.bind.call(this);\n\n        // locate the parent view\n        var parentView = undefined;\n        var parent = this.vm;\n        while (parent) {\n          if (parent._routerView) {\n            parentView = parent._routerView;\n            break;\n          }\n          parent = parent.$parent;\n        }\n        if (parentView) {\n          // register self as a child of the parent view,\n          // instead of activating now. This is so that the\n          // child's activate hook is called after the\n          // parent's has resolved.\n          this.parentView = parentView;\n          parentView.childView = this;\n        } else {\n          // this is the root view!\n          var router = route.router;\n          router._rootView = this;\n        }\n\n        // handle late-rendered view\n        // two possibilities:\n        // 1. root view rendered after transition has been\n        //    validated;\n        // 2. child view rendered after parent view has been\n        //    activated.\n        var transition = route.router._currentTransition;\n        if (!parentView && transition.done || parentView && parentView.activated) {\n          var depth = parentView ? parentView.depth + 1 : 0;\n          activate(this, transition, depth);\n        }\n      },\n\n      unbind: function unbind() {\n        if (this.parentView) {\n          this.parentView.childView = null;\n        }\n        componentDef.unbind.call(this);\n      }\n    });\n\n    Vue.elementDirective('router-view', viewDef);\n  }\n\n  var trailingSlashRE = /\\/$/;\n  var regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n  var queryStringRE = /\\?.*$/;\n\n  // install v-link, which provides navigation support for\n  // HTML5 history mode\n  function Link (Vue) {\n    var _Vue$util = Vue.util;\n    var _bind = _Vue$util.bind;\n    var isObject = _Vue$util.isObject;\n    var addClass = _Vue$util.addClass;\n    var removeClass = _Vue$util.removeClass;\n\n    var onPriority = Vue.directive('on').priority;\n    var LINK_UPDATE = '__vue-router-link-update__';\n\n    var activeId = 0;\n\n    Vue.directive('link-active', {\n      priority: 9999,\n      bind: function bind() {\n        var _this = this;\n\n        var id = String(activeId++);\n        // collect v-links contained within this element.\n        // we need do this here before the parent-child relationship\n        // gets messed up by terminal directives (if, for, components)\n        var childLinks = this.el.querySelectorAll('[v-link]');\n        for (var i = 0, l = childLinks.length; i < l; i++) {\n          var link = childLinks[i];\n          var existingId = link.getAttribute(LINK_UPDATE);\n          var value = existingId ? existingId + ',' + id : id;\n          // leave a mark on the link element which can be persisted\n          // through fragment clones.\n          link.setAttribute(LINK_UPDATE, value);\n        }\n        this.vm.$on(LINK_UPDATE, this.cb = function (link, path) {\n          if (link.activeIds.indexOf(id) > -1) {\n            link.updateClasses(path, _this.el);\n          }\n        });\n      },\n      unbind: function unbind() {\n        this.vm.$off(LINK_UPDATE, this.cb);\n      }\n    });\n\n    Vue.directive('link', {\n      priority: onPriority - 2,\n\n      bind: function bind() {\n        var vm = this.vm;\n        /* istanbul ignore if */\n        if (!vm.$route) {\n          warn$1('v-link can only be used inside a router-enabled app.');\n          return;\n        }\n        this.router = vm.$route.router;\n        // update things when the route changes\n        this.unwatch = vm.$watch('$route', _bind(this.onRouteUpdate, this));\n        // check v-link-active ids\n        var activeIds = this.el.getAttribute(LINK_UPDATE);\n        if (activeIds) {\n          this.el.removeAttribute(LINK_UPDATE);\n          this.activeIds = activeIds.split(',');\n        }\n        // no need to handle click if link expects to be opened\n        // in a new window/tab.\n        /* istanbul ignore if */\n        if (this.el.tagName === 'A' && this.el.getAttribute('target') === '_blank') {\n          return;\n        }\n        // handle click\n        this.handler = _bind(this.onClick, this);\n        this.el.addEventListener('click', this.handler);\n      },\n\n      update: function update(target) {\n        this.target = target;\n        if (isObject(target)) {\n          this.append = target.append;\n          this.exact = target.exact;\n          this.prevActiveClass = this.activeClass;\n          this.activeClass = target.activeClass;\n        }\n        this.onRouteUpdate(this.vm.$route);\n      },\n\n      onClick: function onClick(e) {\n        // don't redirect with control keys\n        /* istanbul ignore if */\n        if (e.metaKey || e.ctrlKey || e.shiftKey) return;\n        // don't redirect when preventDefault called\n        /* istanbul ignore if */\n        if (e.defaultPrevented) return;\n        // don't redirect on right click\n        /* istanbul ignore if */\n        if (e.button !== 0) return;\n\n        var target = this.target;\n        if (target) {\n          // v-link with expression, just go\n          e.preventDefault();\n          this.router.go(target);\n        } else {\n          // no expression, delegate for an <a> inside\n          var el = e.target;\n          while (el.tagName !== 'A' && el !== this.el) {\n            el = el.parentNode;\n          }\n          if (el.tagName === 'A' && sameOrigin(el)) {\n            e.preventDefault();\n            var path = el.pathname;\n            if (this.router.history.root) {\n              path = path.replace(this.router.history.rootRE, '');\n            }\n            this.router.go({\n              path: path,\n              replace: target && target.replace,\n              append: target && target.append\n            });\n          }\n        }\n      },\n\n      onRouteUpdate: function onRouteUpdate(route) {\n        // router.stringifyPath is dependent on current route\n        // and needs to be called again whenver route changes.\n        var newPath = this.router.stringifyPath(this.target);\n        if (this.path !== newPath) {\n          this.path = newPath;\n          this.updateActiveMatch();\n          this.updateHref();\n        }\n        if (this.activeIds) {\n          this.vm.$emit(LINK_UPDATE, this, route.path);\n        } else {\n          this.updateClasses(route.path, this.el);\n        }\n      },\n\n      updateActiveMatch: function updateActiveMatch() {\n        this.activeRE = this.path && !this.exact ? new RegExp('^' + this.path.replace(/\\/$/, '').replace(queryStringRE, '').replace(regexEscapeRE, '\\\\$&') + '(\\\\/|$)') : null;\n      },\n\n      updateHref: function updateHref() {\n        if (this.el.tagName !== 'A') {\n          return;\n        }\n        var path = this.path;\n        var router = this.router;\n        var isAbsolute = path.charAt(0) === '/';\n        // do not format non-hash relative paths\n        var href = path && (router.mode === 'hash' || isAbsolute) ? router.history.formatPath(path, this.append) : path;\n        if (href) {\n          this.el.href = href;\n        } else {\n          this.el.removeAttribute('href');\n        }\n      },\n\n      updateClasses: function updateClasses(path, el) {\n        var activeClass = this.activeClass || this.router._linkActiveClass;\n        // clear old class\n        if (this.prevActiveClass && this.prevActiveClass !== activeClass) {\n          toggleClasses(el, this.prevActiveClass, removeClass);\n        }\n        // remove query string before matching\n        var dest = this.path.replace(queryStringRE, '');\n        path = path.replace(queryStringRE, '');\n        // add new class\n        if (this.exact) {\n          if (dest === path ||\n          // also allow additional trailing slash\n          dest.charAt(dest.length - 1) !== '/' && dest === path.replace(trailingSlashRE, '')) {\n            toggleClasses(el, activeClass, addClass);\n          } else {\n            toggleClasses(el, activeClass, removeClass);\n          }\n        } else {\n          if (this.activeRE && this.activeRE.test(path)) {\n            toggleClasses(el, activeClass, addClass);\n          } else {\n            toggleClasses(el, activeClass, removeClass);\n          }\n        }\n      },\n\n      unbind: function unbind() {\n        this.el.removeEventListener('click', this.handler);\n        this.unwatch && this.unwatch();\n      }\n    });\n\n    function sameOrigin(link) {\n      return link.protocol === location.protocol && link.hostname === location.hostname && link.port === location.port;\n    }\n\n    // this function is copied from v-bind:class implementation until\n    // we properly expose it...\n    function toggleClasses(el, key, fn) {\n      key = key.trim();\n      if (key.indexOf(' ') === -1) {\n        fn(el, key);\n        return;\n      }\n      var keys = key.split(/\\s+/);\n      for (var i = 0, l = keys.length; i < l; i++) {\n        fn(el, keys[i]);\n      }\n    }\n  }\n\n  var historyBackends = {\n    abstract: AbstractHistory,\n    hash: HashHistory,\n    html5: HTML5History\n  };\n\n  // late bind during install\n  var Vue = undefined;\n\n  /**\n   * Router constructor\n   *\n   * @param {Object} [options]\n   */\n\n  var Router = (function () {\n    function Router() {\n      var _this = this;\n\n      var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      var _ref$hashbang = _ref.hashbang;\n      var hashbang = _ref$hashbang === undefined ? true : _ref$hashbang;\n      var _ref$abstract = _ref.abstract;\n      var abstract = _ref$abstract === undefined ? false : _ref$abstract;\n      var _ref$history = _ref.history;\n      var history = _ref$history === undefined ? false : _ref$history;\n      var _ref$saveScrollPosition = _ref.saveScrollPosition;\n      var saveScrollPosition = _ref$saveScrollPosition === undefined ? false : _ref$saveScrollPosition;\n      var _ref$transitionOnLoad = _ref.transitionOnLoad;\n      var transitionOnLoad = _ref$transitionOnLoad === undefined ? false : _ref$transitionOnLoad;\n      var _ref$suppressTransitionError = _ref.suppressTransitionError;\n      var suppressTransitionError = _ref$suppressTransitionError === undefined ? false : _ref$suppressTransitionError;\n      var _ref$root = _ref.root;\n      var root = _ref$root === undefined ? null : _ref$root;\n      var _ref$linkActiveClass = _ref.linkActiveClass;\n      var linkActiveClass = _ref$linkActiveClass === undefined ? 'v-link-active' : _ref$linkActiveClass;\n      babelHelpers.classCallCheck(this, Router);\n\n      /* istanbul ignore if */\n      if (!Router.installed) {\n        throw new Error('Please install the Router with Vue.use() before ' + 'creating an instance.');\n      }\n\n      // Vue instances\n      this.app = null;\n      this._children = [];\n\n      // route recognizer\n      this._recognizer = new RouteRecognizer();\n      this._guardRecognizer = new RouteRecognizer();\n\n      // state\n      this._started = false;\n      this._startCb = null;\n      this._currentRoute = {};\n      this._currentTransition = null;\n      this._previousTransition = null;\n      this._notFoundHandler = null;\n      this._notFoundRedirect = null;\n      this._beforeEachHooks = [];\n      this._afterEachHooks = [];\n\n      // trigger transition on initial render?\n      this._rendered = false;\n      this._transitionOnLoad = transitionOnLoad;\n\n      // history mode\n      this._root = root;\n      this._abstract = abstract;\n      this._hashbang = hashbang;\n\n      // check if HTML5 history is available\n      var hasPushState = typeof window !== 'undefined' && window.history && window.history.pushState;\n      this._history = history && hasPushState;\n      this._historyFallback = history && !hasPushState;\n\n      // create history object\n      var inBrowser = Vue.util.inBrowser;\n      this.mode = !inBrowser || this._abstract ? 'abstract' : this._history ? 'html5' : 'hash';\n\n      var History = historyBackends[this.mode];\n      this.history = new History({\n        root: root,\n        hashbang: this._hashbang,\n        onChange: function onChange(path, state, anchor) {\n          _this._match(path, state, anchor);\n        }\n      });\n\n      // other options\n      this._saveScrollPosition = saveScrollPosition;\n      this._linkActiveClass = linkActiveClass;\n      this._suppress = suppressTransitionError;\n    }\n\n    /**\n     * Allow directly passing components to a route\n     * definition.\n     *\n     * @param {String} path\n     * @param {Object} handler\n     */\n\n    // API ===================================================\n\n    /**\n    * Register a map of top-level paths.\n    *\n    * @param {Object} map\n    */\n\n    Router.prototype.map = function map(_map) {\n      for (var route in _map) {\n        this.on(route, _map[route]);\n      }\n      return this;\n    };\n\n    /**\n     * Register a single root-level path\n     *\n     * @param {String} rootPath\n     * @param {Object} handler\n     *                 - {String} component\n     *                 - {Object} [subRoutes]\n     *                 - {Boolean} [forceRefresh]\n     *                 - {Function} [before]\n     *                 - {Function} [after]\n     */\n\n    Router.prototype.on = function on(rootPath, handler) {\n      if (rootPath === '*') {\n        this._notFound(handler);\n      } else {\n        this._addRoute(rootPath, handler, []);\n      }\n      return this;\n    };\n\n    /**\n     * Set redirects.\n     *\n     * @param {Object} map\n     */\n\n    Router.prototype.redirect = function redirect(map) {\n      for (var path in map) {\n        this._addRedirect(path, map[path]);\n      }\n      return this;\n    };\n\n    /**\n     * Set aliases.\n     *\n     * @param {Object} map\n     */\n\n    Router.prototype.alias = function alias(map) {\n      for (var path in map) {\n        this._addAlias(path, map[path]);\n      }\n      return this;\n    };\n\n    /**\n     * Set global before hook.\n     *\n     * @param {Function} fn\n     */\n\n    Router.prototype.beforeEach = function beforeEach(fn) {\n      this._beforeEachHooks.push(fn);\n      return this;\n    };\n\n    /**\n     * Set global after hook.\n     *\n     * @param {Function} fn\n     */\n\n    Router.prototype.afterEach = function afterEach(fn) {\n      this._afterEachHooks.push(fn);\n      return this;\n    };\n\n    /**\n     * Navigate to a given path.\n     * The path can be an object describing a named path in\n     * the format of { name: '...', params: {}, query: {}}\n     * The path is assumed to be already decoded, and will\n     * be resolved against root (if provided)\n     *\n     * @param {String|Object} path\n     * @param {Boolean} [replace]\n     */\n\n    Router.prototype.go = function go(path) {\n      var replace = false;\n      var append = false;\n      if (Vue.util.isObject(path)) {\n        replace = path.replace;\n        append = path.append;\n      }\n      path = this.stringifyPath(path);\n      if (path) {\n        this.history.go(path, replace, append);\n      }\n    };\n\n    /**\n     * Short hand for replacing current path\n     *\n     * @param {String} path\n     */\n\n    Router.prototype.replace = function replace(path) {\n      if (typeof path === 'string') {\n        path = { path: path };\n      }\n      path.replace = true;\n      this.go(path);\n    };\n\n    /**\n     * Start the router.\n     *\n     * @param {VueConstructor} App\n     * @param {String|Element} container\n     * @param {Function} [cb]\n     */\n\n    Router.prototype.start = function start(App, container, cb) {\n      /* istanbul ignore if */\n      if (this._started) {\n        warn$1('already started.');\n        return;\n      }\n      this._started = true;\n      this._startCb = cb;\n      if (!this.app) {\n        /* istanbul ignore if */\n        if (!App || !container) {\n          throw new Error('Must start vue-router with a component and a ' + 'root container.');\n        }\n        /* istanbul ignore if */\n        if (App instanceof Vue) {\n          throw new Error('Must start vue-router with a component, not a ' + 'Vue instance.');\n        }\n        this._appContainer = container;\n        var Ctor = this._appConstructor = typeof App === 'function' ? App : Vue.extend(App);\n        // give it a name for better debugging\n        Ctor.options.name = Ctor.options.name || 'RouterApp';\n      }\n\n      // handle history fallback in browsers that do not\n      // support HTML5 history API\n      if (this._historyFallback) {\n        var _location = window.location;\n        var _history = new HTML5History({ root: this._root });\n        var path = _history.root ? _location.pathname.replace(_history.rootRE, '') : _location.pathname;\n        if (path && path !== '/') {\n          _location.assign((_history.root || '') + '/' + this.history.formatPath(path) + _location.search);\n          return;\n        }\n      }\n\n      this.history.start();\n    };\n\n    /**\n     * Stop listening to route changes.\n     */\n\n    Router.prototype.stop = function stop() {\n      this.history.stop();\n      this._started = false;\n    };\n\n    /**\n     * Normalize named route object / string paths into\n     * a string.\n     *\n     * @param {Object|String|Number} path\n     * @return {String}\n     */\n\n    Router.prototype.stringifyPath = function stringifyPath(path) {\n      var generatedPath = '';\n      if (path && typeof path === 'object') {\n        if (path.name) {\n          var extend = Vue.util.extend;\n          var currentParams = this._currentTransition && this._currentTransition.to.params;\n          var targetParams = path.params || {};\n          var params = currentParams ? extend(extend({}, currentParams), targetParams) : targetParams;\n          generatedPath = encodeURI(this._recognizer.generate(path.name, params));\n        } else if (path.path) {\n          generatedPath = encodeURI(path.path);\n        }\n        if (path.query) {\n          // note: the generated query string is pre-URL-encoded by the recognizer\n          var query = this._recognizer.generateQueryString(path.query);\n          if (generatedPath.indexOf('?') > -1) {\n            generatedPath += '&' + query.slice(1);\n          } else {\n            generatedPath += query;\n          }\n        }\n      } else {\n        generatedPath = encodeURI(path ? path + '' : '');\n      }\n      return generatedPath;\n    };\n\n    // Internal methods ======================================\n\n    /**\n    * Add a route containing a list of segments to the internal\n    * route recognizer. Will be called recursively to add all\n    * possible sub-routes.\n    *\n    * @param {String} path\n    * @param {Object} handler\n    * @param {Array} segments\n    */\n\n    Router.prototype._addRoute = function _addRoute(path, handler, segments) {\n      guardComponent(path, handler);\n      handler.path = path;\n      handler.fullPath = (segments.reduce(function (path, segment) {\n        return path + segment.path;\n      }, '') + path).replace('//', '/');\n      segments.push({\n        path: path,\n        handler: handler\n      });\n      this._recognizer.add(segments, {\n        as: handler.name\n      });\n      // add sub routes\n      if (handler.subRoutes) {\n        for (var subPath in handler.subRoutes) {\n          // recursively walk all sub routes\n          this._addRoute(subPath, handler.subRoutes[subPath],\n          // pass a copy in recursion to avoid mutating\n          // across branches\n          segments.slice());\n        }\n      }\n    };\n\n    /**\n     * Set the notFound route handler.\n     *\n     * @param {Object} handler\n     */\n\n    Router.prototype._notFound = function _notFound(handler) {\n      guardComponent('*', handler);\n      this._notFoundHandler = [{ handler: handler }];\n    };\n\n    /**\n     * Add a redirect record.\n     *\n     * @param {String} path\n     * @param {String} redirectPath\n     */\n\n    Router.prototype._addRedirect = function _addRedirect(path, redirectPath) {\n      if (path === '*') {\n        this._notFoundRedirect = redirectPath;\n      } else {\n        this._addGuard(path, redirectPath, this.replace);\n      }\n    };\n\n    /**\n     * Add an alias record.\n     *\n     * @param {String} path\n     * @param {String} aliasPath\n     */\n\n    Router.prototype._addAlias = function _addAlias(path, aliasPath) {\n      this._addGuard(path, aliasPath, this._match);\n    };\n\n    /**\n     * Add a path guard.\n     *\n     * @param {String} path\n     * @param {String} mappedPath\n     * @param {Function} handler\n     */\n\n    Router.prototype._addGuard = function _addGuard(path, mappedPath, _handler) {\n      var _this2 = this;\n\n      this._guardRecognizer.add([{\n        path: path,\n        handler: function handler(match, query) {\n          var realPath = mapParams(mappedPath, match.params, query);\n          _handler.call(_this2, realPath);\n        }\n      }]);\n    };\n\n    /**\n     * Check if a path matches any redirect records.\n     *\n     * @param {String} path\n     * @return {Boolean} - if true, will skip normal match.\n     */\n\n    Router.prototype._checkGuard = function _checkGuard(path) {\n      var matched = this._guardRecognizer.recognize(path, true);\n      if (matched) {\n        matched[0].handler(matched[0], matched.queryParams);\n        return true;\n      } else if (this._notFoundRedirect) {\n        matched = this._recognizer.recognize(path);\n        if (!matched) {\n          this.replace(this._notFoundRedirect);\n          return true;\n        }\n      }\n    };\n\n    /**\n     * Match a URL path and set the route context on vm,\n     * triggering view updates.\n     *\n     * @param {String} path\n     * @param {Object} [state]\n     * @param {String} [anchor]\n     */\n\n    Router.prototype._match = function _match(path, state, anchor) {\n      var _this3 = this;\n\n      if (this._checkGuard(path)) {\n        return;\n      }\n\n      var currentRoute = this._currentRoute;\n      var currentTransition = this._currentTransition;\n\n      if (currentTransition) {\n        if (currentTransition.to.path === path) {\n          // do nothing if we have an active transition going to the same path\n          return;\n        } else if (currentRoute.path === path) {\n          // We are going to the same path, but we also have an ongoing but\n          // not-yet-validated transition. Abort that transition and reset to\n          // prev transition.\n          currentTransition.aborted = true;\n          this._currentTransition = this._prevTransition;\n          return;\n        } else {\n          // going to a totally different path. abort ongoing transition.\n          currentTransition.aborted = true;\n        }\n      }\n\n      // construct new route and transition context\n      var route = new Route(path, this);\n      var transition = new RouteTransition(this, route, currentRoute);\n\n      // current transition is updated right now.\n      // however, current route will only be updated after the transition has\n      // been validated.\n      this._prevTransition = currentTransition;\n      this._currentTransition = transition;\n\n      if (!this.app) {\n        (function () {\n          // initial render\n          var router = _this3;\n          _this3.app = new _this3._appConstructor({\n            el: _this3._appContainer,\n            created: function created() {\n              this.$router = router;\n            },\n            _meta: {\n              $route: route\n            }\n          });\n        })();\n      }\n\n      // check global before hook\n      var beforeHooks = this._beforeEachHooks;\n      var startTransition = function startTransition() {\n        transition.start(function () {\n          _this3._postTransition(route, state, anchor);\n        });\n      };\n\n      if (beforeHooks.length) {\n        transition.runQueue(beforeHooks, function (hook, _, next) {\n          if (transition === _this3._currentTransition) {\n            transition.callHook(hook, null, next, {\n              expectBoolean: true\n            });\n          }\n        }, startTransition);\n      } else {\n        startTransition();\n      }\n\n      if (!this._rendered && this._startCb) {\n        this._startCb.call(null);\n      }\n\n      // HACK:\n      // set rendered to true after the transition start, so\n      // that components that are acitvated synchronously know\n      // whether it is the initial render.\n      this._rendered = true;\n    };\n\n    /**\n     * Set current to the new transition.\n     * This is called by the transition object when the\n     * validation of a route has succeeded.\n     *\n     * @param {Transition} transition\n     */\n\n    Router.prototype._onTransitionValidated = function _onTransitionValidated(transition) {\n      // set current route\n      var route = this._currentRoute = transition.to;\n      // update route context for all children\n      if (this.app.$route !== route) {\n        this.app.$route = route;\n        this._children.forEach(function (child) {\n          child.$route = route;\n        });\n      }\n      // call global after hook\n      if (this._afterEachHooks.length) {\n        this._afterEachHooks.forEach(function (hook) {\n          return hook.call(null, {\n            to: transition.to,\n            from: transition.from\n          });\n        });\n      }\n      this._currentTransition.done = true;\n    };\n\n    /**\n     * Handle stuff after the transition.\n     *\n     * @param {Route} route\n     * @param {Object} [state]\n     * @param {String} [anchor]\n     */\n\n    Router.prototype._postTransition = function _postTransition(route, state, anchor) {\n      // handle scroll positions\n      // saved scroll positions take priority\n      // then we check if the path has an anchor\n      var pos = state && state.pos;\n      if (pos && this._saveScrollPosition) {\n        Vue.nextTick(function () {\n          window.scrollTo(pos.x, pos.y);\n        });\n      } else if (anchor) {\n        Vue.nextTick(function () {\n          var el = document.getElementById(anchor.slice(1));\n          if (el) {\n            window.scrollTo(window.scrollX, el.offsetTop);\n          }\n        });\n      }\n    };\n\n    return Router;\n  })();\n\n  function guardComponent(path, handler) {\n    var comp = handler.component;\n    if (Vue.util.isPlainObject(comp)) {\n      comp = handler.component = Vue.extend(comp);\n    }\n    /* istanbul ignore if */\n    if (typeof comp !== 'function') {\n      handler.component = null;\n      warn$1('invalid component for route \"' + path + '\".');\n    }\n  }\n\n  /* Installation */\n\n  Router.installed = false;\n\n  /**\n   * Installation interface.\n   * Install the necessary directives.\n   */\n\n  Router.install = function (externalVue) {\n    /* istanbul ignore if */\n    if (Router.installed) {\n      warn$1('already installed.');\n      return;\n    }\n    Vue = externalVue;\n    applyOverride(Vue);\n    View(Vue);\n    Link(Vue);\n    exports$1.Vue = Vue;\n    Router.installed = true;\n  };\n\n  // auto install\n  /* istanbul ignore if */\n  if (typeof window !== 'undefined' && window.Vue) {\n    window.Vue.use(Router);\n  }\n\n  return Router;\n\n}));\n},{}],73:[function(require,module,exports){\nvar _ = require('../util')\nvar Watcher = require('../watcher')\nvar Path = require('../parsers/path')\nvar textParser = require('../parsers/text')\nvar dirParser = require('../parsers/directive')\nvar expParser = require('../parsers/expression')\nvar filterRE = /[^|]\\|[^|]/\n\n/**\n * Get the value from an expression on this vm.\n *\n * @param {String} exp\n * @param {Boolean} [asStatement]\n * @return {*}\n */\n\nexports.$get = function (exp, asStatement) {\n  var res = expParser.parse(exp)\n  if (res) {\n    if (asStatement && !expParser.isSimplePath(exp)) {\n      var self = this\n      return function statementHandler () {\n        res.get.call(self, self)\n      }\n    } else {\n      try {\n        return res.get.call(this, this)\n      } catch (e) {}\n    }\n  }\n}\n\n/**\n * Set the value from an expression on this vm.\n * The expression must be a valid left-hand\n * expression in an assignment.\n *\n * @param {String} exp\n * @param {*} val\n */\n\nexports.$set = function (exp, val) {\n  var res = expParser.parse(exp, true)\n  if (res && res.set) {\n    res.set.call(this, this, val)\n  }\n}\n\n/**\n * Delete a property on the VM\n *\n * @param {String} key\n */\n\nexports.$delete = function (key) {\n  _.delete(this._data, key)\n}\n\n/**\n * Watch an expression, trigger callback when its\n * value changes.\n *\n * @param {String|Function} expOrFn\n * @param {Function} cb\n * @param {Object} [options]\n *                 - {Boolean} deep\n *                 - {Boolean} immediate\n * @return {Function} - unwatchFn\n */\n\nexports.$watch = function (expOrFn, cb, options) {\n  var vm = this\n  var parsed\n  if (typeof expOrFn === 'string') {\n    parsed = dirParser.parse(expOrFn)\n    expOrFn = parsed.expression\n  }\n  var watcher = new Watcher(vm, expOrFn, cb, {\n    deep: options && options.deep,\n    filters: parsed && parsed.filters\n  })\n  if (options && options.immediate) {\n    cb.call(vm, watcher.value)\n  }\n  return function unwatchFn () {\n    watcher.teardown()\n  }\n}\n\n/**\n * Evaluate a text directive, including filters.\n *\n * @param {String} text\n * @param {Boolean} [asStatement]\n * @return {String}\n */\n\nexports.$eval = function (text, asStatement) {\n  // check for filters.\n  if (filterRE.test(text)) {\n    var dir = dirParser.parse(text)\n    // the filter regex check might give false positive\n    // for pipes inside strings, so it's possible that\n    // we don't get any filters here\n    var val = this.$get(dir.expression, asStatement)\n    return dir.filters\n      ? this._applyFilters(val, null, dir.filters)\n      : val\n  } else {\n    // no filter\n    return this.$get(text, asStatement)\n  }\n}\n\n/**\n * Interpolate a piece of template text.\n *\n * @param {String} text\n * @return {String}\n */\n\nexports.$interpolate = function (text) {\n  var tokens = textParser.parse(text)\n  var vm = this\n  if (tokens) {\n    if (tokens.length === 1) {\n      return vm.$eval(tokens[0].value) + ''\n    } else {\n      return tokens.map(function (token) {\n        return token.tag\n          ? vm.$eval(token.value)\n          : token.value\n      }).join('')\n    }\n  } else {\n    return text\n  }\n}\n\n/**\n * Log instance data as a plain JS object\n * so that it is easier to inspect in console.\n * This method assumes console is available.\n *\n * @param {String} [path]\n */\n\nexports.$log = function (path) {\n  var data = path\n    ? Path.get(this._data, path)\n    : this._data\n  if (data) {\n    data = clean(data)\n  }\n  // include computed fields\n  if (!path) {\n    for (var key in this.$options.computed) {\n      data[key] = clean(this[key])\n    }\n  }\n  console.log(data)\n}\n\n/**\n * \"clean\" a getter/setter converted object into a plain\n * object copy.\n *\n * @param {Object} - obj\n * @return {Object}\n */\n\nfunction clean (obj) {\n  return JSON.parse(JSON.stringify(obj))\n}\n\n},{\"../parsers/directive\":123,\"../parsers/expression\":124,\"../parsers/path\":125,\"../parsers/text\":127,\"../util\":135,\"../watcher\":139}],74:[function(require,module,exports){\nvar _ = require('../util')\nvar transition = require('../transition')\n\n/**\n * Convenience on-instance nextTick. The callback is\n * auto-bound to the instance, and this avoids component\n * modules having to rely on the global Vue.\n *\n * @param {Function} fn\n */\n\nexports.$nextTick = function (fn) {\n  _.nextTick(fn, this)\n}\n\n/**\n * Append instance to target\n *\n * @param {Node} target\n * @param {Function} [cb]\n * @param {Boolean} [withTransition] - defaults to true\n */\n\nexports.$appendTo = function (target, cb, withTransition) {\n  return insert(\n    this, target, cb, withTransition,\n    append, transition.append\n  )\n}\n\n/**\n * Prepend instance to target\n *\n * @param {Node} target\n * @param {Function} [cb]\n * @param {Boolean} [withTransition] - defaults to true\n */\n\nexports.$prependTo = function (target, cb, withTransition) {\n  target = query(target)\n  if (target.hasChildNodes()) {\n    this.$before(target.firstChild, cb, withTransition)\n  } else {\n    this.$appendTo(target, cb, withTransition)\n  }\n  return this\n}\n\n/**\n * Insert instance before target\n *\n * @param {Node} target\n * @param {Function} [cb]\n * @param {Boolean} [withTransition] - defaults to true\n */\n\nexports.$before = function (target, cb, withTransition) {\n  return insert(\n    this, target, cb, withTransition,\n    before, transition.before\n  )\n}\n\n/**\n * Insert instance after target\n *\n * @param {Node} target\n * @param {Function} [cb]\n * @param {Boolean} [withTransition] - defaults to true\n */\n\nexports.$after = function (target, cb, withTransition) {\n  target = query(target)\n  if (target.nextSibling) {\n    this.$before(target.nextSibling, cb, withTransition)\n  } else {\n    this.$appendTo(target.parentNode, cb, withTransition)\n  }\n  return this\n}\n\n/**\n * Remove instance from DOM\n *\n * @param {Function} [cb]\n * @param {Boolean} [withTransition] - defaults to true\n */\n\nexports.$remove = function (cb, withTransition) {\n  if (!this.$el.parentNode) {\n    return cb && cb()\n  }\n  var inDoc = this._isAttached && _.inDoc(this.$el)\n  // if we are not in document, no need to check\n  // for transitions\n  if (!inDoc) withTransition = false\n  var self = this\n  var realCb = function () {\n    if (inDoc) self._callHook('detached')\n    if (cb) cb()\n  }\n  if (this._isFragment) {\n    _.removeNodeRange(\n      this._fragmentStart,\n      this._fragmentEnd,\n      this, this._fragment, realCb\n    )\n  } else {\n    var op = withTransition === false\n      ? remove\n      : transition.remove\n    op(this.$el, this, realCb)\n  }\n  return this\n}\n\n/**\n * Shared DOM insertion function.\n *\n * @param {Vue} vm\n * @param {Element} target\n * @param {Function} [cb]\n * @param {Boolean} [withTransition]\n * @param {Function} op1 - op for non-transition insert\n * @param {Function} op2 - op for transition insert\n * @return vm\n */\n\nfunction insert (vm, target, cb, withTransition, op1, op2) {\n  target = query(target)\n  var targetIsDetached = !_.inDoc(target)\n  var op = withTransition === false || targetIsDetached\n      ? op1\n      : op2\n  var shouldCallHook =\n    !targetIsDetached &&\n    !vm._isAttached &&\n    !_.inDoc(vm.$el)\n  if (vm._isFragment) {\n    _.mapNodeRange(vm._fragmentStart, vm._fragmentEnd, function (node) {\n      op(node, target, vm)\n    })\n    cb && cb()\n  } else {\n    op(vm.$el, target, vm, cb)\n  }\n  if (shouldCallHook) {\n    vm._callHook('attached')\n  }\n  return vm\n}\n\n/**\n * Check for selectors\n *\n * @param {String|Element} el\n */\n\nfunction query (el) {\n  return typeof el === 'string'\n    ? document.querySelector(el)\n    : el\n}\n\n/**\n * Append operation that takes a callback.\n *\n * @param {Node} el\n * @param {Node} target\n * @param {Vue} vm - unused\n * @param {Function} [cb]\n */\n\nfunction append (el, target, vm, cb) {\n  target.appendChild(el)\n  if (cb) cb()\n}\n\n/**\n * InsertBefore operation that takes a callback.\n *\n * @param {Node} el\n * @param {Node} target\n * @param {Vue} vm - unused\n * @param {Function} [cb]\n */\n\nfunction before (el, target, vm, cb) {\n  _.before(el, target)\n  if (cb) cb()\n}\n\n/**\n * Remove operation that takes a callback.\n *\n * @param {Node} el\n * @param {Vue} vm - unused\n * @param {Function} [cb]\n */\n\nfunction remove (el, vm, cb) {\n  _.remove(el)\n  if (cb) cb()\n}\n\n},{\"../transition\":128,\"../util\":135}],75:[function(require,module,exports){\nvar _ = require('../util')\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n */\n\nexports.$on = function (event, fn) {\n  (this._events[event] || (this._events[event] = []))\n    .push(fn)\n  modifyListenerCount(this, event, 1)\n  return this\n}\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n */\n\nexports.$once = function (event, fn) {\n  var self = this\n  function on () {\n    self.$off(event, on)\n    fn.apply(this, arguments)\n  }\n  on.fn = fn\n  this.$on(event, on)\n  return this\n}\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n */\n\nexports.$off = function (event, fn) {\n  var cbs\n  // all\n  if (!arguments.length) {\n    if (this.$parent) {\n      for (event in this._events) {\n        cbs = this._events[event]\n        if (cbs) {\n          modifyListenerCount(this, event, -cbs.length)\n        }\n      }\n    }\n    this._events = {}\n    return this\n  }\n  // specific event\n  cbs = this._events[event]\n  if (!cbs) {\n    return this\n  }\n  if (arguments.length === 1) {\n    modifyListenerCount(this, event, -cbs.length)\n    this._events[event] = null\n    return this\n  }\n  // specific handler\n  var cb\n  var i = cbs.length\n  while (i--) {\n    cb = cbs[i]\n    if (cb === fn || cb.fn === fn) {\n      modifyListenerCount(this, event, -1)\n      cbs.splice(i, 1)\n      break\n    }\n  }\n  return this\n}\n\n/**\n * Trigger an event on self.\n *\n * @param {String} event\n */\n\nexports.$emit = function (event) {\n  var cbs = this._events[event]\n  this._shouldPropagate = !cbs\n  if (cbs) {\n    cbs = cbs.length > 1\n      ? _.toArray(cbs)\n      : cbs\n    var args = _.toArray(arguments, 1)\n    for (var i = 0, l = cbs.length; i < l; i++) {\n      var res = cbs[i].apply(this, args)\n      if (res === true) {\n        this._shouldPropagate = true\n      }\n    }\n  }\n  return this\n}\n\n/**\n * Recursively broadcast an event to all children instances.\n *\n * @param {String} event\n * @param {...*} additional arguments\n */\n\nexports.$broadcast = function (event) {\n  // if no child has registered for this event,\n  // then there's no need to broadcast.\n  if (!this._eventsCount[event]) return\n  var children = this.$children\n  for (var i = 0, l = children.length; i < l; i++) {\n    var child = children[i]\n    child.$emit.apply(child, arguments)\n    if (child._shouldPropagate) {\n      child.$broadcast.apply(child, arguments)\n    }\n  }\n  return this\n}\n\n/**\n * Recursively propagate an event up the parent chain.\n *\n * @param {String} event\n * @param {...*} additional arguments\n */\n\nexports.$dispatch = function () {\n  this.$emit.apply(this, arguments)\n  var parent = this.$parent\n  while (parent) {\n    parent.$emit.apply(parent, arguments)\n    parent = parent._shouldPropagate\n      ? parent.$parent\n      : null\n  }\n  return this\n}\n\n/**\n * Modify the listener counts on all parents.\n * This bookkeeping allows $broadcast to return early when\n * no child has listened to a certain event.\n *\n * @param {Vue} vm\n * @param {String} event\n * @param {Number} count\n */\n\nvar hookRE = /^hook:/\nfunction modifyListenerCount (vm, event, count) {\n  var parent = vm.$parent\n  // hooks do not get broadcasted so no need\n  // to do bookkeeping for them\n  if (!parent || !count || hookRE.test(event)) return\n  while (parent) {\n    parent._eventsCount[event] =\n      (parent._eventsCount[event] || 0) + count\n    parent = parent.$parent\n  }\n}\n\n},{\"../util\":135}],76:[function(require,module,exports){\nvar _ = require('../util')\nvar config = require('../config')\n\n/**\n * Expose useful internals\n */\n\nexports.util = _\nexports.config = config\nexports.set = _.set\nexports.delete = _.delete\nexports.nextTick = _.nextTick\n\n/**\n * The following are exposed for advanced usage / plugins\n */\n\nexports.compiler = require('../compiler')\nexports.FragmentFactory = require('../fragment/factory')\nexports.internalDirectives = require('../directives/internal')\nexports.parsers = {\n  path: require('../parsers/path'),\n  text: require('../parsers/text'),\n  template: require('../parsers/template'),\n  directive: require('../parsers/directive'),\n  expression: require('../parsers/expression')\n}\n\n/**\n * Each instance constructor, including Vue, has a unique\n * cid. This enables us to create wrapped \"child\n * constructors\" for prototypal inheritance and cache them.\n */\n\nexports.cid = 0\nvar cid = 1\n\n/**\n * Class inheritance\n *\n * @param {Object} extendOptions\n */\n\nexports.extend = function (extendOptions) {\n  extendOptions = extendOptions || {}\n  var Super = this\n  var isFirstExtend = Super.cid === 0\n  if (isFirstExtend && extendOptions._Ctor) {\n    return extendOptions._Ctor\n  }\n  var name = extendOptions.name || Super.options.name\n  var Sub = createClass(name || 'VueComponent')\n  Sub.prototype = Object.create(Super.prototype)\n  Sub.prototype.constructor = Sub\n  Sub.cid = cid++\n  Sub.options = _.mergeOptions(\n    Super.options,\n    extendOptions\n  )\n  Sub['super'] = Super\n  // allow further extension\n  Sub.extend = Super.extend\n  // create asset registers, so extended classes\n  // can have their private assets too.\n  config._assetTypes.forEach(function (type) {\n    Sub[type] = Super[type]\n  })\n  // enable recursive self-lookup\n  if (name) {\n    Sub.options.components[name] = Sub\n  }\n  // cache constructor\n  if (isFirstExtend) {\n    extendOptions._Ctor = Sub\n  }\n  return Sub\n}\n\n/**\n * A function that returns a sub-class constructor with the\n * given name. This gives us much nicer output when\n * logging instances in the console.\n *\n * @param {String} name\n * @return {Function}\n */\n\nfunction createClass (name) {\n  return new Function(\n    'return function ' + _.classify(name) +\n    ' (options) { this._init(options) }'\n  )()\n}\n\n/**\n * Plugin system\n *\n * @param {Object} plugin\n */\n\nexports.use = function (plugin) {\n  /* istanbul ignore if */\n  if (plugin.installed) {\n    return\n  }\n  // additional parameters\n  var args = _.toArray(arguments, 1)\n  args.unshift(this)\n  if (typeof plugin.install === 'function') {\n    plugin.install.apply(plugin, args)\n  } else {\n    plugin.apply(null, args)\n  }\n  plugin.installed = true\n  return this\n}\n\n/**\n * Apply a global mixin by merging it into the default\n * options.\n */\n\nexports.mixin = function (mixin) {\n  var Vue = _.Vue\n  Vue.options = _.mergeOptions(Vue.options, mixin)\n}\n\n/**\n * Create asset registration methods with the following\n * signature:\n *\n * @param {String} id\n * @param {*} definition\n */\n\nconfig._assetTypes.forEach(function (type) {\n  exports[type] = function (id, definition) {\n    if (!definition) {\n      return this.options[type + 's'][id]\n    } else {\n      if (\n        type === 'component' &&\n        _.isPlainObject(definition)\n      ) {\n        definition.name = id\n        definition = _.Vue.extend(definition)\n      }\n      this.options[type + 's'][id] = definition\n      return definition\n    }\n  }\n})\n\n},{\"../compiler\":82,\"../config\":84,\"../directives/internal\":91,\"../fragment/factory\":113,\"../parsers/directive\":123,\"../parsers/expression\":124,\"../parsers/path\":125,\"../parsers/template\":126,\"../parsers/text\":127,\"../util\":135}],77:[function(require,module,exports){\n(function (process){\nvar _ = require('../util')\nvar compiler = require('../compiler')\n\n/**\n * Set instance target element and kick off the compilation\n * process. The passed in `el` can be a selector string, an\n * existing Element, or a DocumentFragment (for block\n * instances).\n *\n * @param {Element|DocumentFragment|string} el\n * @public\n */\n\nexports.$mount = function (el) {\n  if (this._isCompiled) {\n    process.env.NODE_ENV !== 'production' && _.warn(\n      '$mount() should be called only once.'\n    )\n    return\n  }\n  el = _.query(el)\n  if (!el) {\n    el = document.createElement('div')\n  }\n  this._compile(el)\n  this._initDOMHooks()\n  if (_.inDoc(this.$el)) {\n    this._callHook('attached')\n    ready.call(this)\n  } else {\n    this.$once('hook:attached', ready)\n  }\n  return this\n}\n\n/**\n * Mark an instance as ready.\n */\n\nfunction ready () {\n  this._isAttached = true\n  this._isReady = true\n  this._callHook('ready')\n}\n\n/**\n * Teardown the instance, simply delegate to the internal\n * _destroy.\n */\n\nexports.$destroy = function (remove, deferCleanup) {\n  this._destroy(remove, deferCleanup)\n}\n\n/**\n * Partially compile a piece of DOM and return a\n * decompile function.\n *\n * @param {Element|DocumentFragment} el\n * @param {Vue} [host]\n * @return {Function}\n */\n\nexports.$compile = function (el, host, scope, frag) {\n  return compiler.compile(el, this.$options, true)(\n    this, el, host, scope, frag\n  )\n}\n\n}).call(this,require('_process'))\n\n},{\"../compiler\":82,\"../util\":135,\"_process\":1}],78:[function(require,module,exports){\n(function (process){\nvar _ = require('./util')\nvar config = require('./config')\n\n// we have two separate queues: one for directive updates\n// and one for user watcher registered via $watch().\n// we want to guarantee directive updates to be called\n// before user watchers so that when user watchers are\n// triggered, the DOM would have already been in updated\n// state.\nvar queue = []\nvar userQueue = []\nvar has = {}\nvar circular = {}\nvar waiting = false\nvar internalQueueDepleted = false\n\n/**\n * Reset the batcher's state.\n */\n\nfunction resetBatcherState () {\n  queue = []\n  userQueue = []\n  has = {}\n  circular = {}\n  waiting = internalQueueDepleted = false\n}\n\n/**\n * Flush both queues and run the watchers.\n */\n\nfunction flushBatcherQueue () {\n  runBatcherQueue(queue)\n  internalQueueDepleted = true\n  runBatcherQueue(userQueue)\n  // dev tool hook\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production') {\n    if (_.inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__) {\n      window.__VUE_DEVTOOLS_GLOBAL_HOOK__.emit('flush')\n    }\n  }\n  resetBatcherState()\n}\n\n/**\n * Run the watchers in a single queue.\n *\n * @param {Array} queue\n */\n\nfunction runBatcherQueue (queue) {\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (var i = 0; i < queue.length; i++) {\n    var watcher = queue[i]\n    var id = watcher.id\n    has[id] = null\n    watcher.run()\n    // in dev build, check and stop circular updates.\n    if (process.env.NODE_ENV !== 'production' && has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1\n      if (circular[id] > config._maxUpdateCount) {\n        queue.splice(has[id], 1)\n        _.warn(\n          'You may have an infinite update loop for watcher ' +\n          'with expression: ' + watcher.expression\n        )\n      }\n    }\n  }\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n *\n * @param {Watcher} watcher\n *   properties:\n *   - {Number} id\n *   - {Function} run\n */\n\nexports.push = function (watcher) {\n  var id = watcher.id\n  if (has[id] == null) {\n    // if an internal watcher is pushed, but the internal\n    // queue is already depleted, we run it immediately.\n    if (internalQueueDepleted && !watcher.user) {\n      watcher.run()\n      return\n    }\n    // push watcher into appropriate queue\n    var q = watcher.user ? userQueue : queue\n    has[id] = q.length\n    q.push(watcher)\n    // queue the flush\n    if (!waiting) {\n      waiting = true\n      _.nextTick(flushBatcherQueue)\n    }\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"./config\":84,\"./util\":135,\"_process\":1}],79:[function(require,module,exports){\n/**\n * A doubly linked list-based Least Recently Used (LRU)\n * cache. Will keep most recently used items while\n * discarding least recently used items when its limit is\n * reached. This is a bare-bone version of\n * Rasmus Andersson's js-lru:\n *\n *   https://github.com/rsms/js-lru\n *\n * @param {Number} limit\n * @constructor\n */\n\nfunction Cache (limit) {\n  this.size = 0\n  this.limit = limit\n  this.head = this.tail = undefined\n  this._keymap = Object.create(null)\n}\n\nvar p = Cache.prototype\n\n/**\n * Put <value> into the cache associated with <key>.\n * Returns the entry which was removed to make room for\n * the new entry. Otherwise undefined is returned.\n * (i.e. if there was enough room already).\n *\n * @param {String} key\n * @param {*} value\n * @return {Entry|undefined}\n */\n\np.put = function (key, value) {\n  var entry = {\n    key: key,\n    value: value\n  }\n  this._keymap[key] = entry\n  if (this.tail) {\n    this.tail.newer = entry\n    entry.older = this.tail\n  } else {\n    this.head = entry\n  }\n  this.tail = entry\n  if (this.size === this.limit) {\n    return this.shift()\n  } else {\n    this.size++\n  }\n}\n\n/**\n * Purge the least recently used (oldest) entry from the\n * cache. Returns the removed entry or undefined if the\n * cache was empty.\n */\n\np.shift = function () {\n  var entry = this.head\n  if (entry) {\n    this.head = this.head.newer\n    this.head.older = undefined\n    entry.newer = entry.older = undefined\n    this._keymap[entry.key] = undefined\n  }\n  return entry\n}\n\n/**\n * Get and register recent use of <key>. Returns the value\n * associated with <key> or undefined if not in cache.\n *\n * @param {String} key\n * @param {Boolean} returnEntry\n * @return {Entry|*}\n */\n\np.get = function (key, returnEntry) {\n  var entry = this._keymap[key]\n  if (entry === undefined) return\n  if (entry === this.tail) {\n    return returnEntry\n      ? entry\n      : entry.value\n  }\n  // HEAD--------------TAIL\n  //   <.older   .newer>\n  //  <--- add direction --\n  //   A  B  C  <D>  E\n  if (entry.newer) {\n    if (entry === this.head) {\n      this.head = entry.newer\n    }\n    entry.newer.older = entry.older // C <-- E.\n  }\n  if (entry.older) {\n    entry.older.newer = entry.newer // C. --> E\n  }\n  entry.newer = undefined // D --x\n  entry.older = this.tail // D. --> E\n  if (this.tail) {\n    this.tail.newer = entry // E. <-- D\n  }\n  this.tail = entry\n  return returnEntry\n    ? entry\n    : entry.value\n}\n\nmodule.exports = Cache\n\n},{}],80:[function(require,module,exports){\n(function (process){\nvar _ = require('../util')\nvar dirParser = require('../parsers/directive')\nvar propDef = require('../directives/internal/prop')\nvar propBindingModes = require('../config')._propBindingModes\nvar empty = {}\n\n// regexes\nvar identRE = require('../parsers/path').identRE\nvar settablePathRE = /^[A-Za-z_$][\\w$]*(\\.[A-Za-z_$][\\w$]*|\\[[^\\[\\]]+\\])*$/\n\n/**\n * Compile props on a root element and return\n * a props link function.\n *\n * @param {Element|DocumentFragment} el\n * @param {Array} propOptions\n * @return {Function} propsLinkFn\n */\n\nmodule.exports = function compileProps (el, propOptions) {\n  var props = []\n  var names = Object.keys(propOptions)\n  var i = names.length\n  var options, name, attr, value, path, parsed, prop, isTitleBinding\n  while (i--) {\n    name = names[i]\n    options = propOptions[name] || empty\n\n    if (process.env.NODE_ENV !== 'production' && name === '$data') {\n      _.warn('Do not use $data as prop.')\n      continue\n    }\n\n    // props could contain dashes, which will be\n    // interpreted as minus calculations by the parser\n    // so we need to camelize the path here\n    path = _.camelize(name)\n    if (!identRE.test(path)) {\n      process.env.NODE_ENV !== 'production' && _.warn(\n        'Invalid prop key: \"' + name + '\". Prop keys ' +\n        'must be valid identifiers.'\n      )\n      continue\n    }\n\n    prop = {\n      name: name,\n      path: path,\n      options: options,\n      mode: propBindingModes.ONE_WAY\n    }\n\n    // IE title issues\n    isTitleBinding = false\n    if (name === 'title' && (el.getAttribute(':title') || el.getAttribute('v-bind:title'))) {\n      isTitleBinding = true\n    }\n\n    // first check literal version\n    attr = _.hyphenate(name)\n    value = prop.raw = _.attr(el, attr)\n    if (value === null || isTitleBinding) {\n      // then check dynamic version\n      if ((value = _.getBindAttr(el, attr)) === null) {\n        if ((value = _.getBindAttr(el, attr + '.sync')) !== null) {\n          prop.mode = propBindingModes.TWO_WAY\n        } else if ((value = _.getBindAttr(el, attr + '.once')) !== null) {\n          prop.mode = propBindingModes.ONE_TIME\n        }\n      }\n      prop.raw = value\n      if (value !== null) {\n        parsed = dirParser.parse(value)\n        value = parsed.expression\n        prop.filters = parsed.filters\n        // check binding type\n        if (_.isLiteral(value)) {\n          // for expressions containing literal numbers and\n          // booleans, there's no need to setup a prop binding,\n          // so we can optimize them as a one-time set.\n          prop.optimizedLiteral = true\n        } else {\n          prop.dynamic = true\n          // check non-settable path for two-way bindings\n          if (process.env.NODE_ENV !== 'production' &&\n              prop.mode === propBindingModes.TWO_WAY &&\n              !settablePathRE.test(value)) {\n            prop.mode = propBindingModes.ONE_WAY\n            _.warn(\n              'Cannot bind two-way prop with non-settable ' +\n              'parent path: ' + value\n            )\n          }\n        }\n        prop.parentPath = value\n\n        // warn required two-way\n        if (\n          process.env.NODE_ENV !== 'production' &&\n          options.twoWay &&\n          prop.mode !== propBindingModes.TWO_WAY\n        ) {\n          _.warn(\n            'Prop \"' + name + '\" expects a two-way binding type.'\n          )\n        }\n\n      } else if (options.required) {\n        // warn missing required\n        process.env.NODE_ENV !== 'production' && _.warn(\n          'Missing required prop: ' + name\n        )\n      }\n    }\n\n    // push prop\n    props.push(prop)\n  }\n  return makePropsLinkFn(props)\n}\n\n/**\n * Build a function that applies props to a vm.\n *\n * @param {Array} props\n * @return {Function} propsLinkFn\n */\n\nfunction makePropsLinkFn (props) {\n  return function propsLinkFn (vm, scope) {\n    // store resolved props info\n    vm._props = {}\n    var i = props.length\n    var prop, path, options, value, raw\n    while (i--) {\n      prop = props[i]\n      raw = prop.raw\n      path = prop.path\n      options = prop.options\n      vm._props[path] = prop\n      if (raw === null) {\n        // initialize absent prop\n        _.initProp(vm, prop, getDefault(vm, options))\n      } else if (prop.dynamic) {\n        // dynamic prop\n        if (vm._context) {\n          if (prop.mode === propBindingModes.ONE_TIME) {\n            // one time binding\n            value = (scope || vm._context).$get(prop.parentPath)\n            _.initProp(vm, prop, value)\n          } else {\n            // dynamic binding\n            vm._bindDir({\n              name: 'prop',\n              def: propDef,\n              prop: prop\n            }, null, null, scope) // el, host, scope\n          }\n        } else {\n          process.env.NODE_ENV !== 'production' && _.warn(\n            'Cannot bind dynamic prop on a root instance' +\n            ' with no parent: ' + prop.name + '=\"' +\n            raw + '\"'\n          )\n        }\n      } else if (prop.optimizedLiteral) {\n        // optimized literal, cast it and just set once\n        raw = _.stripQuotes(raw)\n        value = _.toBoolean(_.toNumber(raw))\n        _.initProp(vm, prop, value)\n      } else {\n        // string literal, but we need to cater for\n        // Boolean props with no value\n        value = options.type === Boolean && raw === ''\n          ? true\n          : raw\n        _.initProp(vm, prop, value)\n      }\n    }\n  }\n}\n\n/**\n * Get the default value of a prop.\n *\n * @param {Vue} vm\n * @param {Object} options\n * @return {*}\n */\n\nfunction getDefault (vm, options) {\n  // no default, return undefined\n  if (!options.hasOwnProperty('default')) {\n    // absent boolean value defaults to false\n    return options.type === Boolean\n      ? false\n      : undefined\n  }\n  var def = options.default\n  // warn against non-factory defaults for Object & Array\n  if (_.isObject(def)) {\n    process.env.NODE_ENV !== 'production' && _.warn(\n      'Object/Array as default prop values will be shared ' +\n      'across multiple instances. Use a factory function ' +\n      'to return the default value instead.'\n    )\n  }\n  // call factory function for non-Function types\n  return typeof def === 'function' && options.type !== Function\n    ? def.call(vm)\n    : def\n}\n\n}).call(this,require('_process'))\n\n},{\"../config\":84,\"../directives/internal/prop\":92,\"../parsers/directive\":123,\"../parsers/path\":125,\"../util\":135,\"_process\":1}],81:[function(require,module,exports){\n(function (process){\nvar _ = require('../util')\nvar publicDirectives = require('../directives/public')\nvar internalDirectives = require('../directives/internal')\nvar compileProps = require('./compile-props')\nvar textParser = require('../parsers/text')\nvar dirParser = require('../parsers/directive')\nvar templateParser = require('../parsers/template')\nvar resolveAsset = _.resolveAsset\n\n// special binding prefixes\nvar bindRE = /^v-bind:|^:/\nvar onRE = /^v-on:|^@/\nvar argRE = /:(.*)$/\nvar modifierRE = /\\.[^\\.]+/g\nvar transitionRE = /^(v-bind:|:)?transition$/\n\n// terminal directives\nvar terminalDirectives = [\n  'for',\n  'if'\n]\n\n// default directive priority\nvar DEFAULT_PRIORITY = 1000\n\n/**\n * Compile a template and return a reusable composite link\n * function, which recursively contains more link functions\n * inside. This top level compile function would normally\n * be called on instance root nodes, but can also be used\n * for partial compilation if the partial argument is true.\n *\n * The returned composite link function, when called, will\n * return an unlink function that tearsdown all directives\n * created during the linking phase.\n *\n * @param {Element|DocumentFragment} el\n * @param {Object} options\n * @param {Boolean} partial\n * @return {Function}\n */\n\nexports.compile = function (el, options, partial) {\n  // link function for the node itself.\n  var nodeLinkFn = partial || !options._asComponent\n    ? compileNode(el, options)\n    : null\n  // link function for the childNodes\n  var childLinkFn =\n    !(nodeLinkFn && nodeLinkFn.terminal) &&\n    el.tagName !== 'SCRIPT' &&\n    el.hasChildNodes()\n      ? compileNodeList(el.childNodes, options)\n      : null\n\n  /**\n   * A composite linker function to be called on a already\n   * compiled piece of DOM, which instantiates all directive\n   * instances.\n   *\n   * @param {Vue} vm\n   * @param {Element|DocumentFragment} el\n   * @param {Vue} [host] - host vm of transcluded content\n   * @param {Object} [scope] - v-for scope\n   * @param {Fragment} [frag] - link context fragment\n   * @return {Function|undefined}\n   */\n\n  return function compositeLinkFn (vm, el, host, scope, frag) {\n    // cache childNodes before linking parent, fix #657\n    var childNodes = _.toArray(el.childNodes)\n    // link\n    var dirs = linkAndCapture(function compositeLinkCapturer () {\n      if (nodeLinkFn) nodeLinkFn(vm, el, host, scope, frag)\n      if (childLinkFn) childLinkFn(vm, childNodes, host, scope, frag)\n    }, vm)\n    return makeUnlinkFn(vm, dirs)\n  }\n}\n\n/**\n * Apply a linker to a vm/element pair and capture the\n * directives created during the process.\n *\n * @param {Function} linker\n * @param {Vue} vm\n */\n\nfunction linkAndCapture (linker, vm) {\n  var originalDirCount = vm._directives.length\n  linker()\n  var dirs = vm._directives.slice(originalDirCount)\n  dirs.sort(directiveComparator)\n  for (var i = 0, l = dirs.length; i < l; i++) {\n    dirs[i]._bind()\n  }\n  return dirs\n}\n\n/**\n * Directive priority sort comparator\n *\n * @param {Object} a\n * @param {Object} b\n */\n\nfunction directiveComparator (a, b) {\n  a = a.descriptor.def.priority || DEFAULT_PRIORITY\n  b = b.descriptor.def.priority || DEFAULT_PRIORITY\n  return a > b ? -1 : a === b ? 0 : 1\n}\n\n/**\n * Linker functions return an unlink function that\n * tearsdown all directives instances generated during\n * the process.\n *\n * We create unlink functions with only the necessary\n * information to avoid retaining additional closures.\n *\n * @param {Vue} vm\n * @param {Array} dirs\n * @param {Vue} [context]\n * @param {Array} [contextDirs]\n * @return {Function}\n */\n\nfunction makeUnlinkFn (vm, dirs, context, contextDirs) {\n  return function unlink (destroying) {\n    teardownDirs(vm, dirs, destroying)\n    if (context && contextDirs) {\n      teardownDirs(context, contextDirs)\n    }\n  }\n}\n\n/**\n * Teardown partial linked directives.\n *\n * @param {Vue} vm\n * @param {Array} dirs\n * @param {Boolean} destroying\n */\n\nfunction teardownDirs (vm, dirs, destroying) {\n  var i = dirs.length\n  while (i--) {\n    dirs[i]._teardown()\n    if (!destroying) {\n      vm._directives.$remove(dirs[i])\n    }\n  }\n}\n\n/**\n * Compile link props on an instance.\n *\n * @param {Vue} vm\n * @param {Element} el\n * @param {Object} props\n * @param {Object} [scope]\n * @return {Function}\n */\n\nexports.compileAndLinkProps = function (vm, el, props, scope) {\n  var propsLinkFn = compileProps(el, props)\n  var propDirs = linkAndCapture(function () {\n    propsLinkFn(vm, scope)\n  }, vm)\n  return makeUnlinkFn(vm, propDirs)\n}\n\n/**\n * Compile the root element of an instance.\n *\n * 1. attrs on context container (context scope)\n * 2. attrs on the component template root node, if\n *    replace:true (child scope)\n *\n * If this is a fragment instance, we only need to compile 1.\n *\n * @param {Vue} vm\n * @param {Element} el\n * @param {Object} options\n * @param {Object} contextOptions\n * @return {Function}\n */\n\nexports.compileRoot = function (el, options, contextOptions) {\n  var containerAttrs = options._containerAttrs\n  var replacerAttrs = options._replacerAttrs\n  var contextLinkFn, replacerLinkFn\n\n  // only need to compile other attributes for\n  // non-fragment instances\n  if (el.nodeType !== 11) {\n    // for components, container and replacer need to be\n    // compiled separately and linked in different scopes.\n    if (options._asComponent) {\n      // 2. container attributes\n      if (containerAttrs && contextOptions) {\n        contextLinkFn = compileDirectives(containerAttrs, contextOptions)\n      }\n      if (replacerAttrs) {\n        // 3. replacer attributes\n        replacerLinkFn = compileDirectives(replacerAttrs, options)\n      }\n    } else {\n      // non-component, just compile as a normal element.\n      replacerLinkFn = compileDirectives(el.attributes, options)\n    }\n  } else if (process.env.NODE_ENV !== 'production' && containerAttrs) {\n    // warn container directives for fragment instances\n    var names = containerAttrs.map(function (attr) {\n      return '\"' + attr.name + '\"'\n    }).join(', ')\n    var plural = containerAttrs.length > 1\n    _.warn(\n      'Attribute' + (plural ? 's ' : ' ') + names +\n      (plural ? ' are' : ' is') + ' ignored on component ' +\n      '<' + options.el.tagName.toLowerCase() + '> because ' +\n      'the component is a fragment instance: ' +\n      'http://vuejs.org/guide/components.html#Fragment_Instance'\n    )\n  }\n\n  return function rootLinkFn (vm, el, scope) {\n    // link context scope dirs\n    var context = vm._context\n    var contextDirs\n    if (context && contextLinkFn) {\n      contextDirs = linkAndCapture(function () {\n        contextLinkFn(context, el, null, scope)\n      }, context)\n    }\n\n    // link self\n    var selfDirs = linkAndCapture(function () {\n      if (replacerLinkFn) replacerLinkFn(vm, el)\n    }, vm)\n\n    // return the unlink function that tearsdown context\n    // container directives.\n    return makeUnlinkFn(vm, selfDirs, context, contextDirs)\n  }\n}\n\n/**\n * Compile a node and return a nodeLinkFn based on the\n * node type.\n *\n * @param {Node} node\n * @param {Object} options\n * @return {Function|null}\n */\n\nfunction compileNode (node, options) {\n  var type = node.nodeType\n  if (type === 1 && node.tagName !== 'SCRIPT') {\n    return compileElement(node, options)\n  } else if (type === 3 && node.data.trim()) {\n    return compileTextNode(node, options)\n  } else {\n    return null\n  }\n}\n\n/**\n * Compile an element and return a nodeLinkFn.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Function|null}\n */\n\nfunction compileElement (el, options) {\n  // preprocess textareas.\n  // textarea treats its text content as the initial value.\n  // just bind it as an attr directive for value.\n  if (el.tagName === 'TEXTAREA') {\n    var tokens = textParser.parse(el.value)\n    if (tokens) {\n      el.setAttribute(':value', textParser.tokensToExp(tokens))\n      el.value = ''\n    }\n  }\n  var linkFn\n  var hasAttrs = el.hasAttributes()\n  // check terminal directives (for & if)\n  if (hasAttrs) {\n    linkFn = checkTerminalDirectives(el, options)\n  }\n  // check element directives\n  if (!linkFn) {\n    linkFn = checkElementDirectives(el, options)\n  }\n  // check component\n  if (!linkFn) {\n    linkFn = checkComponent(el, options)\n  }\n  // normal directives\n  if (!linkFn && hasAttrs) {\n    linkFn = compileDirectives(el.attributes, options)\n  }\n  return linkFn\n}\n\n/**\n * Compile a textNode and return a nodeLinkFn.\n *\n * @param {TextNode} node\n * @param {Object} options\n * @return {Function|null} textNodeLinkFn\n */\n\nfunction compileTextNode (node, options) {\n  var tokens = textParser.parse(node.data)\n  if (!tokens) {\n    return null\n  }\n  var frag = document.createDocumentFragment()\n  var el, token\n  for (var i = 0, l = tokens.length; i < l; i++) {\n    token = tokens[i]\n    el = token.tag\n      ? processTextToken(token, options)\n      : document.createTextNode(token.value)\n    frag.appendChild(el)\n  }\n  return makeTextNodeLinkFn(tokens, frag, options)\n}\n\n/**\n * Process a single text token.\n *\n * @param {Object} token\n * @param {Object} options\n * @return {Node}\n */\n\nfunction processTextToken (token, options) {\n  var el\n  if (token.oneTime) {\n    el = document.createTextNode(token.value)\n  } else {\n    if (token.html) {\n      el = document.createComment('v-html')\n      setTokenType('html')\n    } else {\n      // IE will clean up empty textNodes during\n      // frag.cloneNode(true), so we have to give it\n      // something here...\n      el = document.createTextNode(' ')\n      setTokenType('text')\n    }\n  }\n  function setTokenType (type) {\n    if (token.descriptor) return\n    var parsed = dirParser.parse(token.value)\n    token.descriptor = {\n      name: type,\n      def: publicDirectives[type],\n      expression: parsed.expression,\n      filters: parsed.filters\n    }\n  }\n  return el\n}\n\n/**\n * Build a function that processes a textNode.\n *\n * @param {Array<Object>} tokens\n * @param {DocumentFragment} frag\n */\n\nfunction makeTextNodeLinkFn (tokens, frag) {\n  return function textNodeLinkFn (vm, el, host, scope) {\n    var fragClone = frag.cloneNode(true)\n    var childNodes = _.toArray(fragClone.childNodes)\n    var token, value, node\n    for (var i = 0, l = tokens.length; i < l; i++) {\n      token = tokens[i]\n      value = token.value\n      if (token.tag) {\n        node = childNodes[i]\n        if (token.oneTime) {\n          value = (scope || vm).$eval(value)\n          if (token.html) {\n            _.replace(node, templateParser.parse(value, true))\n          } else {\n            node.data = value\n          }\n        } else {\n          vm._bindDir(token.descriptor, node, host, scope)\n        }\n      }\n    }\n    _.replace(el, fragClone)\n  }\n}\n\n/**\n * Compile a node list and return a childLinkFn.\n *\n * @param {NodeList} nodeList\n * @param {Object} options\n * @return {Function|undefined}\n */\n\nfunction compileNodeList (nodeList, options) {\n  var linkFns = []\n  var nodeLinkFn, childLinkFn, node\n  for (var i = 0, l = nodeList.length; i < l; i++) {\n    node = nodeList[i]\n    nodeLinkFn = compileNode(node, options)\n    childLinkFn =\n      !(nodeLinkFn && nodeLinkFn.terminal) &&\n      node.tagName !== 'SCRIPT' &&\n      node.hasChildNodes()\n        ? compileNodeList(node.childNodes, options)\n        : null\n    linkFns.push(nodeLinkFn, childLinkFn)\n  }\n  return linkFns.length\n    ? makeChildLinkFn(linkFns)\n    : null\n}\n\n/**\n * Make a child link function for a node's childNodes.\n *\n * @param {Array<Function>} linkFns\n * @return {Function} childLinkFn\n */\n\nfunction makeChildLinkFn (linkFns) {\n  return function childLinkFn (vm, nodes, host, scope, frag) {\n    var node, nodeLinkFn, childrenLinkFn\n    for (var i = 0, n = 0, l = linkFns.length; i < l; n++) {\n      node = nodes[n]\n      nodeLinkFn = linkFns[i++]\n      childrenLinkFn = linkFns[i++]\n      // cache childNodes before linking parent, fix #657\n      var childNodes = _.toArray(node.childNodes)\n      if (nodeLinkFn) {\n        nodeLinkFn(vm, node, host, scope, frag)\n      }\n      if (childrenLinkFn) {\n        childrenLinkFn(vm, childNodes, host, scope, frag)\n      }\n    }\n  }\n}\n\n/**\n * Check for element directives (custom elements that should\n * be resovled as terminal directives).\n *\n * @param {Element} el\n * @param {Object} options\n */\n\nfunction checkElementDirectives (el, options) {\n  var tag = el.tagName.toLowerCase()\n  if (_.commonTagRE.test(tag)) return\n  var def = resolveAsset(options, 'elementDirectives', tag)\n  if (def) {\n    return makeTerminalNodeLinkFn(el, tag, '', options, def)\n  }\n}\n\n/**\n * Check if an element is a component. If yes, return\n * a component link function.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Function|undefined}\n */\n\nfunction checkComponent (el, options) {\n  var component = _.checkComponent(el, options)\n  if (component) {\n    var descriptor = {\n      name: 'component',\n      expression: component.id,\n      def: internalDirectives.component,\n      modifiers: {\n        literal: !component.dynamic\n      }\n    }\n    var componentLinkFn = function (vm, el, host, scope, frag) {\n      vm._bindDir(descriptor, el, host, scope, frag)\n    }\n    componentLinkFn.terminal = true\n    return componentLinkFn\n  }\n}\n\n/**\n * Check an element for terminal directives in fixed order.\n * If it finds one, return a terminal link function.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Function} terminalLinkFn\n */\n\nfunction checkTerminalDirectives (el, options) {\n  // skip v-pre\n  if (_.attr(el, 'v-pre') !== null) {\n    return skip\n  }\n  // skip v-else block, but only if following v-if\n  if (el.hasAttribute('v-else')) {\n    var prev = el.previousElementSibling\n    if (prev && prev.hasAttribute('v-if')) {\n      return skip\n    }\n  }\n  var value, dirName\n  for (var i = 0, l = terminalDirectives.length; i < l; i++) {\n    dirName = terminalDirectives[i]\n    /* eslint-disable no-cond-assign */\n    if (value = el.getAttribute('v-' + dirName)) {\n      return makeTerminalNodeLinkFn(el, dirName, value, options)\n    }\n    /* eslint-enable no-cond-assign */\n  }\n}\n\nfunction skip () {}\nskip.terminal = true\n\n/**\n * Build a node link function for a terminal directive.\n * A terminal link function terminates the current\n * compilation recursion and handles compilation of the\n * subtree in the directive.\n *\n * @param {Element} el\n * @param {String} dirName\n * @param {String} value\n * @param {Object} options\n * @param {Object} [def]\n * @return {Function} terminalLinkFn\n */\n\nfunction makeTerminalNodeLinkFn (el, dirName, value, options, def) {\n  var parsed = dirParser.parse(value)\n  var descriptor = {\n    name: dirName,\n    expression: parsed.expression,\n    filters: parsed.filters,\n    raw: value,\n    // either an element directive, or if/for\n    def: def || publicDirectives[dirName]\n  }\n  var fn = function terminalNodeLinkFn (vm, el, host, scope, frag) {\n    vm._bindDir(descriptor, el, host, scope, frag)\n  }\n  fn.terminal = true\n  return fn\n}\n\n/**\n * Compile the directives on an element and return a linker.\n *\n * @param {Array|NamedNodeMap} attrs\n * @param {Object} options\n * @return {Function}\n */\n\nfunction compileDirectives (attrs, options) {\n  var i = attrs.length\n  var dirs = []\n  var attr, name, value, rawName, rawValue, dirName, arg, modifiers, dirDef, tokens\n  while (i--) {\n    attr = attrs[i]\n    name = rawName = attr.name\n    value = rawValue = attr.value\n    tokens = textParser.parse(value)\n    // reset arg\n    arg = null\n    // check modifiers\n    modifiers = parseModifiers(name)\n    name = name.replace(modifierRE, '')\n\n    // attribute interpolations\n    if (tokens) {\n      value = textParser.tokensToExp(tokens)\n      arg = name\n      pushDir('bind', publicDirectives.bind, true)\n    } else\n\n    // special attribute: transition\n    if (transitionRE.test(name)) {\n      modifiers.literal = !bindRE.test(name)\n      pushDir('transition', internalDirectives.transition)\n    } else\n\n    // event handlers\n    if (onRE.test(name)) {\n      arg = name.replace(onRE, '')\n      pushDir('on', publicDirectives.on)\n    } else\n\n    // attribute bindings\n    if (bindRE.test(name)) {\n      dirName = name.replace(bindRE, '')\n      if (dirName === 'style' || dirName === 'class') {\n        pushDir(dirName, internalDirectives[dirName])\n      } else {\n        arg = dirName\n        pushDir('bind', publicDirectives.bind)\n      }\n    } else\n\n    // normal directives\n    if (name.indexOf('v-') === 0) {\n      // check arg\n      arg = (arg = name.match(argRE)) && arg[1]\n      if (arg) {\n        name = name.replace(argRE, '')\n      }\n      // extract directive name\n      dirName = name.slice(2)\n\n      // skip v-else (when used with v-show)\n      if (dirName === 'else') {\n        continue\n      }\n\n      dirDef = resolveAsset(options, 'directives', dirName)\n\n      if (process.env.NODE_ENV !== 'production') {\n        _.assertAsset(dirDef, 'directive', dirName)\n      }\n\n      if (dirDef) {\n        if (_.isLiteral(value)) {\n          value = _.stripQuotes(value)\n          modifiers.literal = true\n        }\n        pushDir(dirName, dirDef)\n      }\n    }\n  }\n\n  /**\n   * Push a directive.\n   *\n   * @param {String} dirName\n   * @param {Object|Function} def\n   * @param {Boolean} [interp]\n   */\n\n  function pushDir (dirName, def, interp) {\n    var parsed = dirParser.parse(value)\n    dirs.push({\n      name: dirName,\n      attr: rawName,\n      raw: rawValue,\n      def: def,\n      arg: arg,\n      modifiers: modifiers,\n      expression: parsed.expression,\n      filters: parsed.filters,\n      interp: interp\n    })\n  }\n\n  if (dirs.length) {\n    return makeNodeLinkFn(dirs)\n  }\n}\n\n/**\n * Parse modifiers from directive attribute name.\n *\n * @param {String} name\n * @return {Object}\n */\n\nfunction parseModifiers (name) {\n  var res = Object.create(null)\n  var match = name.match(modifierRE)\n  if (match) {\n    var i = match.length\n    while (i--) {\n      res[match[i].slice(1)] = true\n    }\n  }\n  return res\n}\n\n/**\n * Build a link function for all directives on a single node.\n *\n * @param {Array} directives\n * @return {Function} directivesLinkFn\n */\n\nfunction makeNodeLinkFn (directives) {\n  return function nodeLinkFn (vm, el, host, scope, frag) {\n    // reverse apply because it's sorted low to high\n    var i = directives.length\n    while (i--) {\n      vm._bindDir(directives[i], el, host, scope, frag)\n    }\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"../directives/internal\":91,\"../directives/public\":101,\"../parsers/directive\":123,\"../parsers/template\":126,\"../parsers/text\":127,\"../util\":135,\"./compile-props\":80,\"_process\":1}],82:[function(require,module,exports){\nvar _ = require('../util')\n\n_.extend(exports, require('./compile'))\n_.extend(exports, require('./transclude'))\n\n},{\"../util\":135,\"./compile\":81,\"./transclude\":83}],83:[function(require,module,exports){\n(function (process){\nvar _ = require('../util')\nvar templateParser = require('../parsers/template')\nvar specialCharRE = /[^\\w\\-:\\.]/\n\n/**\n * Process an element or a DocumentFragment based on a\n * instance option object. This allows us to transclude\n * a template node/fragment before the instance is created,\n * so the processed fragment can then be cloned and reused\n * in v-for.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Element|DocumentFragment}\n */\n\nexports.transclude = function (el, options) {\n  // extract container attributes to pass them down\n  // to compiler, because they need to be compiled in\n  // parent scope. we are mutating the options object here\n  // assuming the same object will be used for compile\n  // right after this.\n  if (options) {\n    options._containerAttrs = extractAttrs(el)\n  }\n  // for template tags, what we want is its content as\n  // a documentFragment (for fragment instances)\n  if (_.isTemplate(el)) {\n    el = templateParser.parse(el)\n  }\n  if (options) {\n    if (options._asComponent && !options.template) {\n      options.template = '<slot></slot>'\n    }\n    if (options.template) {\n      options._content = _.extractContent(el)\n      el = transcludeTemplate(el, options)\n    }\n  }\n  if (el instanceof DocumentFragment) {\n    // anchors for fragment instance\n    // passing in `persist: true` to avoid them being\n    // discarded by IE during template cloning\n    _.prepend(_.createAnchor('v-start', true), el)\n    el.appendChild(_.createAnchor('v-end', true))\n  }\n  return el\n}\n\n/**\n * Process the template option.\n * If the replace option is true this will swap the $el.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Element|DocumentFragment}\n */\n\nfunction transcludeTemplate (el, options) {\n  var template = options.template\n  var frag = templateParser.parse(template, true)\n  if (frag) {\n    var replacer = frag.firstChild\n    var tag = replacer.tagName && replacer.tagName.toLowerCase()\n    if (options.replace) {\n      /* istanbul ignore if */\n      if (el === document.body) {\n        process.env.NODE_ENV !== 'production' && _.warn(\n          'You are mounting an instance with a template to ' +\n          '<body>. This will replace <body> entirely. You ' +\n          'should probably use `replace: false` here.'\n        )\n      }\n      // there are many cases where the instance must\n      // become a fragment instance: basically anything that\n      // can create more than 1 root nodes.\n      if (\n        // multi-children template\n        frag.childNodes.length > 1 ||\n        // non-element template\n        replacer.nodeType !== 1 ||\n        // single nested component\n        tag === 'component' ||\n        _.resolveAsset(options, 'components', tag) ||\n        replacer.hasAttribute('is') ||\n        replacer.hasAttribute(':is') ||\n        replacer.hasAttribute('v-bind:is') ||\n        // element directive\n        _.resolveAsset(options, 'elementDirectives', tag) ||\n        // for block\n        replacer.hasAttribute('v-for') ||\n        // if block\n        replacer.hasAttribute('v-if')\n      ) {\n        return frag\n      } else {\n        options._replacerAttrs = extractAttrs(replacer)\n        mergeAttrs(el, replacer)\n        return replacer\n      }\n    } else {\n      el.appendChild(frag)\n      return el\n    }\n  } else {\n    process.env.NODE_ENV !== 'production' && _.warn(\n      'Invalid template option: ' + template\n    )\n  }\n}\n\n/**\n * Helper to extract a component container's attributes\n * into a plain object array.\n *\n * @param {Element} el\n * @return {Array}\n */\n\nfunction extractAttrs (el) {\n  if (el.nodeType === 1 && el.hasAttributes()) {\n    return _.toArray(el.attributes)\n  }\n}\n\n/**\n * Merge the attributes of two elements, and make sure\n * the class names are merged properly.\n *\n * @param {Element} from\n * @param {Element} to\n */\n\nfunction mergeAttrs (from, to) {\n  var attrs = from.attributes\n  var i = attrs.length\n  var name, value\n  while (i--) {\n    name = attrs[i].name\n    value = attrs[i].value\n    if (!to.hasAttribute(name) && !specialCharRE.test(name)) {\n      to.setAttribute(name, value)\n    } else if (name === 'class') {\n      value = to.getAttribute(name) + ' ' + value\n      to.setAttribute(name, value)\n    }\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"../parsers/template\":126,\"../util\":135,\"_process\":1}],84:[function(require,module,exports){\nmodule.exports = {\n\n  /**\n   * Whether to print debug messages.\n   * Also enables stack trace for warnings.\n   *\n   * @type {Boolean}\n   */\n\n  debug: false,\n\n  /**\n   * Whether to suppress warnings.\n   *\n   * @type {Boolean}\n   */\n\n  silent: false,\n\n  /**\n   * Whether to use async rendering.\n   */\n\n  async: true,\n\n  /**\n   * Whether to warn against errors caught when evaluating\n   * expressions.\n   */\n\n  warnExpressionErrors: true,\n\n  /**\n   * Internal flag to indicate the delimiters have been\n   * changed.\n   *\n   * @type {Boolean}\n   */\n\n  _delimitersChanged: true,\n\n  /**\n   * List of asset types that a component can own.\n   *\n   * @type {Array}\n   */\n\n  _assetTypes: [\n    'component',\n    'directive',\n    'elementDirective',\n    'filter',\n    'transition',\n    'partial'\n  ],\n\n  /**\n   * prop binding modes\n   */\n\n  _propBindingModes: {\n    ONE_WAY: 0,\n    TWO_WAY: 1,\n    ONE_TIME: 2\n  },\n\n  /**\n   * Max circular updates allowed in a batcher flush cycle.\n   */\n\n  _maxUpdateCount: 100\n\n}\n\n/**\n * Interpolation delimiters. Changing these would trigger\n * the text parser to re-compile the regular expressions.\n *\n * @type {Array<String>}\n */\n\nvar delimiters = ['{{', '}}']\nvar unsafeDelimiters = ['{{{', '}}}']\nvar textParser = require('./parsers/text')\n\nObject.defineProperty(module.exports, 'delimiters', {\n  get: function () {\n    return delimiters\n  },\n  set: function (val) {\n    delimiters = val\n    textParser.compileRegex()\n  }\n})\n\nObject.defineProperty(module.exports, 'unsafeDelimiters', {\n  get: function () {\n    return unsafeDelimiters\n  },\n  set: function (val) {\n    unsafeDelimiters = val\n    textParser.compileRegex()\n  }\n})\n\n},{\"./parsers/text\":127}],85:[function(require,module,exports){\n(function (process){\nvar _ = require('./util')\nvar Watcher = require('./watcher')\nvar expParser = require('./parsers/expression')\nfunction noop () {}\n\n/**\n * A directive links a DOM element with a piece of data,\n * which is the result of evaluating an expression.\n * It registers a watcher with the expression and calls\n * the DOM update function when a change is triggered.\n *\n * @param {String} name\n * @param {Node} el\n * @param {Vue} vm\n * @param {Object} descriptor\n *                 - {String} name\n *                 - {Object} def\n *                 - {String} expression\n *                 - {Array<Object>} [filters]\n *                 - {Boolean} literal\n *                 - {String} attr\n *                 - {String} raw\n * @param {Object} def - directive definition object\n * @param {Vue} [host] - transclusion host component\n * @param {Object} [scope] - v-for scope\n * @param {Fragment} [frag] - owner fragment\n * @constructor\n */\n\nfunction Directive (descriptor, vm, el, host, scope, frag) {\n  this.vm = vm\n  this.el = el\n  // copy descriptor properties\n  this.descriptor = descriptor\n  this.name = descriptor.name\n  this.expression = descriptor.expression\n  this.arg = descriptor.arg\n  this.modifiers = descriptor.modifiers\n  this.filters = descriptor.filters\n  this.literal = this.modifiers && this.modifiers.literal\n  // private\n  this._locked = false\n  this._bound = false\n  this._listeners = null\n  // link context\n  this._host = host\n  this._scope = scope\n  this._frag = frag\n  // store directives on node in dev mode\n  if (process.env.NODE_ENV !== 'production' && this.el) {\n    this.el._vue_directives = this.el._vue_directives || []\n    this.el._vue_directives.push(this)\n  }\n}\n\n/**\n * Initialize the directive, mixin definition properties,\n * setup the watcher, call definition bind() and update()\n * if present.\n *\n * @param {Object} def\n */\n\nDirective.prototype._bind = function () {\n  var name = this.name\n  var descriptor = this.descriptor\n\n  // remove attribute\n  if (\n    (name !== 'cloak' || this.vm._isCompiled) &&\n    this.el && this.el.removeAttribute\n  ) {\n    var attr = descriptor.attr || ('v-' + name)\n    this.el.removeAttribute(attr)\n  }\n\n  // copy def properties\n  var def = descriptor.def\n  if (typeof def === 'function') {\n    this.update = def\n  } else {\n    _.extend(this, def)\n  }\n\n  // setup directive params\n  this._setupParams()\n\n  // initial bind\n  if (this.bind) {\n    this.bind()\n  }\n\n  if (this.literal) {\n    this.update && this.update(descriptor.raw)\n  } else if (\n    (this.expression || this.modifiers) &&\n    (this.update || this.twoWay) &&\n    !this._checkStatement()\n  ) {\n    // wrapped updater for context\n    var dir = this\n    if (this.update) {\n      this._update = function (val, oldVal) {\n        if (!dir._locked) {\n          dir.update(val, oldVal)\n        }\n      }\n    } else {\n      this._update = noop\n    }\n    var preProcess = this._preProcess\n      ? _.bind(this._preProcess, this)\n      : null\n    var postProcess = this._postProcess\n      ? _.bind(this._postProcess, this)\n      : null\n    var watcher = this._watcher = new Watcher(\n      this.vm,\n      this.expression,\n      this._update, // callback\n      {\n        filters: this.filters,\n        twoWay: this.twoWay,\n        deep: this.deep,\n        preProcess: preProcess,\n        postProcess: postProcess,\n        scope: this._scope\n      }\n    )\n    // v-model with inital inline value need to sync back to\n    // model instead of update to DOM on init. They would\n    // set the afterBind hook to indicate that.\n    if (this.afterBind) {\n      this.afterBind()\n    } else if (this.update) {\n      this.update(watcher.value)\n    }\n  }\n  this._bound = true\n}\n\n/**\n * Setup all param attributes, e.g. track-by,\n * transition-mode, etc...\n */\n\nDirective.prototype._setupParams = function () {\n  if (!this.params) {\n    return\n  }\n  var params = this.params\n  // swap the params array with a fresh object.\n  this.params = Object.create(null)\n  var i = params.length\n  var key, val, mappedKey\n  while (i--) {\n    key = params[i]\n    mappedKey = _.camelize(key)\n    val = _.getBindAttr(this.el, key)\n    if (val != null) {\n      // dynamic\n      this._setupParamWatcher(mappedKey, val)\n    } else {\n      // static\n      val = _.attr(this.el, key)\n      if (val != null) {\n        this.params[mappedKey] = val === '' ? true : val\n      }\n    }\n  }\n}\n\n/**\n * Setup a watcher for a dynamic param.\n *\n * @param {String} key\n * @param {String} expression\n */\n\nDirective.prototype._setupParamWatcher = function (key, expression) {\n  var self = this\n  var called = false\n  var unwatch = (this._scope || this.vm).$watch(expression, function (val, oldVal) {\n    self.params[key] = val\n    // since we are in immediate mode,\n    // only call the param change callbacks if this is not the first update.\n    if (called) {\n      var cb = self.paramWatchers && self.paramWatchers[key]\n      if (cb) {\n        cb.call(self, val, oldVal)\n      }\n    } else {\n      called = true\n    }\n  }, {\n    immediate: true\n  })\n  ;(this._paramUnwatchFns || (this._paramUnwatchFns = [])).push(unwatch)\n}\n\n/**\n * Check if the directive is a function caller\n * and if the expression is a callable one. If both true,\n * we wrap up the expression and use it as the event\n * handler.\n *\n * e.g. on-click=\"a++\"\n *\n * @return {Boolean}\n */\n\nDirective.prototype._checkStatement = function () {\n  var expression = this.expression\n  if (\n    expression && this.acceptStatement &&\n    !expParser.isSimplePath(expression)\n  ) {\n    var fn = expParser.parse(expression).get\n    var scope = this._scope || this.vm\n    var handler = function () {\n      fn.call(scope, scope)\n    }\n    if (this.filters) {\n      handler = scope._applyFilters(handler, null, this.filters)\n    }\n    this.update(handler)\n    return true\n  }\n}\n\n/**\n * Set the corresponding value with the setter.\n * This should only be used in two-way directives\n * e.g. v-model.\n *\n * @param {*} value\n * @public\n */\n\nDirective.prototype.set = function (value) {\n  /* istanbul ignore else */\n  if (this.twoWay) {\n    this._withLock(function () {\n      this._watcher.set(value)\n    })\n  } else if (process.env.NODE_ENV !== 'production') {\n    _.warn(\n      'Directive.set() can only be used inside twoWay' +\n      'directives.'\n    )\n  }\n}\n\n/**\n * Execute a function while preventing that function from\n * triggering updates on this directive instance.\n *\n * @param {Function} fn\n */\n\nDirective.prototype._withLock = function (fn) {\n  var self = this\n  self._locked = true\n  fn.call(self)\n  _.nextTick(function () {\n    self._locked = false\n  })\n}\n\n/**\n * Convenience method that attaches a DOM event listener\n * to the directive element and autometically tears it down\n * during unbind.\n *\n * @param {String} event\n * @param {Function} handler\n */\n\nDirective.prototype.on = function (event, handler) {\n  _.on(this.el, event, handler)\n  ;(this._listeners || (this._listeners = []))\n    .push([event, handler])\n}\n\n/**\n * Teardown the watcher and call unbind.\n */\n\nDirective.prototype._teardown = function () {\n  if (this._bound) {\n    this._bound = false\n    if (this.unbind) {\n      this.unbind()\n    }\n    if (this._watcher) {\n      this._watcher.teardown()\n    }\n    var listeners = this._listeners\n    var i\n    if (listeners) {\n      i = listeners.length\n      while (i--) {\n        _.off(this.el, listeners[i][0], listeners[i][1])\n      }\n    }\n    var unwatchFns = this._paramUnwatchFns\n    if (unwatchFns) {\n      i = unwatchFns.length\n      while (i--) {\n        unwatchFns[i]()\n      }\n    }\n    if (process.env.NODE_ENV !== 'production' && this.el) {\n      this.el._vue_directives.$remove(this)\n    }\n    this.vm = this.el = this._watcher = this._listeners = null\n  }\n}\n\nmodule.exports = Directive\n\n}).call(this,require('_process'))\n\n},{\"./parsers/expression\":124,\"./util\":135,\"./watcher\":139,\"_process\":1}],86:[function(require,module,exports){\nexports.slot = require('./slot')\nexports.partial = require('./partial')\n\n},{\"./partial\":87,\"./slot\":88}],87:[function(require,module,exports){\n(function (process){\nvar _ = require('../../util')\nvar vIf = require('../public/if')\nvar FragmentFactory = require('../../fragment/factory')\n\nmodule.exports = {\n\n  priority: 1750,\n\n  params: ['name'],\n\n  // watch changes to name for dynamic partials\n  paramWatchers: {\n    name: function (value) {\n      vIf.remove.call(this)\n      if (value) {\n        this.insert(value)\n      }\n    }\n  },\n\n  bind: function () {\n    this.anchor = _.createAnchor('v-partial')\n    _.replace(this.el, this.anchor)\n    this.insert(this.params.name)\n  },\n\n  insert: function (id) {\n    var partial = _.resolveAsset(this.vm.$options, 'partials', id)\n    if (process.env.NODE_ENV !== 'production') {\n      _.assertAsset(partial, 'partial', id)\n    }\n    if (partial) {\n      this.factory = new FragmentFactory(this.vm, partial)\n      vIf.insert.call(this)\n    }\n  },\n\n  unbind: function () {\n    if (this.frag) {\n      this.frag.destroy()\n    }\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"../../fragment/factory\":113,\"../../util\":135,\"../public/if\":100,\"_process\":1}],88:[function(require,module,exports){\nvar _ = require('../../util')\nvar templateParser = require('../../parsers/template')\n\n// This is the elementDirective that handles <content>\n// transclusions. It relies on the raw content of an\n// instance being stored as `$options._content` during\n// the transclude phase.\n\nmodule.exports = {\n\n  priority: 1750,\n\n  params: ['name'],\n\n  bind: function () {\n    var host = this.vm\n    var raw = host.$options._content\n    var content\n    if (!raw) {\n      this.fallback()\n      return\n    }\n    var context = host._context\n    var slotName = this.params.name\n    if (!slotName) {\n      // Default content\n      var self = this\n      var compileDefaultContent = function () {\n        self.compile(\n          extractFragment(raw.childNodes, raw, true),\n          context,\n          host\n        )\n      }\n      if (!host._isCompiled) {\n        // defer until the end of instance compilation,\n        // because the default outlet must wait until all\n        // other possible outlets with selectors have picked\n        // out their contents.\n        host.$once('hook:compiled', compileDefaultContent)\n      } else {\n        compileDefaultContent()\n      }\n    } else {\n      var selector = '[slot=\"' + slotName + '\"]'\n      var nodes = raw.querySelectorAll(selector)\n      if (nodes.length) {\n        content = extractFragment(nodes, raw)\n        if (content.hasChildNodes()) {\n          this.compile(content, context, host)\n        } else {\n          this.fallback()\n        }\n      } else {\n        this.fallback()\n      }\n    }\n  },\n\n  fallback: function () {\n    this.compile(_.extractContent(this.el, true), this.vm)\n  },\n\n  compile: function (content, context, host) {\n    if (content && context) {\n      var scope = host\n        ? host._scope\n        : this._scope\n      this.unlink = context.$compile(\n        content, host, scope, this._frag\n      )\n    }\n    if (content) {\n      _.replace(this.el, content)\n    } else {\n      _.remove(this.el)\n    }\n  },\n\n  unbind: function () {\n    if (this.unlink) {\n      this.unlink()\n    }\n  }\n}\n\n/**\n * Extract qualified content nodes from a node list.\n *\n * @param {NodeList} nodes\n * @param {Element} parent\n * @param {Boolean} main\n * @return {DocumentFragment}\n */\n\nfunction extractFragment (nodes, parent, main) {\n  var frag = document.createDocumentFragment()\n  for (var i = 0, l = nodes.length; i < l; i++) {\n    var node = nodes[i]\n    // if this is the main outlet, we want to skip all\n    // previously selected nodes;\n    // otherwise, we want to mark the node as selected.\n    // clone the node so the original raw content remains\n    // intact. this ensures proper re-compilation in cases\n    // where the outlet is inside a conditional block\n    if (main && !node.__v_selected) {\n      append(node)\n    } else if (!main && node.parentNode === parent) {\n      node.__v_selected = true\n      append(node)\n    }\n  }\n  return frag\n\n  function append (node) {\n    if (_.isTemplate(node) &&\n        !node.hasAttribute('v-if') &&\n        !node.hasAttribute('v-for')) {\n      node = templateParser.parse(node)\n    }\n    node = templateParser.clone(node)\n    frag.appendChild(node)\n  }\n}\n\n},{\"../../parsers/template\":126,\"../../util\":135}],89:[function(require,module,exports){\nvar _ = require('../../util')\nvar addClass = _.addClass\nvar removeClass = _.removeClass\n\nmodule.exports = {\n\n  deep: true,\n\n  update: function (value) {\n    if (value && typeof value === 'string') {\n      this.handleObject(stringToObject(value))\n    } else if (_.isPlainObject(value)) {\n      this.handleObject(value)\n    } else if (_.isArray(value)) {\n      this.handleArray(value)\n    } else {\n      this.cleanup()\n    }\n  },\n\n  handleObject: function (value) {\n    this.cleanup(value)\n    var keys = this.prevKeys = Object.keys(value)\n    for (var i = 0, l = keys.length; i < l; i++) {\n      var key = keys[i]\n      if (value[key]) {\n        addClass(this.el, key)\n      } else {\n        removeClass(this.el, key)\n      }\n    }\n  },\n\n  handleArray: function (value) {\n    this.cleanup(value)\n    for (var i = 0, l = value.length; i < l; i++) {\n      if (value[i]) {\n        addClass(this.el, value[i])\n      }\n    }\n    this.prevKeys = value.slice()\n  },\n\n  cleanup: function (value) {\n    if (this.prevKeys) {\n      var i = this.prevKeys.length\n      while (i--) {\n        var key = this.prevKeys[i]\n        if (key && (!value || !contains(value, key))) {\n          removeClass(this.el, key)\n        }\n      }\n    }\n  }\n}\n\nfunction stringToObject (value) {\n  var res = {}\n  var keys = value.trim().split(/\\s+/)\n  var i = keys.length\n  while (i--) {\n    res[keys[i]] = true\n  }\n  return res\n}\n\nfunction contains (value, key) {\n  return _.isArray(value)\n    ? value.indexOf(key) > -1\n    : value.hasOwnProperty(key)\n}\n\n},{\"../../util\":135}],90:[function(require,module,exports){\n(function (process){\nvar _ = require('../../util')\nvar templateParser = require('../../parsers/template')\n\nmodule.exports = {\n\n  priority: 1500,\n\n  params: [\n    'keep-alive',\n    'transition-mode',\n    'inline-template'\n  ],\n\n  /**\n   * Setup. Two possible usages:\n   *\n   * - static:\n   *   <comp> or <div v-component=\"comp\">\n   *\n   * - dynamic:\n   *   <component :is=\"view\">\n   */\n\n  bind: function () {\n    if (!this.el.__vue__) {\n      // check ref\n      this.ref = _.findRef(this.el)\n      var refs = (this._scope || this.vm).$refs\n      if (this.ref && !refs.hasOwnProperty(this.ref)) {\n        _.defineReactive(refs, this.ref, null)\n      }\n      // keep-alive cache\n      this.keepAlive = this.params.keepAlive\n      if (this.keepAlive) {\n        this.cache = {}\n      }\n      // check inline-template\n      if (this.params.inlineTemplate) {\n        // extract inline template as a DocumentFragment\n        this.inlineTemplate = _.extractContent(this.el, true)\n      }\n      // component resolution related state\n      this.pendingComponentCb =\n      this.Component = null\n      // transition related state\n      this.pendingRemovals = 0\n      this.pendingRemovalCb = null\n      // check dynamic component params\n        // create a ref anchor\n      this.anchor = _.createAnchor('v-component')\n      _.replace(this.el, this.anchor)\n      // if static, build right now.\n      if (this.literal) {\n        this.setComponent(this.expression)\n      }\n    } else {\n      process.env.NODE_ENV !== 'production' && _.warn(\n        'cannot mount component \"' + this.expression + '\" ' +\n        'on already mounted element: ' + this.el\n      )\n    }\n  },\n\n  /**\n   * Public update, called by the watcher in the dynamic\n   * literal scenario, e.g. <component :is=\"view\">\n   */\n\n  update: function (value) {\n    if (!this.literal) {\n      this.setComponent(value)\n    }\n  },\n\n  /**\n   * Switch dynamic components. May resolve the component\n   * asynchronously, and perform transition based on\n   * specified transition mode. Accepts a few additional\n   * arguments specifically for vue-router.\n   *\n   * The callback is called when the full transition is\n   * finished.\n   *\n   * @param {String} value\n   * @param {Function} [cb]\n   */\n\n  setComponent: function (value, cb) {\n    this.invalidatePending()\n    if (!value) {\n      // just remove current\n      this.unbuild(true)\n      this.remove(this.childVM, cb)\n      this.childVM = null\n    } else {\n      var self = this\n      this.resolveComponent(value, function () {\n        self.mountComponent(cb)\n      })\n    }\n  },\n\n  /**\n   * Resolve the component constructor to use when creating\n   * the child vm.\n   */\n\n  resolveComponent: function (id, cb) {\n    var self = this\n    this.pendingComponentCb = _.cancellable(function (Component) {\n      self.ComponentName = Component.options.name || id\n      self.Component = Component\n      cb()\n    })\n    this.vm._resolveComponent(id, this.pendingComponentCb)\n  },\n\n  /**\n   * Create a new instance using the current constructor and\n   * replace the existing instance. This method doesn't care\n   * whether the new component and the old one are actually\n   * the same.\n   *\n   * @param {Function} [cb]\n   */\n\n  mountComponent: function (cb) {\n    // actual mount\n    this.unbuild(true)\n    var self = this\n    var activateHook = this.Component.options.activate\n    var cached = this.getCached()\n    var newComponent = this.build()\n    if (activateHook && !cached) {\n      this.waitingFor = newComponent\n      activateHook.call(newComponent, function () {\n        self.waitingFor = null\n        self.transition(newComponent, cb)\n      })\n    } else {\n      this.transition(newComponent, cb)\n    }\n  },\n\n  /**\n   * When the component changes or unbinds before an async\n   * constructor is resolved, we need to invalidate its\n   * pending callback.\n   */\n\n  invalidatePending: function () {\n    if (this.pendingComponentCb) {\n      this.pendingComponentCb.cancel()\n      this.pendingComponentCb = null\n    }\n  },\n\n  /**\n   * Instantiate/insert a new child vm.\n   * If keep alive and has cached instance, insert that\n   * instance; otherwise build a new one and cache it.\n   *\n   * @param {Object} [extraOptions]\n   * @return {Vue} - the created instance\n   */\n\n  build: function (extraOptions) {\n    var cached = this.getCached()\n    if (cached) {\n      return cached\n    }\n    if (this.Component) {\n      // default options\n      var options = {\n        name: this.ComponentName,\n        el: templateParser.clone(this.el),\n        template: this.inlineTemplate,\n        // make sure to add the child with correct parent\n        // if this is a transcluded component, its parent\n        // should be the transclusion host.\n        parent: this._host || this.vm,\n        // if no inline-template, then the compiled\n        // linker can be cached for better performance.\n        _linkerCachable: !this.inlineTemplate,\n        _ref: this.ref,\n        _asComponent: true,\n        _isRouterView: this._isRouterView,\n        // if this is a transcluded component, context\n        // will be the common parent vm of this instance\n        // and its host.\n        _context: this.vm,\n        // if this is inside an inline v-for, the scope\n        // will be the intermediate scope created for this\n        // repeat fragment. this is used for linking props\n        // and container directives.\n        _scope: this._scope,\n        // pass in the owner fragment of this component.\n        // this is necessary so that the fragment can keep\n        // track of its contained components in order to\n        // call attach/detach hooks for them.\n        _frag: this._frag\n      }\n      // extra options\n      // in 1.0.0 this is used by vue-router only\n      /* istanbul ignore if */\n      if (extraOptions) {\n        _.extend(options, extraOptions)\n      }\n      var child = new this.Component(options)\n      if (this.keepAlive) {\n        this.cache[this.Component.cid] = child\n      }\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' &&\n          this.el.hasAttribute('transition') &&\n          child._isFragment) {\n        _.warn(\n          'Transitions will not work on a fragment instance. ' +\n          'Template: ' + child.$options.template\n        )\n      }\n      return child\n    }\n  },\n\n  /**\n   * Try to get a cached instance of the current component.\n   *\n   * @return {Vue|undefined}\n   */\n\n  getCached: function () {\n    return this.keepAlive && this.cache[this.Component.cid]\n  },\n\n  /**\n   * Teardown the current child, but defers cleanup so\n   * that we can separate the destroy and removal steps.\n   *\n   * @param {Boolean} defer\n   */\n\n  unbuild: function (defer) {\n    if (this.waitingFor) {\n      this.waitingFor.$destroy()\n      this.waitingFor = null\n    }\n    var child = this.childVM\n    if (!child || this.keepAlive) {\n      return\n    }\n    // the sole purpose of `deferCleanup` is so that we can\n    // \"deactivate\" the vm right now and perform DOM removal\n    // later.\n    child.$destroy(false, defer)\n  },\n\n  /**\n   * Remove current destroyed child and manually do\n   * the cleanup after removal.\n   *\n   * @param {Function} cb\n   */\n\n  remove: function (child, cb) {\n    var keepAlive = this.keepAlive\n    if (child) {\n      // we may have a component switch when a previous\n      // component is still being transitioned out.\n      // we want to trigger only one lastest insertion cb\n      // when the existing transition finishes. (#1119)\n      this.pendingRemovals++\n      this.pendingRemovalCb = cb\n      var self = this\n      child.$remove(function () {\n        self.pendingRemovals--\n        if (!keepAlive) child._cleanup()\n        if (!self.pendingRemovals && self.pendingRemovalCb) {\n          self.pendingRemovalCb()\n          self.pendingRemovalCb = null\n        }\n      })\n    } else if (cb) {\n      cb()\n    }\n  },\n\n  /**\n   * Actually swap the components, depending on the\n   * transition mode. Defaults to simultaneous.\n   *\n   * @param {Vue} target\n   * @param {Function} [cb]\n   */\n\n  transition: function (target, cb) {\n    var self = this\n    var current = this.childVM\n    // for devtool inspection\n    if (process.env.NODE_ENV !== 'production') {\n      if (current) current._inactive = true\n      target._inactive = false\n    }\n    this.childVM = target\n    switch (self.params.transitionMode) {\n      case 'in-out':\n        target.$before(self.anchor, function () {\n          self.remove(current, cb)\n        })\n        break\n      case 'out-in':\n        self.remove(current, function () {\n          target.$before(self.anchor, cb)\n        })\n        break\n      default:\n        self.remove(current)\n        target.$before(self.anchor, cb)\n    }\n  },\n\n  /**\n   * Unbind.\n   */\n\n  unbind: function () {\n    this.invalidatePending()\n    // Do not defer cleanup when unbinding\n    this.unbuild()\n    // destroy all keep-alive cached instances\n    if (this.cache) {\n      for (var key in this.cache) {\n        this.cache[key].$destroy()\n      }\n      this.cache = null\n    }\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"../../parsers/template\":126,\"../../util\":135,\"_process\":1}],91:[function(require,module,exports){\nexports.style = require('./style')\nexports['class'] = require('./class')\nexports.component = require('./component')\nexports.prop = require('./prop')\nexports.transition = require('./transition')\n\n},{\"./class\":89,\"./component\":90,\"./prop\":92,\"./style\":93,\"./transition\":94}],92:[function(require,module,exports){\n// NOTE: the prop internal directive is compiled and linked\n// during _initScope(), before the created hook is called.\n// The purpose is to make the initial prop values available\n// inside `created` hooks and `data` functions.\n\nvar _ = require('../../util')\nvar Watcher = require('../../watcher')\nvar bindingModes = require('../../config')._propBindingModes\n\nmodule.exports = {\n\n  bind: function () {\n\n    var child = this.vm\n    var parent = child._context\n    // passed in from compiler directly\n    var prop = this.descriptor.prop\n    var childKey = prop.path\n    var parentKey = prop.parentPath\n    var twoWay = prop.mode === bindingModes.TWO_WAY\n\n    var parentWatcher = this.parentWatcher = new Watcher(\n      parent,\n      parentKey,\n      function (val) {\n        if (_.assertProp(prop, val)) {\n          child[childKey] = val\n        }\n      }, {\n        twoWay: twoWay,\n        filters: prop.filters,\n        // important: props need to be observed on the\n        // v-for scope if present\n        scope: this._scope\n      }\n    )\n\n    // set the child initial value.\n    _.initProp(child, prop, parentWatcher.value)\n\n    // setup two-way binding\n    if (twoWay) {\n      // important: defer the child watcher creation until\n      // the created hook (after data observation)\n      var self = this\n      child.$once('hook:created', function () {\n        self.childWatcher = new Watcher(\n          child,\n          childKey,\n          function (val) {\n            parentWatcher.set(val)\n          }\n        )\n      })\n    }\n  },\n\n  unbind: function () {\n    this.parentWatcher.teardown()\n    if (this.childWatcher) {\n      this.childWatcher.teardown()\n    }\n  }\n}\n\n},{\"../../config\":84,\"../../util\":135,\"../../watcher\":139}],93:[function(require,module,exports){\nvar _ = require('../../util')\nvar prefixes = ['-webkit-', '-moz-', '-ms-']\nvar camelPrefixes = ['Webkit', 'Moz', 'ms']\nvar importantRE = /!important;?$/\nvar testEl = null\nvar propCache = {}\n\nmodule.exports = {\n\n  deep: true,\n\n  update: function (value) {\n    if (typeof value === 'string') {\n      this.el.style.cssText = value\n    } else if (_.isArray(value)) {\n      this.handleObject(value.reduce(_.extend, {}))\n    } else {\n      this.handleObject(value || {})\n    }\n  },\n\n  handleObject: function (value) {\n    // cache object styles so that only changed props\n    // are actually updated.\n    var cache = this.cache || (this.cache = {})\n    var name, val\n    for (name in cache) {\n      if (!(name in value)) {\n        this.handleSingle(name, null)\n        delete cache[name]\n      }\n    }\n    for (name in value) {\n      val = value[name]\n      if (val !== cache[name]) {\n        cache[name] = val\n        this.handleSingle(name, val)\n      }\n    }\n  },\n\n  handleSingle: function (prop, value) {\n    prop = normalize(prop)\n    if (!prop) return // unsupported prop\n    // cast possible numbers/booleans into strings\n    if (value != null) value += ''\n    if (value) {\n      var isImportant = importantRE.test(value)\n        ? 'important'\n        : ''\n      if (isImportant) {\n        value = value.replace(importantRE, '').trim()\n      }\n      this.el.style.setProperty(prop, value, isImportant)\n    } else {\n      this.el.style.removeProperty(prop)\n    }\n  }\n\n}\n\n/**\n * Normalize a CSS property name.\n * - cache result\n * - auto prefix\n * - camelCase -> dash-case\n *\n * @param {String} prop\n * @return {String}\n */\n\nfunction normalize (prop) {\n  if (propCache[prop]) {\n    return propCache[prop]\n  }\n  var res = prefix(prop)\n  propCache[prop] = propCache[res] = res\n  return res\n}\n\n/**\n * Auto detect the appropriate prefix for a CSS property.\n * https://gist.github.com/paulirish/523692\n *\n * @param {String} prop\n * @return {String}\n */\n\nfunction prefix (prop) {\n  prop = _.hyphenate(prop)\n  var camel = _.camelize(prop)\n  var upper = camel.charAt(0).toUpperCase() + camel.slice(1)\n  if (!testEl) {\n    testEl = document.createElement('div')\n  }\n  if (camel in testEl.style) {\n    return prop\n  }\n  var i = prefixes.length\n  var prefixed\n  while (i--) {\n    prefixed = camelPrefixes[i] + upper\n    if (prefixed in testEl.style) {\n      return prefixes[i] + prop\n    }\n  }\n}\n\n},{\"../../util\":135}],94:[function(require,module,exports){\nvar _ = require('../../util')\nvar Transition = require('../../transition/transition')\n\nmodule.exports = {\n\n  priority: 1000,\n\n  update: function (id, oldId) {\n    var el = this.el\n    // resolve on owner vm\n    var hooks = _.resolveAsset(this.vm.$options, 'transitions', id)\n    id = id || 'v'\n    // apply on closest vm\n    el.__v_trans = new Transition(el, id, hooks, this.el.__vue__ || this.vm)\n    if (oldId) {\n      _.removeClass(el, oldId + '-transition')\n    }\n    _.addClass(el, id + '-transition')\n  }\n}\n\n},{\"../../transition/transition\":130,\"../../util\":135}],95:[function(require,module,exports){\n(function (process){\nvar _ = require('../../util')\n\n// xlink\nvar xlinkNS = 'http://www.w3.org/1999/xlink'\nvar xlinkRE = /^xlink:/\n\n// these input element attributes should also set their\n// corresponding properties\nvar inputProps = {\n  value: 1,\n  checked: 1,\n  selected: 1\n}\n\n// these attributes should set a hidden property for\n// binding v-model to object values\nvar modelProps = {\n  value: '_value',\n  'true-value': '_trueValue',\n  'false-value': '_falseValue'\n}\n\n// check for attributes that prohibit interpolations\nvar disallowedInterpAttrRE = /^v-|^:|^@|^(is|transition|transition-mode|debounce|track-by|stagger|enter-stagger|leave-stagger)$/\n\nmodule.exports = {\n\n  priority: 850,\n\n  bind: function () {\n    var attr = this.arg\n    var tag = this.el.tagName\n    // should be deep watch on object mode\n    if (!attr) {\n      this.deep = true\n    }\n    // handle interpolation bindings\n    if (this.descriptor.interp) {\n      // only allow binding on native attributes\n      if (\n        disallowedInterpAttrRE.test(attr) ||\n        (attr === 'name' && (tag === 'PARTIAL' || tag === 'SLOT'))\n      ) {\n        process.env.NODE_ENV !== 'production' && _.warn(\n          attr + '=\"' + this.descriptor.raw + '\": ' +\n          'attribute interpolation is not allowed in Vue.js ' +\n          'directives and special attributes.'\n        )\n        this.el.removeAttribute(attr)\n        this.invalid = true\n      }\n\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production') {\n        var raw = attr + '=\"' + this.descriptor.raw + '\": '\n        // warn src\n        if (attr === 'src') {\n          _.warn(\n            raw + 'interpolation in \"src\" attribute will cause ' +\n            'a 404 request. Use v-bind:src instead.'\n          )\n        }\n\n        // warn style\n        if (attr === 'style') {\n          _.warn(\n            raw + 'interpolation in \"style\" attribute will cause ' +\n            'the attribute to be discarded in Internet Explorer. ' +\n            'Use v-bind:style instead.'\n          )\n        }\n      }\n    }\n  },\n\n  update: function (value) {\n    if (this.invalid) {\n      return\n    }\n    var attr = this.arg\n    if (this.arg) {\n      this.handleSingle(attr, value)\n    } else {\n      this.handleObject(value || {})\n    }\n  },\n\n  // share object handler with v-bind:class\n  handleObject: require('../internal/style').handleObject,\n\n  handleSingle: function (attr, value) {\n    if (inputProps[attr] && attr in this.el) {\n      this.el[attr] = attr === 'value'\n        ? (value || '') // IE9 will set input.value to \"null\" for null...\n        : value\n    }\n    // set model props\n    var modelProp = modelProps[attr]\n    if (modelProp) {\n      this.el[modelProp] = value\n      // update v-model if present\n      var model = this.el.__v_model\n      if (model) {\n        model.listener()\n      }\n    }\n    // do not set value attribute for textarea\n    if (attr === 'value' && this.el.tagName === 'TEXTAREA') {\n      this.el.removeAttribute(attr)\n      return\n    }\n    // update attribute\n    if (value != null && value !== false) {\n      if (xlinkRE.test(attr)) {\n        this.el.setAttributeNS(xlinkNS, attr, value)\n      } else {\n        this.el.setAttribute(attr, value)\n      }\n    } else {\n      this.el.removeAttribute(attr)\n    }\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"../../util\":135,\"../internal/style\":93,\"_process\":1}],96:[function(require,module,exports){\nmodule.exports = {\n  bind: function () {\n    var el = this.el\n    this.vm.$once('hook:compiled', function () {\n      el.removeAttribute('v-cloak')\n    })\n  }\n}\n\n},{}],97:[function(require,module,exports){\nvar _ = require('../../util')\n\nmodule.exports = {\n\n  priority: 1500,\n\n  bind: function () {\n    /* istanbul ignore if */\n    if (!this.arg) {\n      return\n    }\n    var id = this.id = _.camelize(this.arg)\n    var refs = (this._scope || this.vm).$els\n    if (refs.hasOwnProperty(id)) {\n      refs[id] = this.el\n    } else {\n      _.defineReactive(refs, id, this.el)\n    }\n  },\n\n  unbind: function () {\n    var refs = (this._scope || this.vm).$els\n    if (refs[this.id] === this.el) {\n      refs[this.id] = null\n    }\n  }\n}\n\n},{\"../../util\":135}],98:[function(require,module,exports){\n(function (process){\nvar _ = require('../../util')\nvar FragmentFactory = require('../../fragment/factory')\nvar isObject = _.isObject\nvar uid = 0\n\nmodule.exports = {\n\n  priority: 2000,\n\n  params: [\n    'track-by',\n    'stagger',\n    'enter-stagger',\n    'leave-stagger'\n  ],\n\n  bind: function () {\n    // support \"item in items\" syntax\n    var inMatch = this.expression.match(/(.*) in (.*)/)\n    if (inMatch) {\n      var itMatch = inMatch[1].match(/\\((.*),(.*)\\)/)\n      if (itMatch) {\n        this.iterator = itMatch[1].trim()\n        this.alias = itMatch[2].trim()\n      } else {\n        this.alias = inMatch[1].trim()\n      }\n      this.expression = inMatch[2]\n    }\n\n    if (!this.alias) {\n      process.env.NODE_ENV !== 'production' && _.warn(\n        'Alias is required in v-for.'\n      )\n      return\n    }\n\n    // uid as a cache identifier\n    this.id = '__v-for__' + (++uid)\n\n    // check if this is an option list,\n    // so that we know if we need to update the <select>'s\n    // v-model when the option list has changed.\n    // because v-model has a lower priority than v-for,\n    // the v-model is not bound here yet, so we have to\n    // retrive it in the actual updateModel() function.\n    var tag = this.el.tagName\n    this.isOption =\n      (tag === 'OPTION' || tag === 'OPTGROUP') &&\n      this.el.parentNode.tagName === 'SELECT'\n\n    // setup anchor nodes\n    this.start = _.createAnchor('v-for-start')\n    this.end = _.createAnchor('v-for-end')\n    _.replace(this.el, this.end)\n    _.before(this.start, this.end)\n\n    // check ref\n    this.ref = _.findRef(this.el)\n\n    // cache\n    this.cache = Object.create(null)\n\n    // fragment factory\n    this.factory = new FragmentFactory(this.vm, this.el)\n  },\n\n  update: function (data) {\n    this.diff(data)\n    this.updateRef()\n    this.updateModel()\n  },\n\n  /**\n   * Diff, based on new data and old data, determine the\n   * minimum amount of DOM manipulations needed to make the\n   * DOM reflect the new data Array.\n   *\n   * The algorithm diffs the new data Array by storing a\n   * hidden reference to an owner vm instance on previously\n   * seen data. This allows us to achieve O(n) which is\n   * better than a levenshtein distance based algorithm,\n   * which is O(m * n).\n   *\n   * @param {Array} data\n   */\n\n  diff: function (data) {\n    // check if the Array was converted from an Object\n    var item = data[0]\n    var convertedFromObject = this.fromObject =\n      isObject(item) &&\n      item.hasOwnProperty('$key') &&\n      item.hasOwnProperty('$value')\n\n    var trackByKey = this.params.trackBy\n    var oldFrags = this.frags\n    var frags = this.frags = new Array(data.length)\n    var alias = this.alias\n    var iterator = this.iterator\n    var start = this.start\n    var end = this.end\n    var inDoc = _.inDoc(start)\n    var init = !oldFrags\n    var i, l, frag, key, value, primitive\n\n    // First pass, go through the new Array and fill up\n    // the new frags array. If a piece of data has a cached\n    // instance for it, we reuse it. Otherwise build a new\n    // instance.\n    for (i = 0, l = data.length; i < l; i++) {\n      item = data[i]\n      key = convertedFromObject ? item.$key : null\n      value = convertedFromObject ? item.$value : item\n      primitive = !isObject(value)\n      frag = !init && this.getCachedFrag(value, i, key)\n      if (frag) { // reusable fragment\n        frag.reused = true\n        // update $index\n        frag.scope.$index = i\n        // update $key\n        if (key) {\n          frag.scope.$key = key\n        }\n        // update iterator\n        if (iterator) {\n          frag.scope[iterator] = key !== null ? key : i\n        }\n        // update data for track-by, object repeat &\n        // primitive values.\n        if (trackByKey || convertedFromObject || primitive) {\n          frag.scope[alias] = value\n        }\n      } else { // new isntance\n        frag = this.create(value, alias, i, key)\n        frag.fresh = !init\n      }\n      frags[i] = frag\n      if (init) {\n        frag.before(end)\n      }\n    }\n\n    // we're done for the initial render.\n    if (init) {\n      return\n    }\n\n    // Second pass, go through the old fragments and\n    // destroy those who are not reused (and remove them\n    // from cache)\n    var removalIndex = 0\n    var totalRemoved = oldFrags.length - frags.length\n    for (i = 0, l = oldFrags.length; i < l; i++) {\n      frag = oldFrags[i]\n      if (!frag.reused) {\n        this.deleteCachedFrag(frag)\n        this.remove(frag, removalIndex++, totalRemoved, inDoc)\n      }\n    }\n\n    // Final pass, move/insert new fragments into the\n    // right place.\n    var targetPrev, prevEl, currentPrev\n    var insertionIndex = 0\n    for (i = 0, l = frags.length; i < l; i++) {\n      frag = frags[i]\n      // this is the frag that we should be after\n      targetPrev = frags[i - 1]\n      prevEl = targetPrev\n        ? targetPrev.staggerCb\n          ? targetPrev.staggerAnchor\n          : targetPrev.end || targetPrev.node\n        : start\n      if (frag.reused && !frag.staggerCb) {\n        currentPrev = findPrevFrag(frag, start, this.id)\n        if (currentPrev !== targetPrev) {\n          this.move(frag, prevEl)\n        }\n      } else {\n        // new instance, or still in stagger.\n        // insert with updated stagger index.\n        this.insert(frag, insertionIndex++, prevEl, inDoc)\n      }\n      frag.reused = frag.fresh = false\n    }\n  },\n\n  /**\n   * Create a new fragment instance.\n   *\n   * @param {*} value\n   * @param {String} alias\n   * @param {Number} index\n   * @param {String} [key]\n   * @return {Fragment}\n   */\n\n  create: function (value, alias, index, key) {\n    var host = this._host\n    // create iteration scope\n    var parentScope = this._scope || this.vm\n    var scope = Object.create(parentScope)\n    // ref holder for the scope\n    scope.$refs = Object.create(parentScope.$refs)\n    scope.$els = Object.create(parentScope.$els)\n    // make sure point $parent to parent scope\n    scope.$parent = parentScope\n    // for two-way binding on alias\n    scope.$forContext = this\n    // define scope properties\n    _.defineReactive(scope, alias, value)\n    _.defineReactive(scope, '$index', index)\n    if (key) {\n      _.defineReactive(scope, '$key', key)\n    } else if (scope.$key) {\n      // avoid accidental fallback\n      _.define(scope, '$key', null)\n    }\n    if (this.iterator) {\n      _.defineReactive(scope, this.iterator, key !== null ? key : index)\n    }\n    var frag = this.factory.create(host, scope, this._frag)\n    frag.forId = this.id\n    this.cacheFrag(value, frag, index, key)\n    return frag\n  },\n\n  /**\n   * Update the v-ref on owner vm.\n   */\n\n  updateRef: function () {\n    var ref = this.ref\n    if (!ref) return\n    var hash = (this._scope || this.vm).$refs\n    var refs\n    if (!this.fromObject) {\n      refs = this.frags.map(findVmFromFrag)\n    } else {\n      refs = {}\n      this.frags.forEach(function (frag) {\n        refs[frag.scope.$key] = findVmFromFrag(frag)\n      })\n    }\n    if (!hash.hasOwnProperty(ref)) {\n      _.defineReactive(hash, ref, refs)\n    } else {\n      hash[ref] = refs\n    }\n  },\n\n  /**\n   * For option lists, update the containing v-model on\n   * parent <select>.\n   */\n\n  updateModel: function () {\n    if (this.isOption) {\n      var parent = this.start.parentNode\n      var model = parent && parent.__v_model\n      if (model) {\n        model.forceUpdate()\n      }\n    }\n  },\n\n  /**\n   * Insert a fragment. Handles staggering.\n   *\n   * @param {Fragment} frag\n   * @param {Number} index\n   * @param {Node} prevEl\n   * @param {Boolean} inDoc\n   */\n\n  insert: function (frag, index, prevEl, inDoc) {\n    if (frag.staggerCb) {\n      frag.staggerCb.cancel()\n      frag.staggerCb = null\n    }\n    var staggerAmount = this.getStagger(frag, index, null, 'enter')\n    if (inDoc && staggerAmount) {\n      // create an anchor and insert it synchronously,\n      // so that we can resolve the correct order without\n      // worrying about some elements not inserted yet\n      var anchor = frag.staggerAnchor\n      if (!anchor) {\n        anchor = frag.staggerAnchor = _.createAnchor('stagger-anchor')\n        anchor.__vfrag__ = frag\n      }\n      _.after(anchor, prevEl)\n      var op = frag.staggerCb = _.cancellable(function () {\n        frag.staggerCb = null\n        frag.before(anchor)\n        _.remove(anchor)\n      })\n      setTimeout(op, staggerAmount)\n    } else {\n      frag.before(prevEl.nextSibling)\n    }\n  },\n\n  /**\n   * Remove a fragment. Handles staggering.\n   *\n   * @param {Fragment} frag\n   * @param {Number} index\n   * @param {Number} total\n   * @param {Boolean} inDoc\n   */\n\n  remove: function (frag, index, total, inDoc) {\n    if (frag.staggerCb) {\n      frag.staggerCb.cancel()\n      frag.staggerCb = null\n      // it's not possible for the same frag to be removed\n      // twice, so if we have a pending stagger callback,\n      // it means this frag is queued for enter but removed\n      // before its transition started. Since it is already\n      // destroyed, we can just leave it in detached state.\n      return\n    }\n    var staggerAmount = this.getStagger(frag, index, total, 'leave')\n    if (inDoc && staggerAmount) {\n      var op = frag.staggerCb = _.cancellable(function () {\n        frag.staggerCb = null\n        frag.remove(true)\n      })\n      setTimeout(op, staggerAmount)\n    } else {\n      frag.remove(true)\n    }\n  },\n\n  /**\n   * Move a fragment to a new position.\n   * Force no transition.\n   *\n   * @param {Fragment} frag\n   * @param {Node} prevEl\n   */\n\n  move: function (frag, prevEl) {\n    frag.before(prevEl.nextSibling, false)\n  },\n\n  /**\n   * Cache a fragment using track-by or the object key.\n   *\n   * @param {*} value\n   * @param {Fragment} frag\n   * @param {Number} index\n   * @param {String} [key]\n   */\n\n  cacheFrag: function (value, frag, index, key) {\n    var trackByKey = this.params.trackBy\n    var cache = this.cache\n    var primitive = !isObject(value)\n    var id\n    if (key || trackByKey || primitive) {\n      id = trackByKey\n        ? trackByKey === '$index'\n          ? index\n          : value[trackByKey]\n        : (key || value)\n      if (!cache[id]) {\n        cache[id] = frag\n      } else if (trackByKey !== '$index') {\n        process.env.NODE_ENV !== 'production' &&\n        this.warnDuplicate(value)\n      }\n    } else {\n      id = this.id\n      if (value.hasOwnProperty(id)) {\n        if (value[id] === null) {\n          value[id] = frag\n        } else {\n          process.env.NODE_ENV !== 'production' &&\n          this.warnDuplicate(value)\n        }\n      } else {\n        _.define(value, id, frag)\n      }\n    }\n    frag.raw = value\n  },\n\n  /**\n   * Get a cached fragment from the value/index/key\n   *\n   * @param {*} value\n   * @param {Number} index\n   * @param {String} key\n   * @return {Fragment}\n   */\n\n  getCachedFrag: function (value, index, key) {\n    var trackByKey = this.params.trackBy\n    var primitive = !isObject(value)\n    var frag\n    if (key || trackByKey || primitive) {\n      var id = trackByKey\n        ? trackByKey === '$index'\n          ? index\n          : value[trackByKey]\n        : (key || value)\n      frag = this.cache[id]\n    } else {\n      frag = value[this.id]\n    }\n    if (frag && (frag.reused || frag.fresh)) {\n      process.env.NODE_ENV !== 'production' &&\n      this.warnDuplicate(value)\n    }\n    return frag\n  },\n\n  /**\n   * Delete a fragment from cache.\n   *\n   * @param {Fragment} frag\n   */\n\n  deleteCachedFrag: function (frag) {\n    var value = frag.raw\n    var trackByKey = this.params.trackBy\n    var scope = frag.scope\n    var index = scope.$index\n    // fix #948: avoid accidentally fall through to\n    // a parent repeater which happens to have $key.\n    var key = scope.hasOwnProperty('$key') && scope.$key\n    var primitive = !isObject(value)\n    if (trackByKey || key || primitive) {\n      var id = trackByKey\n        ? trackByKey === '$index'\n          ? index\n          : value[trackByKey]\n        : (key || value)\n      this.cache[id] = null\n    } else {\n      value[this.id] = null\n      frag.raw = null\n    }\n  },\n\n  /**\n   * Get the stagger amount for an insertion/removal.\n   *\n   * @param {Fragment} frag\n   * @param {Number} index\n   * @param {Number} total\n   * @param {String} type\n   */\n\n  getStagger: function (frag, index, total, type) {\n    type = type + 'Stagger'\n    var trans = frag.node.__v_trans\n    var hooks = trans && trans.hooks\n    var hook = hooks && (hooks[type] || hooks.stagger)\n    return hook\n      ? hook.call(frag, index, total)\n      : index * parseInt(this.params[type] || this.params.stagger, 10)\n  },\n\n  /**\n   * Pre-process the value before piping it through the\n   * filters. This is passed to and called by the watcher.\n   */\n\n  _preProcess: function (value) {\n    // regardless of type, store the un-filtered raw value.\n    this.rawValue = value\n    return value\n  },\n\n  /**\n   * Post-process the value after it has been piped through\n   * the filters. This is passed to and called by the watcher.\n   *\n   * It is necessary for this to be called during the\n   * wathcer's dependency collection phase because we want\n   * the v-for to update when the source Object is mutated.\n   */\n\n  _postProcess: function (value) {\n    if (_.isArray(value)) {\n      return value\n    } else if (_.isPlainObject(value)) {\n      // convert plain object to array.\n      var keys = Object.keys(value)\n      var i = keys.length\n      var res = new Array(i)\n      var key\n      while (i--) {\n        key = keys[i]\n        res[i] = {\n          $key: key,\n          $value: value[key]\n        }\n      }\n      return res\n    } else {\n      var type = typeof value\n      if (type === 'number') {\n        value = range(value)\n      } else if (type === 'string') {\n        value = _.toArray(value)\n      }\n      return value || []\n    }\n  },\n\n  unbind: function () {\n    if (this.ref) {\n      (this._scope || this.vm).$refs[this.ref] = null\n    }\n    if (this.frags) {\n      var i = this.frags.length\n      var frag\n      while (i--) {\n        frag = this.frags[i]\n        this.deleteCachedFrag(frag)\n        frag.destroy()\n      }\n    }\n  }\n}\n\n/**\n * Helper to find the previous element that is a fragment\n * anchor. This is necessary because a destroyed frag's\n * element could still be lingering in the DOM before its\n * leaving transition finishes, but its inserted flag\n * should have been set to false so we can skip them.\n *\n * If this is a block repeat, we want to make sure we only\n * return frag that is bound to this v-for. (see #929)\n *\n * @param {Fragment} frag\n * @param {Comment|Text} anchor\n * @param {String} id\n * @return {Fragment}\n */\n\nfunction findPrevFrag (frag, anchor, id) {\n  var el = frag.node.previousSibling\n  /* istanbul ignore if */\n  if (!el) return\n  frag = el.__vfrag__\n  while (\n    (!frag || frag.forId !== id || !frag.inserted) &&\n    el !== anchor\n  ) {\n    el = el.previousSibling\n    /* istanbul ignore if */\n    if (!el) return\n    frag = el.__vfrag__\n  }\n  return frag\n}\n\n/**\n * Find a vm from a fragment.\n *\n * @param {Fragment} frag\n * @return {Vue|undefined}\n */\n\nfunction findVmFromFrag (frag) {\n  return frag.node.__vue__ || frag.node.nextSibling.__vue__\n}\n\n/**\n * Create a range array from given number.\n *\n * @param {Number} n\n * @return {Array}\n */\n\nfunction range (n) {\n  var i = -1\n  var ret = new Array(n)\n  while (++i < n) {\n    ret[i] = i\n  }\n  return ret\n}\n\nif (process.env.NODE_ENV !== 'production') {\n  module.exports.warnDuplicate = function (value) {\n    _.warn(\n      'Duplicate value found in v-for=\"' + this.descriptor.raw + '\": ' +\n      JSON.stringify(value) + '. Use track-by=\"$index\" if ' +\n      'you are expecting duplicate values.'\n    )\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"../../fragment/factory\":113,\"../../util\":135,\"_process\":1}],99:[function(require,module,exports){\nvar _ = require('../../util')\nvar templateParser = require('../../parsers/template')\n\nmodule.exports = {\n\n  bind: function () {\n    // a comment node means this is a binding for\n    // {{{ inline unescaped html }}}\n    if (this.el.nodeType === 8) {\n      // hold nodes\n      this.nodes = []\n      // replace the placeholder with proper anchor\n      this.anchor = _.createAnchor('v-html')\n      _.replace(this.el, this.anchor)\n    }\n  },\n\n  update: function (value) {\n    value = _.toString(value)\n    if (this.nodes) {\n      this.swap(value)\n    } else {\n      this.el.innerHTML = value\n    }\n  },\n\n  swap: function (value) {\n    // remove old nodes\n    var i = this.nodes.length\n    while (i--) {\n      _.remove(this.nodes[i])\n    }\n    // convert new value to a fragment\n    // do not attempt to retrieve from id selector\n    var frag = templateParser.parse(value, true, true)\n    // save a reference to these nodes so we can remove later\n    this.nodes = _.toArray(frag.childNodes)\n    _.before(frag, this.anchor)\n  }\n}\n\n},{\"../../parsers/template\":126,\"../../util\":135}],100:[function(require,module,exports){\n(function (process){\nvar _ = require('../../util')\nvar FragmentFactory = require('../../fragment/factory')\n\nmodule.exports = {\n\n  priority: 2000,\n\n  bind: function () {\n    var el = this.el\n    if (!el.__vue__) {\n      // check else block\n      var next = el.nextElementSibling\n      if (next && _.attr(next, 'v-else') !== null) {\n        _.remove(next)\n        this.elseFactory = new FragmentFactory(this.vm, next)\n      }\n      // check main block\n      this.anchor = _.createAnchor('v-if')\n      _.replace(el, this.anchor)\n      this.factory = new FragmentFactory(this.vm, el)\n    } else {\n      process.env.NODE_ENV !== 'production' && _.warn(\n        'v-if=\"' + this.expression + '\" cannot be ' +\n        'used on an instance root element.'\n      )\n      this.invalid = true\n    }\n  },\n\n  update: function (value) {\n    if (this.invalid) return\n    if (value) {\n      if (!this.frag) {\n        this.insert()\n      }\n    } else {\n      this.remove()\n    }\n  },\n\n  insert: function () {\n    if (this.elseFrag) {\n      this.elseFrag.remove(true)\n      this.elseFrag = null\n    }\n    this.frag = this.factory.create(this._host, this._scope, this._frag)\n    this.frag.before(this.anchor)\n  },\n\n  remove: function () {\n    if (this.frag) {\n      this.frag.remove(true)\n      this.frag = null\n    }\n    if (this.elseFactory) {\n      this.elseFrag = this.elseFactory.create(this._host, this._scope, this._frag)\n      this.elseFrag.before(this.anchor)\n    }\n  },\n\n  unbind: function () {\n    if (this.frag) {\n      this.frag.destroy()\n    }\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"../../fragment/factory\":113,\"../../util\":135,\"_process\":1}],101:[function(require,module,exports){\n// text & html\nexports.text = require('./text')\nexports.html = require('./html')\n\n// logic control\nexports['for'] = require('./for')\nexports['if'] = require('./if')\nexports.show = require('./show')\n\n// two-way binding\nexports.model = require('./model')\n\n// event handling\nexports.on = require('./on')\n\n// attributes\nexports.bind = require('./bind')\n\n// ref & el\nexports.el = require('./el')\nexports.ref = require('./ref')\n\n// cloak\nexports.cloak = require('./cloak')\n\n},{\"./bind\":95,\"./cloak\":96,\"./el\":97,\"./for\":98,\"./html\":99,\"./if\":100,\"./model\":103,\"./on\":107,\"./ref\":108,\"./show\":109,\"./text\":110}],102:[function(require,module,exports){\nvar _ = require('../../../util')\n\nmodule.exports = {\n\n  bind: function () {\n    var self = this\n    var el = this.el\n\n    this.getValue = function () {\n      return el.hasOwnProperty('_value')\n        ? el._value\n        : self.params.number\n          ? _.toNumber(el.value)\n          : el.value\n    }\n\n    function getBooleanValue () {\n      var val = el.checked\n      if (val && el.hasOwnProperty('_trueValue')) {\n        return el._trueValue\n      }\n      if (!val && el.hasOwnProperty('_falseValue')) {\n        return el._falseValue\n      }\n      return val\n    }\n\n    this.listener = function () {\n      var model = self._watcher.value\n      if (_.isArray(model)) {\n        var val = self.getValue()\n        if (el.checked) {\n          if (_.indexOf(model, val) < 0) {\n            model.push(val)\n          }\n        } else {\n          model.$remove(val)\n        }\n      } else {\n        self.set(getBooleanValue())\n      }\n    }\n\n    this.on('change', this.listener)\n    if (el.checked) {\n      this.afterBind = this.listener\n    }\n  },\n\n  update: function (value) {\n    var el = this.el\n    if (_.isArray(value)) {\n      el.checked = _.indexOf(value, this.getValue()) > -1\n    } else {\n      if (el.hasOwnProperty('_trueValue')) {\n        el.checked = _.looseEqual(value, el._trueValue)\n      } else {\n        el.checked = !!value\n      }\n    }\n  }\n}\n\n},{\"../../../util\":135}],103:[function(require,module,exports){\n(function (process){\nvar _ = require('../../../util')\n\nvar handlers = {\n  text: require('./text'),\n  radio: require('./radio'),\n  select: require('./select'),\n  checkbox: require('./checkbox')\n}\n\nmodule.exports = {\n\n  priority: 800,\n  twoWay: true,\n  handlers: handlers,\n  params: ['lazy', 'number', 'debounce'],\n\n  /**\n   * Possible elements:\n   *   <select>\n   *   <textarea>\n   *   <input type=\"*\">\n   *     - text\n   *     - checkbox\n   *     - radio\n   *     - number\n   */\n\n  bind: function () {\n    // friendly warning...\n    this.checkFilters()\n    if (this.hasRead && !this.hasWrite) {\n      process.env.NODE_ENV !== 'production' && _.warn(\n        'It seems you are using a read-only filter with ' +\n        'v-model. You might want to use a two-way filter ' +\n        'to ensure correct behavior.'\n      )\n    }\n    var el = this.el\n    var tag = el.tagName\n    var handler\n    if (tag === 'INPUT') {\n      handler = handlers[el.type] || handlers.text\n    } else if (tag === 'SELECT') {\n      handler = handlers.select\n    } else if (tag === 'TEXTAREA') {\n      handler = handlers.text\n    } else {\n      process.env.NODE_ENV !== 'production' && _.warn(\n        'v-model does not support element type: ' + tag\n      )\n      return\n    }\n    el.__v_model = this\n    handler.bind.call(this)\n    this.update = handler.update\n    this._unbind = handler.unbind\n  },\n\n  /**\n   * Check read/write filter stats.\n   */\n\n  checkFilters: function () {\n    var filters = this.filters\n    if (!filters) return\n    var i = filters.length\n    while (i--) {\n      var filter = _.resolveAsset(this.vm.$options, 'filters', filters[i].name)\n      if (typeof filter === 'function' || filter.read) {\n        this.hasRead = true\n      }\n      if (filter.write) {\n        this.hasWrite = true\n      }\n    }\n  },\n\n  unbind: function () {\n    this.el.__v_model = null\n    this._unbind && this._unbind()\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"../../../util\":135,\"./checkbox\":102,\"./radio\":104,\"./select\":105,\"./text\":106,\"_process\":1}],104:[function(require,module,exports){\nvar _ = require('../../../util')\n\nmodule.exports = {\n\n  bind: function () {\n    var self = this\n    var el = this.el\n\n    this.getValue = function () {\n      // value overwrite via v-bind:value\n      if (el.hasOwnProperty('_value')) {\n        return el._value\n      }\n      var val = el.value\n      if (self.params.number) {\n        val = _.toNumber(val)\n      }\n      return val\n    }\n\n    this.listener = function () {\n      self.set(self.getValue())\n    }\n    this.on('change', this.listener)\n\n    if (el.checked) {\n      this.afterBind = this.listener\n    }\n  },\n\n  update: function (value) {\n    this.el.checked = _.looseEqual(value, this.getValue())\n  }\n}\n\n},{\"../../../util\":135}],105:[function(require,module,exports){\nvar _ = require('../../../util')\n\nmodule.exports = {\n\n  bind: function () {\n    var self = this\n    var el = this.el\n\n    // method to force update DOM using latest value.\n    this.forceUpdate = function () {\n      if (self._watcher) {\n        self.update(self._watcher.get())\n      }\n    }\n\n    // check if this is a multiple select\n    var multiple = this.multiple = el.hasAttribute('multiple')\n\n    // attach listener\n    this.listener = function () {\n      var value = getValue(el, multiple)\n      value = self.params.number\n        ? _.isArray(value)\n          ? value.map(_.toNumber)\n          : _.toNumber(value)\n        : value\n      self.set(value)\n    }\n    this.on('change', this.listener)\n\n    // if has initial value, set afterBind\n    var initValue = getValue(el, multiple, true)\n    if ((multiple && initValue.length) ||\n        (!multiple && initValue !== null)) {\n      this.afterBind = this.listener\n    }\n\n    // All major browsers except Firefox resets\n    // selectedIndex with value -1 to 0 when the element\n    // is appended to a new parent, therefore we have to\n    // force a DOM update whenever that happens...\n    this.vm.$on('hook:attached', this.forceUpdate)\n  },\n\n  update: function (value) {\n    var el = this.el\n    el.selectedIndex = -1\n    var multi = this.multiple && _.isArray(value)\n    var options = el.options\n    var i = options.length\n    var op, val\n    while (i--) {\n      op = options[i]\n      val = op.hasOwnProperty('_value')\n        ? op._value\n        : op.value\n      /* eslint-disable eqeqeq */\n      op.selected = multi\n        ? indexOf(value, val) > -1\n        : _.looseEqual(value, val)\n      /* eslint-enable eqeqeq */\n    }\n  },\n\n  unbind: function () {\n    /* istanbul ignore next */\n    this.vm.$off('hook:attached', this.forceUpdate)\n  }\n}\n\n/**\n * Get select value\n *\n * @param {SelectElement} el\n * @param {Boolean} multi\n * @param {Boolean} init\n * @return {Array|*}\n */\n\nfunction getValue (el, multi, init) {\n  var res = multi ? [] : null\n  var op, val, selected\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    op = el.options[i]\n    selected = init\n      ? op.hasAttribute('selected')\n      : op.selected\n    if (selected) {\n      val = op.hasOwnProperty('_value')\n        ? op._value\n        : op.value\n      if (multi) {\n        res.push(val)\n      } else {\n        return val\n      }\n    }\n  }\n  return res\n}\n\n/**\n * Native Array.indexOf uses strict equal, but in this\n * case we need to match string/numbers with custom equal.\n *\n * @param {Array} arr\n * @param {*} val\n */\n\nfunction indexOf (arr, val) {\n  var i = arr.length\n  while (i--) {\n    if (_.looseEqual(arr[i], val)) {\n      return i\n    }\n  }\n  return -1\n}\n\n},{\"../../../util\":135}],106:[function(require,module,exports){\nvar _ = require('../../../util')\n\nmodule.exports = {\n\n  bind: function () {\n    var self = this\n    var el = this.el\n    var isRange = el.type === 'range'\n    var lazy = this.params.lazy\n    var number = this.params.number\n    var debounce = this.params.debounce\n\n    // handle composition events.\n    //   http://blog.evanyou.me/2014/01/03/composition-event/\n    // skip this for Android because it handles composition\n    // events quite differently. Android doesn't trigger\n    // composition events for language input methods e.g.\n    // Chinese, but instead triggers them for spelling\n    // suggestions... (see Discussion/#162)\n    var composing = false\n    if (!_.isAndroid && !isRange) {\n      this.on('compositionstart', function () {\n        composing = true\n      })\n      this.on('compositionend', function () {\n        composing = false\n        // in IE11 the \"compositionend\" event fires AFTER\n        // the \"input\" event, so the input handler is blocked\n        // at the end... have to call it here.\n        //\n        // #1327: in lazy mode this is unecessary.\n        if (!lazy) {\n          self.listener()\n        }\n      })\n    }\n\n    // prevent messing with the input when user is typing,\n    // and force update on blur.\n    this.focused = false\n    if (!isRange) {\n      this.on('focus', function () {\n        self.focused = true\n      })\n      this.on('blur', function () {\n        self.focused = false\n        self.listener()\n      })\n    }\n\n    // Now attach the main listener\n    this.listener = function () {\n      if (composing) return\n      var val = number || isRange\n        ? _.toNumber(el.value)\n        : el.value\n      self.set(val)\n      // force update on next tick to avoid lock & same value\n      // also only update when user is not typing\n      _.nextTick(function () {\n        if (self._bound && !self.focused) {\n          self.update(self._watcher.value)\n        }\n      })\n    }\n\n    // apply debounce\n    if (debounce) {\n      this.listener = _.debounce(this.listener, debounce)\n    }\n\n    // Support jQuery events, since jQuery.trigger() doesn't\n    // trigger native events in some cases and some plugins\n    // rely on $.trigger()\n    //\n    // We want to make sure if a listener is attached using\n    // jQuery, it is also removed with jQuery, that's why\n    // we do the check for each directive instance and\n    // store that check result on itself. This also allows\n    // easier test coverage control by unsetting the global\n    // jQuery variable in tests.\n    this.hasjQuery = typeof jQuery === 'function'\n    if (this.hasjQuery) {\n      jQuery(el).on('change', this.listener)\n      if (!lazy) {\n        jQuery(el).on('input', this.listener)\n      }\n    } else {\n      this.on('change', this.listener)\n      if (!lazy) {\n        this.on('input', this.listener)\n      }\n    }\n\n    // IE9 doesn't fire input event on backspace/del/cut\n    if (!lazy && _.isIE9) {\n      this.on('cut', function () {\n        _.nextTick(self.listener)\n      })\n      this.on('keyup', function (e) {\n        if (e.keyCode === 46 || e.keyCode === 8) {\n          self.listener()\n        }\n      })\n    }\n\n    // set initial value if present\n    if (\n      el.hasAttribute('value') ||\n      (el.tagName === 'TEXTAREA' && el.value.trim())\n    ) {\n      this.afterBind = this.listener\n    }\n  },\n\n  update: function (value) {\n    this.el.value = _.toString(value)\n  },\n\n  unbind: function () {\n    var el = this.el\n    if (this.hasjQuery) {\n      jQuery(el).off('change', this.listener)\n      jQuery(el).off('input', this.listener)\n    }\n  }\n}\n\n},{\"../../../util\":135}],107:[function(require,module,exports){\n(function (process){\nvar _ = require('../../util')\n\n// keyCode aliases\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  'delete': 46,\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40\n}\n\nfunction keyFilter (handler, keys) {\n  var codes = keys.map(function (key) {\n    var code = keyCodes[key]\n    if (!code) {\n      code = parseInt(key, 10)\n    }\n    return code\n  })\n  return function keyHandler (e) {\n    if (codes.indexOf(e.keyCode) > -1) {\n      return handler.call(this, e)\n    }\n  }\n}\n\nfunction stopFilter (handler) {\n  return function stopHandler (e) {\n    e.stopPropagation()\n    return handler.call(this, e)\n  }\n}\n\nfunction preventFilter (handler) {\n  return function preventHandler (e) {\n    e.preventDefault()\n    return handler.call(this, e)\n  }\n}\n\nmodule.exports = {\n\n  acceptStatement: true,\n  priority: 700,\n\n  bind: function () {\n    // deal with iframes\n    if (\n      this.el.tagName === 'IFRAME' &&\n      this.arg !== 'load'\n    ) {\n      var self = this\n      this.iframeBind = function () {\n        _.on(self.el.contentWindow, self.arg, self.handler)\n      }\n      this.on('load', this.iframeBind)\n    }\n  },\n\n  update: function (handler) {\n    // stub a noop for v-on with no value,\n    // e.g. @mousedown.prevent\n    if (!this.descriptor.raw) {\n      handler = function () {}\n    }\n\n    if (typeof handler !== 'function') {\n      process.env.NODE_ENV !== 'production' && _.warn(\n        'v-on:' + this.arg + '=\"' +\n        this.expression + '\" expects a function value, ' +\n        'got ' + handler\n      )\n      return\n    }\n\n    // apply modifiers\n    if (this.modifiers.stop) {\n      handler = stopFilter(handler)\n    }\n    if (this.modifiers.prevent) {\n      handler = preventFilter(handler)\n    }\n    // key filter\n    var keys = Object.keys(this.modifiers)\n      .filter(function (key) {\n        return key !== 'stop' && key !== 'prevent'\n      })\n    if (keys.length) {\n      handler = keyFilter(handler, keys)\n    }\n\n    this.reset()\n    var scope = this._scope || this.vm\n    this.handler = function (e) {\n      scope.$event = e\n      var res = handler(e)\n      scope.$event = null\n      return res\n    }\n    if (this.iframeBind) {\n      this.iframeBind()\n    } else {\n      _.on(this.el, this.arg, this.handler)\n    }\n  },\n\n  reset: function () {\n    var el = this.iframeBind\n      ? this.el.contentWindow\n      : this.el\n    if (this.handler) {\n      _.off(el, this.arg, this.handler)\n    }\n  },\n\n  unbind: function () {\n    this.reset()\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"../../util\":135,\"_process\":1}],108:[function(require,module,exports){\n(function (process){\nif (process.env.NODE_ENV !== 'production') {\n  module.exports = {\n    bind: function () {\n      require('../../util').warn(\n        'v-ref:' + this.arg + ' must be used on a child ' +\n        'component. Found on <' + this.el.tagName.toLowerCase() + '>.'\n      )\n    }\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"../../util\":135,\"_process\":1}],109:[function(require,module,exports){\nvar _ = require('../../util')\nvar transition = require('../../transition')\n\nmodule.exports = {\n\n  bind: function () {\n    // check else block\n    var next = this.el.nextElementSibling\n    if (next && _.attr(next, 'v-else') !== null) {\n      this.elseEl = next\n    }\n  },\n\n  update: function (value) {\n    var el = this.el\n    transition.apply(el, value ? 1 : -1, function () {\n      el.style.display = value ? '' : 'none'\n    }, this.vm)\n    var elseEl = this.elseEl\n    if (elseEl) {\n      transition.apply(elseEl, value ? -1 : 1, function () {\n        elseEl.style.display = value ? 'none' : ''\n      }, this.vm)\n    }\n  }\n}\n\n},{\"../../transition\":128,\"../../util\":135}],110:[function(require,module,exports){\nvar _ = require('../../util')\n\nmodule.exports = {\n\n  bind: function () {\n    this.attr = this.el.nodeType === 3\n      ? 'data'\n      : 'textContent'\n  },\n\n  update: function (value) {\n    this.el[this.attr] = _.toString(value)\n  }\n}\n\n},{\"../../util\":135}],111:[function(require,module,exports){\nvar _ = require('../util')\nvar Path = require('../parsers/path')\nvar toArray = require('../directives/public/for')._postProcess\n\n/**\n * Limit filter for arrays\n *\n * @param {Number} n\n */\n\nexports.limitBy = function (arr, n) {\n  return typeof n === 'number'\n    ? arr.slice(0, n)\n    : arr\n}\n\n/**\n * Filter filter for arrays\n *\n * @param {String} searchKey\n * @param {String} [delimiter]\n * @param {String} dataKey\n */\n\nexports.filterBy = function (arr, search, delimiter /* ...dataKeys */) {\n  arr = toArray(arr)\n  if (search == null) {\n    return arr\n  }\n  if (typeof search === 'function') {\n    return arr.filter(search)\n  }\n  // cast to lowercase string\n  search = ('' + search).toLowerCase()\n  // allow optional `in` delimiter\n  // because why not\n  var n = delimiter === 'in' ? 3 : 2\n  // extract and flatten keys\n  var keys = _.toArray(arguments, n).reduce(function (prev, cur) {\n    return prev.concat(cur)\n  }, [])\n  var res = []\n  var item, key, val, j\n  for (var i = 0, l = arr.length; i < l; i++) {\n    item = arr[i]\n    val = (item && item.$value) || item\n    j = keys.length\n    if (j) {\n      while (j--) {\n        key = keys[j]\n        if ((key === '$key' && contains(item.$key, search)) ||\n            contains(Path.get(val, key), search)) {\n          res.push(item)\n          break\n        }\n      }\n    } else if (contains(item, search)) {\n      res.push(item)\n    }\n  }\n  return res\n}\n\n/**\n * Filter filter for arrays\n *\n * @param {String} sortKey\n * @param {String} reverse\n */\n\nexports.orderBy = function (arr, sortKey, reverse) {\n  arr = toArray(arr)\n  if (!sortKey) {\n    return arr\n  }\n  var order = (reverse && reverse < 0) ? -1 : 1\n  // sort on a copy to avoid mutating original array\n  return arr.slice().sort(function (a, b) {\n    if (sortKey !== '$key') {\n      if (_.isObject(a) && '$value' in a) a = a.$value\n      if (_.isObject(b) && '$value' in b) b = b.$value\n    }\n    a = _.isObject(a) ? Path.get(a, sortKey) : a\n    b = _.isObject(b) ? Path.get(b, sortKey) : b\n    return a === b ? 0 : a > b ? order : -order\n  })\n}\n\n/**\n * String contain helper\n *\n * @param {*} val\n * @param {String} search\n */\n\nfunction contains (val, search) {\n  var i\n  if (_.isPlainObject(val)) {\n    var keys = Object.keys(val)\n    i = keys.length\n    while (i--) {\n      if (contains(val[keys[i]], search)) {\n        return true\n      }\n    }\n  } else if (_.isArray(val)) {\n    i = val.length\n    while (i--) {\n      if (contains(val[i], search)) {\n        return true\n      }\n    }\n  } else if (val != null) {\n    return val.toString().toLowerCase().indexOf(search) > -1\n  }\n}\n\n},{\"../directives/public/for\":98,\"../parsers/path\":125,\"../util\":135}],112:[function(require,module,exports){\nvar _ = require('../util')\n\n/**\n * Stringify value.\n *\n * @param {Number} indent\n */\n\nexports.json = {\n  read: function (value, indent) {\n    return typeof value === 'string'\n      ? value\n      : JSON.stringify(value, null, Number(indent) || 2)\n  },\n  write: function (value) {\n    try {\n      return JSON.parse(value)\n    } catch (e) {\n      return value\n    }\n  }\n}\n\n/**\n * 'abc' => 'Abc'\n */\n\nexports.capitalize = function (value) {\n  if (!value && value !== 0) return ''\n  value = value.toString()\n  return value.charAt(0).toUpperCase() + value.slice(1)\n}\n\n/**\n * 'abc' => 'ABC'\n */\n\nexports.uppercase = function (value) {\n  return (value || value === 0)\n    ? value.toString().toUpperCase()\n    : ''\n}\n\n/**\n * 'AbC' => 'abc'\n */\n\nexports.lowercase = function (value) {\n  return (value || value === 0)\n    ? value.toString().toLowerCase()\n    : ''\n}\n\n/**\n * 12345 => $12,345.00\n *\n * @param {String} sign\n */\n\nvar digitsRE = /(\\d{3})(?=\\d)/g\nexports.currency = function (value, currency) {\n  value = parseFloat(value)\n  if (!isFinite(value) || (!value && value !== 0)) return ''\n  currency = currency != null ? currency : '$'\n  var stringified = Math.abs(value).toFixed(2)\n  var _int = stringified.slice(0, -3)\n  var i = _int.length % 3\n  var head = i > 0\n    ? (_int.slice(0, i) + (_int.length > 3 ? ',' : ''))\n    : ''\n  var _float = stringified.slice(-3)\n  var sign = value < 0 ? '-' : ''\n  return currency + sign + head +\n    _int.slice(i).replace(digitsRE, '$1,') +\n    _float\n}\n\n/**\n * 'item' => 'items'\n *\n * @params\n *  an array of strings corresponding to\n *  the single, double, triple ... forms of the word to\n *  be pluralized. When the number to be pluralized\n *  exceeds the length of the args, it will use the last\n *  entry in the array.\n *\n *  e.g. ['single', 'double', 'triple', 'multiple']\n */\n\nexports.pluralize = function (value) {\n  var args = _.toArray(arguments, 1)\n  return args.length > 1\n    ? (args[value % 10 - 1] || args[args.length - 1])\n    : (args[0] + (value === 1 ? '' : 's'))\n}\n\n/**\n * Debounce a handler function.\n *\n * @param {Function} handler\n * @param {Number} delay = 300\n * @return {Function}\n */\n\nexports.debounce = function (handler, delay) {\n  if (!handler) return\n  if (!delay) {\n    delay = 300\n  }\n  return _.debounce(handler, delay)\n}\n\n/**\n * Install special array filters\n */\n\n_.extend(exports, require('./array-filters'))\n\n},{\"../util\":135,\"./array-filters\":111}],113:[function(require,module,exports){\nvar _ = require('../util')\nvar compiler = require('../compiler')\nvar templateParser = require('../parsers/template')\nvar Fragment = require('./fragment')\nvar Cache = require('../cache')\nvar linkerCache = new Cache(5000)\n\n/**\n * A factory that can be used to create instances of a\n * fragment. Caches the compiled linker if possible.\n *\n * @param {Vue} vm\n * @param {Element|String} el\n */\n\nfunction FragmentFactory (vm, el) {\n  this.vm = vm\n  var template\n  var isString = typeof el === 'string'\n  if (isString || _.isTemplate(el)) {\n    template = templateParser.parse(el, true)\n  } else {\n    template = document.createDocumentFragment()\n    template.appendChild(el)\n  }\n  this.template = template\n  // linker can be cached, but only for components\n  var linker\n  var cid = vm.constructor.cid\n  if (cid > 0) {\n    var cacheId = cid + (isString ? el : el.outerHTML)\n    linker = linkerCache.get(cacheId)\n    if (!linker) {\n      linker = compiler.compile(template, vm.$options, true)\n      linkerCache.put(cacheId, linker)\n    }\n  } else {\n    linker = compiler.compile(template, vm.$options, true)\n  }\n  this.linker = linker\n}\n\n/**\n * Create a fragment instance with given host and scope.\n *\n * @param {Vue} host\n * @param {Object} scope\n * @param {Fragment} parentFrag\n */\n\nFragmentFactory.prototype.create = function (host, scope, parentFrag) {\n  var frag = templateParser.clone(this.template)\n  return new Fragment(this.linker, this.vm, frag, host, scope, parentFrag)\n}\n\nmodule.exports = FragmentFactory\n\n},{\"../cache\":79,\"../compiler\":82,\"../parsers/template\":126,\"../util\":135,\"./fragment\":114}],114:[function(require,module,exports){\nvar _ = require('../util')\nvar transition = require('../transition')\n\n/**\n * Abstraction for a partially-compiled fragment.\n * Can optionally compile content with a child scope.\n *\n * @param {Function} linker\n * @param {Vue} vm\n * @param {DocumentFragment} frag\n * @param {Vue} [host]\n * @param {Object} [scope]\n */\n\nfunction Fragment (linker, vm, frag, host, scope, parentFrag) {\n  this.children = []\n  this.childFrags = []\n  this.vm = vm\n  this.scope = scope\n  this.inserted = false\n  this.parentFrag = parentFrag\n  if (parentFrag) {\n    parentFrag.childFrags.push(this)\n  }\n  this.unlink = linker(vm, frag, host, scope, this)\n  var single = this.single = frag.childNodes.length === 1\n  if (single) {\n    this.node = frag.childNodes[0]\n    this.before = singleBefore\n    this.remove = singleRemove\n  } else {\n    this.node = _.createAnchor('fragment-start')\n    this.end = _.createAnchor('fragment-end')\n    this.frag = frag\n    _.prepend(this.node, frag)\n    frag.appendChild(this.end)\n    this.before = multiBefore\n    this.remove = multiRemove\n  }\n  this.node.__vfrag__ = this\n}\n\n/**\n * Call attach/detach for all components contained within\n * this fragment. Also do so recursively for all child\n * fragments.\n *\n * @param {Function} hook\n */\n\nFragment.prototype.callHook = function (hook) {\n  var i, l\n  for (i = 0, l = this.children.length; i < l; i++) {\n    hook(this.children[i])\n  }\n  for (i = 0, l = this.childFrags.length; i < l; i++) {\n    this.childFrags[i].callHook(hook)\n  }\n}\n\n/**\n * Destroy the fragment.\n */\n\nFragment.prototype.destroy = function () {\n  if (this.parentFrag) {\n    this.parentFrag.childFrags.$remove(this)\n  }\n  this.unlink()\n}\n\n/**\n * Insert fragment before target, single node version\n *\n * @param {Node} target\n * @param {Boolean} withTransition\n */\n\nfunction singleBefore (target, withTransition) {\n  this.inserted = true\n  var method = withTransition !== false\n    ? transition.before\n    : _.before\n  method(this.node, target, this.vm)\n  if (_.inDoc(this.node)) {\n    this.callHook(attach)\n  }\n}\n\n/**\n * Remove fragment, single node version\n *\n * @param {Boolean} [destroy]\n */\n\nfunction singleRemove (destroy) {\n  this.inserted = false\n  var shouldCallRemove = _.inDoc(this.node)\n  var self = this\n  transition.remove(this.node, this.vm, function () {\n    if (shouldCallRemove) {\n      self.callHook(detach)\n    }\n    if (destroy) {\n      self.destroy()\n    }\n  })\n}\n\n/**\n * Insert fragment before target, multi-nodes version\n *\n * @param {Node} target\n * @param {Boolean} withTransition\n */\n\nfunction multiBefore (target, withTransition) {\n  this.inserted = true\n  var vm = this.vm\n  var method = withTransition !== false\n    ? transition.before\n    : _.before\n  _.mapNodeRange(this.node, this.end, function (node) {\n    method(node, target, vm)\n  })\n  if (_.inDoc(this.node)) {\n    this.callHook(attach)\n  }\n}\n\n/**\n * Remove fragment, multi-nodes version\n *\n * @param {Boolean} [destroy]\n */\n\nfunction multiRemove (destroy) {\n  this.inserted = false\n  var self = this\n  var shouldCallRemove = _.inDoc(this.node)\n  _.removeNodeRange(this.node, this.end, this.vm, this.frag, function () {\n    if (shouldCallRemove) {\n      self.callHook(detach)\n    }\n    if (destroy) {\n      self.destroy()\n    }\n  })\n}\n\n/**\n * Call attach hook for a Vue instance.\n *\n * @param {Vue} child\n */\n\nfunction attach (child) {\n  if (!child._isAttached) {\n    child._callHook('attached')\n  }\n}\n\n/**\n * Call detach hook for a Vue instance.\n *\n * @param {Vue} child\n */\n\nfunction detach (child) {\n  if (child._isAttached) {\n    child._callHook('detached')\n  }\n}\n\nmodule.exports = Fragment\n\n},{\"../transition\":128,\"../util\":135}],115:[function(require,module,exports){\n(function (process){\nvar _ = require('../util')\nvar inDoc = _.inDoc\nvar eventRE = /^v-on:|^@/\n\n/**\n * Setup the instance's option events & watchers.\n * If the value is a string, we pull it from the\n * instance's methods by name.\n */\n\nexports._initEvents = function () {\n  var options = this.$options\n  if (options._asComponent) {\n    registerComponentEvents(this, options.el)\n  }\n  registerCallbacks(this, '$on', options.events)\n  registerCallbacks(this, '$watch', options.watch)\n}\n\n/**\n * Register v-on events on a child component\n *\n * @param {Vue} vm\n * @param {Element} el\n */\n\nfunction registerComponentEvents (vm, el) {\n  var attrs = el.attributes\n  var name, handler\n  for (var i = 0, l = attrs.length; i < l; i++) {\n    name = attrs[i].name\n    if (eventRE.test(name)) {\n      name = name.replace(eventRE, '')\n      handler = (vm._scope || vm._context).$eval(attrs[i].value, true)\n      vm.$on(name.replace(eventRE), handler)\n    }\n  }\n}\n\n/**\n * Register callbacks for option events and watchers.\n *\n * @param {Vue} vm\n * @param {String} action\n * @param {Object} hash\n */\n\nfunction registerCallbacks (vm, action, hash) {\n  if (!hash) return\n  var handlers, key, i, j\n  for (key in hash) {\n    handlers = hash[key]\n    if (_.isArray(handlers)) {\n      for (i = 0, j = handlers.length; i < j; i++) {\n        register(vm, action, key, handlers[i])\n      }\n    } else {\n      register(vm, action, key, handlers)\n    }\n  }\n}\n\n/**\n * Helper to register an event/watch callback.\n *\n * @param {Vue} vm\n * @param {String} action\n * @param {String} key\n * @param {Function|String|Object} handler\n * @param {Object} [options]\n */\n\nfunction register (vm, action, key, handler, options) {\n  var type = typeof handler\n  if (type === 'function') {\n    vm[action](key, handler, options)\n  } else if (type === 'string') {\n    var methods = vm.$options.methods\n    var method = methods && methods[handler]\n    if (method) {\n      vm[action](key, method, options)\n    } else {\n      process.env.NODE_ENV !== 'production' && _.warn(\n        'Unknown method: \"' + handler + '\" when ' +\n        'registering callback for ' + action +\n        ': \"' + key + '\".'\n      )\n    }\n  } else if (handler && type === 'object') {\n    register(vm, action, key, handler.handler, handler)\n  }\n}\n\n/**\n * Setup recursive attached/detached calls\n */\n\nexports._initDOMHooks = function () {\n  this.$on('hook:attached', onAttached)\n  this.$on('hook:detached', onDetached)\n}\n\n/**\n * Callback to recursively call attached hook on children\n */\n\nfunction onAttached () {\n  if (!this._isAttached) {\n    this._isAttached = true\n    this.$children.forEach(callAttach)\n  }\n}\n\n/**\n * Iterator to call attached hook\n *\n * @param {Vue} child\n */\n\nfunction callAttach (child) {\n  if (!child._isAttached && inDoc(child.$el)) {\n    child._callHook('attached')\n  }\n}\n\n/**\n * Callback to recursively call detached hook on children\n */\n\nfunction onDetached () {\n  if (this._isAttached) {\n    this._isAttached = false\n    this.$children.forEach(callDetach)\n  }\n}\n\n/**\n * Iterator to call detached hook\n *\n * @param {Vue} child\n */\n\nfunction callDetach (child) {\n  if (child._isAttached && !inDoc(child.$el)) {\n    child._callHook('detached')\n  }\n}\n\n/**\n * Trigger all handlers for a hook\n *\n * @param {String} hook\n */\n\nexports._callHook = function (hook) {\n  var handlers = this.$options[hook]\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      handlers[i].call(this)\n    }\n  }\n  this.$emit('hook:' + hook)\n}\n\n}).call(this,require('_process'))\n\n},{\"../util\":135,\"_process\":1}],116:[function(require,module,exports){\nvar mergeOptions = require('../util').mergeOptions\nvar uid = 0\n\n/**\n * The main init sequence. This is called for every\n * instance, including ones that are created from extended\n * constructors.\n *\n * @param {Object} options - this options object should be\n *                           the result of merging class\n *                           options and the options passed\n *                           in to the constructor.\n */\n\nexports._init = function (options) {\n\n  options = options || {}\n\n  this.$el = null\n  this.$parent = options.parent\n  this.$root = this.$parent\n    ? this.$parent.$root\n    : this\n  this.$children = []\n  this.$refs = {}       // child vm references\n  this.$els = {}        // element references\n  this._watchers = []   // all watchers as an array\n  this._directives = [] // all directives\n\n  // a uid\n  this._uid = uid++\n\n  // a flag to avoid this being observed\n  this._isVue = true\n\n  // events bookkeeping\n  this._events = {}            // registered callbacks\n  this._eventsCount = {}       // for $broadcast optimization\n  this._shouldPropagate = false // for event propagation\n\n  // fragment instance properties\n  this._isFragment = false\n  this._fragment =         // @type {DocumentFragment}\n  this._fragmentStart =    // @type {Text|Comment}\n  this._fragmentEnd = null // @type {Text|Comment}\n\n  // lifecycle state\n  this._isCompiled =\n  this._isDestroyed =\n  this._isReady =\n  this._isAttached =\n  this._isBeingDestroyed = false\n  this._unlinkFn = null\n\n  // context:\n  // if this is a transcluded component, context\n  // will be the common parent vm of this instance\n  // and its host.\n  this._context = options._context || this.$parent\n\n  // scope:\n  // if this is inside an inline v-for, the scope\n  // will be the intermediate scope created for this\n  // repeat fragment. this is used for linking props\n  // and container directives.\n  this._scope = options._scope\n\n  // fragment:\n  // if this instance is compiled inside a Fragment, it\n  // needs to reigster itself as a child of that fragment\n  // for attach/detach to work properly.\n  this._frag = options._frag\n  if (this._frag) {\n    this._frag.children.push(this)\n  }\n\n  // push self into parent / transclusion host\n  if (this.$parent) {\n    this.$parent.$children.push(this)\n  }\n\n  // set ref\n  if (options._ref) {\n    (this._scope || this._context).$refs[options._ref] = this\n  }\n\n  // merge options.\n  options = this.$options = mergeOptions(\n    this.constructor.options,\n    options,\n    this\n  )\n\n  // initialize data as empty object.\n  // it will be filled up in _initScope().\n  this._data = {}\n\n  // call init hook\n  this._callHook('init')\n\n  // initialize data observation and scope inheritance.\n  this._initState()\n\n  // setup event system and option events.\n  this._initEvents()\n\n  // call created hook\n  this._callHook('created')\n\n  // if `el` option is passed, start compilation.\n  if (options.el) {\n    this.$mount(options.el)\n  }\n}\n\n},{\"../util\":135}],117:[function(require,module,exports){\nvar _ = require('../util')\nvar Directive = require('../directive')\nvar compiler = require('../compiler')\n\n/**\n * Transclude, compile and link element.\n *\n * If a pre-compiled linker is available, that means the\n * passed in element will be pre-transcluded and compiled\n * as well - all we need to do is to call the linker.\n *\n * Otherwise we need to call transclude/compile/link here.\n *\n * @param {Element} el\n * @return {Element}\n */\n\nexports._compile = function (el) {\n  var options = this.$options\n\n  // transclude and init element\n  // transclude can potentially replace original\n  // so we need to keep reference; this step also injects\n  // the template and caches the original attributes\n  // on the container node and replacer node.\n  var original = el\n  el = compiler.transclude(el, options)\n  this._initElement(el)\n\n  // root is always compiled per-instance, because\n  // container attrs and props can be different every time.\n  var contextOptions = this._context && this._context.$options\n  var rootLinker = compiler.compileRoot(el, options, contextOptions)\n\n  // compile and link the rest\n  var contentLinkFn\n  var ctor = this.constructor\n  // component compilation can be cached\n  // as long as it's not using inline-template\n  if (options._linkerCachable) {\n    contentLinkFn = ctor.linker\n    if (!contentLinkFn) {\n      contentLinkFn = ctor.linker = compiler.compile(el, options)\n    }\n  }\n\n  // link phase\n  // make sure to link root with prop scope!\n  var rootUnlinkFn = rootLinker(this, el, this._scope)\n  var contentUnlinkFn = contentLinkFn\n    ? contentLinkFn(this, el)\n    : compiler.compile(el, options)(this, el)\n\n  // register composite unlink function\n  // to be called during instance destruction\n  this._unlinkFn = function () {\n    rootUnlinkFn()\n    // passing destroying: true to avoid searching and\n    // splicing the directives\n    contentUnlinkFn(true)\n  }\n\n  // finally replace original\n  if (options.replace) {\n    _.replace(original, el)\n  }\n\n  this._isCompiled = true\n  this._callHook('compiled')\n  return el\n}\n\n/**\n * Initialize instance element. Called in the public\n * $mount() method.\n *\n * @param {Element} el\n */\n\nexports._initElement = function (el) {\n  if (el instanceof DocumentFragment) {\n    this._isFragment = true\n    this.$el = this._fragmentStart = el.firstChild\n    this._fragmentEnd = el.lastChild\n    // set persisted text anchors to empty\n    if (this._fragmentStart.nodeType === 3) {\n      this._fragmentStart.data = this._fragmentEnd.data = ''\n    }\n    this._fragment = el\n  } else {\n    this.$el = el\n  }\n  this.$el.__vue__ = this\n  this._callHook('beforeCompile')\n}\n\n/**\n * Create and bind a directive to an element.\n *\n * @param {String} name - directive name\n * @param {Node} node   - target node\n * @param {Object} desc - parsed directive descriptor\n * @param {Object} def  - directive definition object\n * @param {Vue} [host] - transclusion host component\n * @param {Object} [scope] - v-for scope\n * @param {Fragment} [frag] - owner fragment\n */\n\nexports._bindDir = function (descriptor, node, host, scope, frag) {\n  this._directives.push(\n    new Directive(descriptor, this, node, host, scope, frag)\n  )\n}\n\n/**\n * Teardown an instance, unobserves the data, unbind all the\n * directives, turn off all the event listeners, etc.\n *\n * @param {Boolean} remove - whether to remove the DOM node.\n * @param {Boolean} deferCleanup - if true, defer cleanup to\n *                                 be called later\n */\n\nexports._destroy = function (remove, deferCleanup) {\n  if (this._isBeingDestroyed) {\n    return\n  }\n  this._callHook('beforeDestroy')\n  this._isBeingDestroyed = true\n  var i\n  // remove self from parent. only necessary\n  // if parent is not being destroyed as well.\n  var parent = this.$parent\n  if (parent && !parent._isBeingDestroyed) {\n    parent.$children.$remove(this)\n    // unregister ref\n    var ref = this.$options._ref\n    if (ref) {\n      var scope = this._scope || this._context\n      if (scope.$refs[ref] === this) {\n        scope.$refs[ref] = null\n      }\n    }\n  }\n  // remove self from owner fragment\n  if (this._frag) {\n    this._frag.children.$remove(this)\n  }\n  // destroy all children.\n  i = this.$children.length\n  while (i--) {\n    this.$children[i].$destroy()\n  }\n  // teardown props\n  if (this._propsUnlinkFn) {\n    this._propsUnlinkFn()\n  }\n  // teardown all directives. this also tearsdown all\n  // directive-owned watchers.\n  if (this._unlinkFn) {\n    this._unlinkFn()\n  }\n  i = this._watchers.length\n  while (i--) {\n    this._watchers[i].teardown()\n  }\n  // remove reference to self on $el\n  if (this.$el) {\n    this.$el.__vue__ = null\n  }\n  // remove DOM element\n  var self = this\n  if (remove && this.$el) {\n    this.$remove(function () {\n      self._cleanup()\n    })\n  } else if (!deferCleanup) {\n    this._cleanup()\n  }\n}\n\n/**\n * Clean up to ensure garbage collection.\n * This is called after the leave transition if there\n * is any.\n */\n\nexports._cleanup = function () {\n  // remove reference from data ob\n  // frozen object may not have observer.\n  if (this._data.__ob__) {\n    this._data.__ob__.removeVm(this)\n  }\n  // Clean up references to private properties and other\n  // instances. preserve reference to _data so that proxy\n  // accessors still work. The only potential side effect\n  // here is that mutating the instance after it's destroyed\n  // may affect the state of other components that are still\n  // observing the same object, but that seems to be a\n  // reasonable responsibility for the user rather than\n  // always throwing an error on them.\n  this.$el =\n  this.$parent =\n  this.$root =\n  this.$children =\n  this._watchers =\n  this._context =\n  this._scope =\n  this._directives = null\n  // call the last hook...\n  this._isDestroyed = true\n  this._callHook('destroyed')\n  // turn off all instance listeners.\n  this.$off()\n}\n\n},{\"../compiler\":82,\"../directive\":85,\"../util\":135}],118:[function(require,module,exports){\n(function (process){\nvar _ = require('../util')\n\n/**\n * Apply a list of filter (descriptors) to a value.\n * Using plain for loops here because this will be called in\n * the getter of any watcher with filters so it is very\n * performance sensitive.\n *\n * @param {*} value\n * @param {*} [oldValue]\n * @param {Array} filters\n * @param {Boolean} write\n * @return {*}\n */\n\nexports._applyFilters = function (value, oldValue, filters, write) {\n  var filter, fn, args, arg, offset, i, l, j, k\n  for (i = 0, l = filters.length; i < l; i++) {\n    filter = filters[i]\n    fn = _.resolveAsset(this.$options, 'filters', filter.name)\n    if (process.env.NODE_ENV !== 'production') {\n      _.assertAsset(fn, 'filter', filter.name)\n    }\n    if (!fn) continue\n    fn = write ? fn.write : (fn.read || fn)\n    if (typeof fn !== 'function') continue\n    args = write ? [value, oldValue] : [value]\n    offset = write ? 2 : 1\n    if (filter.args) {\n      for (j = 0, k = filter.args.length; j < k; j++) {\n        arg = filter.args[j]\n        args[j + offset] = arg.dynamic\n          ? this.$get(arg.value)\n          : arg.value\n      }\n    }\n    value = fn.apply(this, args)\n  }\n  return value\n}\n\n/**\n * Resolve a component, depending on whether the component\n * is defined normally or using an async factory function.\n * Resolves synchronously if already resolved, otherwise\n * resolves asynchronously and caches the resolved\n * constructor on the factory.\n *\n * @param {String} id\n * @param {Function} cb\n */\n\nexports._resolveComponent = function (id, cb) {\n  var factory = _.resolveAsset(this.$options, 'components', id)\n  if (process.env.NODE_ENV !== 'production') {\n    _.assertAsset(factory, 'component', id)\n  }\n  if (!factory) {\n    return\n  }\n  // async component factory\n  if (!factory.options) {\n    if (factory.resolved) {\n      // cached\n      cb(factory.resolved)\n    } else if (factory.requested) {\n      // pool callbacks\n      factory.pendingCallbacks.push(cb)\n    } else {\n      factory.requested = true\n      var cbs = factory.pendingCallbacks = [cb]\n      factory(function resolve (res) {\n        if (_.isPlainObject(res)) {\n          res = _.Vue.extend(res)\n        }\n        // cache resolved\n        factory.resolved = res\n        // invoke callbacks\n        for (var i = 0, l = cbs.length; i < l; i++) {\n          cbs[i](res)\n        }\n      }, function reject (reason) {\n        process.env.NODE_ENV !== 'production' && _.warn(\n          'Failed to resolve async component: ' + id + '. ' +\n          (reason ? '\\nReason: ' + reason : '')\n        )\n      })\n    }\n  } else {\n    // normal component\n    cb(factory)\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"../util\":135,\"_process\":1}],119:[function(require,module,exports){\n(function (process){\nvar _ = require('../util')\nvar compiler = require('../compiler')\nvar Observer = require('../observer')\nvar Dep = require('../observer/dep')\nvar Watcher = require('../watcher')\n\n/**\n * Setup the scope of an instance, which contains:\n * - observed data\n * - computed properties\n * - user methods\n * - meta properties\n */\n\nexports._initState = function () {\n  this._initProps()\n  this._initMeta()\n  this._initMethods()\n  this._initData()\n  this._initComputed()\n}\n\n/**\n * Initialize props.\n */\n\nexports._initProps = function () {\n  var options = this.$options\n  var el = options.el\n  var props = options.props\n  if (props && !el) {\n    process.env.NODE_ENV !== 'production' && _.warn(\n      'Props will not be compiled if no `el` option is ' +\n      'provided at instantiation.'\n    )\n  }\n  // make sure to convert string selectors into element now\n  el = options.el = _.query(el)\n  this._propsUnlinkFn = el && el.nodeType === 1 && props\n    // props must be linked in proper scope if inside v-for\n    ? compiler.compileAndLinkProps(this, el, props, this._scope)\n    : null\n}\n\n/**\n * Initialize the data.\n */\n\nexports._initData = function () {\n  var propsData = this._data\n  var optionsDataFn = this.$options.data\n  var optionsData = optionsDataFn && optionsDataFn()\n  if (optionsData) {\n    this._data = optionsData\n    for (var prop in propsData) {\n      if (process.env.NODE_ENV !== 'production' &&\n          optionsData.hasOwnProperty(prop)) {\n        _.warn(\n          'Data field \"' + prop + '\" is already defined ' +\n          'as a prop. Use prop default value instead.'\n        )\n      }\n      if (this._props[prop].raw !== null ||\n          !optionsData.hasOwnProperty(prop)) {\n        _.set(optionsData, prop, propsData[prop])\n      }\n    }\n  }\n  var data = this._data\n  // proxy data on instance\n  var keys = Object.keys(data)\n  var i, key\n  i = keys.length\n  while (i--) {\n    key = keys[i]\n    this._proxy(key)\n  }\n  // observe data\n  Observer.create(data, this)\n}\n\n/**\n * Swap the isntance's $data. Called in $data's setter.\n *\n * @param {Object} newData\n */\n\nexports._setData = function (newData) {\n  newData = newData || {}\n  var oldData = this._data\n  this._data = newData\n  var keys, key, i\n  // unproxy keys not present in new data\n  keys = Object.keys(oldData)\n  i = keys.length\n  while (i--) {\n    key = keys[i]\n    if (!(key in newData)) {\n      this._unproxy(key)\n    }\n  }\n  // proxy keys not already proxied,\n  // and trigger change for changed values\n  keys = Object.keys(newData)\n  i = keys.length\n  while (i--) {\n    key = keys[i]\n    if (!this.hasOwnProperty(key)) {\n      // new property\n      this._proxy(key)\n    }\n  }\n  oldData.__ob__.removeVm(this)\n  Observer.create(newData, this)\n  this._digest()\n}\n\n/**\n * Proxy a property, so that\n * vm.prop === vm._data.prop\n *\n * @param {String} key\n */\n\nexports._proxy = function (key) {\n  if (!_.isReserved(key)) {\n    // need to store ref to self here\n    // because these getter/setters might\n    // be called by child scopes via\n    // prototype inheritance.\n    var self = this\n    Object.defineProperty(self, key, {\n      configurable: true,\n      enumerable: true,\n      get: function proxyGetter () {\n        return self._data[key]\n      },\n      set: function proxySetter (val) {\n        self._data[key] = val\n      }\n    })\n  }\n}\n\n/**\n * Unproxy a property.\n *\n * @param {String} key\n */\n\nexports._unproxy = function (key) {\n  if (!_.isReserved(key)) {\n    delete this[key]\n  }\n}\n\n/**\n * Force update on every watcher in scope.\n */\n\nexports._digest = function () {\n  for (var i = 0, l = this._watchers.length; i < l; i++) {\n    this._watchers[i].update(true) // shallow updates\n  }\n}\n\n/**\n * Setup computed properties. They are essentially\n * special getter/setters\n */\n\nfunction noop () {}\nexports._initComputed = function () {\n  var computed = this.$options.computed\n  if (computed) {\n    for (var key in computed) {\n      var userDef = computed[key]\n      var def = {\n        enumerable: true,\n        configurable: true\n      }\n      if (typeof userDef === 'function') {\n        def.get = makeComputedGetter(userDef, this)\n        def.set = noop\n      } else {\n        def.get = userDef.get\n          ? userDef.cache !== false\n            ? makeComputedGetter(userDef.get, this)\n            : _.bind(userDef.get, this)\n          : noop\n        def.set = userDef.set\n          ? _.bind(userDef.set, this)\n          : noop\n      }\n      Object.defineProperty(this, key, def)\n    }\n  }\n}\n\nfunction makeComputedGetter (getter, owner) {\n  var watcher = new Watcher(owner, getter, null, {\n    lazy: true\n  })\n  return function computedGetter () {\n    if (watcher.dirty) {\n      watcher.evaluate()\n    }\n    if (Dep.target) {\n      watcher.depend()\n    }\n    return watcher.value\n  }\n}\n\n/**\n * Setup instance methods. Methods must be bound to the\n * instance since they might be passed down as a prop to\n * child components.\n */\n\nexports._initMethods = function () {\n  var methods = this.$options.methods\n  if (methods) {\n    for (var key in methods) {\n      this[key] = _.bind(methods[key], this)\n    }\n  }\n}\n\n/**\n * Initialize meta information like $index, $key & $value.\n */\n\nexports._initMeta = function () {\n  var metas = this.$options._meta\n  if (metas) {\n    for (var key in metas) {\n      _.defineReactive(this, key, metas[key])\n    }\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"../compiler\":82,\"../observer\":122,\"../observer/dep\":121,\"../util\":135,\"../watcher\":139,\"_process\":1}],120:[function(require,module,exports){\nvar _ = require('../util')\nvar arrayProto = Array.prototype\nvar arrayMethods = Object.create(arrayProto)\n\n/**\n * Intercept mutating methods and emit events\n */\n\n;[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n]\n.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method]\n  _.define(arrayMethods, method, function mutator () {\n    // avoid leaking arguments:\n    // http://jsperf.com/closure-with-arguments\n    var i = arguments.length\n    var args = new Array(i)\n    while (i--) {\n      args[i] = arguments[i]\n    }\n    var result = original.apply(this, args)\n    var ob = this.__ob__\n    var inserted\n    switch (method) {\n      case 'push':\n        inserted = args\n        break\n      case 'unshift':\n        inserted = args\n        break\n      case 'splice':\n        inserted = args.slice(2)\n        break\n    }\n    if (inserted) ob.observeArray(inserted)\n    // notify change\n    ob.dep.notify()\n    return result\n  })\n})\n\n/**\n * Swap the element at the given index with a new value\n * and emits corresponding event.\n *\n * @param {Number} index\n * @param {*} val\n * @return {*} - replaced element\n */\n\n_.define(\n  arrayProto,\n  '$set',\n  function $set (index, val) {\n    if (index >= this.length) {\n      this.length = index + 1\n    }\n    return this.splice(index, 1, val)[0]\n  }\n)\n\n/**\n * Convenience method to remove the element at given index.\n *\n * @param {Number} index\n * @param {*} val\n */\n\n_.define(\n  arrayProto,\n  '$remove',\n  function $remove (item) {\n    /* istanbul ignore if */\n    if (!this.length) return\n    var index = _.indexOf(this, item)\n    if (index > -1) {\n      return this.splice(index, 1)\n    }\n  }\n)\n\nmodule.exports = arrayMethods\n\n},{\"../util\":135}],121:[function(require,module,exports){\nvar _ = require('../util')\nvar uid = 0\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n *\n * @constructor\n */\n\nfunction Dep () {\n  this.id = uid++\n  this.subs = []\n}\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null\n\n/**\n * Add a directive subscriber.\n *\n * @param {Directive} sub\n */\n\nDep.prototype.addSub = function (sub) {\n  this.subs.push(sub)\n}\n\n/**\n * Remove a directive subscriber.\n *\n * @param {Directive} sub\n */\n\nDep.prototype.removeSub = function (sub) {\n  this.subs.$remove(sub)\n}\n\n/**\n * Add self as a dependency to the target watcher.\n */\n\nDep.prototype.depend = function () {\n  Dep.target.addDep(this)\n}\n\n/**\n * Notify all subscribers of a new value.\n */\n\nDep.prototype.notify = function () {\n  // stablize the subscriber list first\n  var subs = _.toArray(this.subs)\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update()\n  }\n}\n\nmodule.exports = Dep\n\n},{\"../util\":135}],122:[function(require,module,exports){\nvar _ = require('../util')\nvar Dep = require('./dep')\nvar arrayMethods = require('./array')\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods)\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n *\n * @param {Array|Object} value\n * @constructor\n */\n\nfunction Observer (value) {\n  this.value = value\n  this.dep = new Dep()\n  _.define(value, '__ob__', this)\n  if (_.isArray(value)) {\n    var augment = _.hasProto\n      ? protoAugment\n      : copyAugment\n    augment(value, arrayMethods, arrayKeys)\n    this.observeArray(value)\n  } else {\n    this.walk(value)\n  }\n}\n\n// Static methods\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n *\n * @param {*} value\n * @param {Vue} [vm]\n * @return {Observer|undefined}\n * @static\n */\n\nObserver.create = function (value, vm) {\n  if (!value || typeof value !== 'object') {\n    return\n  }\n  var ob\n  if (\n    value.hasOwnProperty('__ob__') &&\n    value.__ob__ instanceof Observer\n  ) {\n    ob = value.__ob__\n  } else if (\n    (_.isArray(value) || _.isPlainObject(value)) &&\n    !Object.isFrozen(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value)\n  }\n  if (ob && vm) {\n    ob.addVm(vm)\n  }\n  return ob\n}\n\n// Instance methods\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n *\n * @param {Object} obj\n */\n\nObserver.prototype.walk = function (obj) {\n  var keys = Object.keys(obj)\n  var i = keys.length\n  while (i--) {\n    this.convert(keys[i], obj[keys[i]])\n  }\n}\n\n/**\n * Observe a list of Array items.\n *\n * @param {Array} items\n */\n\nObserver.prototype.observeArray = function (items) {\n  var i = items.length\n  while (i--) {\n    Observer.create(items[i])\n  }\n}\n\n/**\n * Convert a property into getter/setter so we can emit\n * the events when the property is accessed/changed.\n *\n * @param {String} key\n * @param {*} val\n */\n\nObserver.prototype.convert = function (key, val) {\n  defineReactive(this.value, key, val)\n}\n\n/**\n * Add an owner vm, so that when $set/$delete mutations\n * happen we can notify owner vms to proxy the keys and\n * digest the watchers. This is only called when the object\n * is observed as an instance's root $data.\n *\n * @param {Vue} vm\n */\n\nObserver.prototype.addVm = function (vm) {\n  (this.vms || (this.vms = [])).push(vm)\n}\n\n/**\n * Remove an owner vm. This is called when the object is\n * swapped out as an instance's $data object.\n *\n * @param {Vue} vm\n */\n\nObserver.prototype.removeVm = function (vm) {\n  this.vms.$remove(vm)\n}\n\n// helpers\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n *\n * @param {Object|Array} target\n * @param {Object} proto\n */\n\nfunction protoAugment (target, src) {\n  target.__proto__ = src\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n *\n * @param {Object|Array} target\n * @param {Object} proto\n */\n\nfunction copyAugment (target, src, keys) {\n  var i = keys.length\n  var key\n  while (i--) {\n    key = keys[i]\n    _.define(target, key, src[key])\n  }\n}\n\n/**\n * Define a reactive property on an Object.\n *\n * @param {Object} obj\n * @param {String} key\n * @param {*} val\n */\n\nfunction defineReactive (obj, key, val) {\n  var dep = new Dep()\n  var childOb = Observer.create(val)\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function metaGetter () {\n      if (Dep.target) {\n        dep.depend()\n        if (childOb) {\n          childOb.dep.depend()\n        }\n        if (_.isArray(val)) {\n          for (var e, i = 0, l = val.length; i < l; i++) {\n            e = val[i]\n            e && e.__ob__ && e.__ob__.dep.depend()\n          }\n        }\n      }\n      return val\n    },\n    set: function metaSetter (newVal) {\n      if (newVal === val) return\n      val = newVal\n      childOb = Observer.create(newVal)\n      dep.notify()\n    }\n  })\n}\n\n// Attach to the util object so it can be used elsewhere.\n_.defineReactive = defineReactive\n\nmodule.exports = Observer\n\n},{\"../util\":135,\"./array\":120,\"./dep\":121}],123:[function(require,module,exports){\nvar _ = require('../util')\nvar Cache = require('../cache')\nvar cache = new Cache(1000)\nvar filterTokenRE = /[^\\s'\"]+|'[^']*'|\"[^\"]*\"/g\nvar reservedArgRE = /^in$|^-?\\d+/\n\n/**\n * Parser state\n */\n\nvar str, dir\nvar c, i, l, lastFilterIndex\nvar inSingle, inDouble, curly, square, paren\n\n/**\n * Push a filter to the current directive object\n */\n\nfunction pushFilter () {\n  var exp = str.slice(lastFilterIndex, i).trim()\n  var filter\n  if (exp) {\n    filter = {}\n    var tokens = exp.match(filterTokenRE)\n    filter.name = tokens[0]\n    if (tokens.length > 1) {\n      filter.args = tokens.slice(1).map(processFilterArg)\n    }\n  }\n  if (filter) {\n    (dir.filters = dir.filters || []).push(filter)\n  }\n  lastFilterIndex = i + 1\n}\n\n/**\n * Check if an argument is dynamic and strip quotes.\n *\n * @param {String} arg\n * @return {Object}\n */\n\nfunction processFilterArg (arg) {\n  if (reservedArgRE.test(arg)) {\n    return {\n      value: _.toNumber(arg),\n      dynamic: false\n    }\n  } else {\n    var stripped = _.stripQuotes(arg)\n    var dynamic = stripped === arg\n    return {\n      value: dynamic ? arg : stripped,\n      dynamic: dynamic\n    }\n  }\n}\n\n/**\n * Parse a directive value and extract the expression\n * and its filters into a descriptor.\n *\n * Example:\n *\n * \"a + 1 | uppercase\" will yield:\n * {\n *   expression: 'a + 1',\n *   filters: [\n *     { name: 'uppercase', args: null }\n *   ]\n * }\n *\n * @param {String} str\n * @return {Object}\n */\n\nexports.parse = function (s) {\n\n  var hit = cache.get(s)\n  if (hit) {\n    return hit\n  }\n\n  // reset parser state\n  str = s\n  inSingle = inDouble = false\n  curly = square = paren = 0\n  lastFilterIndex = 0\n  dir = {}\n\n  for (i = 0, l = str.length; i < l; i++) {\n    c = str.charCodeAt(i)\n    if (inSingle) {\n      // check single quote\n      if (c === 0x27) inSingle = !inSingle\n    } else if (inDouble) {\n      // check double quote\n      if (c === 0x22) inDouble = !inDouble\n    } else if (\n      c === 0x7C && // pipe\n      str.charCodeAt(i + 1) !== 0x7C &&\n      str.charCodeAt(i - 1) !== 0x7C\n    ) {\n      if (dir.expression == null) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1\n        dir.expression = str.slice(0, i).trim()\n      } else {\n        // already has filter\n        pushFilter()\n      }\n    } else {\n      switch (c) {\n        case 0x22: inDouble = true; break // \"\n        case 0x27: inSingle = true; break // '\n        case 0x28: paren++; break         // (\n        case 0x29: paren--; break         // )\n        case 0x5B: square++; break        // [\n        case 0x5D: square--; break        // ]\n        case 0x7B: curly++; break         // {\n        case 0x7D: curly--; break         // }\n      }\n    }\n  }\n\n  if (dir.expression == null) {\n    dir.expression = str.slice(0, i).trim()\n  } else if (lastFilterIndex !== 0) {\n    pushFilter()\n  }\n\n  cache.put(s, dir)\n  return dir\n}\n\n},{\"../cache\":79,\"../util\":135}],124:[function(require,module,exports){\n(function (process){\nvar _ = require('../util')\nvar Path = require('./path')\nvar Cache = require('../cache')\nvar expressionCache = new Cache(1000)\n\nvar allowedKeywords =\n  'Math,Date,this,true,false,null,undefined,Infinity,NaN,' +\n  'isNaN,isFinite,decodeURI,decodeURIComponent,encodeURI,' +\n  'encodeURIComponent,parseInt,parseFloat'\nvar allowedKeywordsRE =\n  new RegExp('^(' + allowedKeywords.replace(/,/g, '\\\\b|') + '\\\\b)')\n\n// keywords that don't make sense inside expressions\nvar improperKeywords =\n  'break,case,class,catch,const,continue,debugger,default,' +\n  'delete,do,else,export,extends,finally,for,function,if,' +\n  'import,in,instanceof,let,return,super,switch,throw,try,' +\n  'var,while,with,yield,enum,await,implements,package,' +\n  'proctected,static,interface,private,public'\nvar improperKeywordsRE =\n  new RegExp('^(' + improperKeywords.replace(/,/g, '\\\\b|') + '\\\\b)')\n\nvar wsRE = /\\s/g\nvar newlineRE = /\\n/g\nvar saveRE = /[\\{,]\\s*[\\w\\$_]+\\s*:|('[^']*'|\"[^\"]*\")|new |typeof |void /g\nvar restoreRE = /\"(\\d+)\"/g\nvar pathTestRE = /^[A-Za-z_$][\\w$]*(\\.[A-Za-z_$][\\w$]*|\\['.*?'\\]|\\[\".*?\"\\]|\\[\\d+\\]|\\[[A-Za-z_$][\\w$]*\\])*$/\nvar pathReplaceRE = /[^\\w$\\.]([A-Za-z_$][\\w$]*(\\.[A-Za-z_$][\\w$]*|\\['.*?'\\]|\\[\".*?\"\\])*)/g\nvar booleanLiteralRE = /^(true|false)$/\n\n/**\n * Save / Rewrite / Restore\n *\n * When rewriting paths found in an expression, it is\n * possible for the same letter sequences to be found in\n * strings and Object literal property keys. Therefore we\n * remove and store these parts in a temporary array, and\n * restore them after the path rewrite.\n */\n\nvar saved = []\n\n/**\n * Save replacer\n *\n * The save regex can match two possible cases:\n * 1. An opening object literal\n * 2. A string\n * If matched as a plain string, we need to escape its\n * newlines, since the string needs to be preserved when\n * generating the function body.\n *\n * @param {String} str\n * @param {String} isString - str if matched as a string\n * @return {String} - placeholder with index\n */\n\nfunction save (str, isString) {\n  var i = saved.length\n  saved[i] = isString\n    ? str.replace(newlineRE, '\\\\n')\n    : str\n  return '\"' + i + '\"'\n}\n\n/**\n * Path rewrite replacer\n *\n * @param {String} raw\n * @return {String}\n */\n\nfunction rewrite (raw) {\n  var c = raw.charAt(0)\n  var path = raw.slice(1)\n  if (allowedKeywordsRE.test(path)) {\n    return raw\n  } else {\n    path = path.indexOf('\"') > -1\n      ? path.replace(restoreRE, restore)\n      : path\n    return c + 'scope.' + path\n  }\n}\n\n/**\n * Restore replacer\n *\n * @param {String} str\n * @param {String} i - matched save index\n * @return {String}\n */\n\nfunction restore (str, i) {\n  return saved[i]\n}\n\n/**\n * Rewrite an expression, prefixing all path accessors with\n * `scope.` and generate getter/setter functions.\n *\n * @param {String} exp\n * @param {Boolean} needSet\n * @return {Function}\n */\n\nfunction compileExpFns (exp, needSet) {\n  if (improperKeywordsRE.test(exp)) {\n    process.env.NODE_ENV !== 'production' && _.warn(\n      'Avoid using reserved keywords in expression: ' + exp\n    )\n  }\n  // reset state\n  saved.length = 0\n  // save strings and object literal keys\n  var body = exp\n    .replace(saveRE, save)\n    .replace(wsRE, '')\n  // rewrite all paths\n  // pad 1 space here becaue the regex matches 1 extra char\n  body = (' ' + body)\n    .replace(pathReplaceRE, rewrite)\n    .replace(restoreRE, restore)\n  var getter = makeGetter(body)\n  if (getter) {\n    return {\n      get: getter,\n      body: body,\n      set: needSet\n        ? makeSetter(body)\n        : null\n    }\n  }\n}\n\n/**\n * Compile getter setters for a simple path.\n *\n * @param {String} exp\n * @return {Function}\n */\n\nfunction compilePathFns (exp) {\n  var getter, path\n  if (exp.indexOf('[') < 0) {\n    // really simple path\n    path = exp.split('.')\n    path.raw = exp\n    getter = Path.compileGetter(path)\n  } else {\n    // do the real parsing\n    path = Path.parse(exp)\n    getter = path.get\n  }\n  return {\n    get: getter,\n    // always generate setter for simple paths\n    set: function (obj, val) {\n      Path.set(obj, path, val)\n    }\n  }\n}\n\n/**\n * Build a getter function. Requires eval.\n *\n * We isolate the try/catch so it doesn't affect the\n * optimization of the parse function when it is not called.\n *\n * @param {String} body\n * @return {Function|undefined}\n */\n\nfunction makeGetter (body) {\n  try {\n    return new Function('scope', 'return ' + body + ';')\n  } catch (e) {\n    process.env.NODE_ENV !== 'production' && _.warn(\n      'Invalid expression. ' +\n      'Generated function body: ' + body\n    )\n  }\n}\n\n/**\n * Build a setter function.\n *\n * This is only needed in rare situations like \"a[b]\" where\n * a settable path requires dynamic evaluation.\n *\n * This setter function may throw error when called if the\n * expression body is not a valid left-hand expression in\n * assignment.\n *\n * @param {String} body\n * @return {Function|undefined}\n */\n\nfunction makeSetter (body) {\n  try {\n    return new Function('scope', 'value', body + '=value;')\n  } catch (e) {\n    process.env.NODE_ENV !== 'production' && _.warn(\n      'Invalid setter function body: ' + body\n    )\n  }\n}\n\n/**\n * Check for setter existence on a cache hit.\n *\n * @param {Function} hit\n */\n\nfunction checkSetter (hit) {\n  if (!hit.set) {\n    hit.set = makeSetter(hit.body)\n  }\n}\n\n/**\n * Parse an expression into re-written getter/setters.\n *\n * @param {String} exp\n * @param {Boolean} needSet\n * @return {Function}\n */\n\nexports.parse = function (exp, needSet) {\n  exp = exp.trim()\n  // try cache\n  var hit = expressionCache.get(exp)\n  if (hit) {\n    if (needSet) {\n      checkSetter(hit)\n    }\n    return hit\n  }\n  // we do a simple path check to optimize for them.\n  // the check fails valid paths with unusal whitespaces,\n  // but that's too rare and we don't care.\n  // also skip boolean literals and paths that start with\n  // global \"Math\"\n  var res = exports.isSimplePath(exp)\n    ? compilePathFns(exp)\n    : compileExpFns(exp, needSet)\n  expressionCache.put(exp, res)\n  return res\n}\n\n/**\n * Check if an expression is a simple path.\n *\n * @param {String} exp\n * @return {Boolean}\n */\n\nexports.isSimplePath = function (exp) {\n  return pathTestRE.test(exp) &&\n    // don't treat true/false as paths\n    !booleanLiteralRE.test(exp) &&\n    // Math constants e.g. Math.PI, Math.E etc.\n    exp.slice(0, 5) !== 'Math.'\n}\n\n}).call(this,require('_process'))\n\n},{\"../cache\":79,\"../util\":135,\"./path\":125,\"_process\":1}],125:[function(require,module,exports){\n(function (process){\nvar _ = require('../util')\nvar Cache = require('../cache')\nvar pathCache = new Cache(1000)\nvar identRE = exports.identRE = /^[$_a-zA-Z]+[\\w$]*$/\n\n// actions\nvar APPEND = 0\nvar PUSH = 1\n\n// states\nvar BEFORE_PATH = 0\nvar IN_PATH = 1\nvar BEFORE_IDENT = 2\nvar IN_IDENT = 3\nvar BEFORE_ELEMENT = 4\nvar AFTER_ZERO = 5\nvar IN_INDEX = 6\nvar IN_SINGLE_QUOTE = 7\nvar IN_DOUBLE_QUOTE = 8\nvar IN_SUB_PATH = 9\nvar AFTER_ELEMENT = 10\nvar AFTER_PATH = 11\nvar ERROR = 12\n\nvar pathStateMachine = []\n\npathStateMachine[BEFORE_PATH] = {\n  'ws': [BEFORE_PATH],\n  'ident': [IN_IDENT, APPEND],\n  '[': [BEFORE_ELEMENT],\n  'eof': [AFTER_PATH]\n}\n\npathStateMachine[IN_PATH] = {\n  'ws': [IN_PATH],\n  '.': [BEFORE_IDENT],\n  '[': [BEFORE_ELEMENT],\n  'eof': [AFTER_PATH]\n}\n\npathStateMachine[BEFORE_IDENT] = {\n  'ws': [BEFORE_IDENT],\n  'ident': [IN_IDENT, APPEND]\n}\n\npathStateMachine[IN_IDENT] = {\n  'ident': [IN_IDENT, APPEND],\n  '0': [IN_IDENT, APPEND],\n  'number': [IN_IDENT, APPEND],\n  'ws': [IN_PATH, PUSH],\n  '.': [BEFORE_IDENT, PUSH],\n  '[': [BEFORE_ELEMENT, PUSH],\n  'eof': [AFTER_PATH, PUSH]\n}\n\npathStateMachine[BEFORE_ELEMENT] = {\n  'ws': [BEFORE_ELEMENT],\n  '0': [AFTER_ZERO, APPEND],\n  'number': [IN_INDEX, APPEND],\n  \"'\": [IN_SINGLE_QUOTE, APPEND, ''],\n  '\"': [IN_DOUBLE_QUOTE, APPEND, ''],\n  'ident': [IN_SUB_PATH, APPEND, '*']\n}\n\npathStateMachine[AFTER_ZERO] = {\n  'ws': [AFTER_ELEMENT, PUSH],\n  ']': [IN_PATH, PUSH]\n}\n\npathStateMachine[IN_INDEX] = {\n  '0': [IN_INDEX, APPEND],\n  'number': [IN_INDEX, APPEND],\n  'ws': [AFTER_ELEMENT],\n  ']': [IN_PATH, PUSH]\n}\n\npathStateMachine[IN_SINGLE_QUOTE] = {\n  \"'\": [AFTER_ELEMENT],\n  'eof': ERROR,\n  'else': [IN_SINGLE_QUOTE, APPEND]\n}\n\npathStateMachine[IN_DOUBLE_QUOTE] = {\n  '\"': [AFTER_ELEMENT],\n  'eof': ERROR,\n  'else': [IN_DOUBLE_QUOTE, APPEND]\n}\n\npathStateMachine[IN_SUB_PATH] = {\n  'ident': [IN_SUB_PATH, APPEND],\n  '0': [IN_SUB_PATH, APPEND],\n  'number': [IN_SUB_PATH, APPEND],\n  'ws': [AFTER_ELEMENT],\n  ']': [IN_PATH, PUSH]\n}\n\npathStateMachine[AFTER_ELEMENT] = {\n  'ws': [AFTER_ELEMENT],\n  ']': [IN_PATH, PUSH]\n}\n\n/**\n * Determine the type of a character in a keypath.\n *\n * @param {Char} ch\n * @return {String} type\n */\n\nfunction getPathCharType (ch) {\n  if (ch === undefined) {\n    return 'eof'\n  }\n\n  var code = ch.charCodeAt(0)\n\n  switch (code) {\n    case 0x5B: // [\n    case 0x5D: // ]\n    case 0x2E: // .\n    case 0x22: // \"\n    case 0x27: // '\n    case 0x30: // 0\n      return ch\n\n    case 0x5F: // _\n    case 0x24: // $\n      return 'ident'\n\n    case 0x20: // Space\n    case 0x09: // Tab\n    case 0x0A: // Newline\n    case 0x0D: // Return\n    case 0xA0:  // No-break space\n    case 0xFEFF:  // Byte Order Mark\n    case 0x2028:  // Line Separator\n    case 0x2029:  // Paragraph Separator\n      return 'ws'\n  }\n\n  // a-z, A-Z\n  if (\n    (code >= 0x61 && code <= 0x7A) ||\n    (code >= 0x41 && code <= 0x5A)\n  ) {\n    return 'ident'\n  }\n\n  // 1-9\n  if (code >= 0x31 && code <= 0x39) {\n    return 'number'\n  }\n\n  return 'else'\n}\n\n/**\n * Parse a string path into an array of segments\n *\n * @param {String} path\n * @return {Array|undefined}\n */\n\nfunction parsePath (path) {\n  var keys = []\n  var index = -1\n  var mode = BEFORE_PATH\n  var c, newChar, key, type, transition, action, typeMap\n\n  var actions = []\n  actions[PUSH] = function () {\n    if (key === undefined) {\n      return\n    }\n    keys.push(key)\n    key = undefined\n  }\n  actions[APPEND] = function () {\n    if (key === undefined) {\n      key = newChar\n    } else {\n      key += newChar\n    }\n  }\n\n  function maybeUnescapeQuote () {\n    var nextChar = path[index + 1]\n    if ((mode === IN_SINGLE_QUOTE && nextChar === \"'\") ||\n        (mode === IN_DOUBLE_QUOTE && nextChar === '\"')) {\n      index++\n      newChar = nextChar\n      actions[APPEND]()\n      return true\n    }\n  }\n\n  while (mode != null) {\n    index++\n    c = path[index]\n\n    if (c === '\\\\' && maybeUnescapeQuote()) {\n      continue\n    }\n\n    type = getPathCharType(c)\n    typeMap = pathStateMachine[mode]\n    transition = typeMap[type] || typeMap['else'] || ERROR\n\n    if (transition === ERROR) {\n      return // parse error\n    }\n\n    mode = transition[0]\n    action = actions[transition[1]]\n    if (action) {\n      newChar = transition[2]\n      newChar = newChar === undefined\n        ? c\n        : newChar === '*'\n          ? newChar + c\n          : newChar\n      action()\n    }\n\n    if (mode === AFTER_PATH) {\n      keys.raw = path\n      return keys\n    }\n  }\n}\n\n/**\n * Format a accessor segment based on its type.\n *\n * @param {String} key\n * @return {Boolean}\n */\n\nfunction formatAccessor (key) {\n  if (identRE.test(key)) { // identifier\n    return '.' + key\n  } else if (+key === key >>> 0) { // bracket index\n    return '[' + key + ']'\n  } else if (key.charAt(0) === '*') {\n    return '[o' + formatAccessor(key.slice(1)) + ']'\n  } else { // bracket string\n    return '[\"' + key.replace(/\"/g, '\\\\\"') + '\"]'\n  }\n}\n\n/**\n * Compiles a getter function with a fixed path.\n * The fixed path getter supresses errors.\n *\n * @param {Array} path\n * @return {Function}\n */\n\nexports.compileGetter = function (path) {\n  var body = 'return o' + path.map(formatAccessor).join('')\n  return new Function('o', body)\n}\n\n/**\n * External parse that check for a cache hit first\n *\n * @param {String} path\n * @return {Array|undefined}\n */\n\nexports.parse = function (path) {\n  var hit = pathCache.get(path)\n  if (!hit) {\n    hit = parsePath(path)\n    if (hit) {\n      hit.get = exports.compileGetter(hit)\n      pathCache.put(path, hit)\n    }\n  }\n  return hit\n}\n\n/**\n * Get from an object from a path string\n *\n * @param {Object} obj\n * @param {String} path\n */\n\nexports.get = function (obj, path) {\n  path = exports.parse(path)\n  if (path) {\n    return path.get(obj)\n  }\n}\n\n/**\n * Warn against setting non-existent root path on a vm.\n */\n\nvar warnNonExistent\nif (process.env.NODE_ENV !== 'production') {\n  warnNonExistent = function (path) {\n    _.warn(\n      'You are setting a non-existent path \"' + path.raw + '\" ' +\n      'on a vm instance. Consider pre-initializing the property ' +\n      'with the \"data\" option for more reliable reactivity ' +\n      'and better performance.'\n    )\n  }\n}\n\n/**\n * Set on an object from a path\n *\n * @param {Object} obj\n * @param {String | Array} path\n * @param {*} val\n */\n\nexports.set = function (obj, path, val) {\n  var original = obj\n  if (typeof path === 'string') {\n    path = exports.parse(path)\n  }\n  if (!path || !_.isObject(obj)) {\n    return false\n  }\n  var last, key\n  for (var i = 0, l = path.length; i < l; i++) {\n    last = obj\n    key = path[i]\n    if (key.charAt(0) === '*') {\n      key = original[key.slice(1)]\n    }\n    if (i < l - 1) {\n      obj = obj[key]\n      if (!_.isObject(obj)) {\n        obj = {}\n        if (process.env.NODE_ENV !== 'production' && last._isVue) {\n          warnNonExistent(path)\n        }\n        _.set(last, key, obj)\n      }\n    } else {\n      if (_.isArray(obj)) {\n        obj.$set(key, val)\n      } else if (key in obj) {\n        obj[key] = val\n      } else {\n        if (process.env.NODE_ENV !== 'production' && obj._isVue) {\n          warnNonExistent(path)\n        }\n        _.set(obj, key, val)\n      }\n    }\n  }\n  return true\n}\n\n}).call(this,require('_process'))\n\n},{\"../cache\":79,\"../util\":135,\"_process\":1}],126:[function(require,module,exports){\nvar _ = require('../util')\nvar Cache = require('../cache')\nvar templateCache = new Cache(1000)\nvar idSelectorCache = new Cache(1000)\n\nvar map = {\n  _default: [0, '', ''],\n  legend: [1, '<fieldset>', '</fieldset>'],\n  tr: [2, '<table><tbody>', '</tbody></table>'],\n  col: [\n    2,\n    '<table><tbody></tbody><colgroup>',\n    '</colgroup></table>'\n  ]\n}\n\nmap.td =\nmap.th = [\n  3,\n  '<table><tbody><tr>',\n  '</tr></tbody></table>'\n]\n\nmap.option =\nmap.optgroup = [\n  1,\n  '<select multiple=\"multiple\">',\n  '</select>'\n]\n\nmap.thead =\nmap.tbody =\nmap.colgroup =\nmap.caption =\nmap.tfoot = [1, '<table>', '</table>']\n\nmap.g =\nmap.defs =\nmap.symbol =\nmap.use =\nmap.image =\nmap.text =\nmap.circle =\nmap.ellipse =\nmap.line =\nmap.path =\nmap.polygon =\nmap.polyline =\nmap.rect = [\n  1,\n  '<svg ' +\n    'xmlns=\"http://www.w3.org/2000/svg\" ' +\n    'xmlns:xlink=\"http://www.w3.org/1999/xlink\" ' +\n    'xmlns:ev=\"http://www.w3.org/2001/xml-events\"' +\n    'version=\"1.1\">',\n  '</svg>'\n]\n\n/**\n * Check if a node is a supported template node with a\n * DocumentFragment content.\n *\n * @param {Node} node\n * @return {Boolean}\n */\n\nfunction isRealTemplate (node) {\n  return _.isTemplate(node) &&\n    node.content instanceof DocumentFragment\n}\n\nvar tagRE = /<([\\w:]+)/\nvar entityRE = /&\\w+;|&#\\d+;|&#x[\\dA-F]+;/\n\n/**\n * Convert a string template to a DocumentFragment.\n * Determines correct wrapping by tag types. Wrapping\n * strategy found in jQuery & component/domify.\n *\n * @param {String} templateString\n * @return {DocumentFragment}\n */\n\nfunction stringToFragment (templateString) {\n  // try a cache hit first\n  var hit = templateCache.get(templateString)\n  if (hit) {\n    return hit\n  }\n\n  var frag = document.createDocumentFragment()\n  var tagMatch = templateString.match(tagRE)\n  var entityMatch = entityRE.test(templateString)\n\n  if (!tagMatch && !entityMatch) {\n    // text only, return a single text node.\n    frag.appendChild(\n      document.createTextNode(templateString)\n    )\n  } else {\n\n    var tag = tagMatch && tagMatch[1]\n    var wrap = map[tag] || map._default\n    var depth = wrap[0]\n    var prefix = wrap[1]\n    var suffix = wrap[2]\n    var node = document.createElement('div')\n\n    node.innerHTML = prefix + templateString.trim() + suffix\n    while (depth--) {\n      node = node.lastChild\n    }\n\n    var child\n    /* eslint-disable no-cond-assign */\n    while (child = node.firstChild) {\n    /* eslint-enable no-cond-assign */\n      frag.appendChild(child)\n    }\n  }\n\n  templateCache.put(templateString, frag)\n  return frag\n}\n\n/**\n * Convert a template node to a DocumentFragment.\n *\n * @param {Node} node\n * @return {DocumentFragment}\n */\n\nfunction nodeToFragment (node) {\n  // if its a template tag and the browser supports it,\n  // its content is already a document fragment.\n  if (isRealTemplate(node)) {\n    _.trimNode(node.content)\n    return node.content\n  }\n  // script template\n  if (node.tagName === 'SCRIPT') {\n    return stringToFragment(node.textContent)\n  }\n  // normal node, clone it to avoid mutating the original\n  var clone = exports.clone(node)\n  var frag = document.createDocumentFragment()\n  var child\n  /* eslint-disable no-cond-assign */\n  while (child = clone.firstChild) {\n  /* eslint-enable no-cond-assign */\n    frag.appendChild(child)\n  }\n  _.trimNode(frag)\n  return frag\n}\n\n// Test for the presence of the Safari template cloning bug\n// https://bugs.webkit.org/show_bug.cgi?id=137755\nvar hasBrokenTemplate = (function () {\n  /* istanbul ignore else */\n  if (_.inBrowser) {\n    var a = document.createElement('div')\n    a.innerHTML = '<template>1</template>'\n    return !a.cloneNode(true).firstChild.innerHTML\n  } else {\n    return false\n  }\n})()\n\n// Test for IE10/11 textarea placeholder clone bug\nvar hasTextareaCloneBug = (function () {\n  /* istanbul ignore else */\n  if (_.inBrowser) {\n    var t = document.createElement('textarea')\n    t.placeholder = 't'\n    return t.cloneNode(true).value === 't'\n  } else {\n    return false\n  }\n})()\n\n/**\n * 1. Deal with Safari cloning nested <template> bug by\n *    manually cloning all template instances.\n * 2. Deal with IE10/11 textarea placeholder bug by setting\n *    the correct value after cloning.\n *\n * @param {Element|DocumentFragment} node\n * @return {Element|DocumentFragment}\n */\n\nexports.clone = function (node) {\n  if (!node.querySelectorAll) {\n    return node.cloneNode()\n  }\n  var res = node.cloneNode(true)\n  var i, original, cloned\n  /* istanbul ignore if */\n  if (hasBrokenTemplate) {\n    var clone = res\n    if (isRealTemplate(node)) {\n      node = node.content\n      clone = res.content\n    }\n    original = node.querySelectorAll('template')\n    if (original.length) {\n      cloned = clone.querySelectorAll('template')\n      i = cloned.length\n      while (i--) {\n        cloned[i].parentNode.replaceChild(\n          exports.clone(original[i]),\n          cloned[i]\n        )\n      }\n    }\n  }\n  /* istanbul ignore if */\n  if (hasTextareaCloneBug) {\n    if (node.tagName === 'TEXTAREA') {\n      res.value = node.value\n    } else {\n      original = node.querySelectorAll('textarea')\n      if (original.length) {\n        cloned = res.querySelectorAll('textarea')\n        i = cloned.length\n        while (i--) {\n          cloned[i].value = original[i].value\n        }\n      }\n    }\n  }\n  return res\n}\n\n/**\n * Process the template option and normalizes it into a\n * a DocumentFragment that can be used as a partial or a\n * instance template.\n *\n * @param {*} template\n *    Possible values include:\n *    - DocumentFragment object\n *    - Node object of type Template\n *    - id selector: '#some-template-id'\n *    - template string: '<div><span>{{msg}}</span></div>'\n * @param {Boolean} clone\n * @param {Boolean} noSelector\n * @return {DocumentFragment|undefined}\n */\n\nexports.parse = function (template, clone, noSelector) {\n  var node, frag\n\n  // if the template is already a document fragment,\n  // do nothing\n  if (template instanceof DocumentFragment) {\n    _.trimNode(template)\n    return clone\n      ? exports.clone(template)\n      : template\n  }\n\n  if (typeof template === 'string') {\n    // id selector\n    if (!noSelector && template.charAt(0) === '#') {\n      // id selector can be cached too\n      frag = idSelectorCache.get(template)\n      if (!frag) {\n        node = document.getElementById(template.slice(1))\n        if (node) {\n          frag = nodeToFragment(node)\n          // save selector to cache\n          idSelectorCache.put(template, frag)\n        }\n      }\n    } else {\n      // normal string template\n      frag = stringToFragment(template)\n    }\n  } else if (template.nodeType) {\n    // a direct node\n    frag = nodeToFragment(template)\n  }\n\n  return frag && clone\n    ? exports.clone(frag)\n    : frag\n}\n\n},{\"../cache\":79,\"../util\":135}],127:[function(require,module,exports){\nvar Cache = require('../cache')\nvar config = require('../config')\nvar dirParser = require('./directive')\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g\nvar cache, tagRE, htmlRE\n\n/**\n * Escape a string so it can be used in a RegExp\n * constructor.\n *\n * @param {String} str\n */\n\nfunction escapeRegex (str) {\n  return str.replace(regexEscapeRE, '\\\\$&')\n}\n\nexports.compileRegex = function () {\n  var open = escapeRegex(config.delimiters[0])\n  var close = escapeRegex(config.delimiters[1])\n  var unsafeOpen = escapeRegex(config.unsafeDelimiters[0])\n  var unsafeClose = escapeRegex(config.unsafeDelimiters[1])\n  tagRE = new RegExp(\n    unsafeOpen + '(.+?)' + unsafeClose + '|' +\n    open + '(.+?)' + close,\n    'g'\n  )\n  htmlRE = new RegExp(\n    '^' + unsafeOpen + '.*' + unsafeClose + '$'\n  )\n  // reset cache\n  cache = new Cache(1000)\n}\n\n/**\n * Parse a template text string into an array of tokens.\n *\n * @param {String} text\n * @return {Array<Object> | null}\n *               - {String} type\n *               - {String} value\n *               - {Boolean} [html]\n *               - {Boolean} [oneTime]\n */\n\nexports.parse = function (text) {\n  if (!cache) {\n    exports.compileRegex()\n  }\n  var hit = cache.get(text)\n  if (hit) {\n    return hit\n  }\n  text = text.replace(/\\n/g, '')\n  if (!tagRE.test(text)) {\n    return null\n  }\n  var tokens = []\n  var lastIndex = tagRE.lastIndex = 0\n  var match, index, html, value, first, oneTime\n  /* eslint-disable no-cond-assign */\n  while (match = tagRE.exec(text)) {\n  /* eslint-enable no-cond-assign */\n    index = match.index\n    // push text token\n    if (index > lastIndex) {\n      tokens.push({\n        value: text.slice(lastIndex, index)\n      })\n    }\n    // tag token\n    html = htmlRE.test(match[0])\n    value = html ? match[1] : match[2]\n    first = value.charCodeAt(0)\n    oneTime = first === 42 // *\n    value = oneTime\n      ? value.slice(1)\n      : value\n    tokens.push({\n      tag: true,\n      value: value.trim(),\n      html: html,\n      oneTime: oneTime\n    })\n    lastIndex = index + match[0].length\n  }\n  if (lastIndex < text.length) {\n    tokens.push({\n      value: text.slice(lastIndex)\n    })\n  }\n  cache.put(text, tokens)\n  return tokens\n}\n\n/**\n * Format a list of tokens into an expression.\n * e.g. tokens parsed from 'a {{b}} c' can be serialized\n * into one single expression as '\"a \" + b + \" c\"'.\n *\n * @param {Array} tokens\n * @return {String}\n */\n\nexports.tokensToExp = function (tokens) {\n  if (tokens.length > 1) {\n    return tokens.map(function (token) {\n      return formatToken(token)\n    }).join('+')\n  } else {\n    return formatToken(tokens[0], true)\n  }\n}\n\n/**\n * Format a single token.\n *\n * @param {Object} token\n * @param {Boolean} single\n * @return {String}\n */\n\nfunction formatToken (token, single) {\n  return token.tag\n    ? inlineFilters(token.value, single)\n    : '\"' + token.value + '\"'\n}\n\n/**\n * For an attribute with multiple interpolation tags,\n * e.g. attr=\"some-{{thing | filter}}\", in order to combine\n * the whole thing into a single watchable expression, we\n * have to inline those filters. This function does exactly\n * that. This is a bit hacky but it avoids heavy changes\n * to directive parser and watcher mechanism.\n *\n * @param {String} exp\n * @param {Boolean} single\n * @return {String}\n */\n\nvar filterRE = /[^|]\\|[^|]/\nfunction inlineFilters (exp, single) {\n  if (!filterRE.test(exp)) {\n    return single\n      ? exp\n      : '(' + exp + ')'\n  } else {\n    var dir = dirParser.parse(exp)\n    if (!dir.filters) {\n      return '(' + exp + ')'\n    } else {\n      return 'this._applyFilters(' +\n        dir.expression + // value\n        ',null,' +       // oldValue (null for read)\n        JSON.stringify(dir.filters) + // filter descriptors\n        ',false)'        // write?\n    }\n  }\n}\n\n},{\"../cache\":79,\"../config\":84,\"./directive\":123}],128:[function(require,module,exports){\nvar _ = require('../util')\n\n/**\n * Append with transition.\n *\n * @param {Element} el\n * @param {Element} target\n * @param {Vue} vm\n * @param {Function} [cb]\n */\n\nexports.append = function (el, target, vm, cb) {\n  apply(el, 1, function () {\n    target.appendChild(el)\n  }, vm, cb)\n}\n\n/**\n * InsertBefore with transition.\n *\n * @param {Element} el\n * @param {Element} target\n * @param {Vue} vm\n * @param {Function} [cb]\n */\n\nexports.before = function (el, target, vm, cb) {\n  apply(el, 1, function () {\n    _.before(el, target)\n  }, vm, cb)\n}\n\n/**\n * Remove with transition.\n *\n * @param {Element} el\n * @param {Vue} vm\n * @param {Function} [cb]\n */\n\nexports.remove = function (el, vm, cb) {\n  apply(el, -1, function () {\n    _.remove(el)\n  }, vm, cb)\n}\n\n/**\n * Apply transitions with an operation callback.\n *\n * @param {Element} el\n * @param {Number} direction\n *                  1: enter\n *                 -1: leave\n * @param {Function} op - the actual DOM operation\n * @param {Vue} vm\n * @param {Function} [cb]\n */\n\nvar apply = exports.apply = function (el, direction, op, vm, cb) {\n  var transition = el.__v_trans\n  if (\n    !transition ||\n    // skip if there are no js hooks and CSS transition is\n    // not supported\n    (!transition.hooks && !_.transitionEndEvent) ||\n    // skip transitions for initial compile\n    !vm._isCompiled ||\n    // if the vm is being manipulated by a parent directive\n    // during the parent's compilation phase, skip the\n    // animation.\n    (vm.$parent && !vm.$parent._isCompiled)\n  ) {\n    op()\n    if (cb) cb()\n    return\n  }\n  var action = direction > 0 ? 'enter' : 'leave'\n  transition[action](op, cb)\n}\n\n},{\"../util\":135}],129:[function(require,module,exports){\nvar _ = require('../util')\nvar queue = []\nvar queued = false\n\n/**\n * Push a job into the queue.\n *\n * @param {Function} job\n */\n\nexports.push = function (job) {\n  queue.push(job)\n  if (!queued) {\n    queued = true\n    _.nextTick(flush)\n  }\n}\n\n/**\n * Flush the queue, and do one forced reflow before\n * triggering transitions.\n */\n\nfunction flush () {\n  // Force layout\n  var f = document.documentElement.offsetHeight\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]()\n  }\n  queue = []\n  queued = false\n  // dummy return, so js linters don't complain about\n  // unused variable f\n  return f\n}\n\n},{\"../util\":135}],130:[function(require,module,exports){\nvar _ = require('../util')\nvar queue = require('./queue')\nvar addClass = _.addClass\nvar removeClass = _.removeClass\nvar transitionEndEvent = _.transitionEndEvent\nvar animationEndEvent = _.animationEndEvent\nvar transDurationProp = _.transitionProp + 'Duration'\nvar animDurationProp = _.animationProp + 'Duration'\n\nvar TYPE_TRANSITION = 1\nvar TYPE_ANIMATION = 2\n\n/**\n * A Transition object that encapsulates the state and logic\n * of the transition.\n *\n * @param {Element} el\n * @param {String} id\n * @param {Object} hooks\n * @param {Vue} vm\n */\n\nfunction Transition (el, id, hooks, vm) {\n  this.id = id\n  this.el = el\n  this.enterClass = id + '-enter'\n  this.leaveClass = id + '-leave'\n  this.hooks = hooks\n  this.vm = vm\n  // async state\n  this.pendingCssEvent =\n  this.pendingCssCb =\n  this.cancel =\n  this.pendingJsCb =\n  this.op =\n  this.cb = null\n  this.justEntered = false\n  this.entered = this.left = false\n  this.typeCache = {}\n  // bind\n  var self = this\n  ;['enterNextTick', 'enterDone', 'leaveNextTick', 'leaveDone']\n    .forEach(function (m) {\n      self[m] = _.bind(self[m], self)\n    })\n}\n\nvar p = Transition.prototype\n\n/**\n * Start an entering transition.\n *\n * 1. enter transition triggered\n * 2. call beforeEnter hook\n * 3. add enter class\n * 4. insert/show element\n * 5. call enter hook (with possible explicit js callback)\n * 6. reflow\n * 7. based on transition type:\n *    - transition:\n *        remove class now, wait for transitionend,\n *        then done if there's no explicit js callback.\n *    - animation:\n *        wait for animationend, remove class,\n *        then done if there's no explicit js callback.\n *    - no css transition:\n *        done now if there's no explicit js callback.\n * 8. wait for either done or js callback, then call\n *    afterEnter hook.\n *\n * @param {Function} op - insert/show the element\n * @param {Function} [cb]\n */\n\np.enter = function (op, cb) {\n  this.cancelPending()\n  this.callHook('beforeEnter')\n  this.cb = cb\n  addClass(this.el, this.enterClass)\n  op()\n  this.entered = false\n  this.callHookWithCb('enter')\n  if (this.entered) {\n    return // user called done synchronously.\n  }\n  this.cancel = this.hooks && this.hooks.enterCancelled\n  queue.push(this.enterNextTick)\n}\n\n/**\n * The \"nextTick\" phase of an entering transition, which is\n * to be pushed into a queue and executed after a reflow so\n * that removing the class can trigger a CSS transition.\n */\n\np.enterNextTick = function () {\n\n  // Important hack:\n  // in Chrome, if a just-entered element is applied the\n  // leave class while its interpolated property still has\n  // a very small value (within one frame), Chrome will\n  // skip the leave transition entirely and not firing the\n  // transtionend event. Therefore we need to protected\n  // against such cases using a one-frame timeout.\n  this.justEntered = true\n  var self = this\n  setTimeout(function () {\n    self.justEntered = false\n  }, 17)\n\n  var enterDone = this.enterDone\n  var type = this.getCssTransitionType(this.enterClass)\n  if (!this.pendingJsCb) {\n    if (type === TYPE_TRANSITION) {\n      // trigger transition by removing enter class now\n      removeClass(this.el, this.enterClass)\n      this.setupCssCb(transitionEndEvent, enterDone)\n    } else if (type === TYPE_ANIMATION) {\n      this.setupCssCb(animationEndEvent, enterDone)\n    } else {\n      enterDone()\n    }\n  } else if (type === TYPE_TRANSITION) {\n    removeClass(this.el, this.enterClass)\n  }\n}\n\n/**\n * The \"cleanup\" phase of an entering transition.\n */\n\np.enterDone = function () {\n  this.entered = true\n  this.cancel = this.pendingJsCb = null\n  removeClass(this.el, this.enterClass)\n  this.callHook('afterEnter')\n  if (this.cb) this.cb()\n}\n\n/**\n * Start a leaving transition.\n *\n * 1. leave transition triggered.\n * 2. call beforeLeave hook\n * 3. add leave class (trigger css transition)\n * 4. call leave hook (with possible explicit js callback)\n * 5. reflow if no explicit js callback is provided\n * 6. based on transition type:\n *    - transition or animation:\n *        wait for end event, remove class, then done if\n *        there's no explicit js callback.\n *    - no css transition:\n *        done if there's no explicit js callback.\n * 7. wait for either done or js callback, then call\n *    afterLeave hook.\n *\n * @param {Function} op - remove/hide the element\n * @param {Function} [cb]\n */\n\np.leave = function (op, cb) {\n  this.cancelPending()\n  this.callHook('beforeLeave')\n  this.op = op\n  this.cb = cb\n  addClass(this.el, this.leaveClass)\n  this.left = false\n  this.callHookWithCb('leave')\n  if (this.left) {\n    return // user called done synchronously.\n  }\n  this.cancel = this.hooks && this.hooks.leaveCancelled\n  // only need to handle leaveDone if\n  // 1. the transition is already done (synchronously called\n  //    by the user, which causes this.op set to null)\n  // 2. there's no explicit js callback\n  if (this.op && !this.pendingJsCb) {\n    // if a CSS transition leaves immediately after enter,\n    // the transitionend event never fires. therefore we\n    // detect such cases and end the leave immediately.\n    if (this.justEntered) {\n      this.leaveDone()\n    } else {\n      queue.push(this.leaveNextTick)\n    }\n  }\n}\n\n/**\n * The \"nextTick\" phase of a leaving transition.\n */\n\np.leaveNextTick = function () {\n  var type = this.getCssTransitionType(this.leaveClass)\n  if (type) {\n    var event = type === TYPE_TRANSITION\n      ? transitionEndEvent\n      : animationEndEvent\n    this.setupCssCb(event, this.leaveDone)\n  } else {\n    this.leaveDone()\n  }\n}\n\n/**\n * The \"cleanup\" phase of a leaving transition.\n */\n\np.leaveDone = function () {\n  this.left = true\n  this.cancel = this.pendingJsCb = null\n  this.op()\n  removeClass(this.el, this.leaveClass)\n  this.callHook('afterLeave')\n  if (this.cb) this.cb()\n  this.op = null\n}\n\n/**\n * Cancel any pending callbacks from a previously running\n * but not finished transition.\n */\n\np.cancelPending = function () {\n  this.op = this.cb = null\n  var hasPending = false\n  if (this.pendingCssCb) {\n    hasPending = true\n    _.off(this.el, this.pendingCssEvent, this.pendingCssCb)\n    this.pendingCssEvent = this.pendingCssCb = null\n  }\n  if (this.pendingJsCb) {\n    hasPending = true\n    this.pendingJsCb.cancel()\n    this.pendingJsCb = null\n  }\n  if (hasPending) {\n    removeClass(this.el, this.enterClass)\n    removeClass(this.el, this.leaveClass)\n  }\n  if (this.cancel) {\n    this.cancel.call(this.vm, this.el)\n    this.cancel = null\n  }\n}\n\n/**\n * Call a user-provided synchronous hook function.\n *\n * @param {String} type\n */\n\np.callHook = function (type) {\n  if (this.hooks && this.hooks[type]) {\n    this.hooks[type].call(this.vm, this.el)\n  }\n}\n\n/**\n * Call a user-provided, potentially-async hook function.\n * We check for the length of arguments to see if the hook\n * expects a `done` callback. If true, the transition's end\n * will be determined by when the user calls that callback;\n * otherwise, the end is determined by the CSS transition or\n * animation.\n *\n * @param {String} type\n */\n\np.callHookWithCb = function (type) {\n  var hook = this.hooks && this.hooks[type]\n  if (hook) {\n    if (hook.length > 1) {\n      this.pendingJsCb = _.cancellable(this[type + 'Done'])\n    }\n    hook.call(this.vm, this.el, this.pendingJsCb)\n  }\n}\n\n/**\n * Get an element's transition type based on the\n * calculated styles.\n *\n * @param {String} className\n * @return {Number}\n */\n\np.getCssTransitionType = function (className) {\n  /* istanbul ignore if */\n  if (\n    !transitionEndEvent ||\n    // skip CSS transitions if page is not visible -\n    // this solves the issue of transitionend events not\n    // firing until the page is visible again.\n    // pageVisibility API is supported in IE10+, same as\n    // CSS transitions.\n    document.hidden ||\n    // explicit js-only transition\n    (this.hooks && this.hooks.css === false) ||\n    // element is hidden\n    isHidden(this.el)\n  ) {\n    return\n  }\n  var type = this.typeCache[className]\n  if (type) return type\n  var inlineStyles = this.el.style\n  var computedStyles = window.getComputedStyle(this.el)\n  var transDuration =\n    inlineStyles[transDurationProp] ||\n    computedStyles[transDurationProp]\n  if (transDuration && transDuration !== '0s') {\n    type = TYPE_TRANSITION\n  } else {\n    var animDuration =\n      inlineStyles[animDurationProp] ||\n      computedStyles[animDurationProp]\n    if (animDuration && animDuration !== '0s') {\n      type = TYPE_ANIMATION\n    }\n  }\n  if (type) {\n    this.typeCache[className] = type\n  }\n  return type\n}\n\n/**\n * Setup a CSS transitionend/animationend callback.\n *\n * @param {String} event\n * @param {Function} cb\n */\n\np.setupCssCb = function (event, cb) {\n  this.pendingCssEvent = event\n  var self = this\n  var el = this.el\n  var onEnd = this.pendingCssCb = function (e) {\n    if (e.target === el) {\n      _.off(el, event, onEnd)\n      self.pendingCssEvent = self.pendingCssCb = null\n      if (!self.pendingJsCb && cb) {\n        cb()\n      }\n    }\n  }\n  _.on(el, event, onEnd)\n}\n\n/**\n * Check if an element is hidden - in that case we can just\n * skip the transition alltogether.\n *\n * @param {Element} el\n * @return {Boolean}\n */\n\nfunction isHidden (el) {\n  return !(\n    el.offsetWidth &&\n    el.offsetHeight &&\n    el.getClientRects().length\n  )\n}\n\nmodule.exports = Transition\n\n},{\"../util\":135,\"./queue\":129}],131:[function(require,module,exports){\n(function (process){\nvar _ = require('./index')\n\n/**\n * Check if an element is a component, if yes return its\n * component id.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Object|undefined}\n */\n\nexports.commonTagRE = /^(div|p|span|img|a|b|i|br|ul|ol|li|h1|h2|h3|h4|h5|h6|code|pre|table|th|td|tr|form|label|input|select|option|nav|article|section|header|footer)$/\nexports.checkComponent = function (el, options) {\n  var tag = el.tagName.toLowerCase()\n  var hasAttrs = el.hasAttributes()\n  if (!exports.commonTagRE.test(tag) && tag !== 'component') {\n    if (_.resolveAsset(options, 'components', tag)) {\n      return { id: tag }\n    } else {\n      var is = hasAttrs && getIsBinding(el)\n      if (is) {\n        return is\n      } else if (process.env.NODE_ENV !== 'production') {\n        if (\n          tag.indexOf('-') > -1 ||\n          (\n            /HTMLUnknownElement/.test(el.toString()) &&\n            // Chrome returns unknown for several HTML5 elements.\n            // https://code.google.com/p/chromium/issues/detail?id=540526\n            !/^(data|time|rtc|rb)$/.test(tag)\n          )\n        ) {\n          _.warn(\n            'Unknown custom element: <' + tag + '> - did you ' +\n            'register the component correctly?'\n          )\n        }\n      }\n    }\n  } else if (hasAttrs) {\n    return getIsBinding(el)\n  }\n}\n\n/**\n * Get \"is\" binding from an element.\n *\n * @param {Element} el\n * @return {Object|undefined}\n */\n\nfunction getIsBinding (el) {\n  // dynamic syntax\n  var exp = _.attr(el, 'is')\n  if (exp != null) {\n    return { id: exp }\n  } else {\n    exp = _.getBindAttr(el, 'is')\n    if (exp != null) {\n      return { id: exp, dynamic: true }\n    }\n  }\n}\n\n/**\n * Set a prop's initial value on a vm and its data object.\n *\n * @param {Vue} vm\n * @param {Object} prop\n * @param {*} value\n */\n\nexports.initProp = function (vm, prop, value) {\n  if (exports.assertProp(prop, value)) {\n    var key = prop.path\n    vm[key] = vm._data[key] = value\n  }\n}\n\n/**\n * Assert whether a prop is valid.\n *\n * @param {Object} prop\n * @param {*} value\n */\n\nexports.assertProp = function (prop, value) {\n  // if a prop is not provided and is not required,\n  // skip the check.\n  if (prop.raw === null && !prop.required) {\n    return true\n  }\n  var options = prop.options\n  var type = options.type\n  var valid = true\n  var expectedType\n  if (type) {\n    if (type === String) {\n      expectedType = 'string'\n      valid = typeof value === expectedType\n    } else if (type === Number) {\n      expectedType = 'number'\n      valid = typeof value === 'number'\n    } else if (type === Boolean) {\n      expectedType = 'boolean'\n      valid = typeof value === 'boolean'\n    } else if (type === Function) {\n      expectedType = 'function'\n      valid = typeof value === 'function'\n    } else if (type === Object) {\n      expectedType = 'object'\n      valid = _.isPlainObject(value)\n    } else if (type === Array) {\n      expectedType = 'array'\n      valid = _.isArray(value)\n    } else {\n      valid = value instanceof type\n    }\n  }\n  if (!valid) {\n    process.env.NODE_ENV !== 'production' && _.warn(\n      'Invalid prop: type check failed for ' +\n      prop.path + '=\"' + prop.raw + '\".' +\n      ' Expected ' + formatType(expectedType) +\n      ', got ' + formatValue(value) + '.'\n    )\n    return false\n  }\n  var validator = options.validator\n  if (validator) {\n    if (!validator.call(null, value)) {\n      process.env.NODE_ENV !== 'production' && _.warn(\n        'Invalid prop: custom validator check failed for ' +\n        prop.path + '=\"' + prop.raw + '\"'\n      )\n      return false\n    }\n  }\n  return true\n}\n\nfunction formatType (val) {\n  return val\n    ? val.charAt(0).toUpperCase() + val.slice(1)\n    : 'custom type'\n}\n\nfunction formatValue (val) {\n  return Object.prototype.toString.call(val).slice(8, -1)\n}\n\n}).call(this,require('_process'))\n\n},{\"./index\":135,\"_process\":1}],132:[function(require,module,exports){\n(function (process){\n/**\n * Enable debug utilities.\n */\n\nif (process.env.NODE_ENV !== 'production') {\n\n  var config = require('../config')\n  var hasConsole = typeof console !== 'undefined'\n\n  /**\n   * Log a message.\n   *\n   * @param {String} msg\n   */\n\n  exports.log = function (msg) {\n    if (hasConsole && config.debug) {\n      console.log('[Vue info]: ' + msg)\n    }\n  }\n\n  /**\n   * We've got a problem here.\n   *\n   * @param {String} msg\n   */\n\n  exports.warn = function (msg, e) {\n    if (hasConsole && (!config.silent || config.debug)) {\n      console.warn('[Vue warn]: ' + msg)\n      /* istanbul ignore if */\n      if (config.debug) {\n        console.warn((e || new Error('Warning Stack Trace')).stack)\n      }\n    }\n  }\n\n  /**\n   * Assert asset exists\n   */\n\n  exports.assertAsset = function (val, type, id) {\n    if (!val) {\n      exports.warn('Failed to resolve ' + type + ': ' + id)\n    }\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"../config\":84,\"_process\":1}],133:[function(require,module,exports){\n(function (process){\nvar _ = require('./index')\nvar config = require('../config')\nvar transition = require('../transition')\n\n/**\n * Query an element selector if it's not an element already.\n *\n * @param {String|Element} el\n * @return {Element}\n */\n\nexports.query = function (el) {\n  if (typeof el === 'string') {\n    var selector = el\n    el = document.querySelector(el)\n    if (!el) {\n      process.env.NODE_ENV !== 'production' && _.warn(\n        'Cannot find element: ' + selector\n      )\n    }\n  }\n  return el\n}\n\n/**\n * Check if a node is in the document.\n * Note: document.documentElement.contains should work here\n * but always returns false for comment nodes in phantomjs,\n * making unit tests difficult. This is fixed by doing the\n * contains() check on the node's parentNode instead of\n * the node itself.\n *\n * @param {Node} node\n * @return {Boolean}\n */\n\nexports.inDoc = function (node) {\n  var doc = document.documentElement\n  var parent = node && node.parentNode\n  return doc === node ||\n    doc === parent ||\n    !!(parent && parent.nodeType === 1 && (doc.contains(parent)))\n}\n\n/**\n * Get and remove an attribute from a node.\n *\n * @param {Node} node\n * @param {String} attr\n */\n\nexports.attr = function (node, attr) {\n  var val = node.getAttribute(attr)\n  if (val !== null) {\n    node.removeAttribute(attr)\n  }\n  return val\n}\n\n/**\n * Get an attribute with colon or v-bind: prefix.\n *\n * @param {Node} node\n * @param {String} name\n * @return {String|null}\n */\n\nexports.getBindAttr = function (node, name) {\n  var val = exports.attr(node, ':' + name)\n  if (val === null) {\n    val = exports.attr(node, 'v-bind:' + name)\n  }\n  return val\n}\n\n/**\n * Insert el before target\n *\n * @param {Element} el\n * @param {Element} target\n */\n\nexports.before = function (el, target) {\n  target.parentNode.insertBefore(el, target)\n}\n\n/**\n * Insert el after target\n *\n * @param {Element} el\n * @param {Element} target\n */\n\nexports.after = function (el, target) {\n  if (target.nextSibling) {\n    exports.before(el, target.nextSibling)\n  } else {\n    target.parentNode.appendChild(el)\n  }\n}\n\n/**\n * Remove el from DOM\n *\n * @param {Element} el\n */\n\nexports.remove = function (el) {\n  el.parentNode.removeChild(el)\n}\n\n/**\n * Prepend el to target\n *\n * @param {Element} el\n * @param {Element} target\n */\n\nexports.prepend = function (el, target) {\n  if (target.firstChild) {\n    exports.before(el, target.firstChild)\n  } else {\n    target.appendChild(el)\n  }\n}\n\n/**\n * Replace target with el\n *\n * @param {Element} target\n * @param {Element} el\n */\n\nexports.replace = function (target, el) {\n  var parent = target.parentNode\n  if (parent) {\n    parent.replaceChild(el, target)\n  }\n}\n\n/**\n * Add event listener shorthand.\n *\n * @param {Element} el\n * @param {String} event\n * @param {Function} cb\n */\n\nexports.on = function (el, event, cb) {\n  el.addEventListener(event, cb)\n}\n\n/**\n * Remove event listener shorthand.\n *\n * @param {Element} el\n * @param {String} event\n * @param {Function} cb\n */\n\nexports.off = function (el, event, cb) {\n  el.removeEventListener(event, cb)\n}\n\n/**\n * Add class with compatibility for IE & SVG\n *\n * @param {Element} el\n * @param {Strong} cls\n */\n\nexports.addClass = function (el, cls) {\n  if (el.classList) {\n    el.classList.add(cls)\n  } else {\n    var cur = ' ' + (el.getAttribute('class') || '') + ' '\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim())\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for IE & SVG\n *\n * @param {Element} el\n * @param {Strong} cls\n */\n\nexports.removeClass = function (el, cls) {\n  if (el.classList) {\n    el.classList.remove(cls)\n  } else {\n    var cur = ' ' + (el.getAttribute('class') || '') + ' '\n    var tar = ' ' + cls + ' '\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ')\n    }\n    el.setAttribute('class', cur.trim())\n  }\n  if (!el.className) {\n    el.removeAttribute('class')\n  }\n}\n\n/**\n * Extract raw content inside an element into a temporary\n * container div\n *\n * @param {Element} el\n * @param {Boolean} asFragment\n * @return {Element}\n */\n\nexports.extractContent = function (el, asFragment) {\n  var child\n  var rawContent\n  /* istanbul ignore if */\n  if (\n    exports.isTemplate(el) &&\n    el.content instanceof DocumentFragment\n  ) {\n    el = el.content\n  }\n  if (el.hasChildNodes()) {\n    exports.trimNode(el)\n    rawContent = asFragment\n      ? document.createDocumentFragment()\n      : document.createElement('div')\n    /* eslint-disable no-cond-assign */\n    while (child = el.firstChild) {\n    /* eslint-enable no-cond-assign */\n      rawContent.appendChild(child)\n    }\n  }\n  return rawContent\n}\n\n/**\n * Trim possible empty head/tail textNodes inside a parent.\n *\n * @param {Node} node\n */\n\nexports.trimNode = function (node) {\n  trim(node, node.firstChild)\n  trim(node, node.lastChild)\n}\n\nfunction trim (parent, node) {\n  if (node && node.nodeType === 3 && !node.data.trim()) {\n    parent.removeChild(node)\n  }\n}\n\n/**\n * Check if an element is a template tag.\n * Note if the template appears inside an SVG its tagName\n * will be in lowercase.\n *\n * @param {Element} el\n */\n\nexports.isTemplate = function (el) {\n  return el.tagName &&\n    el.tagName.toLowerCase() === 'template'\n}\n\n/**\n * Create an \"anchor\" for performing dom insertion/removals.\n * This is used in a number of scenarios:\n * - fragment instance\n * - v-html\n * - v-if\n * - v-for\n * - component\n *\n * @param {String} content\n * @param {Boolean} persist - IE trashes empty textNodes on\n *                            cloneNode(true), so in certain\n *                            cases the anchor needs to be\n *                            non-empty to be persisted in\n *                            templates.\n * @return {Comment|Text}\n */\n\nexports.createAnchor = function (content, persist) {\n  return config.debug\n    ? document.createComment(content)\n    : document.createTextNode(persist ? ' ' : '')\n}\n\n/**\n * Find a component ref attribute that starts with $.\n *\n * @param {Element} node\n * @return {String|undefined}\n */\n\nvar refRE = /^v-ref:/\nexports.findRef = function (node) {\n  if (node.hasAttributes()) {\n    var attrs = node.attributes\n    for (var i = 0, l = attrs.length; i < l; i++) {\n      var name = attrs[i].name\n      if (refRE.test(name)) {\n        node.removeAttribute(name)\n        return _.camelize(name.replace(refRE, ''))\n      }\n    }\n  }\n}\n\n/**\n * Map a function to a range of nodes .\n *\n * @param {Node} node\n * @param {Node} end\n * @param {Function} op\n */\n\nexports.mapNodeRange = function (node, end, op) {\n  var next\n  while (node !== end) {\n    next = node.nextSibling\n    op(node)\n    node = next\n  }\n  op(end)\n}\n\n/**\n * Remove a range of nodes with transition, store\n * the nodes in a fragment with correct ordering,\n * and call callback when done.\n *\n * @param {Node} start\n * @param {Node} end\n * @param {Vue} vm\n * @param {DocumentFragment} frag\n * @param {Function} cb\n */\n\nexports.removeNodeRange = function (start, end, vm, frag, cb) {\n  var done = false\n  var removed = 0\n  var nodes = []\n  exports.mapNodeRange(start, end, function (node) {\n    if (node === end) done = true\n    nodes.push(node)\n    transition.remove(node, vm, onRemoved)\n  })\n  function onRemoved () {\n    removed++\n    if (done && removed >= nodes.length) {\n      for (var i = 0; i < nodes.length; i++) {\n        frag.appendChild(nodes[i])\n      }\n      cb && cb()\n    }\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"../config\":84,\"../transition\":128,\"./index\":135,\"_process\":1}],134:[function(require,module,exports){\n// can we use __proto__?\nexports.hasProto = '__proto__' in {}\n\n// Browser environment sniffing\nvar inBrowser = exports.inBrowser =\n  typeof window !== 'undefined' &&\n  Object.prototype.toString.call(window) !== '[object Object]'\n\nexports.isIE9 =\n  inBrowser &&\n  navigator.userAgent.toLowerCase().indexOf('msie 9.0') > 0\n\nexports.isAndroid =\n  inBrowser &&\n  navigator.userAgent.toLowerCase().indexOf('android') > 0\n\n// Transition property/event sniffing\nif (inBrowser && !exports.isIE9) {\n  var isWebkitTrans =\n    window.ontransitionend === undefined &&\n    window.onwebkittransitionend !== undefined\n  var isWebkitAnim =\n    window.onanimationend === undefined &&\n    window.onwebkitanimationend !== undefined\n  exports.transitionProp = isWebkitTrans\n    ? 'WebkitTransition'\n    : 'transition'\n  exports.transitionEndEvent = isWebkitTrans\n    ? 'webkitTransitionEnd'\n    : 'transitionend'\n  exports.animationProp = isWebkitAnim\n    ? 'WebkitAnimation'\n    : 'animation'\n  exports.animationEndEvent = isWebkitAnim\n    ? 'webkitAnimationEnd'\n    : 'animationend'\n}\n\n/**\n * Defer a task to execute it asynchronously. Ideally this\n * should be executed as a microtask, so we leverage\n * MutationObserver if it's available, and fallback to\n * setTimeout(0).\n *\n * @param {Function} cb\n * @param {Object} ctx\n */\n\nexports.nextTick = (function () {\n  var callbacks = []\n  var pending = false\n  var timerFunc\n  function nextTickHandler () {\n    pending = false\n    var copies = callbacks.slice(0)\n    callbacks = []\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]()\n    }\n  }\n  /* istanbul ignore if */\n  if (typeof MutationObserver !== 'undefined') {\n    var counter = 1\n    var observer = new MutationObserver(nextTickHandler)\n    var textNode = document.createTextNode(counter)\n    observer.observe(textNode, {\n      characterData: true\n    })\n    timerFunc = function () {\n      counter = (counter + 1) % 2\n      textNode.data = counter\n    }\n  } else {\n    timerFunc = setTimeout\n  }\n  return function (cb, ctx) {\n    var func = ctx\n      ? function () { cb.call(ctx) }\n      : cb\n    callbacks.push(func)\n    if (pending) return\n    pending = true\n    timerFunc(nextTickHandler, 0)\n  }\n})()\n\n},{}],135:[function(require,module,exports){\nvar lang = require('./lang')\nvar extend = lang.extend\n\nextend(exports, lang)\nextend(exports, require('./env'))\nextend(exports, require('./dom'))\nextend(exports, require('./options'))\nextend(exports, require('./component'))\nextend(exports, require('./debug'))\n\n},{\"./component\":131,\"./debug\":132,\"./dom\":133,\"./env\":134,\"./lang\":136,\"./options\":137}],136:[function(require,module,exports){\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n *\n * @param {Object} obj\n * @param {String} key\n * @param {*} val\n * @public\n */\n\nexports.set = function set (obj, key, val) {\n  if (obj.hasOwnProperty(key)) {\n    obj[key] = val\n    return\n  }\n  if (obj._isVue) {\n    set(obj._data, key, val)\n    return\n  }\n  var ob = obj.__ob__\n  if (!ob) {\n    obj[key] = val\n    return\n  }\n  ob.convert(key, val)\n  ob.dep.notify()\n  if (ob.vms) {\n    var i = ob.vms.length\n    while (i--) {\n      var vm = ob.vms[i]\n      vm._proxy(key)\n      vm._digest()\n    }\n  }\n}\n\n/**\n * Delete a property and trigger change if necessary.\n *\n * @param {Object} obj\n * @param {String} key\n */\n\nexports.delete = function (obj, key) {\n  if (!obj.hasOwnProperty(key)) {\n    return\n  }\n  delete obj[key]\n  var ob = obj.__ob__\n  if (!ob) {\n    return\n  }\n  ob.dep.notify()\n  if (ob.vms) {\n    var i = ob.vms.length\n    while (i--) {\n      var vm = ob.vms[i]\n      vm._unproxy(key)\n      vm._digest()\n    }\n  }\n}\n\n/**\n * Check if an expression is a literal value.\n *\n * @param {String} exp\n * @return {Boolean}\n */\n\nvar literalValueRE = /^\\s?(true|false|[\\d\\.]+|'[^']*'|\"[^\"]*\")\\s?$/\nexports.isLiteral = function (exp) {\n  return literalValueRE.test(exp)\n}\n\n/**\n * Check if a string starts with $ or _\n *\n * @param {String} str\n * @return {Boolean}\n */\n\nexports.isReserved = function (str) {\n  var c = (str + '').charCodeAt(0)\n  return c === 0x24 || c === 0x5F\n}\n\n/**\n * Guard text output, make sure undefined outputs\n * empty string\n *\n * @param {*} value\n * @return {String}\n */\n\nexports.toString = function (value) {\n  return value == null\n    ? ''\n    : value.toString()\n}\n\n/**\n * Check and convert possible numeric strings to numbers\n * before setting back to data\n *\n * @param {*} value\n * @return {*|Number}\n */\n\nexports.toNumber = function (value) {\n  if (typeof value !== 'string') {\n    return value\n  } else {\n    var parsed = Number(value)\n    return isNaN(parsed)\n      ? value\n      : parsed\n  }\n}\n\n/**\n * Convert string boolean literals into real booleans.\n *\n * @param {*} value\n * @return {*|Boolean}\n */\n\nexports.toBoolean = function (value) {\n  return value === 'true'\n    ? true\n    : value === 'false'\n      ? false\n      : value\n}\n\n/**\n * Strip quotes from a string\n *\n * @param {String} str\n * @return {String | false}\n */\n\nexports.stripQuotes = function (str) {\n  var a = str.charCodeAt(0)\n  var b = str.charCodeAt(str.length - 1)\n  return a === b && (a === 0x22 || a === 0x27)\n    ? str.slice(1, -1)\n    : str\n}\n\n/**\n * Camelize a hyphen-delmited string.\n *\n * @param {String} str\n * @return {String}\n */\n\nvar camelizeRE = /-(\\w)/g\nexports.camelize = function (str) {\n  return str.replace(camelizeRE, toUpper)\n}\n\nfunction toUpper (_, c) {\n  return c ? c.toUpperCase() : ''\n}\n\n/**\n * Hyphenate a camelCase string.\n *\n * @param {String} str\n * @return {String}\n */\n\nvar hyphenateRE = /([a-z\\d])([A-Z])/g\nexports.hyphenate = function (str) {\n  return str\n    .replace(hyphenateRE, '$1-$2')\n    .toLowerCase()\n}\n\n/**\n * Converts hyphen/underscore/slash delimitered names into\n * camelized classNames.\n *\n * e.g. my-component => MyComponent\n *      some_else    => SomeElse\n *      some/comp    => SomeComp\n *\n * @param {String} str\n * @return {String}\n */\n\nvar classifyRE = /(?:^|[-_\\/])(\\w)/g\nexports.classify = function (str) {\n  return str.replace(classifyRE, toUpper)\n}\n\n/**\n * Simple bind, faster than native\n *\n * @param {Function} fn\n * @param {Object} ctx\n * @return {Function}\n */\n\nexports.bind = function (fn, ctx) {\n  return function (a) {\n    var l = arguments.length\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n}\n\n/**\n * Convert an Array-like object to a real Array.\n *\n * @param {Array-like} list\n * @param {Number} [start] - start index\n * @return {Array}\n */\n\nexports.toArray = function (list, start) {\n  start = start || 0\n  var i = list.length - start\n  var ret = new Array(i)\n  while (i--) {\n    ret[i] = list[i + start]\n  }\n  return ret\n}\n\n/**\n * Mix properties into target object.\n *\n * @param {Object} to\n * @param {Object} from\n */\n\nexports.extend = function (to, from) {\n  var keys = Object.keys(from)\n  var i = keys.length\n  while (i--) {\n    to[keys[i]] = from[keys[i]]\n  }\n  return to\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n *\n * @param {*} obj\n * @return {Boolean}\n */\n\nexports.isObject = function (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n *\n * @param {*} obj\n * @return {Boolean}\n */\n\nvar toString = Object.prototype.toString\nvar OBJECT_STRING = '[object Object]'\nexports.isPlainObject = function (obj) {\n  return toString.call(obj) === OBJECT_STRING\n}\n\n/**\n * Array type check.\n *\n * @param {*} obj\n * @return {Boolean}\n */\n\nexports.isArray = Array.isArray\n\n/**\n * Define a non-enumerable property\n *\n * @param {Object} obj\n * @param {String} key\n * @param {*} val\n * @param {Boolean} [enumerable]\n */\n\nexports.define = function (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  })\n}\n\n/**\n * Debounce a function so it only gets called after the\n * input stops arriving after the given wait period.\n *\n * @param {Function} func\n * @param {Number} wait\n * @return {Function} - the debounced function\n */\n\nexports.debounce = function (func, wait) {\n  var timeout, args, context, timestamp, result\n  var later = function () {\n    var last = Date.now() - timestamp\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last)\n    } else {\n      timeout = null\n      result = func.apply(context, args)\n      if (!timeout) context = args = null\n    }\n  }\n  return function () {\n    context = this\n    args = arguments\n    timestamp = Date.now()\n    if (!timeout) {\n      timeout = setTimeout(later, wait)\n    }\n    return result\n  }\n}\n\n/**\n * Manual indexOf because it's slightly faster than\n * native.\n *\n * @param {Array} arr\n * @param {*} obj\n */\n\nexports.indexOf = function (arr, obj) {\n  var i = arr.length\n  while (i--) {\n    if (arr[i] === obj) return i\n  }\n  return -1\n}\n\n/**\n * Make a cancellable version of an async callback.\n *\n * @param {Function} fn\n * @return {Function}\n */\n\nexports.cancellable = function (fn) {\n  var cb = function () {\n    if (!cb.cancelled) {\n      return fn.apply(this, arguments)\n    }\n  }\n  cb.cancel = function () {\n    cb.cancelled = true\n  }\n  return cb\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n *\n * @param {*} a\n * @param {*} b\n * @return {Boolean}\n */\n\nexports.looseEqual = function (a, b) {\n  /* eslint-disable eqeqeq */\n  return a == b || (\n    exports.isObject(a) && exports.isObject(b)\n      ? JSON.stringify(a) === JSON.stringify(b)\n      : false\n  )\n  /* eslint-enable eqeqeq */\n}\n\n},{}],137:[function(require,module,exports){\n(function (process){\nvar _ = require('./index')\nvar config = require('../config')\nvar extend = _.extend\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n *\n * All strategy functions follow the same signature:\n *\n * @param {*} parentVal\n * @param {*} childVal\n * @param {Vue} [vm]\n */\n\nvar strats = config.optionMergeStrategies = Object.create(null)\n\n/**\n * Helper that recursively merges two data objects together.\n */\n\nfunction mergeData (to, from) {\n  var key, toVal, fromVal\n  for (key in from) {\n    toVal = to[key]\n    fromVal = from[key]\n    if (!to.hasOwnProperty(key)) {\n      _.set(to, key, fromVal)\n    } else if (_.isObject(toVal) && _.isObject(fromVal)) {\n      mergeData(toVal, fromVal)\n    }\n  }\n  return to\n}\n\n/**\n * Data\n */\n\nstrats.data = function (parentVal, childVal, vm) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal\n    }\n    if (typeof childVal !== 'function') {\n      process.env.NODE_ENV !== 'production' && _.warn(\n        'The \"data\" option should be a function ' +\n        'that returns a per-instance value in component ' +\n        'definitions.'\n      )\n      return parentVal\n    }\n    if (!parentVal) {\n      return childVal\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn () {\n      return mergeData(\n        childVal.call(this),\n        parentVal.call(this)\n      )\n    }\n  } else if (parentVal || childVal) {\n    return function mergedInstanceDataFn () {\n      // instance merge\n      var instanceData = typeof childVal === 'function'\n        ? childVal.call(vm)\n        : childVal\n      var defaultData = typeof parentVal === 'function'\n        ? parentVal.call(vm)\n        : undefined\n      if (instanceData) {\n        return mergeData(instanceData, defaultData)\n      } else {\n        return defaultData\n      }\n    }\n  }\n}\n\n/**\n * El\n */\n\nstrats.el = function (parentVal, childVal, vm) {\n  if (!vm && childVal && typeof childVal !== 'function') {\n    process.env.NODE_ENV !== 'production' && _.warn(\n      'The \"el\" option should be a function ' +\n      'that returns a per-instance value in component ' +\n      'definitions.'\n    )\n    return\n  }\n  var ret = childVal || parentVal\n  // invoke the element factory if this is instance merge\n  return vm && typeof ret === 'function'\n    ? ret.call(vm)\n    : ret\n}\n\n/**\n * Hooks and param attributes are merged as arrays.\n */\n\nstrats.init =\nstrats.created =\nstrats.ready =\nstrats.attached =\nstrats.detached =\nstrats.beforeCompile =\nstrats.compiled =\nstrats.beforeDestroy =\nstrats.destroyed = function (parentVal, childVal) {\n  return childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : _.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal\n}\n\n/**\n * 0.11 deprecation warning\n */\n\nstrats.paramAttributes = function () {\n  /* istanbul ignore next */\n  process.env.NODE_ENV !== 'production' && _.warn(\n    '\"paramAttributes\" option has been deprecated in 0.12. ' +\n    'Use \"props\" instead.'\n  )\n}\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\n\nfunction mergeAssets (parentVal, childVal) {\n  var res = Object.create(parentVal)\n  return childVal\n    ? extend(res, guardArrayAssets(childVal))\n    : res\n}\n\nconfig._assetTypes.forEach(function (type) {\n  strats[type + 's'] = mergeAssets\n})\n\n/**\n * Events & Watchers.\n *\n * Events & watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\n\nstrats.watch =\nstrats.events = function (parentVal, childVal) {\n  if (!childVal) return parentVal\n  if (!parentVal) return childVal\n  var ret = {}\n  extend(ret, parentVal)\n  for (var key in childVal) {\n    var parent = ret[key]\n    var child = childVal[key]\n    if (parent && !_.isArray(parent)) {\n      parent = [parent]\n    }\n    ret[key] = parent\n      ? parent.concat(child)\n      : [child]\n  }\n  return ret\n}\n\n/**\n * Other object hashes.\n */\n\nstrats.props =\nstrats.methods =\nstrats.computed = function (parentVal, childVal) {\n  if (!childVal) return parentVal\n  if (!parentVal) return childVal\n  var ret = Object.create(null)\n  extend(ret, parentVal)\n  extend(ret, childVal)\n  return ret\n}\n\n/**\n * Default strategy.\n */\n\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n}\n\n/**\n * Make sure component options get converted to actual\n * constructors.\n *\n * @param {Object} options\n */\n\nfunction guardComponents (options) {\n  if (options.components) {\n    var components = options.components =\n      guardArrayAssets(options.components)\n    var def\n    var ids = Object.keys(components)\n    for (var i = 0, l = ids.length; i < l; i++) {\n      var key = ids[i]\n      if (_.commonTagRE.test(key)) {\n        process.env.NODE_ENV !== 'production' && _.warn(\n          'Do not use built-in HTML elements as component ' +\n          'id: ' + key\n        )\n        continue\n      }\n      def = components[key]\n      if (_.isPlainObject(def)) {\n        components[key] = _.Vue.extend(def)\n      }\n    }\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n *\n * @param {Object} options\n */\n\nfunction guardProps (options) {\n  var props = options.props\n  var i\n  if (_.isArray(props)) {\n    options.props = {}\n    i = props.length\n    while (i--) {\n      options.props[props[i]] = null\n    }\n  } else if (_.isPlainObject(props)) {\n    var keys = Object.keys(props)\n    i = keys.length\n    while (i--) {\n      var val = props[keys[i]]\n      if (typeof val === 'function') {\n        props[keys[i]] = { type: val }\n      }\n    }\n  }\n}\n\n/**\n * Guard an Array-format assets option and converted it\n * into the key-value Object format.\n *\n * @param {Object|Array} assets\n * @return {Object}\n */\n\nfunction guardArrayAssets (assets) {\n  if (_.isArray(assets)) {\n    var res = {}\n    var i = assets.length\n    var asset\n    while (i--) {\n      asset = assets[i]\n      var id = typeof asset === 'function'\n        ? ((asset.options && asset.options.name) || asset.id)\n        : (asset.name || asset.id)\n      if (!id) {\n        process.env.NODE_ENV !== 'production' && _.warn(\n          'Array-syntax assets must provide a \"name\" or \"id\" field.'\n        )\n      } else {\n        res[id] = asset\n      }\n    }\n    return res\n  }\n  return assets\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n *\n * @param {Object} parent\n * @param {Object} child\n * @param {Vue} [vm] - if vm is present, indicates this is\n *                     an instantiation merge.\n */\n\nexports.mergeOptions = function merge (parent, child, vm) {\n  guardComponents(child)\n  guardProps(child)\n  var options = {}\n  var key\n  if (child.mixins) {\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\n      parent = merge(parent, child.mixins[i], vm)\n    }\n  }\n  for (key in parent) {\n    mergeField(key)\n  }\n  for (key in child) {\n    if (!(parent.hasOwnProperty(key))) {\n      mergeField(key)\n    }\n  }\n  function mergeField (key) {\n    var strat = strats[key] || defaultStrat\n    options[key] = strat(parent[key], child[key], vm, key)\n  }\n  return options\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n *\n * @param {Object} options\n * @param {String} type\n * @param {String} id\n * @return {Object|Function}\n */\n\nexports.resolveAsset = function resolve (options, type, id) {\n  var assets = options[type]\n  var camelizedId\n  return assets[id] ||\n    // camelCase ID\n    assets[camelizedId = _.camelize(id)] ||\n    // Pascal Case ID\n    assets[camelizedId.charAt(0).toUpperCase() + camelizedId.slice(1)]\n}\n\n}).call(this,require('_process'))\n\n},{\"../config\":84,\"./index\":135,\"_process\":1}],138:[function(require,module,exports){\n(function (process){\nvar _ = require('./util')\nvar extend = _.extend\n\n/**\n * The exposed Vue constructor.\n *\n * API conventions:\n * - public API methods/properties are prefiexed with `$`\n * - internal methods/properties are prefixed with `_`\n * - non-prefixed properties are assumed to be proxied user\n *   data.\n *\n * @constructor\n * @param {Object} [options]\n * @public\n */\n\nfunction Vue (options) {\n  this._init(options)\n}\n\n/**\n * Mixin global API\n */\n\nextend(Vue, require('./api/global'))\n\n/**\n * Vue and every constructor that extends Vue has an\n * associated options object, which can be accessed during\n * compilation steps as `this.constructor.options`.\n *\n * These can be seen as the default options of every\n * Vue instance.\n */\n\nVue.options = {\n  replace: true,\n  directives: require('./directives/public'),\n  elementDirectives: require('./directives/element'),\n  filters: require('./filters'),\n  transitions: {},\n  components: {},\n  partials: {}\n}\n\n/**\n * Build up the prototype\n */\n\nvar p = Vue.prototype\n\n/**\n * $data has a setter which does a bunch of\n * teardown/setup work\n */\n\nObject.defineProperty(p, '$data', {\n  get: function () {\n    return this._data\n  },\n  set: function (newData) {\n    if (newData !== this._data) {\n      this._setData(newData)\n    }\n  }\n})\n\n/**\n * Mixin internal instance methods\n */\n\nextend(p, require('./instance/init'))\nextend(p, require('./instance/events'))\nextend(p, require('./instance/state'))\nextend(p, require('./instance/lifecycle'))\nextend(p, require('./instance/misc'))\n\n/**\n * Mixin public API methods\n */\n\nextend(p, require('./api/data'))\nextend(p, require('./api/dom'))\nextend(p, require('./api/events'))\nextend(p, require('./api/lifecycle'))\n\nVue.version = '1.0.4'\nmodule.exports = _.Vue = Vue\n\n/* istanbul ignore if */\nif (process.env.NODE_ENV !== 'production') {\n  if (_.inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__) {\n    window.__VUE_DEVTOOLS_GLOBAL_HOOK__.emit('init', Vue)\n  }\n}\n\n}).call(this,require('_process'))\n\n},{\"./api/data\":73,\"./api/dom\":74,\"./api/events\":75,\"./api/global\":76,\"./api/lifecycle\":77,\"./directives/element\":86,\"./directives/public\":101,\"./filters\":112,\"./instance/events\":115,\"./instance/init\":116,\"./instance/lifecycle\":117,\"./instance/misc\":118,\"./instance/state\":119,\"./util\":135,\"_process\":1}],139:[function(require,module,exports){\n(function (process){\nvar _ = require('./util')\nvar config = require('./config')\nvar Dep = require('./observer/dep')\nvar expParser = require('./parsers/expression')\nvar batcher = require('./batcher')\nvar uid = 0\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n *\n * @param {Vue} vm\n * @param {String} expression\n * @param {Function} cb\n * @param {Object} options\n *                 - {Array} filters\n *                 - {Boolean} twoWay\n *                 - {Boolean} deep\n *                 - {Boolean} user\n *                 - {Boolean} sync\n *                 - {Boolean} lazy\n *                 - {Function} [preProcess]\n *                 - {Function} [postProcess]\n * @constructor\n */\n\nfunction Watcher (vm, expOrFn, cb, options) {\n  // mix in options\n  if (options) {\n    _.extend(this, options)\n  }\n  var isFn = typeof expOrFn === 'function'\n  this.vm = vm\n  vm._watchers.push(this)\n  this.expression = isFn ? expOrFn.toString() : expOrFn\n  this.cb = cb\n  this.id = ++uid // uid for batching\n  this.active = true\n  this.dirty = this.lazy // for lazy watchers\n  this.deps = Object.create(null)\n  this.newDeps = null\n  this.prevError = null // for async error stacks\n  // parse expression for getter/setter\n  if (isFn) {\n    this.getter = expOrFn\n    this.setter = undefined\n  } else {\n    var res = expParser.parse(expOrFn, this.twoWay)\n    this.getter = res.get\n    this.setter = res.set\n  }\n  this.value = this.lazy\n    ? undefined\n    : this.get()\n  // state for avoiding false triggers for deep and Array\n  // watchers during vm._digest()\n  this.queued = this.shallow = false\n}\n\n/**\n * Add a dependency to this directive.\n *\n * @param {Dep} dep\n */\n\nWatcher.prototype.addDep = function (dep) {\n  var id = dep.id\n  if (!this.newDeps[id]) {\n    this.newDeps[id] = dep\n    if (!this.deps[id]) {\n      this.deps[id] = dep\n      dep.addSub(this)\n    }\n  }\n}\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\n\nWatcher.prototype.get = function () {\n  this.beforeGet()\n  var scope = this.scope || this.vm\n  var value\n  try {\n    value = this.getter.call(scope, scope)\n  } catch (e) {\n    if (\n      process.env.NODE_ENV !== 'production' &&\n      config.warnExpressionErrors\n    ) {\n      _.warn(\n        'Error when evaluating expression \"' +\n        this.expression + '\". ' +\n        (config.debug\n          ? ''\n          : 'Turn on debug mode to see stack trace.'\n        ), e\n      )\n    }\n  }\n  // \"touch\" every property so they are all tracked as\n  // dependencies for deep watching\n  if (this.deep) {\n    traverse(value)\n  }\n  if (this.preProcess) {\n    value = this.preProcess(value)\n  }\n  if (this.filters) {\n    value = scope._applyFilters(value, null, this.filters, false)\n  }\n  if (this.postProcess) {\n    value = this.postProcess(value)\n  }\n  this.afterGet()\n  return value\n}\n\n/**\n * Set the corresponding value with the setter.\n *\n * @param {*} value\n */\n\nWatcher.prototype.set = function (value) {\n  var scope = this.scope || this.vm\n  if (this.filters) {\n    value = scope._applyFilters(\n      value, this.value, this.filters, true)\n  }\n  try {\n    this.setter.call(scope, scope, value)\n  } catch (e) {\n    if (\n      process.env.NODE_ENV !== 'production' &&\n      config.warnExpressionErrors\n    ) {\n      _.warn(\n        'Error when evaluating setter \"' +\n        this.expression + '\"', e\n      )\n    }\n  }\n  // two-way sync for v-for alias\n  var forContext = scope.$forContext\n  if (process.env.NODE_ENV !== 'production') {\n    if (\n      forContext &&\n      forContext.filters &&\n      (new RegExp(forContext.alias + '\\\\b')).test(this.expression)\n    ) {\n      _.warn(\n        'It seems you are using two-way binding on ' +\n        'a v-for alias (' + this.expression + '), and the ' +\n        'v-for has filters. This will not work properly. ' +\n        'Either remove the filters or use an array of ' +\n        'objects and bind to object properties instead.'\n      )\n    }\n  }\n  if (\n    forContext &&\n    forContext.alias === this.expression &&\n    !forContext.filters\n  ) {\n    if (scope.$key) { // original is an object\n      forContext.rawValue[scope.$key] = value\n    } else {\n      forContext.rawValue.$set(scope.$index, value)\n    }\n  }\n}\n\n/**\n * Prepare for dependency collection.\n */\n\nWatcher.prototype.beforeGet = function () {\n  Dep.target = this\n  this.newDeps = Object.create(null)\n}\n\n/**\n * Clean up for dependency collection.\n */\n\nWatcher.prototype.afterGet = function () {\n  Dep.target = null\n  var ids = Object.keys(this.deps)\n  var i = ids.length\n  while (i--) {\n    var id = ids[i]\n    if (!this.newDeps[id]) {\n      this.deps[id].removeSub(this)\n    }\n  }\n  this.deps = this.newDeps\n}\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n *\n * @param {Boolean} shallow\n */\n\nWatcher.prototype.update = function (shallow) {\n  if (this.lazy) {\n    this.dirty = true\n  } else if (this.sync || !config.async) {\n    this.run()\n  } else {\n    // if queued, only overwrite shallow with non-shallow,\n    // but not the other way around.\n    this.shallow = this.queued\n      ? shallow\n        ? this.shallow\n        : false\n      : !!shallow\n    this.queued = true\n    // record before-push error stack in debug mode\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.debug) {\n      this.prevError = new Error('[vue] async stack trace')\n    }\n    batcher.push(this)\n  }\n}\n\n/**\n * Batcher job interface.\n * Will be called by the batcher.\n */\n\nWatcher.prototype.run = function () {\n  if (this.active) {\n    var value = this.get()\n    if (\n      value !== this.value ||\n      // Deep watchers and Array watchers should fire even\n      // when the value is the same, because the value may\n      // have mutated; but only do so if this is a\n      // non-shallow update (caused by a vm digest).\n      ((_.isArray(value) || this.deep) && !this.shallow)\n    ) {\n      // set new value\n      var oldValue = this.value\n      this.value = value\n      // in debug + async mode, when a watcher callbacks\n      // throws, we also throw the saved before-push error\n      // so the full cross-tick stack trace is available.\n      var prevError = this.prevError\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' &&\n          config.debug && prevError) {\n        this.prevError = null\n        try {\n          this.cb.call(this.vm, value, oldValue)\n        } catch (e) {\n          _.nextTick(function () {\n            throw prevError\n          }, 0)\n          throw e\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue)\n      }\n    }\n    this.queued = this.shallow = false\n  }\n}\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\n\nWatcher.prototype.evaluate = function () {\n  // avoid overwriting another watcher that is being\n  // collected.\n  var current = Dep.target\n  this.value = this.get()\n  this.dirty = false\n  Dep.target = current\n}\n\n/**\n * Depend on all deps collected by this watcher.\n */\n\nWatcher.prototype.depend = function () {\n  var depIds = Object.keys(this.deps)\n  var i = depIds.length\n  while (i--) {\n    this.deps[depIds[i]].depend()\n  }\n}\n\n/**\n * Remove self from all dependencies' subcriber list.\n */\n\nWatcher.prototype.teardown = function () {\n  if (this.active) {\n    // remove self from vm's watcher list\n    // we can skip this if the vm if being destroyed\n    // which can improve teardown performance.\n    if (!this.vm._isBeingDestroyed) {\n      this.vm._watchers.$remove(this)\n    }\n    var depIds = Object.keys(this.deps)\n    var i = depIds.length\n    while (i--) {\n      this.deps[depIds[i]].removeSub(this)\n    }\n    this.active = false\n    this.vm = this.cb = this.value = null\n  }\n}\n\n/**\n * Recrusively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n *\n * @param {*} val\n */\n\nfunction traverse (val) {\n  var i, keys\n  if (_.isArray(val)) {\n    i = val.length\n    while (i--) traverse(val[i])\n  } else if (_.isObject(val)) {\n    keys = Object.keys(val)\n    i = keys.length\n    while (i--) traverse(val[keys[i]])\n  }\n}\n\nmodule.exports = Watcher\n\n}).call(this,require('_process'))\n\n},{\"./batcher\":78,\"./config\":84,\"./observer/dep\":121,\"./parsers/expression\":124,\"./util\":135,\"_process\":1}],140:[function(require,module,exports){\nvar inserted = exports.cache = {}\n\nexports.insert = function (css) {\n  if (inserted[css]) return\n  inserted[css] = true\n\n  var elem = document.createElement('style')\n  elem.setAttribute('type', 'text/css')\n\n  if ('textContent' in elem) {\n    elem.textContent = css\n  } else {\n    elem.styleSheet.cssText = css\n  }\n\n  document.getElementsByTagName('head')[0].appendChild(elem)\n  return elem\n}\n\n},{}],141:[function(require,module,exports){\n// Import requirements using browserify\n'use strict';\n\n// Insert vue-router and vue-resource into Vue\n\n// Import the actual routes, aliases, ...\n\nvar _routes = require('./routes');\n\n// Create our router object and set options on it\nwindow.Vue = require('vue');\nVue.use(require('vue-resource'));\nwindow.VueRouter = require('vue-router');var router = new VueRouter({\n                    history: true\n});\n\n// Inject the routes into the VueRouter object\n(0, _routes.configRouter)(router);\n\n// Configure the application\nwindow.config = require('./config');\nVue.config.debug = true;\nVue.http.options.root = config.api.base_url;\n\n// Configure our HTTP client\nvar rest = require('rest');\nvar pathPrefix = require('rest/interceptor/pathPrefix');\nvar mime = require('rest/interceptor/mime');\nvar defaultRequest = require('rest/interceptor/defaultRequest');\nvar errorCode = require('rest/interceptor/errorCode');\nvar interceptor = require('rest/interceptor');\nvar jwtAuth = require('./interceptors/jwtAuth');\n\nvar showdown = require('showdown');\nwindow.converter = new showdown.Converter();\n\nwindow.client = rest.wrap(pathPrefix, { prefix: config.api.base_url }).wrap(mime).wrap(defaultRequest, config.api.defaultRequest).wrap(errorCode, { code: 400 }).wrap(jwtAuth);\n\n// Bootstrap the app\nVue.component('nav-component', require('./compiled/nav.vue'));\nVue.component('footer-component', require('./compiled/footer.vue'));\nVue.component('pagination', require('vue-laravel-pagination'));\n\nvar App = Vue.extend(require('./compiled/app.vue'));\nrouter.start(App, '#app');\nwindow.router = router;\n\nString.prototype.trunc = String.prototype.trunc || function (n) {\n                    return this.length > n ? this.substr(0, n - 1) + '...' : this;\n};\n\n},{\"./compiled/app.vue\":142,\"./compiled/footer.vue\":143,\"./compiled/nav.vue\":144,\"./config\":163,\"./interceptors/jwtAuth\":166,\"./routes\":167,\"rest\":3,\"rest/interceptor\":7,\"rest/interceptor/defaultRequest\":8,\"rest/interceptor/errorCode\":9,\"rest/interceptor/mime\":10,\"rest/interceptor/pathPrefix\":11,\"showdown\":45,\"vue\":138,\"vue-laravel-pagination\":47,\"vue-resource\":61,\"vue-router\":72}],142:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n\n  ready: function ready() {\n\n    this.$on('userHasLoggedOut', function () {\n      this.destroyLogin();\n    });\n\n    this.$on('userHasLoggedIn', function (user) {\n      this.setLogin(user);\n    });\n\n    // The app has just been initialized, check if we can get the user data with an already existing token\n    var token = localStorage.getItem('jwt-token');\n    if (token !== null && token !== 'undefined') {\n      var that = this;\n      client({ path: '/users/me' }).then(function (response) {\n        // User has successfully logged in using the token from storage\n        that.setLogin(response.entity.user);\n        // broadcast an event telling our children that the data is ready and views can be rendered\n        that.$broadcast('data-loaded');\n      }, function (response) {\n        // Login with our token failed, do some cleanup and redirect if we're on an authenticated route\n        that.destroyLogin();\n      });\n    }\n  },\n\n  data: function data() {\n    return {\n      user: null,\n      token: null,\n      authenticated: false\n    };\n  },\n\n  methods: {\n\n    setLogin: function setLogin(user) {\n      // Save login info in our data and set header in case it's not set already\n      this.user = user;\n      this.authenticated = true;\n      this.token = localStorage.getItem('jwt-token');\n    },\n\n    destroyLogin: function destroyLogin(user) {\n      // Cleanup when token was invalid our user has logged out\n      this.user = null;\n      this.token = null;\n      this.authenticated = false;\n      localStorage.removeItem('jwt-token');\n      if (this.$route.auth) this.$route.router.go('/auth/login');\n    }\n  }\n\n};\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<router-view></router-view>\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/meSingh/Sites/__KhurafatS/Laragist.org/HTML/resources/assets/js/compiled/app.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":138,\"vue-hot-reload-api\":46}],143:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n  data: function data() {\n    return {\n      links: {\n        facebook: '',\n        twitter: '',\n        github: ''\n      }\n    };\n  }\n};\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n\\n<footer class=\\\"footer\\\">\\n\\t<div class=\\\"container\\\" style=\\\"color: #777;\\\">\\n\\t\\t<!-- Company Information -->\\n\\t\\t<div class=\\\"pull-left\\\" style=\\\"padding-top: 22px;\\\">\\n\\t\\t\\tCopyright  2016 <a href=\\\"http://khurafatstudio.com/\\\" target=\\\"_blank\\\">Khurafat Studio</a>. All rights reserved. <!-- - <a v-link=\\\"{ path: '/terms'}\\\">Terms Of Service</a> -->\\n\\t\\t\\t<!-- Made with <i class=\\\"fa fa-2x fa-heart\\\"></i> by <a href=\\\"#\\\">Mandeep Singh</a> & <a href=\\\"#\\\">Piyush Agrawal</a> -->\\n\\t\\t</div>\\n\\t\\t<!-- Social Icons -->\\n\\t\\t<div class=\\\"pull-right footer-social-icons\\\">\\n\\t\\t\\t<a href=\\\"http://facebook.com/{{ links.facebook }}\\\">\\n\\t\\t\\t\\t<i class=\\\"fa fa-btn fa-facebook-square\\\"></i>\\n\\t\\t\\t</a>\\n\\t\\t\\t<a href=\\\"http://twitter.com/{{ links.twitter }}\\\">\\n\\t\\t\\t\\t<i class=\\\"fa fa-btn fa-twitter-square\\\"></i>\\n\\t\\t\\t</a>\\n\\t\\t\\t<a href=\\\"http://github.com/{{ links.github }}\\\">\\n\\t\\t\\t\\t<i class=\\\"fa fa-github-square\\\"></i>\\n\\t\\t\\t</a>\\n\\t\\t</div>\\n\\t\\t<div class=\\\"clearfix\\\"></div>\\n\\t</div>\\n</footer>\\n\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/meSingh/Sites/__KhurafatS/Laragist.org/HTML/resources/assets/js/compiled/footer.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":138,\"vue-hot-reload-api\":46}],144:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n  data: function data() {\n    return {\n      navTitle: 'Vue.js'\n    };\n  }\n};\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n\\n<!-- Navigation -->\\n<header class=\\\"top-bar navbar\\\">\\n    <div class=\\\"container\\\" style=\\\"padding: 4px;\\\">\\n        <a v-link=\\\"{path: '/'}\\\" class=\\\"\\\">\\n            <img class=\\\"logo\\\" src=\\\"../../images/logo2.png\\\" alt=\\\"Laragist\\\" width=\\\"160px\\\">\\n        </a>\\n        <nav class=\\\"pull-right\\\">\\n            <ul>\\n                <li><a v-link=\\\"{path: '/'}\\\"> Browse Packages</a></li>\\n                <li><a v-link=\\\"{path: '/submit'}\\\"> Submit A Package</a></li>\\n                <li><a v-link=\\\"{path: '/about'}\\\"> About</a></li>\\n                <li><a v-link=\\\"{path: '/support'}\\\"> Support</a></li>\\n            </ul>\\n        </nav>\\n    </div>\\n</header>\\n\\n\\n\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/meSingh/Sites/__KhurafatS/Laragist.org/HTML/resources/assets/js/compiled/nav.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":138,\"vue-hot-reload-api\":46}],145:[function(require,module,exports){\nvar __vueify_style__ = require(\"vueify-insert-css\").insert(\"\\n.title {\\n    color: #999;\\n    font-weight: 100;\\n    font-family: 'Lato', Helvetica, sans-serif;\\n    font-size: 60px;\\n    margin-bottom: 40px;\\n    text-align: center;\\n    margin-top: 20%;\\n}\\n.title a {\\n    display: block;\\n    margin-top: 20px;\\n}\\n.title a:hover {\\n    text-decoration: none;\\n}\")\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<div class=\\\"container-fluid\\\">\\n\\t<div class=\\\"row\\\">\\n\\t\\t<div class=\\\"col-md-3\\\"></div>\\n\\t\\t<div class=\\\"col-md-6 title\\\">\\n\\t\\t\\tSorry, we couldn't find what you were looking for :-(<br>\\n\\t\\t\\t<a href=\\\"/\\\">Go back to the homepage</a>\\n\\t\\t</div>\\n\\t\\t<div class=\\\"col-md-3\\\"></div>\\n\\t</div>\\n</div>\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/meSingh/Sites/__KhurafatS/Laragist.org/HTML/resources/assets/js/compiled/pages/404.vue\"\n  module.hot.dispose(function () {\n    require(\"vueify-insert-css\").cache[\"\\n.title {\\n    color: #999;\\n    font-weight: 100;\\n    font-family: 'Lato', Helvetica, sans-serif;\\n    font-size: 60px;\\n    margin-bottom: 40px;\\n    text-align: center;\\n    margin-top: 20%;\\n}\\n.title a {\\n    display: block;\\n    margin-top: 20px;\\n}\\n.title a:hover {\\n    text-decoration: none;\\n}\"] = false\n    document.head.removeChild(__vueify_style__)\n  })\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":138,\"vue-hot-reload-api\":46,\"vueify-insert-css\":140}],146:[function(require,module,exports){\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<nav-component></nav-component>\\n\\n    <div class=\\\"about\\\">\\n\\n        <section class=\\\"welcome\\\">\\n        \\t<div class=\\\"container\\\">\\n        \\t\\t<h2> About Us</h2>\\n        \\t</div>\\n        </section>\\n\\n        <section class=\\\"container content\\\">\\t\\n            <div class=\\\"block\\\">\\n        \\t    <p>\\n                    Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\\n                </p>\\n            </div>\\n\\n            <div class=\\\"makers\\\">\\n                <h3 class=\\\"text-center\\\">Khurafati Makers</h3>\\n                \\n                <div class=\\\"row\\\">\\n                    <div class=\\\"col-md-4 col-md-offset-2\\\">\\n\\n                        <div class=\\\"block maker text-center\\\">\\n                            <div class=\\\"avatar\\\">\\n                                <img src=\\\"/images/makers/mandeep.png\\\">\\n                            </div>\\n                            <h4>Mandeep Singh</h4>\\n                            <ul class=\\\"list-inline social\\\">\\n                                <li><a href=\\\"#\\\"><i class=\\\"fa fa-link\\\"></i></a></li>\\n                                <li><a href=\\\"#\\\"><i class=\\\"fa fa-github\\\"></i></a></li>\\n                                <li><a href=\\\"#\\\"><i class=\\\"fa fa-linkedin\\\"></i></a></li>\\n                                <li><a href=\\\"#\\\"><i class=\\\"fa fa-twitter\\\"></i></a></li>\\n                            </ul>\\n                        </div>\\n\\n                    </div>\\n                    <div class=\\\"col-md-4\\\">\\n\\n                        <div class=\\\"block maker text-center\\\">\\n                            <div class=\\\"avatar\\\">\\n                                <img src=\\\"/images/makers/piyush.png\\\">\\n                            </div>\\n                            <h4>Piyush Agrawal</h4>\\n                            <ul class=\\\"list-inline social\\\">\\n                                <li><a href=\\\"#\\\"><i class=\\\"fa fa-link\\\"></i></a></li>\\n                                <li><a href=\\\"#\\\"><i class=\\\"fa fa-github\\\"></i></a></li>\\n                                <li><a href=\\\"#\\\"><i class=\\\"fa fa-linkedin\\\"></i></a></li>\\n                                <li><a href=\\\"#\\\"><i class=\\\"fa fa-twitter\\\"></i></a></li>\\n                            </ul>\\n                        </div>\\n\\n                    </div>\\n                </div>\\n            </div>\\n        </section>\\n\\n<footer-component></footer-component>\\n</div>\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/meSingh/Sites/__KhurafatS/Laragist.org/HTML/resources/assets/js/compiled/pages/about.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":138,\"vue-hot-reload-api\":46}],147:[function(require,module,exports){\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<nav-component></nav-component>\\n<div class=\\\"container app-screen\\\">\\n\\t<!-- Tabs -->\\n\\t<div class=\\\"col-md-3\\\">\\n\\t\\t<div class=\\\"panel panel-default panel-flush\\\">\\n\\t\\t\\t<div class=\\\"panel-heading\\\">\\n\\t\\t\\t\\tHome\\n\\t\\t\\t</div>\\n\\t\\t\\t<div class=\\\"panel-body\\\">\\n\\t\\t\\t\\t<div class=\\\"app-tabs\\\">\\n\\t\\t\\t\\t\\t<ul class=\\\"nav app-tabs-stacked\\\">\\n\\t\\t\\t\\t\\t\\t<li v-if=\\\"! $root.authenticated\\\">\\n\\t\\t\\t\\t\\t\\t\\t<a v-link=\\\"{ path: '/auth/login' }\\\">\\n\\t\\t\\t\\t\\t\\t\\t\\t<i class=\\\"fa fa-btn fa-fw fa-sign-in\\\"></i>&nbsp;Sign in\\n\\t\\t\\t\\t\\t\\t\\t</a>\\n\\t\\t\\t\\t\\t\\t</li>\\n\\t\\t\\t\\t\\t\\t<li v-if=\\\"! $root.authenticated\\\">\\n\\t\\t\\t\\t\\t\\t\\t<a v-link=\\\"{ path: '/auth/register' }\\\">\\n\\t\\t\\t\\t\\t\\t\\t\\t<i class=\\\"fa fa-btn fa-fw fa-chevron-circle-up\\\"></i>&nbsp;Register\\n\\t\\t\\t\\t\\t\\t\\t</a>\\n\\t\\t\\t\\t\\t\\t</li>\\n\\t\\t\\t\\t\\t\\t<li v-if=\\\"$root.authenticated\\\">\\n\\t\\t\\t\\t\\t\\t\\t<a v-link=\\\"{ path: '/auth/profile' }\\\">\\n\\t\\t\\t\\t\\t\\t\\t\\t<i class=\\\"fa fa-btn fa-fw fa-user\\\"></i>&nbsp;My Profile\\n\\t\\t\\t\\t\\t\\t\\t</a>\\n\\t\\t\\t\\t\\t\\t</li>\\n\\t\\t\\t\\t\\t</ul>\\n\\t\\t\\t\\t</div>\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\t</div>\\n\\t<!-- Tab Panes -->\\n\\t<div class=\\\"col-md-9\\\">\\n\\t\\t<div class=\\\"tab-content\\\">\\n\\t\\t\\t<div class=\\\"tab-pane\\\">\\n\\t\\t\\t\\t<div class=\\\"panel panel-default\\\">\\n\\t\\t\\t\\t\\t<router-view></router-view>\\n\\t\\t\\t\\t</div>\\n\\t\\t\\t</div><!-- End tab panel -->\\n\\t\\t</div><!-- End tab content -->\\n\\t</div><!-- End tab panes col-md-9 -->\\n</div><!-- End container -->\\n<footer-component></footer-component>\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/meSingh/Sites/__KhurafatS/Laragist.org/HTML/resources/assets/js/compiled/pages/auth.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":138,\"vue-hot-reload-api\":46}],148:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n\n  data: function data() {\n    return {\n      user: {\n        email: null,\n        password: null\n      },\n      messages: [],\n      loggingIn: false\n    };\n  },\n\n  methods: {\n    attempt: function attempt(e) {\n      e.preventDefault();\n      var that = this;\n      that.loggingIn = true;\n      client({ path: 'login', entity: this.user }).then(function (response) {\n        that.$dispatch('userHasFetchedToken', response.token);\n        that.getUserData();\n      }, function (response) {\n        that.messages = [];\n        if (response.status && response.status.code === 401) that.messages.push({ type: 'danger', message: 'Sorry, you provided invalid credentials' });\n        that.loggingIn = false;\n      });\n    },\n\n    getUserData: function getUserData() {\n      var that = this;\n      client({ path: '/users/me' }).then(function (response) {\n        that.$dispatch('userHasLoggedIn', response.entity.user);\n        that.$route.router.go('/auth/profile');\n      }, function (response) {\n        console.log(response);\n      });\n    }\n  },\n\n  route: {\n    activate: function activate(transition) {\n      this.$dispatch('userHasLoggedOut');\n      transition.next();\n    }\n  }\n};\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<div class=\\\"panel-heading\\\">\\n    Sign in to your account\\n</div>\\n<div class=\\\"panel-body\\\">\\n    <form class=\\\"form-horizontal\\\" role=\\\"form\\\" v-on:submit=\\\"attempt\\\">\\n\\n\\t\\t<div id=\\\"alerts\\\" v-if=\\\"messages.length > 0\\\">\\n\\t\\t\\t<div v-for=\\\"message in messages\\\" class=\\\"alert alert-{{ message.type }} alert-dismissible\\\" role=\\\"alert\\\">\\n\\t\\t\\t\\t{{ message.message }}\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\n\\t\\t<div class=\\\"form-group\\\">\\n\\t\\t\\t<label class=\\\"col-md-4 control-label\\\">E-Mail Address</label>\\n\\t\\t\\t<div class=\\\"col-md-6\\\">\\n\\t\\t\\t\\t<input type=\\\"email\\\" class=\\\"form-control\\\" v-model=\\\"user.email\\\">\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\n\\t\\t<div class=\\\"form-group\\\">\\n\\t\\t\\t<label class=\\\"col-md-4 control-label\\\">Password</label>\\n\\t\\t\\t<div class=\\\"col-md-6\\\">\\n\\t\\t\\t\\t<input type=\\\"password\\\" class=\\\"form-control\\\" v-model=\\\"user.password\\\">\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\n\\t\\t<div class=\\\"form-group\\\">\\n\\t\\t\\t<div class=\\\"col-md-6 col-md-offset-4\\\">\\n\\t\\t\\t\\t<button type=\\\"submit\\\" class=\\\"btn btn-primary\\\" :disabled=\\\"loggingIn\\\">\\n\\t\\t\\t\\t\\t<i class=\\\"fa fa-btn fa-sign-in\\\"></i>Login\\n\\t\\t\\t\\t</button>\\n\\n\\t\\t\\t\\t<a class=\\\"btn btn-link\\\" v-link=\\\"{ path: '/auth/forgot' }\\\">Forgot Your Password?</a>\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\t</form>\\n</div>\\n\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/meSingh/Sites/__KhurafatS/Laragist.org/HTML/resources/assets/js/compiled/pages/auth/login.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":138,\"vue-hot-reload-api\":46}],149:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n\n  route: {\n    activate: function activate(transition) {\n      this.$root.authenticated = false;\n      this.$root.user = null;\n      localStorage.removeItem('user');\n      localStorage.removeItem('jwt-token');\n      transition.redirect('/');\n    }\n  }\n\n};\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/meSingh/Sites/__KhurafatS/Laragist.org/HTML/resources/assets/js/compiled/pages/auth/logout.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":138,\"vue-hot-reload-api\":46}],150:[function(require,module,exports){\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<div class=\\\"panel-heading\\\">\\n\\tYour profile\\n</div>\\n<div class=\\\"panel-body\\\">\\n\\t<!-- <button class=\\\"btn btn-primary\\\" v-on=\\\"click: fetch\\\">Fetch</button> -->\\n\\t<table class=\\\"table table-bordered\\\" v-if=\\\"$root.user\\\">\\n\\t\\t<tbody><tr>\\n\\t\\t\\t<th>User ID</th>\\n\\t\\t\\t<th>Name</th>\\n\\t\\t\\t<th>Email</th>\\n\\t\\t</tr>\\n\\t\\t<tr>\\n\\t\\t\\t<td>{{ $root.user.id }}</td>\\n\\t\\t\\t<td>{{ $root.user.name }}</td>\\n\\t\\t\\t<td>{{ $root.user.email }}</td>\\n\\t\\t</tr>\\n\\t</tbody></table>\\n</div>\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/meSingh/Sites/__KhurafatS/Laragist.org/HTML/resources/assets/js/compiled/pages/auth/profile.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":138,\"vue-hot-reload-api\":46}],151:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n\n  data: function data() {\n    return {\n      user: {\n        name: null,\n        email: null,\n        password: null,\n        password_confirmation: null\n      },\n      messages: [],\n      registering: false\n    };\n  },\n\n  methods: {\n    registerUser: function registerUser(e) {\n      e.preventDefault();\n      var that = this;\n      that.registering = true;\n      client({ path: '/register', entity: this.user }).then(function (response) {\n        that.getUserData();\n      }, function (response, status) {\n        that.messages = [];\n        if (response.status && response.status.code === 422) {\n          that.messages = [];\n          for (var key in response.entity) {\n            that.messages.push({ type: 'danger', message: response.entity[key] });\n            that.registering = false;\n          }\n        }\n      });\n    },\n\n    getUserData: function getUserData() {\n      var that = this;\n      client({ path: '/users/me' }).then(function (response) {\n        that.$dispatch('userHasLoggedIn', response.entity.user);\n        that.$route.router.go('/auth/profile');\n      });\n    }\n  }\n};\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<div class=\\\"panel-heading\\\">\\n\\tRegister for an account\\n</div>\\n<div class=\\\"panel-body\\\">\\n\\t<form class=\\\"form-horizontal\\\" role=\\\"form\\\" v-on:submit=\\\"registerUser\\\">\\n\\n\\t\\t<div id=\\\"alerts\\\" v-if=\\\"messages.length > 0\\\">\\n\\t\\t\\t<div v-for=\\\"message in messages\\\" class=\\\"alert alert-{{ message.type }} alert-dismissible\\\" role=\\\"alert\\\">\\n\\t\\t\\t\\t{{ message.message }}\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\n\\t\\t<div class=\\\"form-group\\\">\\n\\t\\t\\t<label class=\\\"col-md-4 control-label\\\">Your name</label>\\n\\t\\t\\t<div class=\\\"col-md-6\\\">\\n\\t\\t\\t\\t<input type=\\\"name\\\" class=\\\"form-control\\\" v-model=\\\"user.name\\\">\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\n\\t\\t<div class=\\\"form-group\\\">\\n\\t\\t\\t<label class=\\\"col-md-4 control-label\\\">E-Mail Address</label>\\n\\t\\t\\t<div class=\\\"col-md-6\\\">\\n\\t\\t\\t\\t<input type=\\\"email\\\" class=\\\"form-control\\\" v-model=\\\"user.email\\\">\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\n\\t\\t<div class=\\\"form-group\\\">\\n\\t\\t\\t<label class=\\\"col-md-4 control-label\\\">Password</label>\\n\\t\\t\\t<div class=\\\"col-md-6\\\">\\n\\t\\t\\t\\t<input type=\\\"password\\\" class=\\\"form-control\\\" v-model=\\\"user.password\\\">\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\n\\t\\t<div class=\\\"form-group\\\">\\n\\t\\t\\t<label class=\\\"col-md-4 control-label\\\">Confirm password</label>\\n\\t\\t\\t<div class=\\\"col-md-6\\\">\\n\\t\\t\\t\\t<input type=\\\"password\\\" class=\\\"form-control\\\" v-model=\\\"user.password_confirmation\\\">\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\n\\t\\t<div class=\\\"form-group\\\">\\n\\t\\t\\t<div class=\\\"col-md-6 col-md-offset-4\\\">\\n\\t\\t\\t\\t<button type=\\\"submit\\\" class=\\\"btn btn-primary\\\" :disabled=\\\"registering\\\">\\n\\t\\t\\t\\t\\t<i class=\\\"fa fa-btn fa-sign-in\\\"></i> Register\\n\\t\\t\\t\\t</button>\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\t</form>\\n</div>\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/meSingh/Sites/__KhurafatS/Laragist.org/HTML/resources/assets/js/compiled/pages/auth/register.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":138,\"vue-hot-reload-api\":46}],152:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n  data: function data() {\n    return {\n      dog: {\n        name: '',\n        age: ''\n      },\n      messages: [],\n      creating: false\n    };\n  },\n\n  methods: {\n    createDog: function createDog(e) {\n      e.preventDefault();\n      var that = this;\n      that.creating = true;\n      client({ path: 'dogs', entity: this.dog }).then(function (response, status) {\n        that.dog.name = '';\n        that.dog.age = '';\n        that.messages = [{ type: 'success', message: 'Woof woof! Your dog was created' }];\n        Vue.nextTick(function () {\n          document.getElementById('nameInput').focus();\n        });\n        that.creating = false;\n      }, function (response, status) {\n        that.messages = [];\n        for (var key in response.entity) {\n          that.messages.push({ type: 'danger', message: response.entity[key] });\n          that.creating = false;\n        }\n      });\n    }\n  }\n};\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<div class=\\\"panel-heading\\\">\\n\\tMake a dog!\\n</div>\\n<div class=\\\"panel-body\\\">\\n\\t<div id=\\\"alerts\\\" v-if=\\\"messages.length > 0\\\">\\n\\t\\t<div v-for=\\\"message in messages\\\" class=\\\"alert alert-{{ message.type }} alert-dismissible\\\" role=\\\"alert\\\">\\n\\t\\t\\t{{ message.message }}\\n\\t\\t</div>\\n\\t</div>\\n\\t<form class=\\\"form-horizontal\\\" role=\\\"form\\\" v-on:submit=\\\"createDog\\\">\\n\\t\\t<div class=\\\"form-group\\\">\\n\\t\\t\\t<label for=\\\"name\\\" class=\\\"col-sm-2 col-sm-offset-1 control-label\\\">Name your dog</label>\\n\\t\\t\\t<div class=\\\"col-sm-5\\\">\\n\\t\\t\\t\\t<input class=\\\"form-control\\\" required=\\\"required\\\" name=\\\"name\\\" type=\\\"text\\\" v-model=\\\"dog.name\\\" id=\\\"nameInput\\\">\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\t\\t<div class=\\\"form-group\\\">\\n\\t\\t\\t<label for=\\\"age\\\" class=\\\"col-sm-2 col-sm-offset-1 control-label\\\">What's the age?</label>\\n\\t\\t\\t<div class=\\\"col-sm-5\\\">\\n\\t\\t\\t\\t<input class=\\\"form-control\\\" required=\\\"required\\\" name=\\\"age\\\" type=\\\"text\\\" v-model=\\\"dog.age\\\">\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\t\\t<div class=\\\"form-group\\\">\\n\\t\\t\\t<div class=\\\"col-sm-4 col-sm-offset-3\\\">\\n\\t\\t\\t\\t<button type=\\\"submit\\\" class=\\\"btn btn-primary\\\" :disabled=\\\"creating\\\">\\n\\t\\t\\t\\t\\t<i class=\\\"fa fa-btn fa-save\\\"></i>Make the dog!\\n\\t\\t\\t\\t</button>\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\t</form>\\n</div>\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/meSingh/Sites/__KhurafatS/Laragist.org/HTML/resources/assets/js/compiled/pages/dogs/create.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":138,\"vue-hot-reload-api\":46}],153:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n\n  data: function data() {\n    return {\n      dogs: [],\n      messages: []\n    };\n  },\n\n  methods: {\n    // Let's fetch some dogs\n    fetch: function fetch(successHandler) {\n      var that = this;\n      client({ path: '/dogs' }).then(function (response) {\n        // Look ma! Puppies!\n        that.$set('dogs', response.entity.data);\n        successHandler(response.entity.data);\n      }, function (response, status) {\n        if (_.contains([401, 500], status)) {\n          that.$dispatch('userHasLoggedOut');\n        }\n      });\n    },\n\n    deleteDog: function deleteDog(index) {\n      var that = this;\n      client({ path: '/dogs/' + this.dogs[index].id, method: 'DELETE' }).then(function (response) {\n        that.dogs.splice(index, 1);\n        that.messages = [{ type: 'success', message: 'Great, dog purged.' }];\n      }, function (response) {\n        that.messages.push({ type: 'danger', message: 'There was a problem removing the dog' });\n      });\n    }\n\n  },\n\n  route: {\n    // Ooh, ooh, are there any new puppies yet?\n    data: function data(transition) {\n      this.fetch(function (data) {\n        transition.next({ dogs: data });\n      });\n    }\n  }\n\n};\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<div class=\\\"panel-heading\\\">\\n\\tList of dogs\\n</div>\\n<div class=\\\"panel-body\\\" v-if=\\\"$loadingRouteData\\\">\\n\\tLoading data {{ loadingRouteData }}\\n</div>\\n<div class=\\\"panel-body\\\" v-if=\\\"messages.length > 0\\\">\\n\\t<div v-for=\\\"message in messages\\\" class=\\\"alert alert-{{ message.type }} alert-dismissible\\\" role=\\\"alert\\\">\\n\\t\\t{{ message.message }}\\n\\t</div>\\n</div>\\n\\n<div class=\\\"panel-body\\\" v-if=\\\"dogs.length == 0\\\">\\n\\tYou have no dogs!\\n</div>\\n\\n<table class=\\\"table\\\" v-if=\\\" ! $loadingRouteData &amp;&amp; dogs.length > 0\\\">\\n\\t<thead>\\n\\t\\t<tr>\\n\\t\\t\\t<th>ID</th>\\n\\t\\t\\t<th>Name</th>\\n\\t\\t\\t<th>Age</th>\\n\\t\\t\\t<th width=\\\"120px\\\">Actions</th>\\n\\t\\t</tr>\\n\\t</thead>\\n\\t<tbody>\\n\\t\\t<tr v-for=\\\"dog in dogs\\\">\\n\\t\\t\\t<td>{{ dog.id }}</td>\\n\\t\\t\\t<td>{{ dog.name }}</td>\\n\\t\\t\\t<td>{{ dog.age }}</td>\\n\\t\\t\\t<td>\\n\\t\\t\\t\\t<a class=\\\"btn btn-primary btn-xs\\\" v-link=\\\"{ path: '/dogs/'+dog.id }\\\">Edit</a>\\n\\t\\t\\t\\t<a class=\\\"btn btn-primary btn-xs\\\" v-on:click=\\\"deleteDog($index)\\\">Delete</a>\\n\\t\\t\\t</td>\\n\\t\\t</tr>\\n\\t</tbody>\\n</table>\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/meSingh/Sites/__KhurafatS/Laragist.org/HTML/resources/assets/js/compiled/pages/dogs/index.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":138,\"vue-hot-reload-api\":46}],154:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n\n  data: function data() {\n    return {\n      dog: {\n        id: null,\n        name: null,\n        age: null\n      },\n      messages: []\n    };\n  },\n\n  methods: {\n    // Let's fetch the dog\n    fetch: function fetch(id, successHandler) {\n      var that = this;\n      client({ path: '/dogs/' + id }).then(function (response) {\n        that.$set('dog', response.entity.data);\n        successHandler(response.entity.data);\n      }, function (response, status, request) {\n        // Go tell your parents that you've messed up somehow\n        if (status === 401) {\n          self.$dispatch('userHasLoggedOut');\n        } else {\n          console.log(response);\n        }\n      });\n    },\n\n    updateDog: function updateDog(e) {\n      e.preventDefault();\n      var self = this;\n      client({ path: '/dogs/' + this.dog.id, entity: this.dog, method: 'PUT' }).then(function (response) {\n        self.messages = [];\n        self.messages.push({ type: 'success', message: 'Woof woof! Your dog was updated' });\n      }, function (response) {\n        self.messages = [];\n        for (var key in response.entity) {\n          self.messages.push({ type: 'danger', message: response.entity[key] });\n        }\n      });\n    }\n\n  },\n\n  route: {\n    // Ooh, ooh, are there any new puppies yet?\n    data: function data(transition) {\n      this.fetch(this.$route.params.id, function (data) {\n        transition.next({ dog: data });\n      });\n    }\n  }\n};\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<div class=\\\"panel-heading\\\">\\n\\tEdit dog\\n</div>\\n<div class=\\\"panel-body\\\">\\n\\t<div id=\\\"alerts\\\" v-if=\\\"messages.length > 0\\\">\\n\\t\\t<div v-for=\\\"message in messages\\\" class=\\\"alert alert-{{ message.type }} alert-dismissible\\\" role=\\\"alert\\\">\\n\\t\\t\\t{{ message.message }}\\n\\t\\t</div>\\n\\t</div>\\n\\t<form class=\\\"form-horizontal\\\" role=\\\"form\\\" v-on:submit=\\\"updateDog\\\">\\n\\t<fieldset disabled=\\\"\\\">\\n\\t\\t<div class=\\\"form-group\\\">\\n\\t\\t\\t<label for=\\\"name\\\" class=\\\"col-sm-2 col-sm-offset-1 control-label\\\">Dog ID</label>\\n\\t\\t\\t<div class=\\\"col-sm-5\\\">\\n\\t\\t\\t\\t<input class=\\\"form-control\\\" required=\\\"required\\\" name=\\\"name\\\" type=\\\"text\\\" v-model=\\\"dog.id\\\">\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\t</fieldset>\\n\\t\\t<div class=\\\"form-group\\\">\\n\\t\\t\\t<label for=\\\"name\\\" class=\\\"col-sm-2 col-sm-offset-1 control-label\\\">Name your dog</label>\\n\\t\\t\\t<div class=\\\"col-sm-5\\\">\\n\\t\\t\\t\\t<input class=\\\"form-control\\\" required=\\\"required\\\" name=\\\"name\\\" type=\\\"text\\\" v-model=\\\"dog.name\\\">\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\t\\t<div class=\\\"form-group\\\">\\n\\t\\t\\t<label for=\\\"age\\\" class=\\\"col-sm-2 col-sm-offset-1 control-label\\\">What's the age?</label>\\n\\t\\t\\t<div class=\\\"col-sm-5\\\">\\n\\t\\t\\t\\t<input class=\\\"form-control\\\" required=\\\"required\\\" name=\\\"age\\\" type=\\\"text\\\" v-model=\\\"dog.age\\\">\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\t\\t<div class=\\\"form-group\\\">\\n\\t\\t\\t<div class=\\\"col-sm-4 col-sm-offset-3\\\">\\n\\t\\t\\t\\t<button type=\\\"submit\\\" class=\\\"btn btn-primary\\\"><i class=\\\"fa fa-btn fa-save\\\"></i>Update the dog!</button>\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\t</form>\\n</div>\\n\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/meSingh/Sites/__KhurafatS/Laragist.org/HTML/resources/assets/js/compiled/pages/dogs/show.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":138,\"vue-hot-reload-api\":46}],155:[function(require,module,exports){\n/**\n * Created by Piyush Agrawal on 23/04/16.\n */\n\n\"use strict\";\n\nmodule.exports = {\n\n    data: function data() {\n        return {\n            gists: [],\n\n            q: \"\",\n            categories: [],\n\n            addtional: \"\",\n            sortedAs: \"Most Downloaded\",\n            sortby: \"&sortby=md\",\n\n            pagination: {\n                total: 120,\n                per_page: 12,\n                current_page: 1,\n                total_pages: 10\n            }\n\n        };\n    },\n\n    created: function created() {\n        this.fetchGists();\n        this.getCategories();\n    },\n\n    methods: {\n        fetchGists: function fetchGists() {\n\n            if (this.q.length < 3 && this.q.length > 0) return;\n\n            var that = this;\n            // GET request\n            client({ path: '/?q=' + this.q + this.addtional + this.sortby + '&page=' + this.pagination.current_page }).then(function (response) {\n                console.log(response);\n                if (response.entity.meta.pagination.total > 0) that.gists = response.entity.data;\n\n                that.pagination = {\n                    total: response.entity.meta.pagination.total,\n                    per_page: response.entity.meta.pagination.per_page,\n                    current_page: response.entity.meta.pagination.current_page,\n                    total_pages: response.entity.meta.pagination.total_pages\n                };\n            }, function (response) {\n                // error callback\n            });\n        },\n\n        getCategories: function getCategories() {\n            var that = this;\n            client({ path: '/categories' }).then(function (response) {\n\n                response.entity.data.forEach(function (item) {\n                    var temp = {\n                        name: item.name,\n                        clicked: 0,\n                        id: item.id\n                    };\n                    that.categories.push(temp);\n                });\n            }, function (response) {\n                // error callback\n            });\n        },\n\n        selectCategory: function selectCategory(category) {\n\n            this.pagination.current_page = 1;\n\n            var current = '';\n            this.categories.forEach(function (item) {\n                if (item.clicked == 1) current = item;\n\n                item.clicked = 0;\n            });\n\n            if (current.id !== category.id) category.clicked = 1;\n\n            if (category.clicked == 1) this.addtional = '&cid=' + category.id;else this.addtional = '';\n\n            this.fetchGists();\n        },\n\n        sort: function sort(type, current) {\n            this.pagination.current_page = 1;\n            this.sortby = \"&sortby=\" + type;\n            this.sortedAs = current;\n            this.fetchGists();\n        },\n\n        author: function author(name) {\n            return name.split('/')[0];\n        },\n\n        \"package\": function _package(name) {\n            return name.split('/')[1];\n        }\n    }\n\n};\n\nVue.transition('slideIn', {\n    enterClass: 'slideInUp',\n    leaveClass: 'slideOutDown'\n});\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n    <nav-component></nav-component>\\n\\n\\t<section class=\\\"welcome\\\">\\n\\t\\t<div class=\\\"container\\\">\\n\\t\\t\\t<div class=\\\"row\\\">\\n\\t\\t\\t\\t<div class=\\\"col-md-3 col-md-offset-1\\\">\\n\\t\\t\\t\\t\\t<img src=\\\"/images/laravel.png\\\" style=\\\"width: 100%;\\\">\\n\\t\\t\\t\\t</div>\\n\\t\\t\\t\\t<div class=\\\"col-md-8\\\">\\n\\t\\t\\t\\t\\t<h2><b>Laragist</b> is a <b>community-supported catalog</b> of laravel packages and libraries curated by <b>Khurafati Gang</b></h2>\\n\\t\\t\\t\\t</div>\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\t</section>\\n\\n    <section class=\\\"promo\\\">\\n        <div class=\\\"container\\\">\\n            <div class=\\\"col-md-10 col-md-offset-1\\\">\\n            <h3>\\n                Want real-time support for these laravel packages?\\n                <button class=\\\"btn btn-lara pull-right\\\"> Get Support </button>\\n            </h3>\\n            </div>\\n        </div>\\n    </section>\\n\\n\\t<section class=\\\"packages\\\">\\n\\t\\t<div class=\\\"container\\\">\\n\\n            <div class=\\\"categories\\\">\\n                <ul class=\\\"list-inline\\\"> \\n             \\n                    <li v-for=\\\"category in categories\\\">\\n                        <a v-bind:class=\\\"{'active': category.clicked }\\\" v-on:click=\\\"selectCategory(category)\\\">\\n                                {{category.name}} \\n                                <i class=\\\"fa fa-times\\\" v-show=\\\"category.clicked\\\"></i>\\n                        </a>\\n                    </li>\\n\\n                </ul>\\n            </div>\\n\\n\\t\\t\\t<div class=\\\"input-group input-group-lg search\\\">\\n\\t\\t\\t\\t<input type=\\\"text\\\" id=\\\"searchInput\\\" v-model=\\\"q\\\" v-on:keyup=\\\"fetchGists()\\\" class=\\\"form-control\\\" placeholder=\\\"Search the best laravel packages by entering 3 or more characters\\\">\\n\\t\\t\\t  \\t<div class=\\\"input-group-btn\\\">\\n\\n\\t\\t\\t\\t\\t\\t<button type=\\\"button\\\" class=\\\"btn btn-default no-outline\\\" data-toggle=\\\"dropdown\\\" aria-haspopup=\\\"true\\\" aria-expanded=\\\"false\\\">\\n\\t\\t\\t\\t    \\t\\t{{ sortedAs }} <span class=\\\"caret\\\"></span>\\n\\t\\t\\t\\t  \\t\\t</button>\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t  \\t\\t<ul class=\\\"dropdown-menu click-pointer\\\">\\n\\t\\t\\t\\t    \\t\\t<li>\\n                                <a v-on:click=\\\"sort('md','Most Downloaded')\\\"> \\n                                    Most Downloaded\\n                                </a>\\n                            </li>\\n                            <li>\\n                                <a v-on:click=\\\"sort('mp','Most Popular')\\\">\\n                                    Most Popular\\n                                </a>\\n                            </li>\\n\\t\\t\\t\\t    \\t\\t<li>\\n                                <a v-on:click=\\\"sort('ru','Recently Updated')\\\">\\n                                    Recently Updated\\n                                </a>\\n                            </li>\\n\\t\\t\\t\\t  \\t\\t</ul>\\n\\t\\t\\t\\t  \\t\\n\\t\\t\\t  \\t</div>\\n\\t\\t\\t</div>\\n\\n            <br>\\n\\n            <div class=\\\"row\\\">\\n    \\t\\t    <div class=\\\"package col-md-6\\\" v-for=\\\"gist in gists\\\">\\n                    <div class=\\\"wrapper\\\">\\n                        <div class=\\\"latest\\\">\\n                            <i class=\\\"fa fa-fw fa-code-fork\\\"></i>&nbsp; \\n                            <span>{{ gist.version }}</span>\\n                        </div>\\n    \\t            <div class=\\\"info\\\">\\n    \\t                <h3><a v-link=\\\"{ name: 'view', params: {user:author(gist.name), name: package(gist.name)}}\\\">{{ gist.name.trunc(32) }}</a></h3>\\n    \\t                <p>{{ gist.description.trunc(120) }}</p>\\n    \\t            </div>\\n    \\t            <div class=\\\"meta\\\">\\n    \\t            \\t<ul class=\\\"list-unstyled\\\">\\n    \\t            \\t\\t<li>\\n    \\t            \\t\\t\\t<i class=\\\"fa fa-fw fa-download\\\"></i>&nbsp; \\n    \\t            \\t\\t\\t<span>{{ gist.downloads_total }}</span>\\n    \\t            \\t\\t</li>\\n    \\t            \\t\\t<li>\\n    \\t            \\t\\t\\t<i class=\\\"fa fa-fw fa-heart\\\"></i>&nbsp; \\n    \\t            \\t\\t\\t<span>{{ gist.favorites }}</span>\\n    \\t            \\t\\t</li>\\n    \\t            \\t</ul>\\n    \\t            </div>\\n                    <div class=\\\"meta-info\\\">\\n                        <p class=\\\"pull-right\\\"><small>updated on: {{ gist.last_updated }}</small></p>\\n                        <ul class=\\\"list-inline\\\">\\n                            <li><i class=\\\"fa fa-fw fa-bars\\\"></i></li>\\n                            <li v-for=\\\"cat in gist.categories\\\">{{cat.name}}</li>\\n                        </ul>\\n                    </div>\\n                    </div>\\n    \\t\\t    </div>\\n\\n            </div>\\n\\t\\t</div>\\n\\t</section>\\n\\n    <div class=\\\"container\\\">\\n        <pagination :pagination=\\\"pagination\\\" size=\\\"pagination-md\\\" class=\\\"text-center\\\" :callback=\\\"fetchGists\\\"></pagination>\\n    </div>\\n\\n    <footer-component></footer-component>\\n\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/meSingh/Sites/__KhurafatS/Laragist.org/HTML/resources/assets/js/compiled/pages/home.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":138,\"vue-hot-reload-api\":46}],156:[function(require,module,exports){\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<div class=\\\"panel-heading\\\">\\n\\tAbout us\\n</div>\\n<div class=\\\"panel-body\\\">\\n\\tThis is a sample webpage that authenticates against a Laravel API and gets the obligatory dogs.\\n</div>\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/meSingh/Sites/__KhurafatS/Laragist.org/HTML/resources/assets/js/compiled/pages/home/about.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":138,\"vue-hot-reload-api\":46}],157:[function(require,module,exports){\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<div class=\\\"panel-heading\\\">\\n\\tHomepage default\\n</div>\\n<div class=\\\"panel-body\\\">\\n\\tSelect an action to your left. This page serves as a demo for the 'default' route in a Vue subRoute.\\n</div>\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/meSingh/Sites/__KhurafatS/Laragist.org/HTML/resources/assets/js/compiled/pages/home/home.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":138,\"vue-hot-reload-api\":46}],158:[function(require,module,exports){\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<div class=\\\"panel-heading\\\">\\n\\tWelcome\\n</div>\\n<div class=\\\"panel-body\\\">\\n\\tHere goes the welcome page\\n</div>\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/meSingh/Sites/__KhurafatS/Laragist.org/HTML/resources/assets/js/compiled/pages/home/welcome.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":138,\"vue-hot-reload-api\":46}],159:[function(require,module,exports){\n/**\n * Created by Piyush Agrawal on 23/04/16.\n */\n\n'use strict';\n\nmodule.exports = {\n\n    data: function data() {\n        return {\n            gists: [],\n            q: '',\n            notFound: false,\n            submitted: false,\n            selectedGist: {\n\n                name: '',\n                first_name: '',\n                email: '',\n                category_id: 0\n            },\n            error: \"\",\n            errors: {\n                first_name: \"\",\n                email: \"\",\n                category_id: \"\"\n            },\n            categories: [],\n            gistsUnderReview: []\n        };\n    },\n\n    created: function created() {\n        this.getCategories();\n        this.getUnderReviews();\n    },\n\n    methods: {\n        search: function search() {\n            this.notFound = false;\n\n            if (this.q.length < 1) {\n                this.getUnderReviews();\n                return;\n            }\n\n            // GET request\n\n            this.gistsUnderReview = [];\n\n            this.$http({ url: 'https://packagist.org/search.json?q=' + this.q, method: 'GET' }).then(function (response) {\n\n                if (response.data.total > 0) this.gists = response.data.results;else {\n                    this.notFound = true;\n                    this.gists = [];\n                }\n\n                console.log(response);\n            }, function (response) {\n                // error callback\n            }).bind(this);\n        },\n\n        selectGist: function selectGist(gist) {\n            this.selectedGist.name = gist.name;\n            this.error = \"\";\n            this.errors = {\n                first_name: \"\",\n                email: \"\",\n                category_id: \"\"\n            };\n            this.submitted = false;\n        },\n\n        getCategories: function getCategories() {\n            var that = this;\n            client({ path: '/categories' }).then(function (response) {\n                response.entity.data.forEach(function (category) {\n                    that.categories.push(category);\n                });\n            });\n        },\n\n        submitPackage: function submitPackage() {\n            this.error = \"\";\n            this.errors = {\n                first_name: \"\",\n                email: \"\",\n                category_id: \"\"\n            };\n            var that = this;\n            client({ path: '/submit', entity: this.selectedGist }).then(function (response) {\n                that.submitted = true;\n            }, function (response) {\n                console.log(response);\n                if (response.status.code == 400) that.error = response.entity.message;else if (response.status.code >= 500) that.error = \"Some unknown error occurred. Please try again later\";else if (response.status.code = 422) {\n                    that.errors.first_name = response.entity.errors.first_name;\n                    that.errors.email = response.entity.errors.email;\n                    that.errors.category_id = response.entity.errors.category_id;\n                    console.log(that.errors);\n                }\n            });\n        },\n\n        getUnderReviews: function getUnderReviews() {\n            var that = this;\n            this.gists = [];\n            client({ path: '/under-review' }).then(function (response) {\n                that.gistsUnderReview = response.entity.data;\n            });\n        }\n\n    }\n\n};\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<nav-component></nav-component>\\n<section class=\\\"welcome\\\">\\n    <div class=\\\"container\\\">\\n        <div class=\\\"row\\\">\\n            <div class=\\\"col-md-3 col-md-offset-1\\\">\\n                <img src=\\\"/images/packagist.png\\\" style=\\\"width: 70%;margin-left: 15%;\\\">\\n            </div>\\n            <div class=\\\"col-md-8\\\">\\n                <h2>Search <b>Packagist.org</b> for laravel packages and submit them to us.</h2>\\n                <input type=\\\"text\\\" id=\\\"searchInput\\\" v-model=\\\"q\\\" v-on:keyup=\\\"search()\\\" class=\\\"form-control input-lg\\\" placeholder=\\\"Search packagist.org by entering 3 or more characters\\\" style=\\\"margin-top: 30px;\\\">\\n            </div>\\n        </div>\\n    </div>\\n</section>\\n<div class=\\\"main-container\\\">\\n    <section class=\\\"packages\\\" style=\\\"padding-top: 50px;\\\">\\n        <div class=\\\"container\\\">\\n            <div class=\\\"row\\\">\\n                <div class=\\\"col-md-8 col-md-offset-2 col-sm-10 col-sm-offset-1 text-center\\\">\\n                    <h3 id=\\\"brand-title\\\" v-if=\\\"!q\\\">Latest submitted packages by our community</h3>\\n                    <h3 id=\\\"brand-title\\\" v-if=\\\"q\\\">Search results for: <span>{{ q | capitalize }}</span></h3>\\n                    <br>\\n                    <div class=\\\"row\\\">\\n                        <div class=\\\"col-lg-12\\\">\\n                        </div>\\n                        <!-- /.col-lg-6 -->\\n                    </div>\\n                    <!-- /.row -->\\n                </div>\\n\\n                <div class=\\\"col-sm-12 text-center\\\">\\n                    <br>\\n                    <div class=\\\"alert alert-danger\\\" v-show=\\\"notFound\\\">Nothing found! Please try searching with different keyword</div>\\n                </div>\\n            </div>\\n        </div>\\n        <div class=\\\"container\\\">\\n            <div class=\\\"row\\\">\\n\\n                <!-- Under review packages -->\\n                <div class=\\\"package col-md-6\\\" v-for=\\\"gist in gistsUnderReview\\\">\\n                    <div class=\\\"wrapper submit-wrapper\\\">\\n                        <div class=\\\"info\\\">\\n                            <h3><a title=\\\"{{gist.name}}\\\">\\n                                        {{gist.name.trunc(32)}}\\n                                </a>\\n                            </h3>\\n                            <p>{{gist.description.trunc(120)}}</p>\\n                        </div>\\n                        <div class=\\\"meta\\\">\\n                            <ul class=\\\"list-unstyled\\\">\\n                                <li>\\n                                    <i class=\\\"fa fa-fw fa-download\\\"></i>&nbsp;\\n                                    <span>{{ gist.downloads_total }}</span>\\n                                </li>\\n                                <li>\\n                                    <i class=\\\"fa fa-fw fa-heart\\\"></i>&nbsp;\\n                                    <span>{{ gist.favorites }}</span>\\n                                </li>\\n                            </ul>\\n                        </div>\\n                        <!-- <div class=\\\"submit pull-right\\\">\\n                            <a href=\\\"#\\\" data-toggle=\\\"modal\\\" v-on:click=\\\"selectGist(gist)\\\" data-target=\\\"#submitModal\\\"> Submitted by:  </a>\\n                        </div> -->\\n                        <div class=\\\"meta-info\\\">\\n                            <p class=\\\"pull-right\\\"><small>submitted by: {{gist.user}}</small></p>\\n                        </div>\\n                    </div>\\n                </div>\\n\\n                <!-- ./ Under review packages -->\\n\\n                <div class=\\\"package col-md-6\\\" v-for=\\\"gist in gists\\\">\\n                    <div class=\\\"wrapper submit-wrapper\\\">\\n                        <div class=\\\"info\\\">\\n                            <h3><a title=\\\"{{gist.name}}\\\">\\n                                        {{gist.name.trunc(32)}}\\n                                </a>\\n                            </h3>\\n                            <p>{{gist.description.trunc(120)}}</p>\\n                        </div>\\n                        <div class=\\\"meta\\\">\\n                            <ul class=\\\"list-unstyled\\\">\\n                                <li>\\n                                    <i class=\\\"fa fa-fw fa-download\\\"></i>&nbsp;\\n                                    <span>{{ gist.downloads }}</span>\\n                                </li>\\n                                <li>\\n                                    <i class=\\\"fa fa-fw fa-heart\\\"></i>&nbsp;\\n                                    <span>{{ gist.favers }}</span>\\n                                </li>\\n                            </ul>\\n                        </div>\\n                        <div class=\\\"submit pull-right\\\">\\n                            <a href=\\\"#\\\" data-toggle=\\\"modal\\\" v-on:click=\\\"selectGist(gist)\\\" data-target=\\\"#submitModal\\\"> Submit </a>\\n                        </div>\\n                        <!-- <div class=\\\"meta-info\\\">\\n                            <p class=\\\"pull-right\\\"><small>submitted by: Mandeep Singh</small></p>\\n                        </div> -->\\n                    </div>\\n                </div>\\n            </div>\\n        </div>\\n    </section>\\n</div>\\n<footer-component></footer-component>\\n<div class=\\\"modal fade in\\\" id=\\\"submitModal\\\" tabindex=\\\"-1\\\" role=\\\"dialog\\\" aria-labelledby=\\\"myModalLabel\\\" aria-hidden=\\\"false\\\">\\n    <div class=\\\"modal-dialog\\\" role=\\\"document\\\">\\n        <div class=\\\"modal-content\\\">\\n            <div class=\\\"modal-header\\\">\\n                <button type=\\\"button\\\" class=\\\"close\\\" data-dismiss=\\\"modal\\\" aria-label=\\\"Close\\\"><span aria-hidden=\\\"true\\\"></span></button>\\n                <h4 class=\\\"modal-title\\\" id=\\\"myModalLabel\\\">Submit Package</h4>\\n            </div>\\n            <div class=\\\"modal-body\\\">\\n                <div class=\\\"alert alert-danger\\\" id=\\\"modalError\\\" v-show=\\\"error\\\">\\n                    {{{error}}}\\n                </div>\\n                <div class=\\\"alert alert-success\\\" id=\\\"modalSuccess\\\" v-show=\\\"submitted\\\">\\n                    Your submission has been saved and will be reviewed by our team.\\n                </div>\\n                <form class=\\\"form-horizontal\\\" v-show=\\\"!submitted\\\">\\n                    <fieldset>\\n                        <!-- Text input-->\\n                        <div class=\\\"form-group\\\">\\n                            <label class=\\\"col-md-4 control-label\\\" for=\\\"name\\\">Name</label>\\n                            <div class=\\\"col-md-6\\\">\\n                                <input id=\\\"name\\\" name=\\\"name\\\" type=\\\"text\\\" placeholder=\\\"\\\" class=\\\"form-control input-md\\\" disabled=\\\"\\\" required=\\\"\\\" v-model=\\\"selectedGist.name\\\">\\n                            </div>\\n                        </div>\\n                        <!-- Text input-->\\n                        <div class=\\\"form-group\\\" v-bind:class=\\\"{'has-error': errors.first_name}\\\">\\n                            <label class=\\\"col-md-4 control-label\\\" for=\\\"first_name\\\">First Name</label>\\n                            <div class=\\\"col-md-6\\\">\\n                                <input id=\\\"first_name\\\" name=\\\"first_name\\\" type=\\\"text\\\" placeholder=\\\"\\\" class=\\\"form-control input-md\\\" required=\\\"\\\" v-model=\\\"selectedGist.first_name\\\">\\n                                <span class=\\\"help-block\\\" v-show=\\\"errors.first_name\\\">{{ errors.first_name[0] }}</span>\\n                            </div>\\n                        </div>\\n                        <!-- Text input-->\\n                        <div class=\\\"form-group\\\" v-bind:class=\\\"{'has-error': errors.email}\\\">\\n                            <label class=\\\"col-md-4 control-label\\\" for=\\\"email\\\">Email</label>\\n                            <div class=\\\"col-md-6\\\">\\n                                <input id=\\\"email\\\" name=\\\"email\\\" type=\\\"text\\\" placeholder=\\\"\\\" class=\\\"form-control input-md\\\" required=\\\"\\\" v-model=\\\"selectedGist.email\\\">\\n                                <span class=\\\"help-block\\\" v-show=\\\"errors.email\\\">{{ errors.email[0] }}</span>\\n\\n                            </div>\\n                        </div>\\n                        <!-- Select Basic -->\\n                        <div class=\\\"form-group\\\" v-bind:class=\\\"{'has-error': errors.category_id}\\\">\\n                            <label class=\\\"col-md-4 control-label\\\" for=\\\"category_id\\\">Select Category</label>\\n                            <div class=\\\"col-md-6\\\">\\n                                <select id=\\\"category_id\\\" name=\\\"category_id\\\" class=\\\"form-control\\\" v-model=\\\"selectedGist.category_id\\\">\\n                                    <option v-for=\\\"category in categories\\\" value=\\\"{{category.id}}\\\">{{category.name}}</option>\\n                                </select>\\n                                <span class=\\\"help-block\\\" v-show=\\\"errors.category_id\\\">{{ errors.category_id[0] }}</span>\\n\\n                            </div>\\n                        </div>\\n                    </fieldset>\\n                </form>\\n            </div>\\n            <div class=\\\"modal-footer\\\">\\n                <button type=\\\"button\\\" class=\\\"btn btn-default\\\" data-dismiss=\\\"modal\\\">Close</button>\\n                <button type=\\\"button\\\" class=\\\"btn btn-primary\\\" v-on:click=\\\"submitPackage()\\\" id=\\\"modalSubmit\\\" v-show=\\\"!submitted\\\">Submit</button>\\n            </div>\\n        </div>\\n    </div>\\n</div>\\n\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/meSingh/Sites/__KhurafatS/Laragist.org/HTML/resources/assets/js/compiled/pages/submit.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":138,\"vue-hot-reload-api\":46}],160:[function(require,module,exports){\n\"use strict\";\n\nmodule.exports = {\n\tdata: function data() {\n\t\treturn {\n\t\t\tsubscriber: {\n\t\t\t\temail_address: \"\",\n\t\t\t\tstatus: \"subscribed\"\n\t\t\t}\n\t\t};\n\t},\n\n\tmethods: {\n\t\tsendEmail: function sendEmail() {\n\n\t\t\tclient({ path: '/subscribers', entity: this.subscriber }).then(function (response) {});\n\t\t}\n\t}\n\n};\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n<nav-component></nav-component>\\n\\n<div class=\\\"support\\\">\\n    <section class=\\\"welcome\\\">\\n        <div class=\\\"container\\\">\\n            <div class=\\\"row\\\">\\n                <div class=\\\"col-md-2 col-md-offset-1\\\">\\n                \\t<i class=\\\"fa fa-life-ring\\\" style=\\\"font-size: 150px; color:#fff\\\"></i>\\n                </div>\\n                <div class=\\\"col-md-8\\\">\\n                    <h2>Get support for our laravel packages</h2>\\n                    <form action=\\\"#\\\" v-on:submit=\\\"sendEmail()\\\">\\n                        <div class=\\\"input-group\\\">\\n                            <input type=\\\"email\\\" id=\\\"searchInput\\\" v-model=\\\"subscriber.email\\\" class=\\\"form-control input-lg\\\" placeholder=\\\"Enter your email\\\">\\n                            <span class=\\\"input-group-btn\\\">\\n                                <button type=\\\"submit\\\" class=\\\"btn btn-custom btn-lg\\\">Subscribe!</button>\\n                            </span>\\n                        </div>\\n                    </form>\\n                </div>\\n            </div>\\n        </div>\\n    </section>\\n\\n    <section class=\\\"container content\\\"> \\n        <div class=\\\"block\\\">\\n            <p>\\n                Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\\n            </p>\\n        </div>\\n    </section>\\n\\n</div>\\n\\n<footer-component></footer-component>\\n\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/meSingh/Sites/__KhurafatS/Laragist.org/HTML/resources/assets/js/compiled/pages/support.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":138,\"vue-hot-reload-api\":46}],161:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n    data: function data() {\n        return {\n            gist: [],\n            user: this.$route.params.user,\n            name: this.$route.params.name,\n            readme: '',\n            version_id: '',\n            version: [],\n            versionsListPulled: 0,\n            readmePulled: 0,\n            versionPulled: 0,\n            selectedVersion: []\n        };\n    },\n\n    created: function created() {\n        this.fetchGist();\n    },\n\n    methods: {\n        fetchGist: function fetchGist() {\n            var that = this;\n\n            client({ path: '/packages/' + this.user + '/' + this.name }).then(function (response) {\n                that.gist = response.entity.data['package'];\n                that.version_id = that.gist.version;\n                that.selectedVersion = that.gist.latest;\n                that.selectedVersion.require_dev = that.gist.latest['require-dev'];\n                that.getreadme(that.version_id);\n            }, function (errorResponse) {\n                console.log('error');\n            });\n        },\n\n        versionsList: function versionsList() {},\n\n        getreadme: function getreadme(version) {\n            var that = this;\n\n            //Creating dummy a element to parse repository url\n            var url = document.createElement('a');\n            url.href = this.gist.repository;\n\n            if (url.hostname == 'github.com') var host = \"https://raw.githubusercontent.com{repo}/\";else if (url.hostname == 'bitbucket.org') var host = \"https://bitbucket.org{repo}/raw/\";\n\n            var pathname = url.pathname.replace('.git', '');\n            host = host.replace('{repo}', pathname);\n\n            this.$http({ url: host + version + '/readme.md' }).then(function (response) {\n                that.readme = converter.makeHtml(response.data);\n            }, function (errorResponse) {\n                this.$http({ url: host + version + '/README.md' }).then(function (response) {\n                    that.readme = converter.makeHtml(response.data);\n                });\n            });\n        },\n\n        selectVersion: function selectVersion() {\n            console.log(this.selectedVersion);\n\n            this.getreadme(this.selectedVersion.version);\n            this.selectedVersion.require_dev = that.selectedVersion.latest['require-dev'];\n        }\n\n    }\n};\n;(typeof module.exports === \"function\"? module.exports.options: module.exports).template = \"\\n\\n<nav-component></nav-component>\\n    \\n    <div class=\\\"package\\\">\\n\\n        <section class=\\\"welcome\\\">\\n            <div class=\\\"container\\\">\\n                <h2>\\n                    {{ selectedVersion.name }} \\n                    <small class=\\\"latest\\\">\\n                        <i class=\\\"fa fa-fw fa-code-fork\\\"></i>\\n                        {{ selectedVersion.version }}\\n                    </small>\\n                </h2>\\n                <div class=\\\"cats\\\">\\n                    <ul class=\\\"list-inline pull-right\\\" v-show=\\\"selectedVersion.licenses[0]\\\">\\n                        <li><i class=\\\"fa fa-fw fa-copyright\\\"></i></li>\\n                        <li v-for=\\\"license in selectedVersion.licenses\\\">{{license}}</li>\\n                    </ul>\\n                    <ul class=\\\"list-inline\\\">\\n                        <li><i class=\\\"fa fa-fw fa-bars\\\"></i></li>\\n                        <li v-for=\\\"cat in gist.categories\\\">{{cat.name}}</li>\\n                    </ul>\\n                </div>\\n            </div>\\n        </section>\\n\\n        <section class=\\\"content\\\">\\n            <div class=\\\"container\\\">\\n\\n                <div class=\\\"row\\\"> <!--  TOP ROW  -->\\n                    <div class=\\\"col-md-8\\\">\\n\\n                        <div class=\\\"install\\\">\\n                            <i class=\\\"fa fa-fw fa-download\\\"></i>\\n                            <code>composer require {{ selectedVersion.name }}</code>\\n                        </div>\\n\\n                        <div class=\\\"description block\\\" v-show=\\\"gist.description\\\">\\n                            <!-- <div class=\\\"page-header\\\">\\n                                <h3>Description</h3>\\n                            </div> -->\\n                            <p>{{selectedVersion.description}}</p>\\n\\n                            <ul class=\\\"list-inline tags\\\" v-show=\\\"selectedVersion.keywords[0]\\\">\\n                                <li><i class=\\\"fa fa-fw fa-tags\\\"></i></li>\\n                                <li v-for=\\\"keyword in selectedVersion.keywords\\\">#{{keyword}}</li>\\n                            </ul>\\n                        </div>\\n\\n\\n\\n                         <!--  THIRD ROW  -->\\n                        <div class=\\\"block\\\">\\n                            <div class=\\\"readme\\\" v-bind:class=\\\"{'readme-limit': !readmePulled}\\\">\\n                                {{{ readme }}}\\n                            </div>\\n                            <div class=\\\"pull-over\\\" v-show=\\\"!readmePulled\\\" v-on:click=\\\"readmePulled=1\\\"><i class=\\\"fa fa-caret-down\\\"></i></div>\\n                        </div>\\n                        <!--  THIRD ROW  -->\\n\\n                    </div>\\n                    <div class=\\\"col-md-4 details\\\">\\n                        <div class=\\\"block\\\">\\n\\n                            <template v-if=\\\"selectedVersion.authors.length > 1\\\">\\n                                <ul class=\\\"list-inline authors\\\">\\n                                    <li v-for=\\\"author in selectedVersion.authors\\\">\\n                                        <img src=\\\"//www.gravatar.com/avatar/{{ author.email_hash}}?s=100\\\" alt=\\\"{{ author.name }}\\\" title=\\\"{{ author.name }}\\\">\\n                                        <h4>{{ author.name }}</h4>\\n                                    </li>\\n                                </ul>\\n\\n                                <hr>\\n\\n                                <div class=\\\"stats\\\">\\n                                    <div class=\\\"row\\\">\\n                                        <div class=\\\"col-md-6\\\">\\n                                            <h3>\\n                                                <i class=\\\"fa fa-download\\\"></i>\\n                                                {{ gist.downloads_total}}\\n                                            </h3>\\n                                        </div>\\n                                        <div class=\\\"col-md-6\\\">\\n                                            <h3>\\n                                                <i class=\\\"fa fa-heart\\\"></i>\\n                                                {{ gist.favorites }}\\n                                            </h3>\\n                                        </div>\\n                                    </div>\\n                                </div>\\n                            </template>\\n                            <template v-if=\\\"selectedVersion.authors.length == 1\\\">\\n                                <div class=\\\"row\\\">\\n                                    <div class=\\\"col-md-6\\\">\\n                                        <ul class=\\\"list-inline authors-alt\\\">\\n                                            <li v-for=\\\"author in gist.authors\\\">\\n                                                <img src=\\\"//www.gravatar.com/avatar/{{ author.email_hash}}?s=120\\\" alt=\\\"{{ author.name }}\\\" title=\\\"{{ author.name }}\\\">\\n                                                <h4>{{ author.name }}</h4>\\n                                            </li>\\n                                        </ul>\\n                                    </div>\\n                                    <div class=\\\"col-md-6\\\">\\n                                        <div class=\\\"stats-alt\\\">\\n                                            <div class=\\\"box\\\">\\n                                                <i class=\\\"fa fa-download\\\"></i>\\n                                                <h3>{{ gist.downloads_total }}</h3>\\n                                            </div>\\n                                            <div class=\\\"box\\\">\\n                                                <i class=\\\"fa fa-heart\\\"></i>\\n                                                <h3>{{ gist.favorites }}</h3>\\n                                            </div>\\n                                        </div>\\n                                    </div>\\n                                </div>\\n                            </template>\\n\\n                            <div class=\\\"btns btn-group btn-group-justified\\\">\\n                                <a href=\\\"{{ gist.repository }}\\\" target=\\\"_blank\\\" class=\\\"btn btn-default repository\\\">\\n                                    View Source\\n                                </a>\\n                                <a href=\\\"{{ gist.homepage }}\\\" target=\\\"_blank\\\" class=\\\"btn btn-default homepage\\\">\\n                                    Visit Homepage\\n                                </a>\\n                            </div>\\n                            \\n                        </div>\\n\\n              \\n                        <!-- <div class=\\\"block\\\" v-bind:class=\\\"{'version-selector' : versionsListPulled!=1}\\\">\\n                            <ul>\\n                                <li v-for=\\\"version in gist.versions\\\">\\n                                    <a href=\\\"#\\\">{{version.version}}</a>\\n                                </li>\\n                            </ul>\\n                            <div class=\\\"pull-over\\\" v-show=\\\"!versionsListPulled\\\" v-on:click=\\\"versionsListPulled=1\\\"><i class=\\\"fa fa-caret-down\\\"></i></div>\\n                        </div> -->\\n\\n                        \\n\\n                        <div class=\\\"version block\\\">\\n                            <div class=\\\"\\\" v-bind:class=\\\"{'version-limit': !versionPulled}\\\">\\n                                <select v-model=\\\"selectedVersion\\\" v-on:change=\\\"selectVersion\\\">\\n                                    <option v-for=\\\"version in gist.versions\\\" v-bind:value=\\\"version\\\">{{version.version}}</option>\\n                                </select>\\n\\n                                <p>{{ version.time }}</p>\\n                                \\n                                <hr>\\n\\n                                <div v-show=\\\"selectedVersion.require\\\">\\n                                    <h4>requires</h4>                                    \\n                                    <ul>\\n                                        <li v-for=\\\"(package, number) in selectedVersion.require\\\">\\n                                            <a href=\\\"https://packagist.org/packages/{{ package }}\\\" target=\\\"_blank\\\">{{ package }}</a>: {{number}}\\n                                        </li>\\n                                    </ul>\\n                                </div>\\n                                <div v-show=\\\"selectedVersion.require_dev\\\">\\n                                    <h4>requires (dev)</h4>\\n                                    <ul>\\n                                        <li v-for=\\\"(package, number) in selectedVersion.require_dev\\\">\\n                                            <a href=\\\"https://packagist.org/packages/{{ package }}\\\" target=\\\"_blank\\\">{{ package }}</a>: {{number}}\\n                                        </li>\\n                                    </ul>\\n                                </div>\\n                                <div v-show=\\\"selectedVersion.suggest\\\">\\n                                    <h4>suggests</h4>\\n                                    <ul>\\n                                        <li v-for=\\\"(package, number) in selectedVersion.suggest\\\">\\n                                            <a href=\\\"https://packagist.org/packages/{{ package }}\\\" target=\\\"_blank\\\">{{ package }}</a>: {{number}}\\n                                        </li>\\n                                    </ul>\\n                                </div>\\n                                <div v-show=\\\"selectedVersion.provides\\\">\\n                                    <h4>provides</h4>\\n                                    <ul>\\n                                        <li v-for=\\\"(package, number) in selectedVersion.provides\\\">\\n                                            {{ package }}: {{number}}\\n                                        </li>\\n                                    </ul>\\n                                </div>\\n                                <div v-show=\\\"selectedVersion.conflicts\\\">\\n                                    <h4>conflicts</h4>\\n                                    <ul>\\n                                        <li v-for=\\\"(package, number) in selectedVersion.conflicts\\\">\\n                                            {{ package }}: {{number}}\\n                                        </li>\\n                                    </ul>\\n                                </div>\\n                                <div v-show=\\\"selectedVersion.replaces\\\">\\n                                    <h4>replaces</h4>\\n                                    <ul>\\n                                        <li v-for=\\\"(package, number) in selectedVersion.replaces\\\">\\n                                            {{ package }}: {{number}}\\n                                        </li>\\n                                    </ul>\\n                                </div>\\n                            </div>\\n                            <div class=\\\"pull-over\\\" v-show=\\\"!versionPulled\\\" v-on:click=\\\"versionPulled=1\\\"><i class=\\\"fa fa-caret-down\\\"></i></div>\\n                        </div><!--  version block  -->\\n                        \\n                    </div>\\n                </div> <!--  SECOND ROW  -->\\n\\n\\n               \\n            </div>\\n        </section>\\n\\n    </div>\\n\\n<footer-component></footer-component>\\n\"\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"/Users/meSingh/Sites/__KhurafatS/Laragist.org/HTML/resources/assets/js/compiled/pages/view.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, module.exports.template)\n  }\n})()}\n},{\"vue\":138,\"vue-hot-reload-api\":46}],162:[function(require,module,exports){\n'use strict';\n\nvar config = {\n  env: 'development',\n  api: {\n    base_url: 'http://internal-api.laragist.org/v1',\n    defaultRequest: {\n      headers: {\n        'X-Requested-With': 'rest.js',\n        'Content-Type': 'application/json'\n      }\n    }\n  },\n  social: {\n    facebook: '',\n    twitter: '',\n    github: 'khurafat'\n  },\n  debug: true\n};\n\nmodule.exports = config;\n\n},{}],163:[function(require,module,exports){\n(function (process){\n'use strict';\n\nvar env = process.env.APP_ENV || 'development';\n\nvar config = {\n  development: require('./development.config'),\n  production: require('./production.config'),\n  staging: require('./staging.config')\n};\n\nmodule.exports = config[env];\n\n}).call(this,require('_process'))\n\n},{\"./development.config\":162,\"./production.config\":164,\"./staging.config\":165,\"_process\":1}],164:[function(require,module,exports){\n'use strict';\n\nvar config = {\n  env: 'production',\n  api: {\n    base_url: 'http://internal-api.laragist.org/v1',\n    defaultRequest: {\n      headers: {\n        'X-Requested-With': 'rest.js',\n        'Content-Type': 'application/json'\n      }\n    }\n  },\n  social: {\n    facebook: '',\n    twitter: '',\n    github: ''\n  },\n  debug: false\n};\n\nmodule.exports = config;\n\n},{}],165:[function(require,module,exports){\n'use strict';\n\nvar config = {\n  env: 'staging',\n  api: {\n    base_url: 'http://internal-api.laragist.org/v1',\n    defaultRequest: {\n      headers: {\n        'X-Requested-With': 'rest.js',\n        'Content-Type': 'application/json'\n      }\n    }\n  },\n  social: {\n    facebook: '',\n    twitter: '',\n    github: ''\n  },\n  debug: true\n};\nmodule.exports = config;\n\n},{}],166:[function(require,module,exports){\n'use strict';\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (require) {\n\n\t\tvar interceptor;\n\n\t\tinterceptor = require('rest/interceptor');\n\n\t\t/**\n   * Authenticates the request using JWT Authentication\n   *\n   * @param {Client} [client] client to wrap\n   * @param {Object} config\n   *\n   * @returns {Client}\n   */\n\t\treturn interceptor({\n\t\t\trequest: function request(_request, config) {\n\t\t\t\tvar token, headers;\n\n\t\t\t\ttoken = localStorage.getItem('jwt-token');\n\t\t\t\theaders = _request.headers || (_request.headers = {});\n\n\t\t\t\tif (token !== null && token !== 'undefined') {\n\t\t\t\t\theaders.Authorization = token;\n\t\t\t\t}\n\n\t\t\t\treturn _request;\n\t\t\t},\n\t\t\tresponse: function response(_response) {\n\t\t\t\tif (_response.status && _response.status.code == 401) {\n\t\t\t\t\tlocalStorage.removeItem('jwt-token');\n\t\t\t\t}\n\t\t\t\tif (_response.headers && _response.headers.Authorization) {\n\t\t\t\t\tlocalStorage.setItem('jwt-token', _response.headers.Authorization);\n\t\t\t\t}\n\t\t\t\tif (_response.entity && _response.entity.token && _response.entity.token.length > 10) {\n\t\t\t\t\tlocalStorage.setItem('jwt-token', 'Bearer ' + _response.entity.token);\n\t\t\t\t}\n\t\t\t\treturn _response;\n\t\t\t}\n\t\t});\n\t});\n})(typeof define === 'function' && define.amd ? define : function (factory) {\n\tmodule.exports = factory(require);\n}\n// Boilerplate for AMD and Node\n);\n\n},{\"rest/interceptor\":7}],167:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n\n  configRouter: function configRouter(router) {\n\n    router.map({\n      '/auth': {\n        component: require('./compiled/pages/auth.vue'),\n        subRoutes: {\n          '/login': {\n            component: require('./compiled/pages/auth/login.vue'),\n            guest: true\n          },\n          '/register': {\n            component: require('./compiled/pages/auth/register.vue'),\n            guest: true\n          },\n          '/profile': {\n            component: require('./compiled/pages/auth/profile.vue'),\n            auth: true\n          },\n          '/logout': {\n            component: require('./compiled/pages/auth/logout.vue'),\n            auth: true\n          }\n        }\n      },\n      '/home': {\n        component: require('./compiled/pages/home.vue'),\n        subRoutes: {\n          '/': {\n            component: require('./compiled/pages/home/home.vue')\n          },\n          '/welcome': {\n            component: require('./compiled/pages/home/welcome.vue')\n          },\n          '/about': {\n            component: require('./compiled/pages/home/about.vue')\n          }\n        }\n      },\n      '/submit': {\n        component: require('./compiled/pages/submit.vue'),\n        subRoutes: {\n          '/': {\n            component: require('./compiled/pages/dogs/index.vue')\n          },\n          '/:id': {\n            component: require('./compiled/pages/dogs/show.vue')\n          },\n          '/create': {\n            component: require('./compiled/pages/dogs/create.vue')\n          }\n        }\n      },\n      '/packages/:user/:name': {\n        name: 'view',\n        component: require('./compiled/pages/view.vue')\n      },\n      '/about': {\n        name: 'about',\n        component: require('./compiled/pages/about.vue')\n      },\n      '/support': {\n        name: 'about',\n        component: require('./compiled/pages/support.vue')\n      },\n      '*': {\n        component: require('./compiled/pages/404.vue')\n      }\n    });\n\n    router.alias({\n      '': '/home',\n      '/auth': '/auth/login'\n    });\n\n    router.beforeEach(function (transition) {\n\n      var token = localStorage.getItem('jwt-token');\n      if (transition.to.auth) {\n        if (!token || token === null) {\n          transition.redirect('/auth/login');\n        }\n      }\n      if (transition.to.guest) {\n        if (token) {\n          transition.redirect('/');\n        }\n      }\n      transition.next();\n    });\n  }\n};\n\n},{\"./compiled/pages/404.vue\":145,\"./compiled/pages/about.vue\":146,\"./compiled/pages/auth.vue\":147,\"./compiled/pages/auth/login.vue\":148,\"./compiled/pages/auth/logout.vue\":149,\"./compiled/pages/auth/profile.vue\":150,\"./compiled/pages/auth/register.vue\":151,\"./compiled/pages/dogs/create.vue\":152,\"./compiled/pages/dogs/index.vue\":153,\"./compiled/pages/dogs/show.vue\":154,\"./compiled/pages/home.vue\":155,\"./compiled/pages/home/about.vue\":156,\"./compiled/pages/home/home.vue\":157,\"./compiled/pages/home/welcome.vue\":158,\"./compiled/pages/submit.vue\":159,\"./compiled/pages/support.vue\":160,\"./compiled/pages/view.vue\":161}]},{},[141])\n//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9sYXJhdmVsLWVsaXhpci9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1wYWNrL19wcmVsdWRlLmpzIiwibm9kZV9tb2R1bGVzL2xhcmF2ZWwtZWxpeGlyL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVzdC9VcmxCdWlsZGVyLmpzIiwibm9kZV9tb2R1bGVzL3Jlc3QvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZXN0L2NsaWVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZXN0L2NsaWVudC9kZWZhdWx0LmpzIiwibm9kZV9tb2R1bGVzL3Jlc3QvY2xpZW50L3hoci5qcyIsIm5vZGVfbW9kdWxlcy9yZXN0L2ludGVyY2VwdG9yLmpzIiwibm9kZV9tb2R1bGVzL3Jlc3QvaW50ZXJjZXB0b3IvZGVmYXVsdFJlcXVlc3QuanMiLCJub2RlX21vZHVsZXMvcmVzdC9pbnRlcmNlcHRvci9lcnJvckNvZGUuanMiLCJub2RlX21vZHVsZXMvcmVzdC9pbnRlcmNlcHRvci9taW1lLmpzIiwibm9kZV9tb2R1bGVzL3Jlc3QvaW50ZXJjZXB0b3IvcGF0aFByZWZpeC5qcyIsIm5vZGVfbW9kdWxlcy9yZXN0L2ludGVyY2VwdG9yL3RlbXBsYXRlLmpzIiwibm9kZV9tb2R1bGVzL3Jlc3QvbWltZS5qcyIsIm5vZGVfbW9kdWxlcy9yZXN0L21pbWUvcmVnaXN0cnkuanMiLCJub2RlX21vZHVsZXMvcmVzdC9taW1lL3R5cGUvYXBwbGljYXRpb24vaGFsLmpzIiwibm9kZV9tb2R1bGVzL3Jlc3QvbWltZS90eXBlL2FwcGxpY2F0aW9uL2pzb24uanMiLCJub2RlX21vZHVsZXMvcmVzdC9taW1lL3R5cGUvYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkLmpzIiwibm9kZV9tb2R1bGVzL3Jlc3QvbWltZS90eXBlL211bHRpcGFydC9mb3JtLWRhdGEuanMiLCJub2RlX21vZHVsZXMvcmVzdC9taW1lL3R5cGUvdGV4dC9wbGFpbi5qcyIsIm5vZGVfbW9kdWxlcy9yZXN0L25vZGVfbW9kdWxlcy93aGVuL2xpYi9Qcm9taXNlLmpzIiwibm9kZV9tb2R1bGVzL3Jlc3Qvbm9kZV9tb2R1bGVzL3doZW4vbGliL1NjaGVkdWxlci5qcyIsIm5vZGVfbW9kdWxlcy9yZXN0L25vZGVfbW9kdWxlcy93aGVuL2xpYi9UaW1lb3V0RXJyb3IuanMiLCJub2RlX21vZHVsZXMvcmVzdC9ub2RlX21vZHVsZXMvd2hlbi9saWIvYXBwbHkuanMiLCJub2RlX21vZHVsZXMvcmVzdC9ub2RlX21vZHVsZXMvd2hlbi9saWIvZGVjb3JhdG9ycy9hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9yZXN0L25vZGVfbW9kdWxlcy93aGVuL2xpYi9kZWNvcmF0b3JzL2Zsb3cuanMiLCJub2RlX21vZHVsZXMvcmVzdC9ub2RlX21vZHVsZXMvd2hlbi9saWIvZGVjb3JhdG9ycy9mb2xkLmpzIiwibm9kZV9tb2R1bGVzL3Jlc3Qvbm9kZV9tb2R1bGVzL3doZW4vbGliL2RlY29yYXRvcnMvaW5zcGVjdC5qcyIsIm5vZGVfbW9kdWxlcy9yZXN0L25vZGVfbW9kdWxlcy93aGVuL2xpYi9kZWNvcmF0b3JzL2l0ZXJhdGUuanMiLCJub2RlX21vZHVsZXMvcmVzdC9ub2RlX21vZHVsZXMvd2hlbi9saWIvZGVjb3JhdG9ycy9wcm9ncmVzcy5qcyIsIm5vZGVfbW9kdWxlcy9yZXN0L25vZGVfbW9kdWxlcy93aGVuL2xpYi9kZWNvcmF0b3JzL3RpbWVkLmpzIiwibm9kZV9tb2R1bGVzL3Jlc3Qvbm9kZV9tb2R1bGVzL3doZW4vbGliL2RlY29yYXRvcnMvdW5oYW5kbGVkUmVqZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3Jlc3Qvbm9kZV9tb2R1bGVzL3doZW4vbGliL2RlY29yYXRvcnMvd2l0aC5qcyIsIm5vZGVfbW9kdWxlcy9yZXN0L25vZGVfbW9kdWxlcy93aGVuL2xpYi9lbnYuanMiLCJub2RlX21vZHVsZXMvcmVzdC9ub2RlX21vZHVsZXMvd2hlbi9saWIvZm9ybWF0LmpzIiwibm9kZV9tb2R1bGVzL3Jlc3Qvbm9kZV9tb2R1bGVzL3doZW4vbGliL21ha2VQcm9taXNlLmpzIiwibm9kZV9tb2R1bGVzL3Jlc3Qvbm9kZV9tb2R1bGVzL3doZW4vbGliL3N0YXRlLmpzIiwibm9kZV9tb2R1bGVzL3Jlc3Qvbm9kZV9tb2R1bGVzL3doZW4vd2hlbi5qcyIsIm5vZGVfbW9kdWxlcy9yZXN0L3V0aWwvZmluZC5qcyIsIm5vZGVfbW9kdWxlcy9yZXN0L3V0aWwvbGF6eVByb21pc2UuanMiLCJub2RlX21vZHVsZXMvcmVzdC91dGlsL21peGluLmpzIiwibm9kZV9tb2R1bGVzL3Jlc3QvdXRpbC9ub3JtYWxpemVIZWFkZXJOYW1lLmpzIiwibm9kZV9tb2R1bGVzL3Jlc3QvdXRpbC9yZXNwb25zZVByb21pc2UuanMiLCJub2RlX21vZHVsZXMvcmVzdC91dGlsL3VyaUVuY29kZXIuanMiLCJub2RlX21vZHVsZXMvcmVzdC91dGlsL3VyaVRlbXBsYXRlLmpzIiwibm9kZV9tb2R1bGVzL3Nob3dkb3duL2Rpc3Qvc2hvd2Rvd24uanMiLCJub2RlX21vZHVsZXMvdnVlLWhvdC1yZWxvYWQtYXBpL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS1sYXJhdmVsLXBhZ2luYXRpb24vdnVlLXBhZ2luYXRpb24uanMiLCJub2RlX21vZHVsZXMvdnVlLXJlc291cmNlL3NyYy9odHRwL2JlZm9yZS5qcyIsIm5vZGVfbW9kdWxlcy92dWUtcmVzb3VyY2Uvc3JjL2h0dHAvY2xpZW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS1yZXNvdXJjZS9zcmMvaHR0cC9jbGllbnQvanNvbnAuanMiLCJub2RlX21vZHVsZXMvdnVlLXJlc291cmNlL3NyYy9odHRwL2NsaWVudC94ZHIuanMiLCJub2RlX21vZHVsZXMvdnVlLXJlc291cmNlL3NyYy9odHRwL2NsaWVudC94aHIuanMiLCJub2RlX21vZHVsZXMvdnVlLXJlc291cmNlL3NyYy9odHRwL2NvcnMuanMiLCJub2RlX21vZHVsZXMvdnVlLXJlc291cmNlL3NyYy9odHRwL2hlYWRlci5qcyIsIm5vZGVfbW9kdWxlcy92dWUtcmVzb3VyY2Uvc3JjL2h0dHAvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdnVlLXJlc291cmNlL3NyYy9odHRwL2ludGVyY2VwdG9yLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS1yZXNvdXJjZS9zcmMvaHR0cC9qc29ucC5qcyIsIm5vZGVfbW9kdWxlcy92dWUtcmVzb3VyY2Uvc3JjL2h0dHAvbWV0aG9kLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS1yZXNvdXJjZS9zcmMvaHR0cC9taW1lLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS1yZXNvdXJjZS9zcmMvaHR0cC90aW1lb3V0LmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS1yZXNvdXJjZS9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdnVlLXJlc291cmNlL3NyYy9saWIvcHJvbWlzZS5qcyIsIm5vZGVfbW9kdWxlcy92dWUtcmVzb3VyY2Uvc3JjL2xpYi91cmwtdGVtcGxhdGUuanMiLCJub2RlX21vZHVsZXMvdnVlLXJlc291cmNlL3NyYy9wcm9taXNlLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS1yZXNvdXJjZS9zcmMvcmVzb3VyY2UuanMiLCJub2RlX21vZHVsZXMvdnVlLXJlc291cmNlL3NyYy91cmwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdnVlLXJlc291cmNlL3NyYy91cmwvbGVnYWN5LmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS1yZXNvdXJjZS9zcmMvdXJsL3F1ZXJ5LmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS1yZXNvdXJjZS9zcmMvdXJsL3Jvb3QuanMiLCJub2RlX21vZHVsZXMvdnVlLXJlc291cmNlL3NyYy91cmwvdGVtcGxhdGUuanMiLCJub2RlX21vZHVsZXMvdnVlLXJlc291cmNlL3NyYy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS1yb3V0ZXIvZGlzdC92dWUtcm91dGVyLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvYXBpL2RhdGEuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9hcGkvZG9tLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvYXBpL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2FwaS9nbG9iYWwuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9hcGkvbGlmZWN5Y2xlLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvYmF0Y2hlci5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2NhY2hlLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvY29tcGlsZXIvY29tcGlsZS1wcm9wcy5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2NvbXBpbGVyL2NvbXBpbGUuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9jb21waWxlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2NvbXBpbGVyL3RyYW5zY2x1ZGUuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9jb25maWcuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9kaXJlY3RpdmUuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9kaXJlY3RpdmVzL2VsZW1lbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9kaXJlY3RpdmVzL2VsZW1lbnQvcGFydGlhbC5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2RpcmVjdGl2ZXMvZWxlbWVudC9zbG90LmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvZGlyZWN0aXZlcy9pbnRlcm5hbC9jbGFzcy5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2RpcmVjdGl2ZXMvaW50ZXJuYWwvY29tcG9uZW50LmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvZGlyZWN0aXZlcy9pbnRlcm5hbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2RpcmVjdGl2ZXMvaW50ZXJuYWwvcHJvcC5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2RpcmVjdGl2ZXMvaW50ZXJuYWwvc3R5bGUuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9kaXJlY3RpdmVzL2ludGVybmFsL3RyYW5zaXRpb24uanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9kaXJlY3RpdmVzL3B1YmxpYy9iaW5kLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvZGlyZWN0aXZlcy9wdWJsaWMvY2xvYWsuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9kaXJlY3RpdmVzL3B1YmxpYy9lbC5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2RpcmVjdGl2ZXMvcHVibGljL2Zvci5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2RpcmVjdGl2ZXMvcHVibGljL2h0bWwuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9kaXJlY3RpdmVzL3B1YmxpYy9pZi5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2RpcmVjdGl2ZXMvcHVibGljL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvZGlyZWN0aXZlcy9wdWJsaWMvbW9kZWwvY2hlY2tib3guanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9kaXJlY3RpdmVzL3B1YmxpYy9tb2RlbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2RpcmVjdGl2ZXMvcHVibGljL21vZGVsL3JhZGlvLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvZGlyZWN0aXZlcy9wdWJsaWMvbW9kZWwvc2VsZWN0LmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvZGlyZWN0aXZlcy9wdWJsaWMvbW9kZWwvdGV4dC5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2RpcmVjdGl2ZXMvcHVibGljL29uLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvZGlyZWN0aXZlcy9wdWJsaWMvcmVmLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvZGlyZWN0aXZlcy9wdWJsaWMvc2hvdy5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2RpcmVjdGl2ZXMvcHVibGljL3RleHQuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9maWx0ZXJzL2FycmF5LWZpbHRlcnMuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9maWx0ZXJzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvZnJhZ21lbnQvZmFjdG9yeS5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2ZyYWdtZW50L2ZyYWdtZW50LmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvaW5zdGFuY2UvZXZlbnRzLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvaW5zdGFuY2UvaW5pdC5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2luc3RhbmNlL2xpZmVjeWNsZS5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL2luc3RhbmNlL21pc2MuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9pbnN0YW5jZS9zdGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL29ic2VydmVyL2FycmF5LmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvb2JzZXJ2ZXIvZGVwLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvb2JzZXJ2ZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9wYXJzZXJzL2RpcmVjdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL3BhcnNlcnMvZXhwcmVzc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL3BhcnNlcnMvcGF0aC5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL3BhcnNlcnMvdGVtcGxhdGUuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy9wYXJzZXJzL3RleHQuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy90cmFuc2l0aW9uL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvdHJhbnNpdGlvbi9xdWV1ZS5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL3RyYW5zaXRpb24vdHJhbnNpdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL3V0aWwvY29tcG9uZW50LmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvdXRpbC9kZWJ1Zy5qcyIsIm5vZGVfbW9kdWxlcy92dWUvc3JjL3V0aWwvZG9tLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvdXRpbC9lbnYuanMiLCJub2RlX21vZHVsZXMvdnVlL3NyYy91dGlsL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvdXRpbC9sYW5nLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvdXRpbC9vcHRpb25zLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvdnVlLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9zcmMvd2F0Y2hlci5qcyIsIm5vZGVfbW9kdWxlcy92dWVpZnktaW5zZXJ0LWNzcy9pbmRleC5qcyIsIi9Vc2Vycy9tZVNpbmdoL1NpdGVzL19fS2h1cmFmYXRTL0xhcmFnaXN0Lm9yZy9IVE1ML3Jlc291cmNlcy9hc3NldHMvanMvYm9vdHN0cmFwLmpzIiwicmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9hcHAudnVlIiwicmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9mb290ZXIudnVlIiwicmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9uYXYudnVlIiwicmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9wYWdlcy80MDQudnVlIiwicmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9wYWdlcy9hYm91dC52dWUiLCJyZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBpbGVkL3BhZ2VzL2F1dGgudnVlIiwicmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9wYWdlcy9hdXRoL2xvZ2luLnZ1ZSIsInJlc291cmNlcy9hc3NldHMvanMvY29tcGlsZWQvcGFnZXMvYXV0aC9sb2dvdXQudnVlIiwicmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9wYWdlcy9hdXRoL3Byb2ZpbGUudnVlIiwicmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9wYWdlcy9hdXRoL3JlZ2lzdGVyLnZ1ZSIsInJlc291cmNlcy9hc3NldHMvanMvY29tcGlsZWQvcGFnZXMvZG9ncy9jcmVhdGUudnVlIiwicmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9wYWdlcy9kb2dzL2luZGV4LnZ1ZSIsInJlc291cmNlcy9hc3NldHMvanMvY29tcGlsZWQvcGFnZXMvZG9ncy9zaG93LnZ1ZSIsInJlc291cmNlcy9hc3NldHMvanMvY29tcGlsZWQvcGFnZXMvaG9tZS52dWUiLCJyZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBpbGVkL3BhZ2VzL2hvbWUvYWJvdXQudnVlIiwicmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9wYWdlcy9ob21lL2hvbWUudnVlIiwicmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9wYWdlcy9ob21lL3dlbGNvbWUudnVlIiwicmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9wYWdlcy9zdWJtaXQudnVlIiwicmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9wYWdlcy9zdXBwb3J0LnZ1ZSIsInJlc291cmNlcy9hc3NldHMvanMvY29tcGlsZWQvcGFnZXMvdmlldy52dWUiLCIvVXNlcnMvbWVTaW5naC9TaXRlcy9fX0todXJhZmF0Uy9MYXJhZ2lzdC5vcmcvSFRNTC9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbmZpZy9kZXZlbG9wbWVudC5jb25maWcuanMiLCIvVXNlcnMvbWVTaW5naC9TaXRlcy9fX0todXJhZmF0Uy9MYXJhZ2lzdC5vcmcvSFRNTC9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbmZpZy9pbmRleC5qcyIsIi9Vc2Vycy9tZVNpbmdoL1NpdGVzL19fS2h1cmFmYXRTL0xhcmFnaXN0Lm9yZy9IVE1ML3Jlc291cmNlcy9hc3NldHMvanMvY29uZmlnL3Byb2R1Y3Rpb24uY29uZmlnLmpzIiwiL1VzZXJzL21lU2luZ2gvU2l0ZXMvX19LaHVyYWZhdFMvTGFyYWdpc3Qub3JnL0hUTUwvcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb25maWcvc3RhZ2luZy5jb25maWcuanMiLCIvVXNlcnMvbWVTaW5naC9TaXRlcy9fX0todXJhZmF0Uy9MYXJhZ2lzdC5vcmcvSFRNTC9yZXNvdXJjZXMvYXNzZXRzL2pzL2ludGVyY2VwdG9ycy9qd3RBdXRoLmpzIiwiL1VzZXJzL21lU2luZ2gvU2l0ZXMvX19LaHVyYWZhdFMvTGFyYWdpc3Qub3JnL0hUTUwvcmVzb3VyY2VzL2Fzc2V0cy9qcy9yb3V0ZXMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3BOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6c0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaFVBO0FBQ0E7QUFDQTs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNsVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdmxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2pQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN4UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3RXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0WUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbFdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdlZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7c0JDVDZCLFVBQVU7OztBQVJ2QyxNQUFNLENBQUMsR0FBRyxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQTtBQUMzQixHQUFHLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFBO0FBQ2hDLE1BQU0sQ0FBQyxTQUFTLEdBQUcsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFBLEFBU3hDLElBQU0sTUFBTSxHQUFHLElBQUksU0FBUyxDQUFDO0FBQzVCLDJCQUFPLEVBQUUsSUFBSTtDQUNiLENBQUMsQ0FBQTs7O0FBR0YsMEJBQWEsTUFBTSxDQUFDLENBQUE7OztBQUdwQixNQUFNLENBQUMsTUFBTSxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQTtBQUNuQyxHQUFHLENBQUMsTUFBTSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUE7QUFDdkIsR0FBRyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDOzs7QUFHNUMsSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFBO0FBQzFCLElBQUksVUFBVSxHQUFHLE9BQU8sQ0FBQyw2QkFBNkIsQ0FBQyxDQUFBO0FBQ3ZELElBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyx1QkFBdUIsQ0FBQyxDQUFBO0FBQzNDLElBQUksY0FBYyxHQUFHLE9BQU8sQ0FBQyxpQ0FBaUMsQ0FBQyxDQUFBO0FBQy9ELElBQUksU0FBUyxHQUFHLE9BQU8sQ0FBQyw0QkFBNEIsQ0FBQyxDQUFBO0FBQ3JELElBQUksV0FBVyxHQUFHLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFBO0FBQzdDLElBQUksT0FBTyxHQUFHLE9BQU8sQ0FBQyx3QkFBd0IsQ0FBQyxDQUFBOztBQUUvQyxJQUFJLFFBQVEsR0FBSSxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7QUFDcEMsTUFBTSxDQUFDLFNBQVMsR0FBRyxJQUFJLFFBQVEsQ0FBQyxTQUFTLEVBQUUsQ0FBQzs7QUFFNUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxFQUFFLE1BQU0sRUFBRSxNQUFNLENBQUMsR0FBRyxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQ2pELElBQUksQ0FBQyxJQUFJLENBQUMsQ0FDVixJQUFJLENBQUMsY0FBYyxFQUFFLE1BQU0sQ0FBQyxHQUFHLENBQUMsY0FBYyxDQUFDLENBQy9DLElBQUksQ0FBQyxTQUFTLEVBQUUsRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FDOUIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDOzs7QUFHbkMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxlQUFlLEVBQUUsT0FBTyxDQUFDLG9CQUFvQixDQUFDLENBQUMsQ0FBQTtBQUM3RCxHQUFHLENBQUMsU0FBUyxDQUFDLGtCQUFrQixFQUFFLE9BQU8sQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDLENBQUE7QUFDbkUsR0FBRyxDQUFDLFNBQVMsQ0FBQyxZQUFZLEVBQUUsT0FBTyxDQUFDLHdCQUF3QixDQUFDLENBQUMsQ0FBQTs7QUFFOUQsSUFBTSxHQUFHLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxDQUFBO0FBQ3JELE1BQU0sQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLE1BQU0sQ0FBQyxDQUFBO0FBQ3pCLE1BQU0sQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFBOztBQUd0QixNQUFNLENBQUMsU0FBUyxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDLEtBQUssSUFDekMsVUFBUyxDQUFDLEVBQUM7QUFDUCwyQkFBTyxBQUFDLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxHQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFDLENBQUMsR0FBQyxDQUFDLENBQUMsR0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO0NBQ3BFLENBQUM7OztBQ3ZERjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hGQSxJQUFJLE1BQU0sR0FBRztBQUNYLEtBQUcsRUFBRSxhQUFhO0FBQ2xCLEtBQUcsRUFBRTtBQUNILFlBQVEsRUFBRSxxQ0FBcUM7QUFDL0Msa0JBQWMsRUFBRTtBQUNkLGFBQU8sRUFBRTtBQUNQLDBCQUFrQixFQUFFLFNBQVM7QUFDN0Isc0JBQWMsRUFBRSxrQkFBa0I7T0FDbkM7S0FDRjtHQUNGO0FBQ0QsUUFBTSxFQUFFO0FBQ04sWUFBUSxFQUFFLEVBQUU7QUFDWixXQUFPLEVBQUUsRUFBRTtBQUNYLFVBQU0sRUFBRSxVQUFVO0dBQ25CO0FBQ0QsT0FBSyxFQUFFLElBQUk7Q0FDWixDQUFBOztBQUVELE1BQU0sQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFBOzs7Ozs7QUNuQnZCLElBQUksR0FBRyxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsT0FBTyxJQUFJLGFBQWEsQ0FBQTs7QUFFOUMsSUFBSSxNQUFNLEdBQUc7QUFDWCxhQUFXLEVBQUUsT0FBTyxDQUFDLHNCQUFzQixDQUFDO0FBQzVDLFlBQVUsRUFBRSxPQUFPLENBQUMscUJBQXFCLENBQUM7QUFDMUMsU0FBTyxFQUFFLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQztDQUNyQyxDQUFBOztBQUVELE1BQU0sQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFBOzs7Ozs7O0FDUjVCLElBQUksTUFBTSxHQUFHO0FBQ1gsS0FBRyxFQUFFLFlBQVk7QUFDakIsS0FBRyxFQUFFO0FBQ0gsWUFBUSxFQUFFLHFDQUFxQztBQUMvQyxrQkFBYyxFQUFFO0FBQ2QsYUFBTyxFQUFFO0FBQ1AsMEJBQWtCLEVBQUUsU0FBUztBQUM3QixzQkFBYyxFQUFFLGtCQUFrQjtPQUNuQztLQUNGO0dBQ0Y7QUFDRCxRQUFNLEVBQUU7QUFDTixZQUFRLEVBQUUsRUFBRTtBQUNaLFdBQU8sRUFBRSxFQUFFO0FBQ1gsVUFBTSxFQUFFLEVBQUU7R0FDWDtBQUNELE9BQUssRUFBRSxLQUFLO0NBQ2IsQ0FBQTs7QUFFRCxNQUFNLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQTs7Ozs7QUNuQnZCLElBQUksTUFBTSxHQUFHO0FBQ1gsS0FBRyxFQUFFLFNBQVM7QUFDZCxLQUFHLEVBQUU7QUFDSCxZQUFRLEVBQUUscUNBQXFDO0FBQy9DLGtCQUFjLEVBQUU7QUFDZCxhQUFPLEVBQUU7QUFDUCwwQkFBa0IsRUFBRSxTQUFTO0FBQzdCLHNCQUFjLEVBQUUsa0JBQWtCO09BQ25DO0tBQ0Y7R0FDRjtBQUNELFFBQU0sRUFBRTtBQUNOLFlBQVEsRUFBRSxFQUFFO0FBQ1osV0FBTyxFQUFFLEVBQUU7QUFDWCxVQUFNLEVBQUUsRUFBRTtHQUNYO0FBQ0QsT0FBSyxFQUFFLElBQUk7Q0FDWixDQUFBO0FBQ0QsTUFBTSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUE7Ozs7O0FDbEJ2QixBQUFDLENBQUEsVUFBVSxNQUFNLEVBQUU7QUFDbEIsYUFBWSxDQUFDOztBQUViLE9BQU0sQ0FBQyxVQUFVLE9BQU8sRUFBRTs7QUFFekIsTUFBSSxXQUFXLENBQUM7O0FBRWhCLGFBQVcsR0FBRyxPQUFPLENBQUMsa0JBQWtCLENBQUMsQ0FBQzs7Ozs7Ozs7OztBQVUxQyxTQUFPLFdBQVcsQ0FBQztBQUNsQixVQUFPLEVBQUUsaUJBQVUsUUFBTyxFQUFFLE1BQU0sRUFBRTtBQUNuQyxRQUFJLEtBQUssRUFBRSxPQUFPLENBQUM7O0FBRW5CLFNBQUssR0FBRyxZQUFZLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBQzFDLFdBQU8sR0FBRyxRQUFPLENBQUMsT0FBTyxLQUFLLFFBQU8sQ0FBQyxPQUFPLEdBQUcsRUFBRSxDQUFBLEFBQUMsQ0FBQzs7QUFFcEQsUUFBSyxLQUFLLEtBQUssSUFBSSxJQUFJLEtBQUssS0FBSyxXQUFXLEVBQUU7QUFDN0MsWUFBTyxDQUFDLGFBQWEsR0FBRyxLQUFLLENBQUM7S0FDOUI7O0FBRUUsV0FBTyxRQUFPLENBQUM7SUFDbEI7QUFDRCxXQUFRLEVBQUUsa0JBQVUsU0FBUSxFQUFFO0FBQzdCLFFBQUksU0FBUSxDQUFDLE1BQU0sSUFBSSxTQUFRLENBQUMsTUFBTSxDQUFDLElBQUksSUFBSSxHQUFHLEVBQUU7QUFDbkQsaUJBQVksQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLENBQUM7S0FDckM7QUFDRCxRQUFJLFNBQVEsQ0FBQyxPQUFPLElBQUksU0FBUSxDQUFDLE9BQU8sQ0FBQyxhQUFhLEVBQUU7QUFDdkQsaUJBQVksQ0FBQyxPQUFPLENBQUMsV0FBVyxFQUFFLFNBQVEsQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUE7S0FDakU7QUFDRCxRQUFJLFNBQVEsQ0FBQyxNQUFNLElBQUksU0FBUSxDQUFDLE1BQU0sQ0FBQyxLQUFLLElBQUksU0FBUSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLEVBQUUsRUFBRTtBQUNsRixpQkFBWSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEVBQUUsU0FBUyxHQUFHLFNBQVEsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7S0FDckU7QUFDRCxXQUFPLFNBQVEsQ0FBQztJQUNoQjtHQUNELENBQUMsQ0FBQztFQUVILENBQUMsQ0FBQztDQUVILENBQUEsQ0FDQSxPQUFPLE1BQU0sS0FBSyxVQUFVLElBQUksTUFBTSxDQUFDLEdBQUcsR0FBRyxNQUFNLEdBQUcsVUFBVSxPQUFPLEVBQUU7QUFBRSxPQUFNLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztDQUFFOztDQUUvRyxDQUFFOzs7OztBQ2pESCxNQUFNLENBQUMsT0FBTyxHQUFHOztBQUVmLGNBQVksRUFBRSxzQkFBVSxNQUFNLEVBQUU7O0FBRTlCLFVBQU0sQ0FBQyxHQUFHLENBQUM7QUFDVCxhQUFPLEVBQUU7QUFDUCxpQkFBUyxFQUFFLE9BQU8sQ0FBQywyQkFBMkIsQ0FBQztBQUMvQyxpQkFBUyxFQUFFO0FBQ1Qsa0JBQVEsRUFBRTtBQUNSLHFCQUFTLEVBQUUsT0FBTyxDQUFDLGlDQUFpQyxDQUFDO0FBQ3JELGlCQUFLLEVBQUUsSUFBSTtXQUNaO0FBQ0QscUJBQVcsRUFBRTtBQUNYLHFCQUFTLEVBQUUsT0FBTyxDQUFDLG9DQUFvQyxDQUFDO0FBQ3hELGlCQUFLLEVBQUUsSUFBSTtXQUNaO0FBQ0Qsb0JBQVUsRUFBRTtBQUNWLHFCQUFTLEVBQUUsT0FBTyxDQUFDLG1DQUFtQyxDQUFDO0FBQ3ZELGdCQUFJLEVBQUUsSUFBSTtXQUNYO0FBQ0QsbUJBQVMsRUFBRTtBQUNULHFCQUFTLEVBQUUsT0FBTyxDQUFDLGtDQUFrQyxDQUFDO0FBQ3RELGdCQUFJLEVBQUUsSUFBSTtXQUNYO1NBQ0Y7T0FDRjtBQUNELGFBQU8sRUFBRTtBQUNQLGlCQUFTLEVBQUUsT0FBTyxDQUFDLDJCQUEyQixDQUFDO0FBQy9DLGlCQUFTLEVBQUU7QUFDVCxhQUFHLEVBQUU7QUFDSCxxQkFBUyxFQUFFLE9BQU8sQ0FBQyxnQ0FBZ0MsQ0FBQztXQUNyRDtBQUNELG9CQUFVLEVBQUU7QUFDVixxQkFBUyxFQUFFLE9BQU8sQ0FBQyxtQ0FBbUMsQ0FBQztXQUN4RDtBQUNELGtCQUFRLEVBQUU7QUFDUixxQkFBUyxFQUFFLE9BQU8sQ0FBQyxpQ0FBaUMsQ0FBQztXQUN0RDtTQUNGO09BQ0Y7QUFDRCxlQUFTLEVBQUU7QUFDVCxpQkFBUyxFQUFFLE9BQU8sQ0FBQyw2QkFBNkIsQ0FBQztBQUNqRCxpQkFBUyxFQUFFO0FBQ1QsYUFBRyxFQUFFO0FBQ0gscUJBQVMsRUFBRSxPQUFPLENBQUMsaUNBQWlDLENBQUM7V0FDdEQ7QUFDRCxnQkFBTSxFQUFFO0FBQ04scUJBQVMsRUFBRSxPQUFPLENBQUMsZ0NBQWdDLENBQUM7V0FDckQ7QUFDRCxtQkFBUyxFQUFFO0FBQ1QscUJBQVMsRUFBRSxPQUFPLENBQUMsa0NBQWtDLENBQUM7V0FDdkQ7U0FDRjtPQUNGO0FBQ0QsNkJBQXVCLEVBQUU7QUFDdkIsWUFBSSxFQUFDLE1BQU07QUFDWCxpQkFBUyxFQUFFLE9BQU8sQ0FBQywyQkFBMkIsQ0FBQztPQUNoRDtBQUNELGNBQVEsRUFBRTtBQUNSLFlBQUksRUFBQyxPQUFPO0FBQ1osaUJBQVMsRUFBRSxPQUFPLENBQUMsNEJBQTRCLENBQUM7T0FDakQ7QUFDRCxnQkFBVSxFQUFFO0FBQ1YsWUFBSSxFQUFDLE9BQU87QUFDWixpQkFBUyxFQUFFLE9BQU8sQ0FBQyw4QkFBOEIsQ0FBQztPQUNuRDtBQUNELFNBQUcsRUFBRTtBQUNILGlCQUFTLEVBQUUsT0FBTyxDQUFDLDBCQUEwQixDQUFDO09BQy9DO0tBQ0YsQ0FBQyxDQUFBOztBQUVGLFVBQU0sQ0FBQyxLQUFLLENBQUM7QUFDWCxRQUFFLEVBQUUsT0FBTztBQUNYLGFBQU8sRUFBRSxhQUFhO0tBQ3ZCLENBQUMsQ0FBQTs7QUFFRixVQUFNLENBQUMsVUFBVSxDQUFDLFVBQVUsVUFBVSxFQUFFOztBQUV0QyxVQUFJLEtBQUssR0FBRyxZQUFZLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFBO0FBQzdDLFVBQUksVUFBVSxDQUFDLEVBQUUsQ0FBQyxJQUFJLEVBQUU7QUFDdEIsWUFBSSxDQUFDLEtBQUssSUFBSSxLQUFLLEtBQUssSUFBSSxFQUFFO0FBQzVCLG9CQUFVLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxDQUFBO1NBQ25DO09BQ0Y7QUFDRCxVQUFJLFVBQVUsQ0FBQyxFQUFFLENBQUMsS0FBSyxFQUFFO0FBQ3ZCLFlBQUksS0FBSyxFQUFFO0FBQ1Qsb0JBQVUsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUE7U0FDekI7T0FDRjtBQUNELGdCQUFVLENBQUMsSUFBSSxFQUFFLENBQUE7S0FDbEIsQ0FBQyxDQUFBO0dBQ0g7Q0FDRixDQUFBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBzZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDEyLTIwMTMgdGhlIG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzXG4gKiBAbGljZW5zZSBNSVQsIHNlZSBMSUNFTlNFLnR4dCBmb3IgZGV0YWlsc1xuICpcbiAqIEBhdXRob3IgU2NvdHQgQW5kcmV3c1xuICovXG5cbihmdW5jdGlvbiAoZGVmaW5lLCBsb2NhdGlvbikge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIHVuZGVmO1xuXG5cdGRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuXG5cdFx0dmFyIG1peGluLCBvcmlnaW4sIHVybFJFLCBhYnNvbHV0ZVVybFJFLCBmdWxseVF1YWxpZmllZFVybFJFO1xuXG5cdFx0bWl4aW4gPSByZXF1aXJlKCcuL3V0aWwvbWl4aW4nKTtcblxuXHRcdHVybFJFID0gLyhbYS16XVthLXowLTlcXCtcXC1cXC5dKjopXFwvXFwvKFteQF0rQCk/KChbXjpcXC9dKykoOihbMC05XSspKT8pPyhcXC9bXj8jXSopPyhcXD9bXiNdKik/KCNcXFMqKT8vaTtcblx0XHRhYnNvbHV0ZVVybFJFID0gL14oW2Etel1bYS16MC05XFwtXFwrXFwuXSo6XFwvXFwvfFxcLykvaTtcblx0XHRmdWxseVF1YWxpZmllZFVybFJFID0gLyhbYS16XVthLXowLTlcXCtcXC1cXC5dKjopXFwvXFwvKFteQF0rQCk/KChbXjpcXC9dKykoOihbMC05XSspKT8pP1xcLy9pO1xuXG5cdFx0LyoqXG5cdFx0ICogQXBwbHkgcGFyYW1zIHRvIHRoZSB0ZW1wbGF0ZSB0byBjcmVhdGUgYSBVUkwuXG5cdFx0ICpcblx0XHQgKiBQYXJhbWV0ZXJzIHRoYXQgYXJlIG5vdCBhcHBsaWVkIGRpcmVjdGx5IHRvIHRoZSB0ZW1wbGF0ZSwgYXJlIGFwcGVuZGVkXG5cdFx0ICogdG8gdGhlIFVSTCBhcyBxdWVyeSBzdHJpbmcgcGFyYW1ldGVycy5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB0ZW1wbGF0ZSB0aGUgVVJJIHRlbXBsYXRlXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzIHRvIGFwcGx5IHRvIHRoZSB0ZW1wbGF0ZVxuXHRcdCAqIEByZXR1cm4ge3N0cmluZ30gdGhlIHJlc3VsdGluZyBVUkxcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBidWlsZFVybCh0ZW1wbGF0ZSwgcGFyYW1zKSB7XG5cdFx0XHQvLyBpbnRlcm5hbCBidWlsZGVyIHRvIGNvbnZlcnQgdGVtcGxhdGUgd2l0aCBwYXJhbXMuXG5cdFx0XHR2YXIgdXJsLCBuYW1lLCBxdWVyeVN0cmluZ1BhcmFtcywgcmU7XG5cblx0XHRcdHVybCA9IHRlbXBsYXRlO1xuXHRcdFx0cXVlcnlTdHJpbmdQYXJhbXMgPSB7fTtcblxuXHRcdFx0aWYgKHBhcmFtcykge1xuXHRcdFx0XHRmb3IgKG5hbWUgaW4gcGFyYW1zKSB7XG5cdFx0XHRcdFx0Lypqc2hpbnQgZm9yaW46ZmFsc2UgKi9cblx0XHRcdFx0XHRyZSA9IG5ldyBSZWdFeHAoJ1xcXFx7JyArIG5hbWUgKyAnXFxcXH0nKTtcblx0XHRcdFx0XHRpZiAocmUudGVzdCh1cmwpKSB7XG5cdFx0XHRcdFx0XHR1cmwgPSB1cmwucmVwbGFjZShyZSwgZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtc1tuYW1lXSksICdnJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0cXVlcnlTdHJpbmdQYXJhbXNbbmFtZV0gPSBwYXJhbXNbbmFtZV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAobmFtZSBpbiBxdWVyeVN0cmluZ1BhcmFtcykge1xuXHRcdFx0XHRcdHVybCArPSB1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJztcblx0XHRcdFx0XHR1cmwgKz0gZW5jb2RlVVJJQ29tcG9uZW50KG5hbWUpO1xuXHRcdFx0XHRcdGlmIChxdWVyeVN0cmluZ1BhcmFtc1tuYW1lXSAhPT0gbnVsbCAmJiBxdWVyeVN0cmluZ1BhcmFtc1tuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHR1cmwgKz0gJz0nO1xuXHRcdFx0XHRcdFx0dXJsICs9IGVuY29kZVVSSUNvbXBvbmVudChxdWVyeVN0cmluZ1BhcmFtc1tuYW1lXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdXJsO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyLCB0ZXN0KSB7XG5cdFx0XHRyZXR1cm4gc3RyLmluZGV4T2YodGVzdCkgPT09IDA7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlIGEgbmV3IFVSTCBCdWlsZGVyXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ3xVcmxCdWlsZGVyfSB0ZW1wbGF0ZSB0aGUgYmFzZSB0ZW1wbGF0ZSB0byBidWlsZCBmcm9tLCBtYXkgYmUgYW5vdGhlciBVcmxCdWlsZGVyXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdIGJhc2UgcGFyYW1ldGVyc1xuXHRcdCAqIEBjb25zdHJ1Y3RvclxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIFVybEJ1aWxkZXIodGVtcGxhdGUsIHBhcmFtcykge1xuXHRcdFx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFVybEJ1aWxkZXIpKSB7XG5cdFx0XHRcdC8vIGludm9rZSBhcyBhIGNvbnN0cnVjdG9yXG5cdFx0XHRcdHJldHVybiBuZXcgVXJsQnVpbGRlcih0ZW1wbGF0ZSwgcGFyYW1zKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRlbXBsYXRlIGluc3RhbmNlb2YgVXJsQnVpbGRlcikge1xuXHRcdFx0XHR0aGlzLl90ZW1wbGF0ZSA9IHRlbXBsYXRlLnRlbXBsYXRlO1xuXHRcdFx0XHR0aGlzLl9wYXJhbXMgPSBtaXhpbih7fSwgdGhpcy5fcGFyYW1zLCBwYXJhbXMpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHRoaXMuX3RlbXBsYXRlID0gKHRlbXBsYXRlIHx8ICcnKS50b1N0cmluZygpO1xuXHRcdFx0XHR0aGlzLl9wYXJhbXMgPSBwYXJhbXMgfHwge307XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0VXJsQnVpbGRlci5wcm90b3R5cGUgPSB7XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQ3JlYXRlIGEgbmV3IFVybEJ1aWxkZXIgaW5zdGFuY2UgdGhhdCBleHRlbmRzIHRoZSBjdXJyZW50IGJ1aWxkZXIuXG5cdFx0XHQgKiBUaGUgY3VycmVudCBidWlsZGVyIGlzIHVubW9kaWZpZWQuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IFt0ZW1wbGF0ZV0gVVJMIHRlbXBsYXRlIHRvIGFwcGVuZCB0byB0aGUgY3VycmVudCB0ZW1wbGF0ZVxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdIHBhcmFtcyB0byBjb21iaW5lIHdpdGggY3VycmVudCBwYXJhbXMuICBOZXcgcGFyYW1zIG92ZXJyaWRlIGV4aXN0aW5nIHBhcmFtc1xuXHRcdFx0ICogQHJldHVybiB7VXJsQnVpbGRlcn0gdGhlIG5ldyBidWlsZGVyXG5cdFx0XHQgKi9cblx0XHRcdGFwcGVuZDogZnVuY3Rpb24gKHRlbXBsYXRlLCAgcGFyYW1zKSB7XG5cdFx0XHRcdC8vIFRPRE8gY29uc2lkZXIgcXVlcnkgc3RyaW5ncyBhbmQgZnJhZ21lbnRzXG5cdFx0XHRcdHJldHVybiBuZXcgVXJsQnVpbGRlcih0aGlzLl90ZW1wbGF0ZSArIHRlbXBsYXRlLCBtaXhpbih7fSwgdGhpcy5fcGFyYW1zLCBwYXJhbXMpKTtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQ3JlYXRlIGEgbmV3IFVybEJ1aWxkZXIgd2l0aCBhIGZ1bGx5IHF1YWxpZmllZCBVUkwgYmFzZWQgb24gdGhlXG5cdFx0XHQgKiB3aW5kb3cncyBsb2NhdGlvbiBvciBiYXNlIGhyZWYgYW5kIHRoZSBjdXJyZW50IHRlbXBsYXRlcyByZWxhdGl2ZSBVUkwuXG5cdFx0XHQgKlxuXHRcdFx0ICogUGF0aCB2YXJpYWJsZXMgYXJlIHByZXNlcnZlZC5cblx0XHRcdCAqXG5cdFx0XHQgKiAqQnJvd3NlciBvbmx5KlxuXHRcdFx0ICpcblx0XHRcdCAqIEByZXR1cm4ge1VybEJ1aWxkZXJ9IHRoZSBmdWxseSBxdWFsaWZpZWQgVVJMIHRlbXBsYXRlXG5cdFx0XHQgKi9cblx0XHRcdGZ1bGx5UXVhbGlmeTogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAoIWxvY2F0aW9uKSB7IHJldHVybiB0aGlzOyB9XG5cdFx0XHRcdGlmICh0aGlzLmlzRnVsbHlRdWFsaWZpZWQoKSkgeyByZXR1cm4gdGhpczsgfVxuXG5cdFx0XHRcdHZhciB0ZW1wbGF0ZSA9IHRoaXMuX3RlbXBsYXRlO1xuXG5cdFx0XHRcdGlmIChzdGFydHNXaXRoKHRlbXBsYXRlLCAnLy8nKSkge1xuXHRcdFx0XHRcdHRlbXBsYXRlID0gb3JpZ2luLnByb3RvY29sICsgdGVtcGxhdGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoc3RhcnRzV2l0aCh0ZW1wbGF0ZSwgJy8nKSkge1xuXHRcdFx0XHRcdHRlbXBsYXRlID0gb3JpZ2luLm9yaWdpbiArIHRlbXBsYXRlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKCF0aGlzLmlzQWJzb2x1dGUoKSkge1xuXHRcdFx0XHRcdHRlbXBsYXRlID0gb3JpZ2luLm9yaWdpbiArIG9yaWdpbi5wYXRobmFtZS5zdWJzdHJpbmcoMCwgb3JpZ2luLnBhdGhuYW1lLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh0ZW1wbGF0ZS5pbmRleE9mKCcvJywgOCkgPT09IC0xKSB7XG5cdFx0XHRcdFx0Ly8gZGVmYXVsdCB0aGUgcGF0aG5hbWUgdG8gJy8nXG5cdFx0XHRcdFx0dGVtcGxhdGUgPSB0ZW1wbGF0ZSArICcvJztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBuZXcgVXJsQnVpbGRlcih0ZW1wbGF0ZSwgdGhpcy5fcGFyYW1zKTtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogVHJ1ZSBpZiB0aGUgVVJMIGlzIGFic29sdXRlXG5cdFx0XHQgKlxuXHRcdFx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0XHRcdCAqL1xuXHRcdFx0aXNBYnNvbHV0ZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gYWJzb2x1dGVVcmxSRS50ZXN0KHRoaXMuYnVpbGQoKSk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFRydWUgaWYgdGhlIFVSTCBpcyBmdWxseSBxdWFsaWZpZWRcblx0XHRcdCAqXG5cdFx0XHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHRcdFx0ICovXG5cdFx0XHRpc0Z1bGx5UXVhbGlmaWVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiBmdWxseVF1YWxpZmllZFVybFJFLnRlc3QodGhpcy5idWlsZCgpKTtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogVHJ1ZSBpZiB0aGUgVVJMIGlzIGNyb3NzIG9yaWdpbi4gVGhlIHByb3RvY29sLCBob3N0IGFuZCBwb3J0IG11c3Qgbm90IGJlXG5cdFx0XHQgKiB0aGUgc2FtZSBpbiBvcmRlciB0byBiZSBjcm9zcyBvcmlnaW4sXG5cdFx0XHQgKlxuXHRcdFx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0XHRcdCAqL1xuXHRcdFx0aXNDcm9zc09yaWdpbjogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAoIW9yaWdpbikge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciB1cmwgPSB0aGlzLnBhcnRzKCk7XG5cdFx0XHRcdHJldHVybiB1cmwucHJvdG9jb2wgIT09IG9yaWdpbi5wcm90b2NvbCB8fFxuXHRcdFx0XHQgICAgICAgdXJsLmhvc3RuYW1lICE9PSBvcmlnaW4uaG9zdG5hbWUgfHxcblx0XHRcdFx0ICAgICAgIHVybC5wb3J0ICE9PSBvcmlnaW4ucG9ydDtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU3BsaXQgYSBVUkwgaW50byBpdHMgY29uc2l0dWVudCBwYXJ0cyBmb2xsb3dpbmcgdGhlIG5hbWluZyBjb252ZW50aW9uIG9mXG5cdFx0XHQgKiAnd2luZG93LmxvY2F0aW9uJy4gT25lIGRpZmZlcmVuY2UgaXMgdGhhdCB0aGUgcG9ydCB3aWxsIGNvbnRhaW4gdGhlXG5cdFx0XHQgKiBwcm90b2NvbCBkZWZhdWx0IGlmIG5vdCBzcGVjaWZpZWQuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0RPTS93aW5kb3cubG9jYXRpb25cblx0XHRcdCAqXG5cdFx0XHQgKiBAcmV0dXJucyB7T2JqZWN0fSBhICd3aW5kb3cubG9jYXRpb24nLWxpa2Ugb2JqZWN0XG5cdFx0XHQgKi9cblx0XHRcdHBhcnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdC8qanNoaW50IG1heGNvbXBsZXhpdHk6MjAgKi9cblx0XHRcdFx0dmFyIHVybCwgcGFydHM7XG5cdFx0XHRcdHVybCA9IHRoaXMuZnVsbHlRdWFsaWZ5KCkuYnVpbGQoKS5tYXRjaCh1cmxSRSk7XG5cdFx0XHRcdHBhcnRzID0ge1xuXHRcdFx0XHRcdGhyZWY6IHVybFswXSxcblx0XHRcdFx0XHRwcm90b2NvbDogdXJsWzFdLFxuXHRcdFx0XHRcdGhvc3Q6IHVybFszXSB8fCAnJyxcblx0XHRcdFx0XHRob3N0bmFtZTogdXJsWzRdIHx8ICcnLFxuXHRcdFx0XHRcdHBvcnQ6IHVybFs2XSxcblx0XHRcdFx0XHRwYXRobmFtZTogdXJsWzddIHx8ICcnLFxuXHRcdFx0XHRcdHNlYXJjaDogdXJsWzhdIHx8ICcnLFxuXHRcdFx0XHRcdGhhc2g6IHVybFs5XSB8fCAnJ1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRwYXJ0cy5vcmlnaW4gPSBwYXJ0cy5wcm90b2NvbCArICcvLycgKyBwYXJ0cy5ob3N0O1xuXHRcdFx0XHRwYXJ0cy5wb3J0ID0gcGFydHMucG9ydCB8fCAocGFydHMucHJvdG9jb2wgPT09ICdodHRwczonID8gJzQ0MycgOiBwYXJ0cy5wcm90b2NvbCA9PT0gJ2h0dHA6JyA/ICc4MCcgOiAnJyk7XG5cdFx0XHRcdHJldHVybiBwYXJ0cztcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogRXhwYW5kIHRoZSB0ZW1wbGF0ZSByZXBsYWNpbmcgcGF0aCB2YXJpYWJsZXMgd2l0aCBwYXJhbWV0ZXJzXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdIHBhcmFtcyB0byBjb21iaW5lIHdpdGggY3VycmVudCBwYXJhbXMuICBOZXcgcGFyYW1zIG92ZXJyaWRlIGV4aXN0aW5nIHBhcmFtc1xuXHRcdFx0ICogQHJldHVybiB7c3RyaW5nfSB0aGUgZXhwYW5kZWQgVVJMXG5cdFx0XHQgKi9cblx0XHRcdGJ1aWxkOiBmdW5jdGlvbiAocGFyYW1zKSB7XG5cdFx0XHRcdHJldHVybiBidWlsZFVybCh0aGlzLl90ZW1wbGF0ZSwgbWl4aW4oe30sIHRoaXMuX3BhcmFtcywgcGFyYW1zKSk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBzZWUgYnVpbGRcblx0XHRcdCAqL1xuXHRcdFx0dG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuYnVpbGQoKTtcblx0XHRcdH1cblxuXHRcdH07XG5cblx0XHRvcmlnaW4gPSBsb2NhdGlvbiA/IG5ldyBVcmxCdWlsZGVyKGxvY2F0aW9uLmhyZWYpLnBhcnRzKCkgOiB1bmRlZjtcblxuXHRcdHJldHVybiBVcmxCdWlsZGVyO1xuXHR9KTtcblxufShcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24gKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUpOyB9LFxuXHR0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5sb2NhdGlvbiA6IHZvaWQgMFxuXHQvLyBCb2lsZXJwbGF0ZSBmb3IgQU1EIGFuZCBOb2RlXG4pKTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNCB0aGUgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnNcbiAqIEBsaWNlbnNlIE1JVCwgc2VlIExJQ0VOU0UudHh0IGZvciBkZXRhaWxzXG4gKlxuICogQGF1dGhvciBTY290dCBBbmRyZXdzXG4gKi9cblxuKGZ1bmN0aW9uIChkZWZpbmUpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdGRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuXG5cdFx0dmFyIHJlc3QgPSByZXF1aXJlKCcuL2NsaWVudC9kZWZhdWx0JyksXG5cdFx0ICAgIGJyb3dzZXIgPSByZXF1aXJlKCcuL2NsaWVudC94aHInKTtcblxuXHRcdHJlc3Quc2V0UGxhdGZvcm1EZWZhdWx0Q2xpZW50KGJyb3dzZXIpO1xuXG5cdFx0cmV0dXJuIHJlc3Q7XG5cblx0fSk7XG5cbn0oXG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uIChmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKTsgfVxuXHQvLyBCb2lsZXJwbGF0ZSBmb3IgQU1EIGFuZCBOb2RlXG4pKTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNCB0aGUgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnNcbiAqIEBsaWNlbnNlIE1JVCwgc2VlIExJQ0VOU0UudHh0IGZvciBkZXRhaWxzXG4gKlxuICogQGF1dGhvciBTY290dCBBbmRyZXdzXG4gKi9cblxuKGZ1bmN0aW9uIChkZWZpbmUpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdGRlZmluZShmdW5jdGlvbiAoLyogcmVxdWlyZSAqLykge1xuXG5cdFx0LyoqXG5cdFx0ICogQWRkIGNvbW1vbiBoZWxwZXIgbWV0aG9kcyB0byBhIGNsaWVudCBpbXBsXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBpbXBsIHRoZSBjbGllbnQgaW1wbGVtZW50YXRpb25cblx0XHQgKiBAcGFyYW0ge0NsaWVudH0gW3RhcmdldF0gdGFyZ2V0IG9mIHRoaXMgY2xpZW50LCB1c2VkIHdoZW4gd3JhcHBpbmcgb3RoZXIgY2xpZW50c1xuXHRcdCAqIEByZXR1cm5zIHtDbGllbnR9IHRoZSBjbGllbnQgaW1wbCB3aXRoIGFkZGl0aW9uYWwgbWV0aG9kc1xuXHRcdCAqL1xuXHRcdHJldHVybiBmdW5jdGlvbiBjbGllbnQoaW1wbCwgdGFyZ2V0KSB7XG5cblx0XHRcdGlmICh0YXJnZXQpIHtcblxuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogQHJldHVybnMge0NsaWVudH0gdGhlIHRhcmdldCBjbGllbnRcblx0XHRcdFx0ICovXG5cdFx0XHRcdGltcGwuc2tpcCA9IGZ1bmN0aW9uIHNraXAoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRhcmdldDtcblx0XHRcdFx0fTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEFsbG93IGEgY2xpZW50IHRvIGVhc2lseSBiZSB3cmFwcGVkIGJ5IGFuIGludGVyY2VwdG9yXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtJbnRlcmNlcHRvcn0gaW50ZXJjZXB0b3IgdGhlIGludGVyY2VwdG9yIHRvIHdyYXAgdGhpcyBjbGllbnQgd2l0aFxuXHRcdFx0ICogQHBhcmFtIFtjb25maWddIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBpbnRlcmNlcHRvclxuXHRcdFx0ICogQHJldHVybnMge0NsaWVudH0gdGhlIG5ld2x5IHdyYXBwZWQgY2xpZW50XG5cdFx0XHQgKi9cblx0XHRcdGltcGwud3JhcCA9IGZ1bmN0aW9uIHdyYXAoaW50ZXJjZXB0b3IsIGNvbmZpZykge1xuXHRcdFx0XHRyZXR1cm4gaW50ZXJjZXB0b3IoaW1wbCwgY29uZmlnKTtcblx0XHRcdH07XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQGRlcHJlY2F0ZWRcblx0XHRcdCAqL1xuXHRcdFx0aW1wbC5jaGFpbiA9IGZ1bmN0aW9uIGNoYWluKCkge1xuXHRcdFx0XHRpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coJ3Jlc3QuanM6IGNsaWVudC5jaGFpbigpIGlzIGRlcHJlY2F0ZWQsIHVzZSBjbGllbnQud3JhcCgpIGluc3RlYWQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBpbXBsLndyYXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdH07XG5cblx0XHRcdHJldHVybiBpbXBsO1xuXG5cdFx0fTtcblxuXHR9KTtcblxufShcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24gKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUpOyB9XG5cdC8vIEJvaWxlcnBsYXRlIGZvciBBTUQgYW5kIE5vZGVcbikpO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE0IHRoZSBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9yc1xuICogQGxpY2Vuc2UgTUlULCBzZWUgTElDRU5TRS50eHQgZm9yIGRldGFpbHNcbiAqXG4gKiBAYXV0aG9yIFNjb3R0IEFuZHJld3NcbiAqL1xuXG4oZnVuY3Rpb24gKGRlZmluZSkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIHVuZGVmO1xuXG5cdGRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuXG5cdFx0LyoqXG5cdFx0ICogUGxhaW4gSlMgT2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyB0aGF0IHJlcHJlc2VudCBhbiBIVFRQIHJlcXVlc3QuXG5cdFx0ICpcblx0XHQgKiBEZXBlbmRpbmcgb24gdGhlIGNhcGFiaWxpdGllcyBvZiB0aGUgdW5kZXJseWluZyBjbGllbnQsIGEgcmVxdWVzdFxuXHRcdCAqIG1heSBiZSBjYW5jZWxhYmxlLiBJZiBhIHJlcXVlc3QgbWF5IGJlIGNhbmNlbGVkLCB0aGUgY2xpZW50IHdpbGwgYWRkXG5cdFx0ICogYSBjYW5jZWxlZCBmbGFnIGFuZCBjYW5jZWwgZnVuY3Rpb24gdG8gdGhlIHJlcXVlc3Qgb2JqZWN0LiBDYW5jZWxpbmdcblx0XHQgKiB0aGUgcmVxdWVzdCB3aWxsIHB1dCB0aGUgcmVzcG9uc2UgaW50byBhbiBlcnJvciBzdGF0ZS5cblx0XHQgKlxuXHRcdCAqIEBmaWVsZCB7c3RyaW5nfSBbbWV0aG9kPSdHRVQnXSBIVFRQIG1ldGhvZCwgY29tbW9ubHkgR0VULCBQT1NULCBQVVQsIERFTEVURSBvciBIRUFEXG5cdFx0ICogQGZpZWxkIHtzdHJpbmd8VXJsQnVpbGRlcn0gW3BhdGg9JyddIHBhdGggdGVtcGxhdGUgd2l0aCBvcHRpb25hbCBwYXRoIHZhcmlhYmxlc1xuXHRcdCAqIEBmaWVsZCB7T2JqZWN0fSBbcGFyYW1zXSBwYXJhbWV0ZXJzIGZvciB0aGUgcGF0aCB0ZW1wbGF0ZSBhbmQgcXVlcnkgc3RyaW5nXG5cdFx0ICogQGZpZWxkIHtPYmplY3R9IFtoZWFkZXJzXSBjdXN0b20gSFRUUCBoZWFkZXJzIHRvIHNlbmQsIGluIGFkZGl0aW9uIHRvIHRoZSBjbGllbnRzIGRlZmF1bHQgaGVhZGVyc1xuXHRcdCAqIEBmaWVsZCBbZW50aXR5XSB0aGUgSFRUUCBlbnRpdHksIGNvbW1vbiBmb3IgUE9TVCBvciBQVVQgcmVxdWVzdHNcblx0XHQgKiBAZmllbGQge2Jvb2xlYW59IFtjYW5jZWxlZF0gdHJ1ZSBpZiB0aGUgcmVxdWVzdCBoYXMgYmVlbiBjYW5jZWxlZCwgc2V0IGJ5IHRoZSBjbGllbnRcblx0XHQgKiBAZmllbGQge0Z1bmN0aW9ufSBbY2FuY2VsXSBjYW5jZWxzIHRoZSByZXF1ZXN0IGlmIGludm9rZWQsIHByb3ZpZGVkIGJ5IHRoZSBjbGllbnRcblx0XHQgKiBAZmllbGQge0NsaWVudH0gW29yaWdpbmF0b3JdIHRoZSBjbGllbnQgdGhhdCBmaXJzdCBoYW5kbGVkIHRoaXMgcmVxdWVzdCwgcHJvdmlkZWQgYnkgdGhlIGludGVyY2VwdG9yXG5cdFx0ICpcblx0XHQgKiBAY2xhc3MgUmVxdWVzdFxuXHRcdCAqL1xuXG5cdFx0LyoqXG5cdFx0ICogUGxhaW4gSlMgT2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyB0aGF0IHJlcHJlc2VudCBhbiBIVFRQIHJlc3BvbnNlXG5cdFx0ICpcblx0XHQgKiBAZmllbGQge09iamVjdH0gW3JlcXVlc3RdIHRoZSByZXF1ZXN0IG9iamVjdCBhcyByZWNlaXZlZCBieSB0aGUgcm9vdCBjbGllbnRcblx0XHQgKiBAZmllbGQge09iamVjdH0gW3Jhd10gdGhlIHVuZGVybHlpbmcgcmVxdWVzdCBvYmplY3QsIGxpa2UgWG1sSHR0cFJlcXVlc3QgaW4gYSBicm93c2VyXG5cdFx0ICogQGZpZWxkIHtudW1iZXJ9IFtzdGF0dXMuY29kZV0gc3RhdHVzIGNvZGUgb2YgdGhlIHJlc3BvbnNlIChpLmUuIDIwMCwgNDA0KVxuXHRcdCAqIEBmaWVsZCB7c3RyaW5nfSBbc3RhdHVzLnRleHRdIHN0YXR1cyBwaHJhc2Ugb2YgdGhlIHJlc3BvbnNlXG5cdFx0ICogQGZpZWxkIHtPYmplY3RdIFtoZWFkZXJzXSByZXNwb25zZSBoZWFkZXJzIGhhc2ggb2Ygbm9ybWFsaXplZCBuYW1lLCB2YWx1ZSBwYWlyc1xuXHRcdCAqIEBmaWVsZCBbZW50aXR5XSB0aGUgcmVzcG9uc2UgYm9keVxuXHRcdCAqXG5cdFx0ICogQGNsYXNzIFJlc3BvbnNlXG5cdFx0ICovXG5cblx0XHQvKipcblx0XHQgKiBIVFRQIGNsaWVudCBwYXJ0aWN1bGFybHkgc3VpdGVkIGZvciBSRVNUZnVsIG9wZXJhdGlvbnMuXG5cdFx0ICpcblx0XHQgKiBAZmllbGQge2Z1bmN0aW9ufSB3cmFwIHdyYXBzIHRoaXMgY2xpZW50IHdpdGggYSBuZXcgaW50ZXJjZXB0b3IgcmV0dXJuaW5nIHRoZSB3cmFwcGVkIGNsaWVudFxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtSZXF1ZXN0fSB0aGUgSFRUUCByZXF1ZXN0XG5cdFx0ICogQHJldHVybnMge1Jlc3BvbnNlUHJvbWlzZTxSZXNwb25zZT59IGEgcHJvbWlzZSB0aGUgcmVzb2x2ZXMgdG8gdGhlIEhUVFAgcmVzcG9uc2Vcblx0XHQgKlxuXHRcdCAqIEBjbGFzcyBDbGllbnRcblx0XHQgKi9cblxuXHRcdCAvKipcblx0XHQgICogRXh0ZW5kZWQgd2hlbi5qcyBQcm9taXNlcy9BKyBwcm9taXNlIHdpdGggSFRUUCBzcGVjaWZpYyBoZWxwZXJzXG5cdFx0ICAqcVxuXHRcdCAgKiBAbWV0aG9kIGVudGl0eSBwcm9taXNlIGZvciB0aGUgSFRUUCBlbnRpdHlcblx0XHQgICogQG1ldGhvZCBzdGF0dXMgcHJvbWlzZSBmb3IgdGhlIEhUVFAgc3RhdHVzIGNvZGVcblx0XHQgICogQG1ldGhvZCBoZWFkZXJzIHByb21pc2UgZm9yIHRoZSBIVFRQIHJlc3BvbnNlIGhlYWRlcnNcblx0XHQgICogQG1ldGhvZCBoZWFkZXIgcHJvbWlzZSBmb3IgYSBzcGVjaWZpYyBIVFRQIHJlc3BvbnNlIGhlYWRlclxuXHRcdCAgKlxuXHRcdCAgKiBAY2xhc3MgUmVzcG9uc2VQcm9taXNlXG5cdFx0ICAqIEBleHRlbmRzIFByb21pc2Vcblx0XHQgICovXG5cblx0XHR2YXIgY2xpZW50LCB0YXJnZXQsIHBsYXRmb3JtRGVmYXVsdDtcblxuXHRcdGNsaWVudCA9IHJlcXVpcmUoJy4uL2NsaWVudCcpO1xuXG5cdFx0LyoqXG5cdFx0ICogTWFrZSBhIHJlcXVlc3Qgd2l0aCB0aGUgZGVmYXVsdCBjbGllbnRcblx0XHQgKiBAcGFyYW0ge1JlcXVlc3R9IHRoZSBIVFRQIHJlcXVlc3Rcblx0XHQgKiBAcmV0dXJucyB7UHJvbWlzZTxSZXNwb25zZT59IGEgcHJvbWlzZSB0aGUgcmVzb2x2ZXMgdG8gdGhlIEhUVFAgcmVzcG9uc2Vcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBkZWZhdWx0Q2xpZW50KCkge1xuXHRcdFx0cmV0dXJuIHRhcmdldC5hcHBseSh1bmRlZiwgYXJndW1lbnRzKTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBDaGFuZ2UgdGhlIGRlZmF1bHQgY2xpZW50XG5cdFx0ICogQHBhcmFtIHtDbGllbnR9IGNsaWVudCB0aGUgbmV3IGRlZmF1bHQgY2xpZW50XG5cdFx0ICovXG5cdFx0ZGVmYXVsdENsaWVudC5zZXREZWZhdWx0Q2xpZW50ID0gZnVuY3Rpb24gc2V0RGVmYXVsdENsaWVudChjbGllbnQpIHtcblx0XHRcdHRhcmdldCA9IGNsaWVudDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogT2J0YWluIGEgZGlyZWN0IHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBkZWZhdWx0IGNsaWVudFxuXHRcdCAqIEByZXR1cm5zIHtDbGllbnR9IHRoZSBkZWZhdWx0IGNsaWVudFxuXHRcdCAqL1xuXHRcdGRlZmF1bHRDbGllbnQuZ2V0RGVmYXVsdENsaWVudCA9IGZ1bmN0aW9uIGdldERlZmF1bHRDbGllbnQoKSB7XG5cdFx0XHRyZXR1cm4gdGFyZ2V0O1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBSZXNldCB0aGUgZGVmYXVsdCBjbGllbnQgdG8gdGhlIHBsYXRmb3JtIGRlZmF1bHRcblx0XHQgKi9cblx0XHRkZWZhdWx0Q2xpZW50LnJlc2V0RGVmYXVsdENsaWVudCA9IGZ1bmN0aW9uIHJlc2V0RGVmYXVsdENsaWVudCgpIHtcblx0XHRcdHRhcmdldCA9IHBsYXRmb3JtRGVmYXVsdDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRkZWZhdWx0Q2xpZW50LnNldFBsYXRmb3JtRGVmYXVsdENsaWVudCA9IGZ1bmN0aW9uIHNldFBsYXRmb3JtRGVmYXVsdENsaWVudChjbGllbnQpIHtcblx0XHRcdGlmIChwbGF0Zm9ybURlZmF1bHQpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcmVkZWZpbmUgcGxhdGZvcm1EZWZhdWx0Q2xpZW50Jyk7XG5cdFx0XHR9XG5cdFx0XHR0YXJnZXQgPSBwbGF0Zm9ybURlZmF1bHQgPSBjbGllbnQ7XG5cdFx0fTtcblxuXHRcdHJldHVybiBjbGllbnQoZGVmYXVsdENsaWVudCk7XG5cblx0fSk7XG5cbn0oXG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uIChmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKTsgfVxuXHQvLyBCb2lsZXJwbGF0ZSBmb3IgQU1EIGFuZCBOb2RlXG4pKTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE0IHRoZSBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9yc1xuICogQGxpY2Vuc2UgTUlULCBzZWUgTElDRU5TRS50eHQgZm9yIGRldGFpbHNcbiAqXG4gKiBAYXV0aG9yIFNjb3R0IEFuZHJld3NcbiAqL1xuXG4oZnVuY3Rpb24gKGRlZmluZSwgZ2xvYmFsKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHRkZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUpIHtcblxuXHRcdHZhciB3aGVuLCBVcmxCdWlsZGVyLCBub3JtYWxpemVIZWFkZXJOYW1lLCByZXNwb25zZVByb21pc2UsIGNsaWVudCwgaGVhZGVyU3BsaXRSRTtcblxuXHRcdHdoZW4gPSByZXF1aXJlKCd3aGVuJyk7XG5cdFx0VXJsQnVpbGRlciA9IHJlcXVpcmUoJy4uL1VybEJ1aWxkZXInKTtcblx0XHRub3JtYWxpemVIZWFkZXJOYW1lID0gcmVxdWlyZSgnLi4vdXRpbC9ub3JtYWxpemVIZWFkZXJOYW1lJyk7XG5cdFx0cmVzcG9uc2VQcm9taXNlID0gcmVxdWlyZSgnLi4vdXRpbC9yZXNwb25zZVByb21pc2UnKTtcblx0XHRjbGllbnQgPSByZXF1aXJlKCcuLi9jbGllbnQnKTtcblxuXHRcdC8vIGFjY29yZGluZyB0byB0aGUgc3BlYywgdGhlIGxpbmUgYnJlYWsgaXMgJ1xcclxcbicsIGJ1dCBkb2Vzbid0IGhvbGQgdHJ1ZSBpbiBwcmFjdGljZVxuXHRcdGhlYWRlclNwbGl0UkUgPSAvW1xccnxcXG5dKy87XG5cblx0XHRmdW5jdGlvbiBwYXJzZUhlYWRlcnMocmF3KSB7XG5cdFx0XHQvLyBOb3RlOiBTZXQtQ29va2llIHdpbGwgYmUgcmVtb3ZlZCBieSB0aGUgYnJvd3NlclxuXHRcdFx0dmFyIGhlYWRlcnMgPSB7fTtcblxuXHRcdFx0aWYgKCFyYXcpIHsgcmV0dXJuIGhlYWRlcnM7IH1cblxuXHRcdFx0cmF3LnRyaW0oKS5zcGxpdChoZWFkZXJTcGxpdFJFKS5mb3JFYWNoKGZ1bmN0aW9uIChoZWFkZXIpIHtcblx0XHRcdFx0dmFyIGJvdW5kYXJ5LCBuYW1lLCB2YWx1ZTtcblx0XHRcdFx0Ym91bmRhcnkgPSBoZWFkZXIuaW5kZXhPZignOicpO1xuXHRcdFx0XHRuYW1lID0gbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXIuc3Vic3RyaW5nKDAsIGJvdW5kYXJ5KS50cmltKCkpO1xuXHRcdFx0XHR2YWx1ZSA9IGhlYWRlci5zdWJzdHJpbmcoYm91bmRhcnkgKyAxKS50cmltKCk7XG5cdFx0XHRcdGlmIChoZWFkZXJzW25hbWVdKSB7XG5cdFx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoaGVhZGVyc1tuYW1lXSkpIHtcblx0XHRcdFx0XHRcdC8vIGFkZCB0byBhbiBleGlzdGluZyBhcnJheVxuXHRcdFx0XHRcdFx0aGVhZGVyc1tuYW1lXS5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBjb252ZXJ0IHNpbmdsZSB2YWx1ZSB0byBhcnJheVxuXHRcdFx0XHRcdFx0aGVhZGVyc1tuYW1lXSA9IFtoZWFkZXJzW25hbWVdLCB2YWx1ZV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdC8vIG5ldywgc2luZ2xlIHZhbHVlXG5cdFx0XHRcdFx0aGVhZGVyc1tuYW1lXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuIGhlYWRlcnM7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc2FmZU1peGluKHRhcmdldCwgc291cmNlKSB7XG5cdFx0XHRPYmplY3Qua2V5cyhzb3VyY2UgfHwge30pLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcblx0XHRcdFx0Ly8gbWFrZSBzdXJlIHRoZSBwcm9wZXJ0eSBhbHJlYWR5IGV4aXN0cyBhc1xuXHRcdFx0XHQvLyBJRSA2IHdpbGwgYmxvdyB1cCBpZiB3ZSBhZGQgYSBuZXcgcHJvcFxuXHRcdFx0XHRpZiAoc291cmNlLmhhc093blByb3BlcnR5KHByb3ApICYmIHByb3AgaW4gdGFyZ2V0KSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRcdC8vIGlnbm9yZSwgZXhwZWN0ZWQgZm9yIHNvbWUgcHJvcGVydGllcyBhdCBzb21lIHBvaW50cyBpbiB0aGUgcmVxdWVzdCBsaWZlY3ljbGVcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRyZXR1cm4gdGFyZ2V0O1xuXHRcdH1cblxuXHRcdHJldHVybiBjbGllbnQoZnVuY3Rpb24geGhyKHJlcXVlc3QpIHtcblx0XHRcdHJldHVybiByZXNwb25zZVByb21pc2UucHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHRcdC8qanNoaW50IG1heGNvbXBsZXhpdHk6MjAgKi9cblxuXHRcdFx0XHR2YXIgY2xpZW50LCBtZXRob2QsIHVybCwgaGVhZGVycywgZW50aXR5LCBoZWFkZXJOYW1lLCByZXNwb25zZSwgWE1MSHR0cFJlcXVlc3Q7XG5cblx0XHRcdFx0cmVxdWVzdCA9IHR5cGVvZiByZXF1ZXN0ID09PSAnc3RyaW5nJyA/IHsgcGF0aDogcmVxdWVzdCB9IDogcmVxdWVzdCB8fCB7fTtcblx0XHRcdFx0cmVzcG9uc2UgPSB7IHJlcXVlc3Q6IHJlcXVlc3QgfTtcblxuXHRcdFx0XHRpZiAocmVxdWVzdC5jYW5jZWxlZCkge1xuXHRcdFx0XHRcdHJlc3BvbnNlLmVycm9yID0gJ3ByZWNhbmNlbGVkJztcblx0XHRcdFx0XHRyZWplY3QocmVzcG9uc2UpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGVudGl0eSA9IHJlcXVlc3QuZW50aXR5O1xuXHRcdFx0XHRyZXF1ZXN0Lm1ldGhvZCA9IHJlcXVlc3QubWV0aG9kIHx8IChlbnRpdHkgPyAnUE9TVCcgOiAnR0VUJyk7XG5cdFx0XHRcdG1ldGhvZCA9IHJlcXVlc3QubWV0aG9kO1xuXHRcdFx0XHR1cmwgPSByZXNwb25zZS51cmwgPSBuZXcgVXJsQnVpbGRlcihyZXF1ZXN0LnBhdGggfHwgJycsIHJlcXVlc3QucGFyYW1zKS5idWlsZCgpO1xuXG5cdFx0XHRcdFhNTEh0dHBSZXF1ZXN0ID0gcmVxdWVzdC5lbmdpbmUgfHwgZ2xvYmFsLlhNTEh0dHBSZXF1ZXN0O1xuXHRcdFx0XHRpZiAoIVhNTEh0dHBSZXF1ZXN0KSB7XG5cdFx0XHRcdFx0cmVqZWN0KHsgcmVxdWVzdDogcmVxdWVzdCwgdXJsOiB1cmwsIGVycm9yOiAneGhyLW5vdC1hdmFpbGFibGUnIH0pO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Y2xpZW50ID0gcmVzcG9uc2UucmF3ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cblx0XHRcdFx0XHQvLyBtaXhpbiBleHRyYSByZXF1ZXN0IHByb3BlcnRpZXMgYmVmb3JlIGFuZCBhZnRlciBvcGVuaW5nIHRoZSByZXF1ZXN0IGFzIHNvbWUgcHJvcGVydGllcyByZXF1aXJlIGJlaW5nIHNldCBhdCBkaWZmZXJlbnQgcGhhc2VzIG9mIHRoZSByZXF1ZXN0XG5cdFx0XHRcdFx0c2FmZU1peGluKGNsaWVudCwgcmVxdWVzdC5taXhpbik7XG5cdFx0XHRcdFx0Y2xpZW50Lm9wZW4obWV0aG9kLCB1cmwsIHRydWUpO1xuXHRcdFx0XHRcdHNhZmVNaXhpbihjbGllbnQsIHJlcXVlc3QubWl4aW4pO1xuXG5cdFx0XHRcdFx0aGVhZGVycyA9IHJlcXVlc3QuaGVhZGVycztcblx0XHRcdFx0XHRmb3IgKGhlYWRlck5hbWUgaW4gaGVhZGVycykge1xuXHRcdFx0XHRcdFx0Lypqc2hpbnQgZm9yaW46ZmFsc2UgKi9cblx0XHRcdFx0XHRcdGlmIChoZWFkZXJOYW1lID09PSAnQ29udGVudC1UeXBlJyAmJiBoZWFkZXJzW2hlYWRlck5hbWVdID09PSAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScpIHtcblx0XHRcdFx0XHRcdFx0Ly8gWE1MSHR0cFJlcXVlc3QgZ2VuZXJhdGVzIGl0cyBvd24gQ29udGVudC1UeXBlIGhlYWRlciB3aXRoIHRoZVxuXHRcdFx0XHRcdFx0XHQvLyBhcHByb3ByaWF0ZSBtdWx0aXBhcnQgYm91bmRhcnkgd2hlbiBzZW5kaW5nIG11bHRpcGFydC9mb3JtLWRhdGEuXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRjbGllbnQuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXJOYW1lLCBoZWFkZXJzW2hlYWRlck5hbWVdKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXF1ZXN0LmNhbmNlbGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0cmVxdWVzdC5jYW5jZWwgPSBmdW5jdGlvbiBjYW5jZWwoKSB7XG5cdFx0XHRcdFx0XHRyZXF1ZXN0LmNhbmNlbGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGNsaWVudC5hYm9ydCgpO1xuXHRcdFx0XHRcdFx0cmVqZWN0KHJlc3BvbnNlKTtcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0Y2xpZW50Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgvKiBlICovKSB7XG5cdFx0XHRcdFx0XHRpZiAocmVxdWVzdC5jYW5jZWxlZCkgeyByZXR1cm47IH1cblx0XHRcdFx0XHRcdGlmIChjbGllbnQucmVhZHlTdGF0ZSA9PT0gKFhNTEh0dHBSZXF1ZXN0LkRPTkUgfHwgNCkpIHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2Uuc3RhdHVzID0ge1xuXHRcdFx0XHRcdFx0XHRcdGNvZGU6IGNsaWVudC5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0dGV4dDogY2xpZW50LnN0YXR1c1RleHRcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UuaGVhZGVycyA9IHBhcnNlSGVhZGVycyhjbGllbnQuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpO1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZS5lbnRpdHkgPSBjbGllbnQucmVzcG9uc2VUZXh0O1xuXG5cdFx0XHRcdFx0XHRcdGlmIChyZXNwb25zZS5zdGF0dXMuY29kZSA+IDApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBjaGVjayBzdGF0dXMgY29kZSBhcyByZWFkeXN0YXRlY2hhbmdlIGZpcmVzIGJlZm9yZSBlcnJvciBldmVudFxuXHRcdFx0XHRcdFx0XHRcdHJlc29sdmUocmVzcG9uc2UpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdC8vIGdpdmUgdGhlIGVycm9yIGNhbGxiYWNrIGEgY2hhbmNlIHRvIGZpcmUgYmVmb3JlIHJlc29sdmluZ1xuXHRcdFx0XHRcdFx0XHRcdC8vIHJlcXVlc3RzIGZvciBmaWxlOi8vIFVSTHMgZG8gbm90IGhhdmUgYSBzdGF0dXMgY29kZVxuXHRcdFx0XHRcdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZShyZXNwb25zZSk7XG5cdFx0XHRcdFx0XHRcdFx0fSwgMCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGNsaWVudC5vbmVycm9yID0gZnVuY3Rpb24gKC8qIGUgKi8pIHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UuZXJyb3IgPSAnbG9hZGVycm9yJztcblx0XHRcdFx0XHRcdFx0cmVqZWN0KHJlc3BvbnNlKTtcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHQvLyBJRSA2IHdpbGwgbm90IHN1cHBvcnQgZXJyb3IgaGFuZGxpbmdcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjbGllbnQuc2VuZChlbnRpdHkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0cmVzcG9uc2UuZXJyb3IgPSAnbG9hZGVycm9yJztcblx0XHRcdFx0XHRyZWplY3QocmVzcG9uc2UpO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdH0pO1xuXG59KFxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbiAoZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSk7IH0sXG5cdHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdm9pZCAwXG5cdC8vIEJvaWxlcnBsYXRlIGZvciBBTUQgYW5kIE5vZGVcbikpO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgdGhlIG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzXG4gKiBAbGljZW5zZSBNSVQsIHNlZSBMSUNFTlNFLnR4dCBmb3IgZGV0YWlsc1xuICpcbiAqIEBhdXRob3IgU2NvdHQgQW5kcmV3c1xuICovXG5cbihmdW5jdGlvbiAoZGVmaW5lKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHRkZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUpIHtcblxuXHRcdHZhciBkZWZhdWx0Q2xpZW50LCBtaXhpbiwgcmVzcG9uc2VQcm9taXNlLCBjbGllbnQsIHdoZW47XG5cblx0XHRkZWZhdWx0Q2xpZW50ID0gcmVxdWlyZSgnLi9jbGllbnQvZGVmYXVsdCcpO1xuXHRcdG1peGluID0gcmVxdWlyZSgnLi91dGlsL21peGluJyk7XG5cdFx0cmVzcG9uc2VQcm9taXNlID0gcmVxdWlyZSgnLi91dGlsL3Jlc3BvbnNlUHJvbWlzZScpO1xuXHRcdGNsaWVudCA9IHJlcXVpcmUoJy4vY2xpZW50Jyk7XG5cdFx0d2hlbiA9IHJlcXVpcmUoJ3doZW4nKTtcblxuXHRcdC8qKlxuXHRcdCAqIEludGVyY2VwdG9ycyBoYXZlIHRoZSBhYmlsaXR5IHRvIGludGVyY2VwdCB0aGUgcmVxdWVzdCBhbmQvb3JnIHJlc3BvbnNlXG5cdFx0ICogb2JqZWN0cy4gIFRoZXkgbWF5IGF1Z21lbnQsIHBydW5lLCB0cmFuc2Zvcm0gb3IgcmVwbGFjZSB0aGVcblx0XHQgKiByZXF1ZXN0L3Jlc3BvbnNlIGFzIG5lZWRlZC4gIENsaWVudHMgbWF5IGJlIGNvbXBvc2VkIGJ5IHdyYXBwaW5nXG5cdFx0ICogdG9nZXRoZXIgbXVsdGlwbGUgaW50ZXJjZXB0b3JzLlxuXHRcdCAqXG5cdFx0ICogQ29uZmlndXJlZCBpbnRlcmNlcHRvcnMgYXJlIGZ1bmN0aW9uYWwgaW4gbmF0dXJlLiAgV3JhcHBpbmcgYSBjbGllbnQgaW5cblx0XHQgKiBhbiBpbnRlcmNlcHRvciB3aWxsIG5vdCBhZmZlY3QgdGhlIGNsaWVudCwgbWVyZWx5IHRoZSBkYXRhIHRoYXQgZmxvd3MgaW5cblx0XHQgKiBhbmQgb3V0IG9mIHRoYXQgY2xpZW50LiAgQSBjb21tb24gY29uZmlndXJhdGlvbiBjYW4gYmUgY3JlYXRlZCBvbmNlIGFuZFxuXHRcdCAqIHNoYXJlZDsgc3BlY2lhbGl6YXRpb24gY2FuIGJlIGNyZWF0ZWQgYnkgZnVydGhlciB3cmFwcGluZyB0aGF0IGNsaWVudFxuXHRcdCAqIHdpdGggY3VzdG9tIGludGVyY2VwdG9ycy5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7Q2xpZW50fSBbdGFyZ2V0XSBjbGllbnQgdG8gd3JhcFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBjb25maWd1cmF0aW9uIGZvciB0aGUgaW50ZXJjZXB0b3IsIHByb3BlcnRpZXMgd2lsbCBiZSBzcGVjaWZpYyB0byB0aGUgaW50ZXJjZXB0b3IgaW1wbGVtZW50YXRpb25cblx0XHQgKiBAcmV0dXJucyB7Q2xpZW50fSBBIGNsaWVudCB3cmFwcGVkIHdpdGggdGhlIGludGVyY2VwdG9yXG5cdFx0ICpcblx0XHQgKiBAY2xhc3MgSW50ZXJjZXB0b3Jcblx0XHQgKi9cblxuXHRcdGZ1bmN0aW9uIGRlZmF1bHRJbml0SGFuZGxlcihjb25maWcpIHtcblx0XHRcdHJldHVybiBjb25maWc7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZGVmYXVsdFJlcXVlc3RIYW5kbGVyKHJlcXVlc3QgLyosIGNvbmZpZywgbWV0YSAqLykge1xuXHRcdFx0cmV0dXJuIHJlcXVlc3Q7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZGVmYXVsdFJlc3BvbnNlSGFuZGxlcihyZXNwb25zZSAvKiwgY29uZmlnLCBtZXRhICovKSB7XG5cdFx0XHRyZXR1cm4gcmVzcG9uc2U7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmFjZShwcm9taXNlc09yVmFsdWVzKSB7XG5cdFx0XHQvLyB0aGlzIGZ1bmN0aW9uIGlzIGRpZmZlcmVudCB0aGFuIHdoZW4uYW55IGFzIHRoZSBmaXJzdCB0byByZWplY3QgYWxzbyB3aW5zXG5cdFx0XHRyZXR1cm4gd2hlbi5wcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdFx0cHJvbWlzZXNPclZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9taXNlT3JWYWx1ZSkge1xuXHRcdFx0XHRcdHdoZW4ocHJvbWlzZU9yVmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogQWx0ZXJuYXRlIHJldHVybiB0eXBlIGZvciB0aGUgcmVxdWVzdCBoYW5kbGVyIHRoYXQgYWxsb3dzIGZvciBtb3JlIGNvbXBsZXggaW50ZXJhY3Rpb25zLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHByb3BlcnRpZXMucmVxdWVzdCB0aGUgdHJhZGl0aW9uYWwgcmVxdWVzdCByZXR1cm4gb2JqZWN0XG5cdFx0ICogQHBhcmFtIHtQcm9taXNlfSBbcHJvcGVydGllcy5hYm9ydF0gcHJvbWlzZSB0aGF0IHJlc29sdmVzIGlmL3doZW4gdGhlIHJlcXVlc3QgaXMgYWJvcnRlZFxuXHRcdCAqIEBwYXJhbSB7Q2xpZW50fSBbcHJvcGVydGllcy5jbGllbnRdIG92ZXJyaWRlIHRoZSBkZWZpbmVkIGNsaWVudCB3aXRoIGFuIGFsdGVybmF0ZSBjbGllbnRcblx0XHQgKiBAcGFyYW0gW3Byb3BlcnRpZXMucmVzcG9uc2VdIHJlc3BvbnNlIGZvciB0aGUgcmVxdWVzdCwgc2hvcnQgY2lyY3VpdCB0aGUgcmVxdWVzdFxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIENvbXBsZXhSZXF1ZXN0KHByb3BlcnRpZXMpIHtcblx0XHRcdGlmICghKHRoaXMgaW5zdGFuY2VvZiBDb21wbGV4UmVxdWVzdCkpIHtcblx0XHRcdFx0Ly8gaW4gY2FzZSB1c2VycyBmb3JnZXQgdGhlICduZXcnIGRvbid0IG1peCBpbnRvIHRoZSBpbnRlcmNlcHRvclxuXHRcdFx0XHRyZXR1cm4gbmV3IENvbXBsZXhSZXF1ZXN0KHByb3BlcnRpZXMpO1xuXHRcdFx0fVxuXHRcdFx0bWl4aW4odGhpcywgcHJvcGVydGllcyk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlIGEgbmV3IGludGVyY2VwdG9yIGZvciB0aGUgcHJvdmlkZWQgaGFuZGxlcnMuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcnMuaW5pdF0gb25lIHRpbWUgaW50aWFsaXphdGlvbiwgbXVzdCByZXR1cm4gdGhlIGNvbmZpZyBvYmplY3Rcblx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcnMucmVxdWVzdF0gcmVxdWVzdCBoYW5kbGVyXG5cdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW2hhbmRsZXJzLnJlc3BvbnNlXSByZXNwb25zZSBoYW5kbGVyIHJlZ2FyZGxlc3Mgb2YgZXJyb3Igc3RhdGVcblx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcnMuc3VjY2Vzc10gcmVzcG9uc2UgaGFuZGxlciB3aGVuIHRoZSByZXF1ZXN0IGlzIG5vdCBpbiBlcnJvclxuXHRcdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtoYW5kbGVycy5lcnJvcl0gcmVzcG9uc2UgaGFuZGxlciB3aGVuIHRoZSByZXF1ZXN0IGlzIGluIGVycm9yLCBtYXkgYmUgdXNlZCB0byAndW5yZWplY3QnIGFuIGVycm9yIHN0YXRlXG5cdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW2hhbmRsZXJzLmNsaWVudF0gdGhlIGNsaWVudCB0byB1c2UgaWYgb3RoZXJ3aXNlIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIHBsYXRmb3JtIGRlZmF1bHQgY2xpZW50XG5cdFx0ICpcblx0XHQgKiBAcmV0dXJucyB7SW50ZXJjZXB0b3J9XG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gaW50ZXJjZXB0b3IoaGFuZGxlcnMpIHtcblxuXHRcdFx0dmFyIGluaXRIYW5kbGVyLCByZXF1ZXN0SGFuZGxlciwgc3VjY2Vzc1Jlc3BvbnNlSGFuZGxlciwgZXJyb3JSZXNwb25zZUhhbmRsZXI7XG5cblx0XHRcdGhhbmRsZXJzID0gaGFuZGxlcnMgfHwge307XG5cblx0XHRcdGluaXRIYW5kbGVyICAgICAgICAgICAgPSBoYW5kbGVycy5pbml0ICAgIHx8IGRlZmF1bHRJbml0SGFuZGxlcjtcblx0XHRcdHJlcXVlc3RIYW5kbGVyICAgICAgICAgPSBoYW5kbGVycy5yZXF1ZXN0IHx8IGRlZmF1bHRSZXF1ZXN0SGFuZGxlcjtcblx0XHRcdHN1Y2Nlc3NSZXNwb25zZUhhbmRsZXIgPSBoYW5kbGVycy5zdWNjZXNzIHx8IGhhbmRsZXJzLnJlc3BvbnNlIHx8IGRlZmF1bHRSZXNwb25zZUhhbmRsZXI7XG5cdFx0XHRlcnJvclJlc3BvbnNlSGFuZGxlciAgID0gaGFuZGxlcnMuZXJyb3IgICB8fCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdC8vIFByb3BhZ2F0ZSB0aGUgcmVqZWN0aW9uLCB3aXRoIHRoZSByZXN1bHQgb2YgdGhlIGhhbmRsZXJcblx0XHRcdFx0cmV0dXJuIHdoZW4oKGhhbmRsZXJzLnJlc3BvbnNlIHx8IGRlZmF1bHRSZXNwb25zZUhhbmRsZXIpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHdoZW4ucmVqZWN0LCB3aGVuLnJlamVjdCk7XG5cdFx0XHR9O1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgY29uZmlnKSB7XG5cblx0XHRcdFx0aWYgKHR5cGVvZiB0YXJnZXQgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0Y29uZmlnID0gdGFyZ2V0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0dGFyZ2V0ID0gaGFuZGxlcnMuY2xpZW50IHx8IGRlZmF1bHRDbGllbnQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25maWcgPSBpbml0SGFuZGxlcihjb25maWcgfHwge30pO1xuXG5cdFx0XHRcdGZ1bmN0aW9uIGludGVyY2VwdGVkQ2xpZW50KHJlcXVlc3QpIHtcblx0XHRcdFx0XHR2YXIgY29udGV4dCwgbWV0YTtcblx0XHRcdFx0XHRjb250ZXh0ID0ge307XG5cdFx0XHRcdFx0bWV0YSA9IHsgJ2FyZ3VtZW50cyc6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksIGNsaWVudDogaW50ZXJjZXB0ZWRDbGllbnQgfTtcblx0XHRcdFx0XHRyZXF1ZXN0ID0gdHlwZW9mIHJlcXVlc3QgPT09ICdzdHJpbmcnID8geyBwYXRoOiByZXF1ZXN0IH0gOiByZXF1ZXN0IHx8IHt9O1xuXHRcdFx0XHRcdHJlcXVlc3Qub3JpZ2luYXRvciA9IHJlcXVlc3Qub3JpZ2luYXRvciB8fCBpbnRlcmNlcHRlZENsaWVudDtcblx0XHRcdFx0XHRyZXR1cm4gcmVzcG9uc2VQcm9taXNlKFxuXHRcdFx0XHRcdFx0cmVxdWVzdEhhbmRsZXIuY2FsbChjb250ZXh0LCByZXF1ZXN0LCBjb25maWcsIG1ldGEpLFxuXHRcdFx0XHRcdFx0ZnVuY3Rpb24gKHJlcXVlc3QpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHJlc3BvbnNlLCBhYm9ydCwgbmV4dDtcblx0XHRcdFx0XHRcdFx0bmV4dCA9IHRhcmdldDtcblx0XHRcdFx0XHRcdFx0aWYgKHJlcXVlc3QgaW5zdGFuY2VvZiBDb21wbGV4UmVxdWVzdCkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIHVucGFjayByZXF1ZXN0XG5cdFx0XHRcdFx0XHRcdFx0YWJvcnQgPSByZXF1ZXN0LmFib3J0O1xuXHRcdFx0XHRcdFx0XHRcdG5leHQgPSByZXF1ZXN0LmNsaWVudCB8fCBuZXh0O1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlID0gcmVxdWVzdC5yZXNwb25zZTtcblx0XHRcdFx0XHRcdFx0XHQvLyBub3JtYWxpemUgcmVxdWVzdCwgbXVzdCBiZSBsYXN0XG5cdFx0XHRcdFx0XHRcdFx0cmVxdWVzdCA9IHJlcXVlc3QucmVxdWVzdDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXNwb25zZSA9IHJlc3BvbnNlIHx8IHdoZW4ocmVxdWVzdCwgZnVuY3Rpb24gKHJlcXVlc3QpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gd2hlbihcblx0XHRcdFx0XHRcdFx0XHRcdG5leHQocmVxdWVzdCksXG5cdFx0XHRcdFx0XHRcdFx0XHRmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHN1Y2Nlc3NSZXNwb25zZUhhbmRsZXIuY2FsbChjb250ZXh0LCByZXNwb25zZSwgY29uZmlnLCBtZXRhKTtcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGVycm9yUmVzcG9uc2VIYW5kbGVyLmNhbGwoY29udGV4dCwgcmVzcG9uc2UsIGNvbmZpZywgbWV0YSk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBhYm9ydCA/IHJhY2UoW3Jlc3BvbnNlLCBhYm9ydF0pIDogcmVzcG9uc2U7XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0ZnVuY3Rpb24gKGVycm9yKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB3aGVuLnJlamVjdCh7IHJlcXVlc3Q6IHJlcXVlc3QsIGVycm9yOiBlcnJvciB9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGNsaWVudChpbnRlcmNlcHRlZENsaWVudCwgdGFyZ2V0KTtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0aW50ZXJjZXB0b3IuQ29tcGxleFJlcXVlc3QgPSBDb21wbGV4UmVxdWVzdDtcblxuXHRcdHJldHVybiBpbnRlcmNlcHRvcjtcblxuXHR9KTtcblxufShcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24gKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUpOyB9XG5cdC8vIEJvaWxlcnBsYXRlIGZvciBBTUQgYW5kIE5vZGVcbikpO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDEzIHRoZSBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9yc1xuICogQGxpY2Vuc2UgTUlULCBzZWUgTElDRU5TRS50eHQgZm9yIGRldGFpbHNcbiAqXG4gKiBAYXV0aG9yIFNjb3R0IEFuZHJld3NcbiAqL1xuXG4oZnVuY3Rpb24gKGRlZmluZSkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0ZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cblx0XHR2YXIgaW50ZXJjZXB0b3IsIG1peGluVXRpbCwgZGVmYXVsdGVyO1xuXG5cdFx0aW50ZXJjZXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcmNlcHRvcicpO1xuXHRcdG1peGluVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvbWl4aW4nKTtcblxuXHRcdGRlZmF1bHRlciA9IChmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGZ1bmN0aW9uIG1peGluKHByb3AsIHRhcmdldCwgZGVmYXVsdHMpIHtcblx0XHRcdFx0aWYgKHByb3AgaW4gdGFyZ2V0IHx8IHByb3AgaW4gZGVmYXVsdHMpIHtcblx0XHRcdFx0XHR0YXJnZXRbcHJvcF0gPSBtaXhpblV0aWwoe30sIGRlZmF1bHRzW3Byb3BdLCB0YXJnZXRbcHJvcF0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGNvcHkocHJvcCwgdGFyZ2V0LCBkZWZhdWx0cykge1xuXHRcdFx0XHRpZiAocHJvcCBpbiBkZWZhdWx0cyAmJiAhKHByb3AgaW4gdGFyZ2V0KSkge1xuXHRcdFx0XHRcdHRhcmdldFtwcm9wXSA9IGRlZmF1bHRzW3Byb3BdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHZhciBtYXBwaW5ncyA9IHtcblx0XHRcdFx0bWV0aG9kOiBjb3B5LFxuXHRcdFx0XHRwYXRoOiBjb3B5LFxuXHRcdFx0XHRwYXJhbXM6IG1peGluLFxuXHRcdFx0XHRoZWFkZXJzOiBtaXhpbixcblx0XHRcdFx0ZW50aXR5OiBjb3B5LFxuXHRcdFx0XHRtaXhpbjogbWl4aW5cblx0XHRcdH07XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBkZWZhdWx0cykge1xuXHRcdFx0XHRmb3IgKHZhciBwcm9wIGluIG1hcHBpbmdzKSB7XG5cdFx0XHRcdFx0Lypqc2hpbnQgZm9yaW46IGZhbHNlICovXG5cdFx0XHRcdFx0bWFwcGluZ3NbcHJvcF0ocHJvcCwgdGFyZ2V0LCBkZWZhdWx0cyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRhcmdldDtcblx0XHRcdH07XG5cblx0XHR9KCkpO1xuXG5cdFx0LyoqXG5cdFx0ICogUHJvdmlkZSBkZWZhdWx0IHZhbHVlcyBmb3IgYSByZXF1ZXN0LiBUaGVzZSB2YWx1ZXMgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZVxuXHRcdCAqIHJlcXVlc3QgaWYgdGhlIHJlcXVlc3Qgb2JqZWN0IGRvZXMgbm90IGFscmVhZHkgY29udGFpbiBhbiBleHBsaWNpdCB2YWx1ZS5cblx0XHQgKlxuXHRcdCAqIEZvciAncGFyYW1zJywgJ2hlYWRlcnMnLCBhbmQgJ21peGluJywgaW5kaXZpZHVhbCB2YWx1ZXMgYXJlIG1peGVkIGluIHdpdGggdGhlXG5cdFx0ICogcmVxdWVzdCdzIHZhbHVlcy4gVGhlIHJlc3VsdCBpcyBhIG5ldyBvYmplY3QgcmVwcmVzZW50aWluZyB0aGUgY29tYmluZWRcblx0XHQgKiByZXF1ZXN0IGFuZCBjb25maWcgdmFsdWVzLiBOZWl0aGVyIGlucHV0IG9iamVjdCBpcyBtdXRhdGVkLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtDbGllbnR9IFtjbGllbnRdIGNsaWVudCB0byB3cmFwXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcubWV0aG9kXSB0aGUgZGVmYXVsdCBtZXRob2Rcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmZpZy5wYXRoXSB0aGUgZGVmYXVsdCBwYXRoXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcucGFyYW1zXSB0aGUgZGVmYXVsdCBwYXJhbXMsIG1peGVkIHdpdGggdGhlIHJlcXVlc3QncyBleGlzdGluZyBwYXJhbXNcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5oZWFkZXJzXSB0aGUgZGVmYXVsdCBoZWFkZXJzLCBtaXhlZCB3aXRoIHRoZSByZXF1ZXN0J3MgZXhpc3RpbmcgaGVhZGVyc1xuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm1peGluXSB0aGUgZGVmYXVsdCBcIm1peGluc1wiIChodHRwL2h0dHBzIG9wdGlvbnMpLCBtaXhlZCB3aXRoIHRoZSByZXF1ZXN0J3MgZXhpc3RpbmcgXCJtaXhpbnNcIlxuXHRcdCAqXG5cdFx0ICogQHJldHVybnMge0NsaWVudH1cblx0XHQgKi9cblx0XHRyZXR1cm4gaW50ZXJjZXB0b3Ioe1xuXHRcdFx0cmVxdWVzdDogZnVuY3Rpb24gaGFuZGxlUmVxdWVzdChyZXF1ZXN0LCBjb25maWcpIHtcblx0XHRcdFx0cmV0dXJuIGRlZmF1bHRlcihyZXF1ZXN0LCBjb25maWcpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdH0pO1xuXG59KFxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbiAoZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSk7IH1cblx0Ly8gQm9pbGVycGxhdGUgZm9yIEFNRCBhbmQgTm9kZVxuKSk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTItMjAxMyB0aGUgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnNcbiAqIEBsaWNlbnNlIE1JVCwgc2VlIExJQ0VOU0UudHh0IGZvciBkZXRhaWxzXG4gKlxuICogQGF1dGhvciBTY290dCBBbmRyZXdzXG4gKi9cblxuKGZ1bmN0aW9uIChkZWZpbmUpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdGRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuXG5cdFx0dmFyIGludGVyY2VwdG9yLCB3aGVuO1xuXG5cdFx0aW50ZXJjZXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcmNlcHRvcicpO1xuXHRcdHdoZW4gPSByZXF1aXJlKCd3aGVuJyk7XG5cblx0XHQvKipcblx0XHQgKiBSZWplY3RzIHRoZSByZXNwb25zZSBwcm9taXNlIGJhc2VkIG9uIHRoZSBzdGF0dXMgY29kZS5cblx0XHQgKlxuXHRcdCAqIENvZGVzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgcHJvdmlkZWQgdmFsdWUgYXJlIHJlamVjdGVkLiAgRGVmYXVsdFxuXHRcdCAqIHZhbHVlIDQwMC5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7Q2xpZW50fSBbY2xpZW50XSBjbGllbnQgdG8gd3JhcFxuXHRcdCAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLmNvZGU9NDAwXSBjb2RlIHRvIGluZGljYXRlIGEgcmVqZWN0aW9uXG5cdFx0ICpcblx0XHQgKiBAcmV0dXJucyB7Q2xpZW50fVxuXHRcdCAqL1xuXHRcdHJldHVybiBpbnRlcmNlcHRvcih7XG5cdFx0XHRpbml0OiBmdW5jdGlvbiAoY29uZmlnKSB7XG5cdFx0XHRcdGNvbmZpZy5jb2RlID0gY29uZmlnLmNvZGUgfHwgNDAwO1xuXHRcdFx0XHRyZXR1cm4gY29uZmlnO1xuXHRcdFx0fSxcblx0XHRcdHJlc3BvbnNlOiBmdW5jdGlvbiAocmVzcG9uc2UsIGNvbmZpZykge1xuXHRcdFx0XHRpZiAocmVzcG9uc2Uuc3RhdHVzICYmIHJlc3BvbnNlLnN0YXR1cy5jb2RlID49IGNvbmZpZy5jb2RlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHdoZW4ucmVqZWN0KHJlc3BvbnNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmVzcG9uc2U7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0fSk7XG5cbn0oXG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uIChmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKTsgfVxuXHQvLyBCb2lsZXJwbGF0ZSBmb3IgQU1EIGFuZCBOb2RlXG4pKTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE0IHRoZSBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9yc1xuICogQGxpY2Vuc2UgTUlULCBzZWUgTElDRU5TRS50eHQgZm9yIGRldGFpbHNcbiAqXG4gKiBAYXV0aG9yIFNjb3R0IEFuZHJld3NcbiAqL1xuXG4oZnVuY3Rpb24gKGRlZmluZSkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0ZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cblx0XHR2YXIgaW50ZXJjZXB0b3IsIG1pbWUsIHJlZ2lzdHJ5LCBub29wQ29udmVydGVyLCB3aGVuO1xuXG5cdFx0aW50ZXJjZXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcmNlcHRvcicpO1xuXHRcdG1pbWUgPSByZXF1aXJlKCcuLi9taW1lJyk7XG5cdFx0cmVnaXN0cnkgPSByZXF1aXJlKCcuLi9taW1lL3JlZ2lzdHJ5Jyk7XG5cdFx0d2hlbiA9IHJlcXVpcmUoJ3doZW4nKTtcblxuXHRcdG5vb3BDb252ZXJ0ZXIgPSB7XG5cdFx0XHRyZWFkOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmo7IH0sXG5cdFx0XHR3cml0ZTogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqOyB9XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIE1JTUUgdHlwZSBzdXBwb3J0IGZvciByZXF1ZXN0IGFuZCByZXNwb25zZSBlbnRpdGllcy4gIEVudGl0aWVzIGFyZVxuXHRcdCAqIChkZSlzZXJpYWxpemVkIHVzaW5nIHRoZSBjb252ZXJ0ZXIgZm9yIHRoZSBNSU1FIHR5cGUuXG5cdFx0ICpcblx0XHQgKiBSZXF1ZXN0IGVudGl0aWVzIGFyZSBjb252ZXJ0ZWQgdXNpbmcgdGhlIGRlc2lyZWQgY29udmVydGVyIGFuZCB0aGVcblx0XHQgKiAnQWNjZXB0JyByZXF1ZXN0IGhlYWRlciBwcmVmZXJzIHRoaXMgTUlNRS5cblx0XHQgKlxuXHRcdCAqIFJlc3BvbnNlIGVudGl0aWVzIGFyZSBjb252ZXJ0ZWQgYmFzZWQgb24gdGhlIENvbnRlbnQtVHlwZSByZXNwb25zZSBoZWFkZXIuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge0NsaWVudH0gW2NsaWVudF0gY2xpZW50IHRvIHdyYXBcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmZpZy5taW1lPSd0ZXh0L3BsYWluJ10gTUlNRSB0eXBlIHRvIGVuY29kZSB0aGUgcmVxdWVzdFxuXHRcdCAqICAgZW50aXR5XG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcuYWNjZXB0XSBBY2NlcHQgaGVhZGVyIGZvciB0aGUgcmVxdWVzdFxuXHRcdCAqIEBwYXJhbSB7Q2xpZW50fSBbY29uZmlnLmNsaWVudD08cmVxdWVzdC5vcmlnaW5hdG9yPl0gY2xpZW50IHBhc3NlZCB0byB0aGVcblx0XHQgKiAgIGNvbnZlcnRlciwgZGVmYXVsdHMgdG8gdGhlIGNsaWVudCBvcmlnaW5hdGluZyB0aGUgcmVxdWVzdFxuXHRcdCAqIEBwYXJhbSB7UmVnaXN0cnl9IFtjb25maWcucmVnaXN0cnldIE1JTUUgcmVnaXN0cnksIGRlZmF1bHRzIHRvIHRoZSByb290XG5cdFx0ICogICByZWdpc3RyeVxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NvbmZpZy5wZXJtaXNzaXZlXSBBbGxvdyBhbiB1bmtvd24gcmVxdWVzdCBNSU1FIHR5cGVcblx0XHQgKlxuXHRcdCAqIEByZXR1cm5zIHtDbGllbnR9XG5cdFx0ICovXG5cdFx0cmV0dXJuIGludGVyY2VwdG9yKHtcblx0XHRcdGluaXQ6IGZ1bmN0aW9uIChjb25maWcpIHtcblx0XHRcdFx0Y29uZmlnLnJlZ2lzdHJ5ID0gY29uZmlnLnJlZ2lzdHJ5IHx8IHJlZ2lzdHJ5O1xuXHRcdFx0XHRyZXR1cm4gY29uZmlnO1xuXHRcdFx0fSxcblx0XHRcdHJlcXVlc3Q6IGZ1bmN0aW9uIChyZXF1ZXN0LCBjb25maWcpIHtcblx0XHRcdFx0dmFyIHR5cGUsIGhlYWRlcnM7XG5cblx0XHRcdFx0aGVhZGVycyA9IHJlcXVlc3QuaGVhZGVycyB8fCAocmVxdWVzdC5oZWFkZXJzID0ge30pO1xuXHRcdFx0XHR0eXBlID0gbWltZS5wYXJzZShoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9IGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddIHx8IGNvbmZpZy5taW1lIHx8ICd0ZXh0L3BsYWluJyk7XG5cdFx0XHRcdGhlYWRlcnMuQWNjZXB0ID0gaGVhZGVycy5BY2NlcHQgfHwgY29uZmlnLmFjY2VwdCB8fCB0eXBlLnJhdyArICcsIGFwcGxpY2F0aW9uL2pzb247cT0wLjgsIHRleHQvcGxhaW47cT0wLjUsICovKjtxPTAuMic7XG5cblx0XHRcdFx0aWYgKCEoJ2VudGl0eScgaW4gcmVxdWVzdCkpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmVxdWVzdDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBjb25maWcucmVnaXN0cnkubG9va3VwKHR5cGUpLm90aGVyd2lzZShmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0Ly8gZmFpbGVkIHRvIHJlc29sdmUgY29udmVydGVyXG5cdFx0XHRcdFx0aWYgKGNvbmZpZy5wZXJtaXNzaXZlKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbm9vcENvbnZlcnRlcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhyb3cgJ21pbWUtdW5rbm93bic7XG5cdFx0XHRcdH0pLnRoZW4oZnVuY3Rpb24gKGNvbnZlcnRlcikge1xuXHRcdFx0XHRcdHZhciBjbGllbnQgPSBjb25maWcuY2xpZW50IHx8IHJlcXVlc3Qub3JpZ2luYXRvcjtcblxuXHRcdFx0XHRcdHJldHVybiB3aGVuLmF0dGVtcHQoY29udmVydGVyLndyaXRlLCByZXF1ZXN0LmVudGl0eSwgeyBjbGllbnQ6IGNsaWVudCwgcmVxdWVzdDogcmVxdWVzdCwgbWltZTogdHlwZSwgcmVnaXN0cnk6IGNvbmZpZy5yZWdpc3RyeSB9KVxuXHRcdFx0XHRcdFx0Lm90aGVyd2lzZShmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dGhyb3cgJ21pbWUtc2VyaWFsaXphdGlvbic7XG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0LnRoZW4oZnVuY3Rpb24oZW50aXR5KSB7XG5cdFx0XHRcdFx0XHRcdHJlcXVlc3QuZW50aXR5ID0gZW50aXR5O1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVxdWVzdDtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cdFx0XHRyZXNwb25zZTogZnVuY3Rpb24gKHJlc3BvbnNlLCBjb25maWcpIHtcblx0XHRcdFx0aWYgKCEocmVzcG9uc2UuaGVhZGVycyAmJiByZXNwb25zZS5oZWFkZXJzWydDb250ZW50LVR5cGUnXSAmJiByZXNwb25zZS5lbnRpdHkpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3BvbnNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHR5cGUgPSBtaW1lLnBhcnNlKHJlc3BvbnNlLmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKTtcblxuXHRcdFx0XHRyZXR1cm4gY29uZmlnLnJlZ2lzdHJ5Lmxvb2t1cCh0eXBlKS5vdGhlcndpc2UoZnVuY3Rpb24gKCkgeyByZXR1cm4gbm9vcENvbnZlcnRlcjsgfSkudGhlbihmdW5jdGlvbiAoY29udmVydGVyKSB7XG5cdFx0XHRcdFx0dmFyIGNsaWVudCA9IGNvbmZpZy5jbGllbnQgfHwgcmVzcG9uc2UucmVxdWVzdCAmJiByZXNwb25zZS5yZXF1ZXN0Lm9yaWdpbmF0b3I7XG5cblx0XHRcdFx0XHRyZXR1cm4gd2hlbi5hdHRlbXB0KGNvbnZlcnRlci5yZWFkLCByZXNwb25zZS5lbnRpdHksIHsgY2xpZW50OiBjbGllbnQsIHJlc3BvbnNlOiByZXNwb25zZSwgbWltZTogdHlwZSwgcmVnaXN0cnk6IGNvbmZpZy5yZWdpc3RyeSB9KVxuXHRcdFx0XHRcdFx0Lm90aGVyd2lzZShmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZS5lcnJvciA9ICdtaW1lLWRlc2VyaWFsaXphdGlvbic7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlLmNhdXNlID0gZTtcblx0XHRcdFx0XHRcdFx0dGhyb3cgcmVzcG9uc2U7XG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0LnRoZW4oZnVuY3Rpb24gKGVudGl0eSkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZS5lbnRpdHkgPSBlbnRpdHk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXNwb25zZTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHR9KTtcblxufShcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24gKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUpOyB9XG5cdC8vIEJvaWxlcnBsYXRlIGZvciBBTUQgYW5kIE5vZGVcbikpO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDEyLTIwMTMgdGhlIG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzXG4gKiBAbGljZW5zZSBNSVQsIHNlZSBMSUNFTlNFLnR4dCBmb3IgZGV0YWlsc1xuICpcbiAqIEBhdXRob3IgU2NvdHQgQW5kcmV3c1xuICovXG5cbihmdW5jdGlvbiAoZGVmaW5lKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHRkZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUpIHtcblxuXHRcdHZhciBpbnRlcmNlcHRvciwgVXJsQnVpbGRlcjtcblxuXHRcdGludGVyY2VwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJjZXB0b3InKTtcblx0XHRVcmxCdWlsZGVyID0gcmVxdWlyZSgnLi4vVXJsQnVpbGRlcicpO1xuXG5cdFx0ZnVuY3Rpb24gc3RhcnRzV2l0aChzdHIsIHByZWZpeCkge1xuXHRcdFx0cmV0dXJuIHN0ci5pbmRleE9mKHByZWZpeCkgPT09IDA7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZW5kc1dpdGgoc3RyLCBzdWZmaXgpIHtcblx0XHRcdHJldHVybiBzdHIubGFzdEluZGV4T2Yoc3VmZml4KSArIHN1ZmZpeC5sZW5ndGggPT09IHN0ci5sZW5ndGg7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogUHJlZml4ZXMgdGhlIHJlcXVlc3QgcGF0aCB3aXRoIGEgY29tbW9uIHZhbHVlLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtDbGllbnR9IFtjbGllbnRdIGNsaWVudCB0byB3cmFwXG5cdFx0ICogQHBhcmFtIHtudW1iZXJ9IFtjb25maWcucHJlZml4XSBwYXRoIHByZWZpeFxuXHRcdCAqXG5cdFx0ICogQHJldHVybnMge0NsaWVudH1cblx0XHQgKi9cblx0XHRyZXR1cm4gaW50ZXJjZXB0b3Ioe1xuXHRcdFx0cmVxdWVzdDogZnVuY3Rpb24gKHJlcXVlc3QsIGNvbmZpZykge1xuXHRcdFx0XHR2YXIgcGF0aDtcblxuXHRcdFx0XHRpZiAoY29uZmlnLnByZWZpeCAmJiAhKG5ldyBVcmxCdWlsZGVyKHJlcXVlc3QucGF0aCkuaXNGdWxseVF1YWxpZmllZCgpKSkge1xuXHRcdFx0XHRcdHBhdGggPSBjb25maWcucHJlZml4O1xuXHRcdFx0XHRcdGlmIChyZXF1ZXN0LnBhdGgpIHtcblx0XHRcdFx0XHRcdGlmICghZW5kc1dpdGgocGF0aCwgJy8nKSAmJiAhc3RhcnRzV2l0aChyZXF1ZXN0LnBhdGgsICcvJykpIHtcblx0XHRcdFx0XHRcdFx0Ly8gYWRkIG1pc3NpbmcgJy8nIGJldHdlZW4gcGF0aCBzZWN0aW9uc1xuXHRcdFx0XHRcdFx0XHRwYXRoICs9ICcvJztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHBhdGggKz0gcmVxdWVzdC5wYXRoO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXF1ZXN0LnBhdGggPSBwYXRoO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHJlcXVlc3Q7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0fSk7XG5cbn0oXG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uIChmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKTsgfVxuXHQvLyBCb2lsZXJwbGF0ZSBmb3IgQU1EIGFuZCBOb2RlXG4pKTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNSB0aGUgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnNcbiAqIEBsaWNlbnNlIE1JVCwgc2VlIExJQ0VOU0UudHh0IGZvciBkZXRhaWxzXG4gKlxuICogQGF1dGhvciBTY290dCBBbmRyZXdzXG4gKi9cblxuKGZ1bmN0aW9uIChkZWZpbmUpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdGRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuXG5cdFx0dmFyIGludGVyY2VwdG9yLCB1cmlUZW1wbGF0ZSwgbWl4aW47XG5cblx0XHRpbnRlcmNlcHRvciA9IHJlcXVpcmUoJy4uL2ludGVyY2VwdG9yJyk7XG5cdFx0dXJpVGVtcGxhdGUgPSByZXF1aXJlKCcuLi91dGlsL3VyaVRlbXBsYXRlJyk7XG5cdFx0bWl4aW4gPSByZXF1aXJlKCcuLi91dGlsL21peGluJyk7XG5cblx0XHQvKipcblx0XHQgKiBBcHBsaWVzIHJlcXVlc3QgcGFyYW1zIHRvIHRoZSBwYXRoIGFzIGEgVVJJIFRlbXBsYXRlXG5cdFx0ICpcblx0XHQgKiBQYXJhbXMgYXJlIHJlbW92ZWQgZnJvbSB0aGUgcmVxdWVzdCBvYmplY3QsIGFzIHRoZXkgaGF2ZSBiZWVuIGNvbnN1bWVkLlxuXHRcdCAqXG5cdFx0ICogQHNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjU3MFxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtDbGllbnR9IFtjbGllbnRdIGNsaWVudCB0byB3cmFwXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcucGFyYW1zXSBkZWZhdWx0IHBhcmFtIHZhbHVlc1xuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLnRlbXBsYXRlXSBkZWZhdWx0IHRlbXBsYXRlXG5cdFx0ICpcblx0XHQgKiBAcmV0dXJucyB7Q2xpZW50fVxuXHRcdCAqL1xuXHRcdHJldHVybiBpbnRlcmNlcHRvcih7XG5cdFx0XHRpbml0OiBmdW5jdGlvbiAoY29uZmlnKSB7XG5cdFx0XHRcdGNvbmZpZy5wYXJhbXMgPSBjb25maWcucGFyYW1zIHx8IHt9O1xuXHRcdFx0XHRjb25maWcudGVtcGxhdGUgPSBjb25maWcudGVtcGxhdGUgfHwgJyc7XG5cdFx0XHRcdHJldHVybiBjb25maWc7XG5cdFx0XHR9LFxuXHRcdFx0cmVxdWVzdDogZnVuY3Rpb24gKHJlcXVlc3QsIGNvbmZpZykge1xuXHRcdFx0XHR2YXIgdGVtcGxhdGUsIHBhcmFtcztcblxuXHRcdFx0XHR0ZW1wbGF0ZSA9IHJlcXVlc3QucGF0aCB8fCBjb25maWcudGVtcGxhdGU7XG5cdFx0XHRcdHBhcmFtcyA9IG1peGluKHt9LCByZXF1ZXN0LnBhcmFtcywgY29uZmlnLnBhcmFtcyk7XG5cblx0XHRcdFx0cmVxdWVzdC5wYXRoID0gdXJpVGVtcGxhdGUuZXhwYW5kKHRlbXBsYXRlLCBwYXJhbXMpO1xuXHRcdFx0XHRkZWxldGUgcmVxdWVzdC5wYXJhbXM7XG5cblx0XHRcdFx0cmV0dXJuIHJlcXVlc3Q7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0fSk7XG5cbn0oXG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uIChmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKTsgfVxuXHQvLyBCb2lsZXJwbGF0ZSBmb3IgQU1EIGFuZCBOb2RlXG4pKTtcbiIsIi8qXG4qIENvcHlyaWdodCAyMDE0IHRoZSBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9yc1xuKiBAbGljZW5zZSBNSVQsIHNlZSBMSUNFTlNFLnR4dCBmb3IgZGV0YWlsc1xuKlxuKiBAYXV0aG9yIFNjb3R0IEFuZHJld3NcbiovXG5cbihmdW5jdGlvbiAoZGVmaW5lKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgdW5kZWY7XG5cblx0ZGVmaW5lKGZ1bmN0aW9uICgvKiByZXF1aXJlICovKSB7XG5cblx0XHQvKipcblx0XHQgKiBQYXJzZSBhIE1JTUUgdHlwZSBpbnRvIGl0J3MgY29uc3RpdHVlbnQgcGFydHNcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBtaW1lIE1JTUUgdHlwZSB0byBwYXJzZVxuXHRcdCAqIEByZXR1cm4ge3tcblx0XHQgKiAgIHtzdHJpbmd9IHJhdyB0aGUgb3JpZ2luYWwgTUlNRSB0eXBlXG5cdFx0ICogICB7c3RyaW5nfSB0eXBlIHRoZSB0eXBlIGFuZCBzdWJ0eXBlXG5cdFx0ICogICB7c3RyaW5nfSBbc3VmZml4XSBtaW1lIHN1ZmZpeCwgaW5jbHVkaW5nIHRoZSBwbHVzLCBpZiBhbnlcblx0XHQgKiAgIHtPYmplY3R9IHBhcmFtcyBrZXkvdmFsdWUgcGFpciBvZiBhdHRyaWJ1dGVzXG5cdFx0ICogfX1cblx0XHQgKi9cblx0XHRmdW5jdGlvbiBwYXJzZShtaW1lKSB7XG5cdFx0XHR2YXIgcGFyYW1zLCB0eXBlO1xuXG5cdFx0XHRwYXJhbXMgPSBtaW1lLnNwbGl0KCc7Jyk7XG5cdFx0XHR0eXBlID0gcGFyYW1zWzBdLnRyaW0oKS5zcGxpdCgnKycpO1xuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRyYXc6IG1pbWUsXG5cdFx0XHRcdHR5cGU6IHR5cGVbMF0sXG5cdFx0XHRcdHN1ZmZpeDogdHlwZVsxXSA/ICcrJyArIHR5cGVbMV0gOiAnJyxcblx0XHRcdFx0cGFyYW1zOiBwYXJhbXMuc2xpY2UoMSkucmVkdWNlKGZ1bmN0aW9uIChwYXJhbXMsIHBhaXIpIHtcblx0XHRcdFx0XHRwYWlyID0gcGFpci5zcGxpdCgnPScpO1xuXHRcdFx0XHRcdHBhcmFtc1twYWlyWzBdLnRyaW0oKV0gPSBwYWlyWzFdID8gcGFpclsxXS50cmltKCkgOiB1bmRlZjtcblx0XHRcdFx0XHRyZXR1cm4gcGFyYW1zO1xuXHRcdFx0XHR9LCB7fSlcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHBhcnNlOiBwYXJzZVxuXHRcdH07XG5cblx0fSk7XG5cbn0oXG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uIChmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKTsgfVxuXHQvLyBCb2lsZXJwbGF0ZSBmb3IgQU1EIGFuZCBOb2RlXG4pKTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE0IHRoZSBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9yc1xuICogQGxpY2Vuc2UgTUlULCBzZWUgTElDRU5TRS50eHQgZm9yIGRldGFpbHNcbiAqXG4gKiBAYXV0aG9yIFNjb3R0IEFuZHJld3NcbiAqL1xuXG4oZnVuY3Rpb24gKGRlZmluZSkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0ZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cblx0XHR2YXIgbWltZSwgd2hlbiwgcmVnaXN0cnk7XG5cblx0XHRtaW1lID0gcmVxdWlyZSgnLi4vbWltZScpO1xuXHRcdHdoZW4gPSByZXF1aXJlKCd3aGVuJyk7XG5cblx0XHRmdW5jdGlvbiBSZWdpc3RyeShtaW1lcykge1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIExvb2t1cCB0aGUgY29udmVydGVyIGZvciBhIE1JTUUgdHlwZVxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIHRoZSBNSU1FIHR5cGVcblx0XHRcdCAqIEByZXR1cm4gYSBwcm9taXNlIGZvciB0aGUgY29udmVydGVyXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMubG9va3VwID0gZnVuY3Rpb24gbG9va3VwKHR5cGUpIHtcblx0XHRcdFx0dmFyIHBhcnNlZDtcblxuXHRcdFx0XHRwYXJzZWQgPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgPyBtaW1lLnBhcnNlKHR5cGUpIDogdHlwZTtcblxuXHRcdFx0XHRpZiAobWltZXNbcGFyc2VkLnJhd10pIHtcblx0XHRcdFx0XHRyZXR1cm4gbWltZXNbcGFyc2VkLnJhd107XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG1pbWVzW3BhcnNlZC50eXBlICsgcGFyc2VkLnN1ZmZpeF0pIHtcblx0XHRcdFx0XHRyZXR1cm4gbWltZXNbcGFyc2VkLnR5cGUgKyBwYXJzZWQuc3VmZml4XTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobWltZXNbcGFyc2VkLnR5cGVdKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1pbWVzW3BhcnNlZC50eXBlXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobWltZXNbcGFyc2VkLnN1ZmZpeF0pIHtcblx0XHRcdFx0XHRyZXR1cm4gbWltZXNbcGFyc2VkLnN1ZmZpeF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gd2hlbi5yZWplY3QobmV3IEVycm9yKCdVbmFibGUgdG8gbG9jYXRlIGNvbnZlcnRlciBmb3IgbWltZSBcIicgKyBwYXJzZWQucmF3ICsgJ1wiJykpO1xuXHRcdFx0fTtcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBDcmVhdGUgYSBsYXRlIGRpc3BhdGNoZWQgcHJveHkgdG8gdGhlIHRhcmdldCBjb252ZXJ0ZXIuXG5cdFx0XHQgKlxuXHRcdFx0ICogQ29tbW9uIHdoZW4gYSBjb252ZXJ0ZXIgaXMgcmVnaXN0ZXJlZCB1bmRlciBtdWx0aXBsZSBuYW1lcyBhbmRcblx0XHRcdCAqIHNob3VsZCBiZSBrZXB0IGluIHN5bmMgaWYgdXBkYXRlZC5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBtaW1lIGNvbnZlcnRlciB0byBkaXNwYXRjaCB0b1xuXHRcdFx0ICogQHJldHVybnMgY29udmVydGVyIHdob3NlIHJlYWQvd3JpdGUgbWV0aG9kcyB0YXJnZXQgdGhlIGRlc2lyZWQgbWltZSBjb252ZXJ0ZXJcblx0XHRcdCAqL1xuXHRcdFx0dGhpcy5kZWxlZ2F0ZSA9IGZ1bmN0aW9uIGRlbGVnYXRlKHR5cGUpIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRyZWFkOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cztcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmxvb2t1cCh0eXBlKS50aGVuKGZ1bmN0aW9uIChjb252ZXJ0ZXIpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGNvbnZlcnRlci5yZWFkLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHRcdFx0XHRcdFx0fS5iaW5kKHRoaXMpKTtcblx0XHRcdFx0XHR9LmJpbmQodGhpcyksXG5cdFx0XHRcdFx0d3JpdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdHZhciBhcmdzID0gYXJndW1lbnRzO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMubG9va3VwKHR5cGUpLnRoZW4oZnVuY3Rpb24gKGNvbnZlcnRlcikge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gY29udmVydGVyLndyaXRlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHRcdFx0XHRcdFx0fS5iaW5kKHRoaXMpKTtcblx0XHRcdFx0XHR9LmJpbmQodGhpcylcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogUmVnaXN0ZXIgYSBjdXN0b20gY29udmVydGVyIGZvciBhIE1JTUUgdHlwZVxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIHRoZSBNSU1FIHR5cGVcblx0XHRcdCAqIEBwYXJhbSBjb252ZXJ0ZXIgdGhlIGNvbnZlcnRlciBmb3IgdGhlIE1JTUUgdHlwZVxuXHRcdFx0ICogQHJldHVybiBhIHByb21pc2UgZm9yIHRoZSBjb252ZXJ0ZXJcblx0XHRcdCAqL1xuXHRcdFx0dGhpcy5yZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyKHR5cGUsIGNvbnZlcnRlcikge1xuXHRcdFx0XHRtaW1lc1t0eXBlXSA9IHdoZW4oY29udmVydGVyKTtcblx0XHRcdFx0cmV0dXJuIG1pbWVzW3R5cGVdO1xuXHRcdFx0fTtcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBDcmVhdGUgYSBjaGlsZCByZWdpc3RyeSB3aG9lcyByZWdpc3RlcmVkIGNvbnZlcnRlcnMgcmVtYWluIGxvY2FsLCB3aGlsZVxuXHRcdFx0ICogYWJsZSB0byBsb29rdXAgY29udmVydGVycyBmcm9tIGl0cyBwYXJlbnQuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHJldHVybnMgY2hpbGQgTUlNRSByZWdpc3RyeVxuXHRcdFx0ICovXG5cdFx0XHR0aGlzLmNoaWxkID0gZnVuY3Rpb24gY2hpbGQoKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgUmVnaXN0cnkoT2JqZWN0LmNyZWF0ZShtaW1lcykpO1xuXHRcdFx0fTtcblxuXHRcdH1cblxuXHRcdHJlZ2lzdHJ5ID0gbmV3IFJlZ2lzdHJ5KHt9KTtcblxuXHRcdC8vIGluY2x1ZGUgcHJvdmlkZWQgc2VyaWFsaXplcnNcblx0XHRyZWdpc3RyeS5yZWdpc3RlcignYXBwbGljYXRpb24vaGFsJywgcmVxdWlyZSgnLi90eXBlL2FwcGxpY2F0aW9uL2hhbCcpKTtcblx0XHRyZWdpc3RyeS5yZWdpc3RlcignYXBwbGljYXRpb24vanNvbicsIHJlcXVpcmUoJy4vdHlwZS9hcHBsaWNhdGlvbi9qc29uJykpO1xuXHRcdHJlZ2lzdHJ5LnJlZ2lzdGVyKCdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLCByZXF1aXJlKCcuL3R5cGUvYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJykpO1xuXHRcdHJlZ2lzdHJ5LnJlZ2lzdGVyKCdtdWx0aXBhcnQvZm9ybS1kYXRhJywgcmVxdWlyZSgnLi90eXBlL211bHRpcGFydC9mb3JtLWRhdGEnKSk7XG5cdFx0cmVnaXN0cnkucmVnaXN0ZXIoJ3RleHQvcGxhaW4nLCByZXF1aXJlKCcuL3R5cGUvdGV4dC9wbGFpbicpKTtcblxuXHRcdHJlZ2lzdHJ5LnJlZ2lzdGVyKCcranNvbicsIHJlZ2lzdHJ5LmRlbGVnYXRlKCdhcHBsaWNhdGlvbi9qc29uJykpO1xuXG5cdFx0cmV0dXJuIHJlZ2lzdHJ5O1xuXG5cdH0pO1xuXG59KFxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbiAoZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSk7IH1cblx0Ly8gQm9pbGVycGxhdGUgZm9yIEFNRCBhbmQgTm9kZVxuKSk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSB0aGUgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnNcbiAqIEBsaWNlbnNlIE1JVCwgc2VlIExJQ0VOU0UudHh0IGZvciBkZXRhaWxzXG4gKlxuICogQGF1dGhvciBTY290dCBBbmRyZXdzXG4gKi9cblxuKGZ1bmN0aW9uIChkZWZpbmUpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdGRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuXG5cdFx0dmFyIHBhdGhQcmVmaXgsIHRlbXBsYXRlLCBmaW5kLCBsYXp5UHJvbWlzZSwgcmVzcG9uc2VQcm9taXNlLCB3aGVuO1xuXG5cdFx0cGF0aFByZWZpeCA9IHJlcXVpcmUoJy4uLy4uLy4uL2ludGVyY2VwdG9yL3BhdGhQcmVmaXgnKTtcblx0XHR0ZW1wbGF0ZSA9IHJlcXVpcmUoJy4uLy4uLy4uL2ludGVyY2VwdG9yL3RlbXBsYXRlJyk7XG5cdFx0ZmluZCA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWwvZmluZCcpO1xuXHRcdGxhenlQcm9taXNlID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbC9sYXp5UHJvbWlzZScpO1xuXHRcdHJlc3BvbnNlUHJvbWlzZSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWwvcmVzcG9uc2VQcm9taXNlJyk7XG5cdFx0d2hlbiA9IHJlcXVpcmUoJ3doZW4nKTtcblxuXHRcdGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KG9iaiwgbmFtZSwgdmFsdWUpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIG5hbWUsIHtcblx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdFx0XHR3cml0ZWFibGU6IHRydWVcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEh5cGVydGV4dCBBcHBsaWNhdGlvbiBMYW5ndWFnZSBzZXJpYWxpemVyXG5cdFx0ICpcblx0XHQgKiBJbXBsZW1lbnRlZCB0byBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQta2VsbHktanNvbi1oYWwtMDZcblx0XHQgKlxuXHRcdCAqIEFzIHRoZSBzcGVjIGlzIHN0aWxsIGEgZHJhZnQsIHRoaXMgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1cGRhdGVkIGFzIHRoZVxuXHRcdCAqIHNwZWMgZXZvbHZlc1xuXHRcdCAqXG5cdFx0ICogT2JqZWN0cyBhcmUgcmVhZCBhcyBIQUwgaW5kZXhpbmcgbGlua3MgYW5kIGVtYmVkZGVkIG9iamVjdHMgb24gdG8gdGhlXG5cdFx0ICogcmVzb3VyY2UuIE9iamVjdHMgYXJlIHdyaXR0ZW4gYXMgcGxhaW4gSlNPTi5cblx0XHQgKlxuXHRcdCAqIEVtYmVkZGVkIHJlbGF0aW9uc2hpcHMgYXJlIGluZGV4ZWQgb250byB0aGUgcmVzb3VyY2UgYnkgdGhlIHJlbGF0aW9uc2hpcFxuXHRcdCAqIGFzIGEgcHJvbWlzZSBmb3IgdGhlIHJlbGF0ZWQgcmVzb3VyY2UuXG5cdFx0ICpcblx0XHQgKiBMaW5rcyBhcmUgaW5kZXhlZCBvbnRvIHRoZSByZXNvdXJjZSBhcyBhIGxhenkgcHJvbWlzZSB0aGF0IHdpbGwgR0VUIHRoZVxuXHRcdCAqIHJlc291cmNlIHdoZW4gYSBoYW5kbGVyIGlzIGZpcnN0IHJlZ2lzdGVyZWQgb24gdGhlIHByb21pc2UuXG5cdFx0ICpcblx0XHQgKiBBIGByZXF1ZXN0Rm9yYCBtZXRob2QgaXMgYWRkZWQgdG8gdGhlIGVudGl0eSB0byBtYWtlIGEgcmVxdWVzdCBmb3IgdGhlXG5cdFx0ICogcmVsYXRpb25zaGlwLlxuXHRcdCAqXG5cdFx0ICogQSBgY2xpZW50Rm9yYCBtZXRob2QgaXMgYWRkZWQgdG8gdGhlIGVudGl0eSB0byBnZXQgYSBmdWxsIENsaWVudCBmb3IgYVxuXHRcdCAqIHJlbGF0aW9uc2hpcC5cblx0XHQgKlxuXHRcdCAqIFRoZSBgX2xpbmtzYCBhbmQgYF9lbWJlZGRlZGAgcHJvcGVydGllcyBvbiB0aGUgcmVzb3VyY2UgYXJlIG1hZGVcblx0XHQgKiBub24tZW51bWVyYWJsZS5cblx0XHQgKi9cblx0XHRyZXR1cm4ge1xuXG5cdFx0XHRyZWFkOiBmdW5jdGlvbiAoc3RyLCBvcHRzKSB7XG5cdFx0XHRcdHZhciBjbGllbnQsIGNvbnNvbGU7XG5cblx0XHRcdFx0b3B0cyA9IG9wdHMgfHwge307XG5cdFx0XHRcdGNsaWVudCA9IG9wdHMuY2xpZW50O1xuXHRcdFx0XHRjb25zb2xlID0gb3B0cy5jb25zb2xlIHx8IGNvbnNvbGU7XG5cblx0XHRcdFx0ZnVuY3Rpb24gZGVwcmVjYXRpb25XYXJuaW5nKHJlbGF0aW9uc2hpcCwgZGVwcmVjYXRpb24pIHtcblx0XHRcdFx0XHRpZiAoZGVwcmVjYXRpb24gJiYgY29uc29sZSAmJiBjb25zb2xlLndhcm4gfHwgY29uc29sZS5sb2cpIHtcblx0XHRcdFx0XHRcdChjb25zb2xlLndhcm4gfHwgY29uc29sZS5sb2cpLmNhbGwoY29uc29sZSwgJ1JlbGF0aW9uc2hpcCBcXCcnICsgcmVsYXRpb25zaGlwICsgJ1xcJyBpcyBkZXByZWNhdGVkLCBzZWUgJyArIGRlcHJlY2F0aW9uKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gb3B0cy5yZWdpc3RyeS5sb29rdXAob3B0cy5taW1lLnN1ZmZpeCkudGhlbihmdW5jdGlvbiAoY29udmVydGVyKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHdoZW4oY29udmVydGVyLnJlYWQoc3RyLCBvcHRzKSkudGhlbihmdW5jdGlvbiAocm9vdCkge1xuXG5cdFx0XHRcdFx0XHRmaW5kLmZpbmRQcm9wZXJ0aWVzKHJvb3QsICdfZW1iZWRkZWQnLCBmdW5jdGlvbiAoZW1iZWRkZWQsIHJlc291cmNlLCBuYW1lKSB7XG5cdFx0XHRcdFx0XHRcdE9iamVjdC5rZXlzKGVtYmVkZGVkKS5mb3JFYWNoKGZ1bmN0aW9uIChyZWxhdGlvbnNoaXApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAocmVsYXRpb25zaGlwIGluIHJlc291cmNlKSB7IHJldHVybjsgfVxuXHRcdFx0XHRcdFx0XHRcdHZhciByZWxhdGVkID0gcmVzcG9uc2VQcm9taXNlKHtcblx0XHRcdFx0XHRcdFx0XHRcdGVudGl0eTogZW1iZWRkZWRbcmVsYXRpb25zaGlwXVxuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdGRlZmluZVByb3BlcnR5KHJlc291cmNlLCByZWxhdGlvbnNoaXAsIHJlbGF0ZWQpO1xuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0ZGVmaW5lUHJvcGVydHkocmVzb3VyY2UsIG5hbWUsIGVtYmVkZGVkKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0ZmluZC5maW5kUHJvcGVydGllcyhyb290LCAnX2xpbmtzJywgZnVuY3Rpb24gKGxpbmtzLCByZXNvdXJjZSwgbmFtZSkge1xuXHRcdFx0XHRcdFx0XHRPYmplY3Qua2V5cyhsaW5rcykuZm9yRWFjaChmdW5jdGlvbiAocmVsYXRpb25zaGlwKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGxpbmsgPSBsaW5rc1tyZWxhdGlvbnNoaXBdO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChyZWxhdGlvbnNoaXAgaW4gcmVzb3VyY2UpIHsgcmV0dXJuOyB9XG5cdFx0XHRcdFx0XHRcdFx0ZGVmaW5lUHJvcGVydHkocmVzb3VyY2UsIHJlbGF0aW9uc2hpcCwgcmVzcG9uc2VQcm9taXNlLm1ha2UobGF6eVByb21pc2UoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKGxpbmsuZGVwcmVjYXRpb24pIHsgZGVwcmVjYXRpb25XYXJuaW5nKHJlbGF0aW9uc2hpcCwgbGluay5kZXByZWNhdGlvbik7IH1cblx0XHRcdFx0XHRcdFx0XHRcdGlmIChsaW5rLnRlbXBsYXRlZCA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdGVtcGxhdGUoY2xpZW50KSh7IHBhdGg6IGxpbmsuaHJlZiB9KTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBjbGllbnQoeyBwYXRoOiBsaW5rLmhyZWYgfSk7XG5cdFx0XHRcdFx0XHRcdFx0fSkpKTtcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdGRlZmluZVByb3BlcnR5KHJlc291cmNlLCBuYW1lLCBsaW5rcyk7XG5cdFx0XHRcdFx0XHRcdGRlZmluZVByb3BlcnR5KHJlc291cmNlLCAnY2xpZW50Rm9yJywgZnVuY3Rpb24gKHJlbGF0aW9uc2hpcCwgY2xpZW50T3ZlcnJpZGUpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgbGluayA9IGxpbmtzW3JlbGF0aW9uc2hpcF07XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCFsaW5rKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcmVsYXRpb25zaGlwOiAnICsgcmVsYXRpb25zaGlwKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGxpbmsuZGVwcmVjYXRpb24pIHsgZGVwcmVjYXRpb25XYXJuaW5nKHJlbGF0aW9uc2hpcCwgbGluay5kZXByZWNhdGlvbik7IH1cblx0XHRcdFx0XHRcdFx0XHRpZiAobGluay50ZW1wbGF0ZWQgPT09IHRydWUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiB0ZW1wbGF0ZShcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2xpZW50T3ZlcnJpZGUgfHwgY2xpZW50LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IHRlbXBsYXRlOiBsaW5rLmhyZWYgfVxuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHBhdGhQcmVmaXgoXG5cdFx0XHRcdFx0XHRcdFx0XHRjbGllbnRPdmVycmlkZSB8fCBjbGllbnQsXG5cdFx0XHRcdFx0XHRcdFx0XHR7IHByZWZpeDogbGluay5ocmVmIH1cblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0ZGVmaW5lUHJvcGVydHkocmVzb3VyY2UsICdyZXF1ZXN0Rm9yJywgZnVuY3Rpb24gKHJlbGF0aW9uc2hpcCwgcmVxdWVzdCwgY2xpZW50T3ZlcnJpZGUpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgY2xpZW50ID0gdGhpcy5jbGllbnRGb3IocmVsYXRpb25zaGlwLCBjbGllbnRPdmVycmlkZSk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGNsaWVudChyZXF1ZXN0KTtcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIHJvb3Q7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHR9LFxuXG5cdFx0XHR3cml0ZTogZnVuY3Rpb24gKG9iaiwgb3B0cykge1xuXHRcdFx0XHRyZXR1cm4gb3B0cy5yZWdpc3RyeS5sb29rdXAob3B0cy5taW1lLnN1ZmZpeCkudGhlbihmdW5jdGlvbiAoY29udmVydGVyKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNvbnZlcnRlci53cml0ZShvYmosIG9wdHMpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdH07XG5cdH0pO1xuXG59KFxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbiAoZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSk7IH1cblx0Ly8gQm9pbGVycGxhdGUgZm9yIEFNRCBhbmQgTm9kZVxuKSk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTItMjAxNSB0aGUgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnNcbiAqIEBsaWNlbnNlIE1JVCwgc2VlIExJQ0VOU0UudHh0IGZvciBkZXRhaWxzXG4gKlxuICogQGF1dGhvciBTY290dCBBbmRyZXdzXG4gKi9cblxuKGZ1bmN0aW9uIChkZWZpbmUpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdGRlZmluZShmdW5jdGlvbiAoLyogcmVxdWlyZSAqLykge1xuXG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlIGEgbmV3IEpTT04gY29udmVydGVyIHdpdGggY3VzdG9tIHJldml2ZXIvcmVwbGFjZXIuXG5cdFx0ICpcblx0XHQgKiBUaGUgZXh0ZW5kZWQgY29udmVydGVyIG11c3QgYmUgcHVibGlzaGVkIHRvIGEgTUlNRSByZWdpc3RyeSBpbiBvcmRlclxuXHRcdCAqIHRvIGJlIHVzZWQuIFRoZSBleGlzdGluZyBjb252ZXJ0ZXIgd2lsbCBub3QgYmUgbW9kaWZpZWQuXG5cdFx0ICpcblx0XHQgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0pTT05cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb259IFtyZXZpdmVyPXVuZGVmaW5lZF0gY3VzdG9tIEpTT04ucGFyc2UgcmV2aXZlclxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb258QXJyYXl9IFtyZXBsYWNlcj11bmRlZmluZWRdIGN1c3RvbSBKU09OLnN0cmluZ2lmeSByZXBsYWNlclxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGNyZWF0ZUNvbnZlcnRlcihyZXZpdmVyLCByZXBsYWNlcikge1xuXHRcdFx0cmV0dXJuIHtcblxuXHRcdFx0XHRyZWFkOiBmdW5jdGlvbiAoc3RyKSB7XG5cdFx0XHRcdFx0cmV0dXJuIEpTT04ucGFyc2Uoc3RyLCByZXZpdmVyKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHR3cml0ZTogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0XHRcdHJldHVybiBKU09OLnN0cmluZ2lmeShvYmosIHJlcGxhY2VyKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHRleHRlbmQ6IGNyZWF0ZUNvbnZlcnRlclxuXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHJldHVybiBjcmVhdGVDb252ZXJ0ZXIoKTtcblxuXHR9KTtcblxufShcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24gKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUpOyB9XG5cdC8vIEJvaWxlcnBsYXRlIGZvciBBTUQgYW5kIE5vZGVcbikpO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDEyIHRoZSBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9yc1xuICogQGxpY2Vuc2UgTUlULCBzZWUgTElDRU5TRS50eHQgZm9yIGRldGFpbHNcbiAqXG4gKiBAYXV0aG9yIFNjb3R0IEFuZHJld3NcbiAqL1xuXG4oZnVuY3Rpb24gKGRlZmluZSkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0ZGVmaW5lKGZ1bmN0aW9uICgvKiByZXF1aXJlICovKSB7XG5cblx0XHR2YXIgZW5jb2RlZFNwYWNlUkUsIHVybEVuY29kZWRTcGFjZVJFO1xuXG5cdFx0ZW5jb2RlZFNwYWNlUkUgPSAvJTIwL2c7XG5cdFx0dXJsRW5jb2RlZFNwYWNlUkUgPSAvXFwrL2c7XG5cblx0XHRmdW5jdGlvbiB1cmxFbmNvZGUoc3RyKSB7XG5cdFx0XHRzdHIgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyKTtcblx0XHRcdC8vIHNwZWMgc2F5cyBzcGFjZSBzaG91bGQgYmUgZW5jb2RlZCBhcyAnKydcblx0XHRcdHJldHVybiBzdHIucmVwbGFjZShlbmNvZGVkU3BhY2VSRSwgJysnKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1cmxEZWNvZGUoc3RyKSB7XG5cdFx0XHQvLyBzcGVjIHNheXMgc3BhY2Ugc2hvdWxkIGJlIGVuY29kZWQgYXMgJysnXG5cdFx0XHRzdHIgPSBzdHIucmVwbGFjZSh1cmxFbmNvZGVkU3BhY2VSRSwgJyAnKTtcblx0XHRcdHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhcHBlbmQoc3RyLCBuYW1lLCB2YWx1ZSkge1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRcdHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdFx0c3RyID0gYXBwZW5kKHN0ciwgbmFtZSwgdmFsdWUpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRpZiAoc3RyLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRzdHIgKz0gJyYnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0ciArPSB1cmxFbmNvZGUobmFtZSk7XG5cdFx0XHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0c3RyICs9ICc9JyArIHVybEVuY29kZSh2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBzdHI7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblxuXHRcdFx0cmVhZDogZnVuY3Rpb24gKHN0cikge1xuXHRcdFx0XHR2YXIgb2JqID0ge307XG5cdFx0XHRcdHN0ci5zcGxpdCgnJicpLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG5cdFx0XHRcdFx0dmFyIHBhaXIsIG5hbWUsIHZhbHVlO1xuXHRcdFx0XHRcdHBhaXIgPSBlbnRyeS5zcGxpdCgnPScpO1xuXHRcdFx0XHRcdG5hbWUgPSB1cmxEZWNvZGUocGFpclswXSk7XG5cdFx0XHRcdFx0aWYgKHBhaXIubGVuZ3RoID09PSAyKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IHVybERlY29kZShwYWlyWzFdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChuYW1lIGluIG9iaikge1xuXHRcdFx0XHRcdFx0aWYgKCFBcnJheS5pc0FycmF5KG9ialtuYW1lXSkpIHtcblx0XHRcdFx0XHRcdFx0Ly8gY29udmVydCB0byBhbiBhcnJheSwgcGVyc2VydmluZyBjdXJybmVudCB2YWx1ZVxuXHRcdFx0XHRcdFx0XHRvYmpbbmFtZV0gPSBbb2JqW25hbWVdXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG9ialtuYW1lXS5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRvYmpbbmFtZV0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm4gb2JqO1xuXHRcdFx0fSxcblxuXHRcdFx0d3JpdGU6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdFx0dmFyIHN0ciA9ICcnO1xuXHRcdFx0XHRPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRcdFx0XHRzdHIgPSBhcHBlbmQoc3RyLCBuYW1lLCBvYmpbbmFtZV0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmV0dXJuIHN0cjtcblx0XHRcdH1cblxuXHRcdH07XG5cdH0pO1xuXG59KFxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbiAoZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSk7IH1cblx0Ly8gQm9pbGVycGxhdGUgZm9yIEFNRCBhbmQgTm9kZVxuKSk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTQgdGhlIG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzXG4gKiBAbGljZW5zZSBNSVQsIHNlZSBMSUNFTlNFLnR4dCBmb3IgZGV0YWlsc1xuICpcbiAqIEBhdXRob3IgTWljaGFlbCBKYWNrc29uXG4gKi9cblxuLyogZ2xvYmFsIEZvcm1EYXRhLCBGaWxlLCBCbG9iICovXG5cbihmdW5jdGlvbiAoZGVmaW5lKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHRkZWZpbmUoZnVuY3Rpb24gKC8qIHJlcXVpcmUgKi8pIHtcblxuXHRcdGZ1bmN0aW9uIGlzRm9ybUVsZW1lbnQob2JqZWN0KSB7XG5cdFx0XHRyZXR1cm4gb2JqZWN0ICYmXG5cdFx0XHRcdG9iamVjdC5ub2RlVHlwZSA9PT0gMSAmJiAvLyBOb2RlLkVMRU1FTlRfTk9ERVxuXHRcdFx0XHRvYmplY3QudGFnTmFtZSA9PT0gJ0ZPUk0nO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNyZWF0ZUZvcm1EYXRhRnJvbU9iamVjdChvYmplY3QpIHtcblx0XHRcdHZhciBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuXG5cdFx0XHR2YXIgdmFsdWU7XG5cdFx0XHRmb3IgKHZhciBwcm9wZXJ0eSBpbiBvYmplY3QpIHtcblx0XHRcdFx0aWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG5cblx0XHRcdFx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBGaWxlKSB7XG5cdFx0XHRcdFx0XHRmb3JtRGF0YS5hcHBlbmQocHJvcGVydHksIHZhbHVlLCB2YWx1ZS5uYW1lKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgQmxvYikge1xuXHRcdFx0XHRcdFx0Zm9ybURhdGEuYXBwZW5kKHByb3BlcnR5LCB2YWx1ZSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGZvcm1EYXRhLmFwcGVuZChwcm9wZXJ0eSwgU3RyaW5nKHZhbHVlKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmb3JtRGF0YTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXG5cdFx0XHR3cml0ZTogZnVuY3Rpb24gKG9iamVjdCkge1xuXHRcdFx0XHRpZiAodHlwZW9mIEZvcm1EYXRhID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignVGhlIG11bHRpcGFydC9mb3JtLWRhdGEgbWltZSBzZXJpYWxpemVyIHJlcXVpcmVzIEZvcm1EYXRhIHN1cHBvcnQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQgRm9ybURhdGEgZGlyZWN0bHkuXG5cdFx0XHRcdGlmIChvYmplY3QgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuXHRcdFx0XHRcdHJldHVybiBvYmplY3Q7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0IDxmb3JtPiBlbGVtZW50cy5cblx0XHRcdFx0aWYgKGlzRm9ybUVsZW1lbnQob2JqZWN0KSkge1xuXHRcdFx0XHRcdHJldHVybiBuZXcgRm9ybURhdGEob2JqZWN0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQgcGxhaW4gb2JqZWN0cywgbWF5IGNvbnRhaW4gRmlsZS9CbG9iIGFzIHZhbHVlLlxuXHRcdFx0XHRpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNyZWF0ZUZvcm1EYXRhRnJvbU9iamVjdChvYmplY3QpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gY3JlYXRlIEZvcm1EYXRhIGZyb20gb2JqZWN0ICcgKyBvYmplY3QpO1xuXHRcdFx0fVxuXG5cdFx0fTtcblx0fSk7XG5cbn0oXG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uIChmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKTsgfVxuXHQvLyBCb2lsZXJwbGF0ZSBmb3IgQU1EIGFuZCBOb2RlXG4pKTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxMiB0aGUgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnNcbiAqIEBsaWNlbnNlIE1JVCwgc2VlIExJQ0VOU0UudHh0IGZvciBkZXRhaWxzXG4gKlxuICogQGF1dGhvciBTY290dCBBbmRyZXdzXG4gKi9cblxuKGZ1bmN0aW9uIChkZWZpbmUpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdGRlZmluZShmdW5jdGlvbiAoLyogcmVxdWlyZSAqLykge1xuXG5cdFx0cmV0dXJuIHtcblxuXHRcdFx0cmVhZDogZnVuY3Rpb24gKHN0cikge1xuXHRcdFx0XHRyZXR1cm4gc3RyO1xuXHRcdFx0fSxcblxuXHRcdFx0d3JpdGU6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdFx0cmV0dXJuIG9iai50b1N0cmluZygpO1xuXHRcdFx0fVxuXG5cdFx0fTtcblx0fSk7XG5cbn0oXG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uIChmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKTsgfVxuXHQvLyBCb2lsZXJwbGF0ZSBmb3IgQU1EIGFuZCBOb2RlXG4pKTtcbiIsIi8qKiBAbGljZW5zZSBNSVQgTGljZW5zZSAoYykgY29weXJpZ2h0IDIwMTAtMjAxNCBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9ycyAqL1xuLyoqIEBhdXRob3IgQnJpYW4gQ2F2YWxpZXIgKi9cbi8qKiBAYXV0aG9yIEpvaG4gSGFubiAqL1xuXG4oZnVuY3Rpb24oZGVmaW5lKSB7ICd1c2Ugc3RyaWN0JztcbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuXG5cdHZhciBtYWtlUHJvbWlzZSA9IHJlcXVpcmUoJy4vbWFrZVByb21pc2UnKTtcblx0dmFyIFNjaGVkdWxlciA9IHJlcXVpcmUoJy4vU2NoZWR1bGVyJyk7XG5cdHZhciBhc3luYyA9IHJlcXVpcmUoJy4vZW52JykuYXNhcDtcblxuXHRyZXR1cm4gbWFrZVByb21pc2Uoe1xuXHRcdHNjaGVkdWxlcjogbmV3IFNjaGVkdWxlcihhc3luYylcblx0fSk7XG5cbn0pO1xufSkodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24gKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUpOyB9KTtcbiIsIi8qKiBAbGljZW5zZSBNSVQgTGljZW5zZSAoYykgY29weXJpZ2h0IDIwMTAtMjAxNCBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9ycyAqL1xuLyoqIEBhdXRob3IgQnJpYW4gQ2F2YWxpZXIgKi9cbi8qKiBAYXV0aG9yIEpvaG4gSGFubiAqL1xuXG4oZnVuY3Rpb24oZGVmaW5lKSB7ICd1c2Ugc3RyaWN0JztcbmRlZmluZShmdW5jdGlvbigpIHtcblxuXHQvLyBDcmVkaXQgdG8gVHdpc29sIChodHRwczovL2dpdGh1Yi5jb20vVHdpc29sKSBmb3Igc3VnZ2VzdGluZ1xuXHQvLyB0aGlzIHR5cGUgb2YgZXh0ZW5zaWJsZSBxdWV1ZSArIHRyYW1wb2xpbmUgYXBwcm9hY2ggZm9yIG5leHQtdGljayBjb25mbGF0aW9uLlxuXG5cdC8qKlxuXHQgKiBBc3luYyB0YXNrIHNjaGVkdWxlclxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBhc3luYyBmdW5jdGlvbiB0byBzY2hlZHVsZSBhIHNpbmdsZSBhc3luYyBmdW5jdGlvblxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIFNjaGVkdWxlcihhc3luYykge1xuXHRcdHRoaXMuX2FzeW5jID0gYXN5bmM7XG5cdFx0dGhpcy5fcnVubmluZyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5fcXVldWUgPSB0aGlzO1xuXHRcdHRoaXMuX3F1ZXVlTGVuID0gMDtcblx0XHR0aGlzLl9hZnRlclF1ZXVlID0ge307XG5cdFx0dGhpcy5fYWZ0ZXJRdWV1ZUxlbiA9IDA7XG5cblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0dGhpcy5kcmFpbiA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0c2VsZi5fZHJhaW4oKTtcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEVucXVldWUgYSB0YXNrXG5cdCAqIEBwYXJhbSB7eyBydW46ZnVuY3Rpb24gfX0gdGFza1xuXHQgKi9cblx0U2NoZWR1bGVyLnByb3RvdHlwZS5lbnF1ZXVlID0gZnVuY3Rpb24odGFzaykge1xuXHRcdHRoaXMuX3F1ZXVlW3RoaXMuX3F1ZXVlTGVuKytdID0gdGFzaztcblx0XHR0aGlzLnJ1bigpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBFbnF1ZXVlIGEgdGFzayB0byBydW4gYWZ0ZXIgdGhlIG1haW4gdGFzayBxdWV1ZVxuXHQgKiBAcGFyYW0ge3sgcnVuOmZ1bmN0aW9uIH19IHRhc2tcblx0ICovXG5cdFNjaGVkdWxlci5wcm90b3R5cGUuYWZ0ZXJRdWV1ZSA9IGZ1bmN0aW9uKHRhc2spIHtcblx0XHR0aGlzLl9hZnRlclF1ZXVlW3RoaXMuX2FmdGVyUXVldWVMZW4rK10gPSB0YXNrO1xuXHRcdHRoaXMucnVuKCk7XG5cdH07XG5cblx0U2NoZWR1bGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuX3J1bm5pbmcpIHtcblx0XHRcdHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xuXHRcdFx0dGhpcy5fYXN5bmModGhpcy5kcmFpbik7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmFpbiB0aGUgaGFuZGxlciBxdWV1ZSBlbnRpcmVseSwgYW5kIHRoZW4gdGhlIGFmdGVyIHF1ZXVlXG5cdCAqL1xuXHRTY2hlZHVsZXIucHJvdG90eXBlLl9kcmFpbiA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpID0gMDtcblx0XHRmb3IgKDsgaSA8IHRoaXMuX3F1ZXVlTGVuOyArK2kpIHtcblx0XHRcdHRoaXMuX3F1ZXVlW2ldLnJ1bigpO1xuXHRcdFx0dGhpcy5fcXVldWVbaV0gPSB2b2lkIDA7XG5cdFx0fVxuXG5cdFx0dGhpcy5fcXVldWVMZW4gPSAwO1xuXHRcdHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCB0aGlzLl9hZnRlclF1ZXVlTGVuOyArK2kpIHtcblx0XHRcdHRoaXMuX2FmdGVyUXVldWVbaV0ucnVuKCk7XG5cdFx0XHR0aGlzLl9hZnRlclF1ZXVlW2ldID0gdm9pZCAwO1xuXHRcdH1cblxuXHRcdHRoaXMuX2FmdGVyUXVldWVMZW4gPSAwO1xuXHR9O1xuXG5cdHJldHVybiBTY2hlZHVsZXI7XG5cbn0pO1xufSh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbihmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpOyB9KSk7XG4iLCIvKiogQGxpY2Vuc2UgTUlUIExpY2Vuc2UgKGMpIGNvcHlyaWdodCAyMDEwLTIwMTQgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnMgKi9cbi8qKiBAYXV0aG9yIEJyaWFuIENhdmFsaWVyICovXG4vKiogQGF1dGhvciBKb2huIEhhbm4gKi9cblxuKGZ1bmN0aW9uKGRlZmluZSkgeyAndXNlIHN0cmljdCc7XG5kZWZpbmUoZnVuY3Rpb24oKSB7XG5cblx0LyoqXG5cdCAqIEN1c3RvbSBlcnJvciB0eXBlIGZvciBwcm9taXNlcyByZWplY3RlZCBieSBwcm9taXNlLnRpbWVvdXRcblx0ICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2Vcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBUaW1lb3V0RXJyb3IgKG1lc3NhZ2UpIHtcblx0XHRFcnJvci5jYWxsKHRoaXMpO1xuXHRcdHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG5cdFx0dGhpcy5uYW1lID0gVGltZW91dEVycm9yLm5hbWU7XG5cdFx0aWYgKHR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0RXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgVGltZW91dEVycm9yKTtcblx0XHR9XG5cdH1cblxuXHRUaW1lb3V0RXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuXHRUaW1lb3V0RXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGltZW91dEVycm9yO1xuXG5cdHJldHVybiBUaW1lb3V0RXJyb3I7XG59KTtcbn0odHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24oZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTsgfSkpOyIsIi8qKiBAbGljZW5zZSBNSVQgTGljZW5zZSAoYykgY29weXJpZ2h0IDIwMTAtMjAxNCBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9ycyAqL1xuLyoqIEBhdXRob3IgQnJpYW4gQ2F2YWxpZXIgKi9cbi8qKiBAYXV0aG9yIEpvaG4gSGFubiAqL1xuXG4oZnVuY3Rpb24oZGVmaW5lKSB7ICd1c2Ugc3RyaWN0JztcbmRlZmluZShmdW5jdGlvbigpIHtcblxuXHRtYWtlQXBwbHkudHJ5Q2F0Y2hSZXNvbHZlID0gdHJ5Q2F0Y2hSZXNvbHZlO1xuXG5cdHJldHVybiBtYWtlQXBwbHk7XG5cblx0ZnVuY3Rpb24gbWFrZUFwcGx5KFByb21pc2UsIGNhbGwpIHtcblx0XHRpZihhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuXHRcdFx0Y2FsbCA9IHRyeUNhdGNoUmVzb2x2ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYXBwbHk7XG5cblx0XHRmdW5jdGlvbiBhcHBseShmLCB0aGlzQXJnLCBhcmdzKSB7XG5cdFx0XHR2YXIgcCA9IFByb21pc2UuX2RlZmVyKCk7XG5cdFx0XHR2YXIgbCA9IGFyZ3MubGVuZ3RoO1xuXHRcdFx0dmFyIHBhcmFtcyA9IG5ldyBBcnJheShsKTtcblx0XHRcdGNhbGxBbmRSZXNvbHZlKHsgZjpmLCB0aGlzQXJnOnRoaXNBcmcsIGFyZ3M6YXJncywgcGFyYW1zOnBhcmFtcywgaTpsLTEsIGNhbGw6Y2FsbCB9LCBwLl9oYW5kbGVyKTtcblxuXHRcdFx0cmV0dXJuIHA7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY2FsbEFuZFJlc29sdmUoYywgaCkge1xuXHRcdFx0aWYoYy5pIDwgMCkge1xuXHRcdFx0XHRyZXR1cm4gY2FsbChjLmYsIGMudGhpc0FyZywgYy5wYXJhbXMsIGgpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgaGFuZGxlciA9IFByb21pc2UuX2hhbmRsZXIoYy5hcmdzW2MuaV0pO1xuXHRcdFx0aGFuZGxlci5mb2xkKGNhbGxBbmRSZXNvbHZlTmV4dCwgYywgdm9pZCAwLCBoKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjYWxsQW5kUmVzb2x2ZU5leHQoYywgeCwgaCkge1xuXHRcdFx0Yy5wYXJhbXNbYy5pXSA9IHg7XG5cdFx0XHRjLmkgLT0gMTtcblx0XHRcdGNhbGxBbmRSZXNvbHZlKGMsIGgpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHRyeUNhdGNoUmVzb2x2ZShmLCB0aGlzQXJnLCBhcmdzLCByZXNvbHZlcikge1xuXHRcdHRyeSB7XG5cdFx0XHRyZXNvbHZlci5yZXNvbHZlKGYuYXBwbHkodGhpc0FyZywgYXJncykpO1xuXHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0cmVzb2x2ZXIucmVqZWN0KGUpO1xuXHRcdH1cblx0fVxuXG59KTtcbn0odHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24oZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTsgfSkpO1xuXG5cbiIsIi8qKiBAbGljZW5zZSBNSVQgTGljZW5zZSAoYykgY29weXJpZ2h0IDIwMTAtMjAxNCBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9ycyAqL1xuLyoqIEBhdXRob3IgQnJpYW4gQ2F2YWxpZXIgKi9cbi8qKiBAYXV0aG9yIEpvaG4gSGFubiAqL1xuXG4oZnVuY3Rpb24oZGVmaW5lKSB7ICd1c2Ugc3RyaWN0JztcbmRlZmluZShmdW5jdGlvbihyZXF1aXJlKSB7XG5cblx0dmFyIHN0YXRlID0gcmVxdWlyZSgnLi4vc3RhdGUnKTtcblx0dmFyIGFwcGxpZXIgPSByZXF1aXJlKCcuLi9hcHBseScpO1xuXG5cdHJldHVybiBmdW5jdGlvbiBhcnJheShQcm9taXNlKSB7XG5cblx0XHR2YXIgYXBwbHlGb2xkID0gYXBwbGllcihQcm9taXNlKTtcblx0XHR2YXIgdG9Qcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlO1xuXHRcdHZhciBhbGwgPSBQcm9taXNlLmFsbDtcblxuXHRcdHZhciBhciA9IEFycmF5LnByb3RvdHlwZS5yZWR1Y2U7XG5cdFx0dmFyIGFyciA9IEFycmF5LnByb3RvdHlwZS5yZWR1Y2VSaWdodDtcblx0XHR2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cblx0XHQvLyBBZGRpdGlvbmFsIGFycmF5IGNvbWJpbmF0b3JzXG5cblx0XHRQcm9taXNlLmFueSA9IGFueTtcblx0XHRQcm9taXNlLnNvbWUgPSBzb21lO1xuXHRcdFByb21pc2Uuc2V0dGxlID0gc2V0dGxlO1xuXG5cdFx0UHJvbWlzZS5tYXAgPSBtYXA7XG5cdFx0UHJvbWlzZS5maWx0ZXIgPSBmaWx0ZXI7XG5cdFx0UHJvbWlzZS5yZWR1Y2UgPSByZWR1Y2U7XG5cdFx0UHJvbWlzZS5yZWR1Y2VSaWdodCA9IHJlZHVjZVJpZ2h0O1xuXG5cdFx0LyoqXG5cdFx0ICogV2hlbiB0aGlzIHByb21pc2UgZnVsZmlsbHMgd2l0aCBhbiBhcnJheSwgZG9cblx0XHQgKiBvbkZ1bGZpbGxlZC5hcHBseSh2b2lkIDAsIGFycmF5KVxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uRnVsZmlsbGVkIGZ1bmN0aW9uIHRvIGFwcGx5XG5cdFx0ICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2UgZm9yIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgb25GdWxmaWxsZWRcblx0XHQgKi9cblx0XHRQcm9taXNlLnByb3RvdHlwZS5zcHJlYWQgPSBmdW5jdGlvbihvbkZ1bGZpbGxlZCkge1xuXHRcdFx0cmV0dXJuIHRoaXMudGhlbihhbGwpLnRoZW4oZnVuY3Rpb24oYXJyYXkpIHtcblx0XHRcdFx0cmV0dXJuIG9uRnVsZmlsbGVkLmFwcGx5KHRoaXMsIGFycmF5KTtcblx0XHRcdH0pO1xuXHRcdH07XG5cblx0XHRyZXR1cm4gUHJvbWlzZTtcblxuXHRcdC8qKlxuXHRcdCAqIE9uZS13aW5uZXIgY29tcGV0aXRpdmUgcmFjZS5cblx0XHQgKiBSZXR1cm4gYSBwcm9taXNlIHRoYXQgd2lsbCBmdWxmaWxsIHdoZW4gb25lIG9mIHRoZSBwcm9taXNlc1xuXHRcdCAqIGluIHRoZSBpbnB1dCBhcnJheSBmdWxmaWxscywgb3Igd2lsbCByZWplY3Qgd2hlbiBhbGwgcHJvbWlzZXNcblx0XHQgKiBoYXZlIHJlamVjdGVkLlxuXHRcdCAqIEBwYXJhbSB7YXJyYXl9IHByb21pc2VzXG5cdFx0ICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2UgZm9yIHRoZSBmaXJzdCBmdWxmaWxsZWQgdmFsdWVcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBhbnkocHJvbWlzZXMpIHtcblx0XHRcdHZhciBwID0gUHJvbWlzZS5fZGVmZXIoKTtcblx0XHRcdHZhciByZXNvbHZlciA9IHAuX2hhbmRsZXI7XG5cdFx0XHR2YXIgbCA9IHByb21pc2VzLmxlbmd0aD4+PjA7XG5cblx0XHRcdHZhciBwZW5kaW5nID0gbDtcblx0XHRcdHZhciBlcnJvcnMgPSBbXTtcblxuXHRcdFx0Zm9yICh2YXIgaCwgeCwgaSA9IDA7IGkgPCBsOyArK2kpIHtcblx0XHRcdFx0eCA9IHByb21pc2VzW2ldO1xuXHRcdFx0XHRpZih4ID09PSB2b2lkIDAgJiYgIShpIGluIHByb21pc2VzKSkge1xuXHRcdFx0XHRcdC0tcGVuZGluZztcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGggPSBQcm9taXNlLl9oYW5kbGVyKHgpO1xuXHRcdFx0XHRpZihoLnN0YXRlKCkgPiAwKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZXIuYmVjb21lKGgpO1xuXHRcdFx0XHRcdFByb21pc2UuX3Zpc2l0UmVtYWluaW5nKHByb21pc2VzLCBpLCBoKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRoLnZpc2l0KHJlc29sdmVyLCBoYW5kbGVGdWxmaWxsLCBoYW5kbGVSZWplY3QpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmKHBlbmRpbmcgPT09IDApIHtcblx0XHRcdFx0cmVzb2x2ZXIucmVqZWN0KG5ldyBSYW5nZUVycm9yKCdhbnkoKTogYXJyYXkgbXVzdCBub3QgYmUgZW1wdHknKSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwO1xuXG5cdFx0XHRmdW5jdGlvbiBoYW5kbGVGdWxmaWxsKHgpIHtcblx0XHRcdFx0Lypqc2hpbnQgdmFsaWR0aGlzOnRydWUqL1xuXHRcdFx0XHRlcnJvcnMgPSBudWxsO1xuXHRcdFx0XHR0aGlzLnJlc29sdmUoeCk7IC8vIHRoaXMgPT09IHJlc29sdmVyXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGhhbmRsZVJlamVjdChlKSB7XG5cdFx0XHRcdC8qanNoaW50IHZhbGlkdGhpczp0cnVlKi9cblx0XHRcdFx0aWYodGhpcy5yZXNvbHZlZCkgeyAvLyB0aGlzID09PSByZXNvbHZlclxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGVycm9ycy5wdXNoKGUpO1xuXHRcdFx0XHRpZigtLXBlbmRpbmcgPT09IDApIHtcblx0XHRcdFx0XHR0aGlzLnJlamVjdChlcnJvcnMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogTi13aW5uZXIgY29tcGV0aXRpdmUgcmFjZVxuXHRcdCAqIFJldHVybiBhIHByb21pc2UgdGhhdCB3aWxsIGZ1bGZpbGwgd2hlbiBuIGlucHV0IHByb21pc2VzIGhhdmVcblx0XHQgKiBmdWxmaWxsZWQsIG9yIHdpbGwgcmVqZWN0IHdoZW4gaXQgYmVjb21lcyBpbXBvc3NpYmxlIGZvciBuXG5cdFx0ICogaW5wdXQgcHJvbWlzZXMgdG8gZnVsZmlsbCAoaWUgd2hlbiBwcm9taXNlcy5sZW5ndGggLSBuICsgMVxuXHRcdCAqIGhhdmUgcmVqZWN0ZWQpXG5cdFx0ICogQHBhcmFtIHthcnJheX0gcHJvbWlzZXNcblx0XHQgKiBAcGFyYW0ge251bWJlcn0gblxuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIGZvciB0aGUgZWFybGllc3QgbiBmdWxmaWxsbWVudCB2YWx1ZXNcblx0XHQgKlxuXHRcdCAqIEBkZXByZWNhdGVkXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gc29tZShwcm9taXNlcywgbikge1xuXHRcdFx0Lypqc2hpbnQgbWF4Y29tcGxleGl0eTo3Ki9cblx0XHRcdHZhciBwID0gUHJvbWlzZS5fZGVmZXIoKTtcblx0XHRcdHZhciByZXNvbHZlciA9IHAuX2hhbmRsZXI7XG5cblx0XHRcdHZhciByZXN1bHRzID0gW107XG5cdFx0XHR2YXIgZXJyb3JzID0gW107XG5cblx0XHRcdHZhciBsID0gcHJvbWlzZXMubGVuZ3RoPj4+MDtcblx0XHRcdHZhciBuRnVsZmlsbCA9IDA7XG5cdFx0XHR2YXIgblJlamVjdDtcblx0XHRcdHZhciB4LCBpOyAvLyByZXVzZWQgaW4gYm90aCBmb3IoKSBsb29wc1xuXG5cdFx0XHQvLyBGaXJzdCBwYXNzOiBjb3VudCBhY3R1YWwgYXJyYXkgaXRlbXNcblx0XHRcdGZvcihpPTA7IGk8bDsgKytpKSB7XG5cdFx0XHRcdHggPSBwcm9taXNlc1tpXTtcblx0XHRcdFx0aWYoeCA9PT0gdm9pZCAwICYmICEoaSBpbiBwcm9taXNlcykpIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHQrK25GdWxmaWxsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21wdXRlIGFjdHVhbCBnb2Fsc1xuXHRcdFx0biA9IE1hdGgubWF4KG4sIDApO1xuXHRcdFx0blJlamVjdCA9IChuRnVsZmlsbCAtIG4gKyAxKTtcblx0XHRcdG5GdWxmaWxsID0gTWF0aC5taW4obiwgbkZ1bGZpbGwpO1xuXG5cdFx0XHRpZihuID4gbkZ1bGZpbGwpIHtcblx0XHRcdFx0cmVzb2x2ZXIucmVqZWN0KG5ldyBSYW5nZUVycm9yKCdzb21lKCk6IGFycmF5IG11c3QgY29udGFpbiBhdCBsZWFzdCAnXG5cdFx0XHRcdCsgbiArICcgaXRlbShzKSwgYnV0IGhhZCAnICsgbkZ1bGZpbGwpKTtcblx0XHRcdH0gZWxzZSBpZihuRnVsZmlsbCA9PT0gMCkge1xuXHRcdFx0XHRyZXNvbHZlci5yZXNvbHZlKHJlc3VsdHMpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZWNvbmQgcGFzczogb2JzZXJ2ZSBlYWNoIGFycmF5IGl0ZW0sIG1ha2UgcHJvZ3Jlc3MgdG93YXJkIGdvYWxzXG5cdFx0XHRmb3IoaT0wOyBpPGw7ICsraSkge1xuXHRcdFx0XHR4ID0gcHJvbWlzZXNbaV07XG5cdFx0XHRcdGlmKHggPT09IHZvaWQgMCAmJiAhKGkgaW4gcHJvbWlzZXMpKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRQcm9taXNlLl9oYW5kbGVyKHgpLnZpc2l0KHJlc29sdmVyLCBmdWxmaWxsLCByZWplY3QsIHJlc29sdmVyLm5vdGlmeSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwO1xuXG5cdFx0XHRmdW5jdGlvbiBmdWxmaWxsKHgpIHtcblx0XHRcdFx0Lypqc2hpbnQgdmFsaWR0aGlzOnRydWUqL1xuXHRcdFx0XHRpZih0aGlzLnJlc29sdmVkKSB7IC8vIHRoaXMgPT09IHJlc29sdmVyXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVzdWx0cy5wdXNoKHgpO1xuXHRcdFx0XHRpZigtLW5GdWxmaWxsID09PSAwKSB7XG5cdFx0XHRcdFx0ZXJyb3JzID0gbnVsbDtcblx0XHRcdFx0XHR0aGlzLnJlc29sdmUocmVzdWx0cyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gcmVqZWN0KGUpIHtcblx0XHRcdFx0Lypqc2hpbnQgdmFsaWR0aGlzOnRydWUqL1xuXHRcdFx0XHRpZih0aGlzLnJlc29sdmVkKSB7IC8vIHRoaXMgPT09IHJlc29sdmVyXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZXJyb3JzLnB1c2goZSk7XG5cdFx0XHRcdGlmKC0tblJlamVjdCA9PT0gMCkge1xuXHRcdFx0XHRcdHJlc3VsdHMgPSBudWxsO1xuXHRcdFx0XHRcdHRoaXMucmVqZWN0KGVycm9ycyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBBcHBseSBmIHRvIHRoZSB2YWx1ZSBvZiBlYWNoIHByb21pc2UgaW4gYSBsaXN0IG9mIHByb21pc2VzXG5cdFx0ICogYW5kIHJldHVybiBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgdGhlIHJlc3VsdHMuXG5cdFx0ICogQHBhcmFtIHthcnJheX0gcHJvbWlzZXNcblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9uKHg6KiwgaW5kZXg6TnVtYmVyKToqfSBmIG1hcHBpbmcgZnVuY3Rpb25cblx0XHQgKiBAcmV0dXJucyB7UHJvbWlzZX1cblx0XHQgKi9cblx0XHRmdW5jdGlvbiBtYXAocHJvbWlzZXMsIGYpIHtcblx0XHRcdHJldHVybiBQcm9taXNlLl90cmF2ZXJzZShmLCBwcm9taXNlcyk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogRmlsdGVyIHRoZSBwcm92aWRlZCBhcnJheSBvZiBwcm9taXNlcyB1c2luZyB0aGUgcHJvdmlkZWQgcHJlZGljYXRlLiAgSW5wdXQgbWF5XG5cdFx0ICogY29udGFpbiBwcm9taXNlcyBhbmQgdmFsdWVzXG5cdFx0ICogQHBhcmFtIHtBcnJheX0gcHJvbWlzZXMgYXJyYXkgb2YgcHJvbWlzZXMgYW5kIHZhbHVlc1xuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb24oeDoqLCBpbmRleDpOdW1iZXIpOmJvb2xlYW59IHByZWRpY2F0ZSBmaWx0ZXJpbmcgcHJlZGljYXRlLlxuXHRcdCAqICBNdXN0IHJldHVybiB0cnV0aHkgKG9yIHByb21pc2UgZm9yIHRydXRoeSkgZm9yIGl0ZW1zIHRvIHJldGFpbi5cblx0XHQgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSB0aGF0IHdpbGwgZnVsZmlsbCB3aXRoIGFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIGl0ZW1zXG5cdFx0ICogIGZvciB3aGljaCBwcmVkaWNhdGUgcmV0dXJuZWQgdHJ1dGh5LlxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGZpbHRlcihwcm9taXNlcywgcHJlZGljYXRlKSB7XG5cdFx0XHR2YXIgYSA9IHNsaWNlLmNhbGwocHJvbWlzZXMpO1xuXHRcdFx0cmV0dXJuIFByb21pc2UuX3RyYXZlcnNlKHByZWRpY2F0ZSwgYSkudGhlbihmdW5jdGlvbihrZWVwKSB7XG5cdFx0XHRcdHJldHVybiBmaWx0ZXJTeW5jKGEsIGtlZXApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZmlsdGVyU3luYyhwcm9taXNlcywga2VlcCkge1xuXHRcdFx0Ly8gU2FmZSBiZWNhdXNlIHdlIGtub3cgYWxsIHByb21pc2VzIGhhdmUgZnVsZmlsbGVkIGlmIHdlJ3ZlIG1hZGUgaXQgdGhpcyBmYXJcblx0XHRcdHZhciBsID0ga2VlcC5sZW5ndGg7XG5cdFx0XHR2YXIgZmlsdGVyZWQgPSBuZXcgQXJyYXkobCk7XG5cdFx0XHRmb3IodmFyIGk9MCwgaj0wOyBpPGw7ICsraSkge1xuXHRcdFx0XHRpZihrZWVwW2ldKSB7XG5cdFx0XHRcdFx0ZmlsdGVyZWRbaisrXSA9IFByb21pc2UuX2hhbmRsZXIocHJvbWlzZXNbaV0pLnZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRmaWx0ZXJlZC5sZW5ndGggPSBqO1xuXHRcdFx0cmV0dXJuIGZpbHRlcmVkO1xuXG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJuIGEgcHJvbWlzZSB0aGF0IHdpbGwgYWx3YXlzIGZ1bGZpbGwgd2l0aCBhbiBhcnJheSBjb250YWluaW5nXG5cdFx0ICogdGhlIG91dGNvbWUgc3RhdGVzIG9mIGFsbCBpbnB1dCBwcm9taXNlcy4gIFRoZSByZXR1cm5lZCBwcm9taXNlXG5cdFx0ICogd2lsbCBuZXZlciByZWplY3QuXG5cdFx0ICogQHBhcmFtIHtBcnJheX0gcHJvbWlzZXNcblx0XHQgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSBmb3IgYXJyYXkgb2Ygc2V0dGxlZCBzdGF0ZSBkZXNjcmlwdG9yc1xuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIHNldHRsZShwcm9taXNlcykge1xuXHRcdFx0cmV0dXJuIGFsbChwcm9taXNlcy5tYXAoc2V0dGxlT25lKSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc2V0dGxlT25lKHApIHtcblx0XHRcdHZhciBoID0gUHJvbWlzZS5faGFuZGxlcihwKTtcblx0XHRcdGlmKGguc3RhdGUoKSA9PT0gMCkge1xuXHRcdFx0XHRyZXR1cm4gdG9Qcm9taXNlKHApLnRoZW4oc3RhdGUuZnVsZmlsbGVkLCBzdGF0ZS5yZWplY3RlZCk7XG5cdFx0XHR9XG5cblx0XHRcdGguX3VucmVwb3J0KCk7XG5cdFx0XHRyZXR1cm4gc3RhdGUuaW5zcGVjdChoKTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBUcmFkaXRpb25hbCByZWR1Y2UgZnVuY3Rpb24sIHNpbWlsYXIgdG8gYEFycmF5LnByb3RvdHlwZS5yZWR1Y2UoKWAsIGJ1dFxuXHRcdCAqIGlucHV0IG1heSBjb250YWluIHByb21pc2VzIGFuZC9vciB2YWx1ZXMsIGFuZCByZWR1Y2VGdW5jXG5cdFx0ICogbWF5IHJldHVybiBlaXRoZXIgYSB2YWx1ZSBvciBhIHByb21pc2UsICphbmQqIGluaXRpYWxWYWx1ZSBtYXlcblx0XHQgKiBiZSBhIHByb21pc2UgZm9yIHRoZSBzdGFydGluZyB2YWx1ZS5cblx0XHQgKiBAcGFyYW0ge0FycmF5fFByb21pc2V9IHByb21pc2VzIGFycmF5IG9yIHByb21pc2UgZm9yIGFuIGFycmF5IG9mIGFueXRoaW5nLFxuXHRcdCAqICAgICAgbWF5IGNvbnRhaW4gYSBtaXggb2YgcHJvbWlzZXMgYW5kIHZhbHVlcy5cblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9uKGFjY3VtdWxhdGVkOiosIHg6KiwgaW5kZXg6TnVtYmVyKToqfSBmIHJlZHVjZSBmdW5jdGlvblxuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlfSB0aGF0IHdpbGwgcmVzb2x2ZSB0byB0aGUgZmluYWwgcmVkdWNlZCB2YWx1ZVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIHJlZHVjZShwcm9taXNlcywgZiAvKiwgaW5pdGlhbFZhbHVlICovKSB7XG5cdFx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhci5jYWxsKHByb21pc2VzLCBsaWZ0Q29tYmluZShmKSwgYXJndW1lbnRzWzJdKVxuXHRcdFx0XHRcdDogYXIuY2FsbChwcm9taXNlcywgbGlmdENvbWJpbmUoZikpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFRyYWRpdGlvbmFsIHJlZHVjZSBmdW5jdGlvbiwgc2ltaWxhciB0byBgQXJyYXkucHJvdG90eXBlLnJlZHVjZVJpZ2h0KClgLCBidXRcblx0XHQgKiBpbnB1dCBtYXkgY29udGFpbiBwcm9taXNlcyBhbmQvb3IgdmFsdWVzLCBhbmQgcmVkdWNlRnVuY1xuXHRcdCAqIG1heSByZXR1cm4gZWl0aGVyIGEgdmFsdWUgb3IgYSBwcm9taXNlLCAqYW5kKiBpbml0aWFsVmFsdWUgbWF5XG5cdFx0ICogYmUgYSBwcm9taXNlIGZvciB0aGUgc3RhcnRpbmcgdmFsdWUuXG5cdFx0ICogQHBhcmFtIHtBcnJheXxQcm9taXNlfSBwcm9taXNlcyBhcnJheSBvciBwcm9taXNlIGZvciBhbiBhcnJheSBvZiBhbnl0aGluZyxcblx0XHQgKiAgICAgIG1heSBjb250YWluIGEgbWl4IG9mIHByb21pc2VzIGFuZCB2YWx1ZXMuXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbihhY2N1bXVsYXRlZDoqLCB4OiosIGluZGV4Ok51bWJlcik6Kn0gZiByZWR1Y2UgZnVuY3Rpb25cblx0XHQgKiBAcmV0dXJucyB7UHJvbWlzZX0gdGhhdCB3aWxsIHJlc29sdmUgdG8gdGhlIGZpbmFsIHJlZHVjZWQgdmFsdWVcblx0XHQgKi9cblx0XHRmdW5jdGlvbiByZWR1Y2VSaWdodChwcm9taXNlcywgZiAvKiwgaW5pdGlhbFZhbHVlICovKSB7XG5cdFx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcnIuY2FsbChwcm9taXNlcywgbGlmdENvbWJpbmUoZiksIGFyZ3VtZW50c1syXSlcblx0XHRcdFx0XHQ6IGFyci5jYWxsKHByb21pc2VzLCBsaWZ0Q29tYmluZShmKSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gbGlmdENvbWJpbmUoZikge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHosIHgsIGkpIHtcblx0XHRcdFx0cmV0dXJuIGFwcGx5Rm9sZChmLCB2b2lkIDAsIFt6LHgsaV0pO1xuXHRcdFx0fTtcblx0XHR9XG5cdH07XG5cbn0pO1xufSh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbihmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKTsgfSkpO1xuIiwiLyoqIEBsaWNlbnNlIE1JVCBMaWNlbnNlIChjKSBjb3B5cmlnaHQgMjAxMC0yMDE0IG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzICovXG4vKiogQGF1dGhvciBCcmlhbiBDYXZhbGllciAqL1xuLyoqIEBhdXRob3IgSm9obiBIYW5uICovXG5cbihmdW5jdGlvbihkZWZpbmUpIHsgJ3VzZSBzdHJpY3QnO1xuZGVmaW5lKGZ1bmN0aW9uKCkge1xuXG5cdHJldHVybiBmdW5jdGlvbiBmbG93KFByb21pc2UpIHtcblxuXHRcdHZhciByZXNvbHZlID0gUHJvbWlzZS5yZXNvbHZlO1xuXHRcdHZhciByZWplY3QgPSBQcm9taXNlLnJlamVjdDtcblx0XHR2YXIgb3JpZ0NhdGNoID0gUHJvbWlzZS5wcm90b3R5cGVbJ2NhdGNoJ107XG5cblx0XHQvKipcblx0XHQgKiBIYW5kbGUgdGhlIHVsdGltYXRlIGZ1bGZpbGxtZW50IHZhbHVlIG9yIHJlamVjdGlvbiByZWFzb24sIGFuZCBhc3N1bWVcblx0XHQgKiByZXNwb25zaWJpbGl0eSBmb3IgYWxsIGVycm9ycy4gIElmIGFuIGVycm9yIHByb3BhZ2F0ZXMgb3V0IG9mIHJlc3VsdFxuXHRcdCAqIG9yIGhhbmRsZUZhdGFsRXJyb3IsIGl0IHdpbGwgYmUgcmV0aHJvd24gdG8gdGhlIGhvc3QsIHJlc3VsdGluZyBpbiBhXG5cdFx0ICogbG91ZCBzdGFjayB0cmFjayBvbiBtb3N0IHBsYXRmb3JtcyBhbmQgYSBjcmFzaCBvbiBzb21lLlxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb24/fSBvblJlc3VsdFxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb24/fSBvbkVycm9yXG5cdFx0ICogQHJldHVybnMge3VuZGVmaW5lZH1cblx0XHQgKi9cblx0XHRQcm9taXNlLnByb3RvdHlwZS5kb25lID0gZnVuY3Rpb24ob25SZXN1bHQsIG9uRXJyb3IpIHtcblx0XHRcdHRoaXMuX2hhbmRsZXIudmlzaXQodGhpcy5faGFuZGxlci5yZWNlaXZlciwgb25SZXN1bHQsIG9uRXJyb3IpO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBBZGQgRXJyb3ItdHlwZSBhbmQgcHJlZGljYXRlIG1hdGNoaW5nIHRvIGNhdGNoLiAgRXhhbXBsZXM6XG5cdFx0ICogcHJvbWlzZS5jYXRjaChUeXBlRXJyb3IsIGhhbmRsZVR5cGVFcnJvcilcblx0XHQgKiAgIC5jYXRjaChwcmVkaWNhdGUsIGhhbmRsZU1hdGNoZWRFcnJvcnMpXG5cdFx0ICogICAuY2F0Y2goaGFuZGxlUmVtYWluaW5nRXJyb3JzKVxuXHRcdCAqIEBwYXJhbSBvblJlamVjdGVkXG5cdFx0ICogQHJldHVybnMgeyp9XG5cdFx0ICovXG5cdFx0UHJvbWlzZS5wcm90b3R5cGVbJ2NhdGNoJ10gPSBQcm9taXNlLnByb3RvdHlwZS5vdGhlcndpc2UgPSBmdW5jdGlvbihvblJlamVjdGVkKSB7XG5cdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcblx0XHRcdFx0cmV0dXJuIG9yaWdDYXRjaC5jYWxsKHRoaXMsIG9uUmVqZWN0ZWQpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZih0eXBlb2Ygb25SZWplY3RlZCAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5lbnN1cmUocmVqZWN0SW52YWxpZFByZWRpY2F0ZSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvcmlnQ2F0Y2guY2FsbCh0aGlzLCBjcmVhdGVDYXRjaEZpbHRlcihhcmd1bWVudHNbMV0sIG9uUmVqZWN0ZWQpKTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogV3JhcHMgdGhlIHByb3ZpZGVkIGNhdGNoIGhhbmRsZXIsIHNvIHRoYXQgaXQgd2lsbCBvbmx5IGJlIGNhbGxlZFxuXHRcdCAqIGlmIHRoZSBwcmVkaWNhdGUgZXZhbHVhdGVzIHRydXRoeVxuXHRcdCAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBoYW5kbGVyXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbn0gcHJlZGljYXRlXG5cdFx0ICogQHJldHVybnMge2Z1bmN0aW9ufSBjb25kaXRpb25hbCBjYXRjaCBoYW5kbGVyXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gY3JlYXRlQ2F0Y2hGaWx0ZXIoaGFuZGxlciwgcHJlZGljYXRlKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRyZXR1cm4gZXZhbHVhdGVQcmVkaWNhdGUoZSwgcHJlZGljYXRlKVxuXHRcdFx0XHRcdD8gaGFuZGxlci5jYWxsKHRoaXMsIGUpXG5cdFx0XHRcdFx0OiByZWplY3QoZSk7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEVuc3VyZXMgdGhhdCBvbkZ1bGZpbGxlZE9yUmVqZWN0ZWQgd2lsbCBiZSBjYWxsZWQgcmVnYXJkbGVzcyBvZiB3aGV0aGVyXG5cdFx0ICogdGhpcyBwcm9taXNlIGlzIGZ1bGZpbGxlZCBvciByZWplY3RlZC4gIG9uRnVsZmlsbGVkT3JSZWplY3RlZCBXSUxMIE5PVFxuXHRcdCAqIHJlY2VpdmUgdGhlIHByb21pc2VzJyB2YWx1ZSBvciByZWFzb24uICBBbnkgcmV0dXJuZWQgdmFsdWUgd2lsbCBiZSBkaXNyZWdhcmRlZC5cblx0XHQgKiBvbkZ1bGZpbGxlZE9yUmVqZWN0ZWQgbWF5IHRocm93IG9yIHJldHVybiBhIHJlamVjdGVkIHByb21pc2UgdG8gc2lnbmFsXG5cdFx0ICogYW4gYWRkaXRpb25hbCBlcnJvci5cblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIGhhbmRsZXIgdG8gYmUgY2FsbGVkIHJlZ2FyZGxlc3Mgb2Zcblx0XHQgKiAgZnVsZmlsbG1lbnQgb3IgcmVqZWN0aW9uXG5cdFx0ICogQHJldHVybnMge1Byb21pc2V9XG5cdFx0ICovXG5cdFx0UHJvbWlzZS5wcm90b3R5cGVbJ2ZpbmFsbHknXSA9IFByb21pc2UucHJvdG90eXBlLmVuc3VyZSA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcblx0XHRcdGlmKHR5cGVvZiBoYW5kbGVyICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uKHgpIHtcblx0XHRcdFx0cmV0dXJuIHJ1blNpZGVFZmZlY3QoaGFuZGxlciwgdGhpcywgaWRlbnRpdHksIHgpO1xuXHRcdFx0fSwgZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRyZXR1cm4gcnVuU2lkZUVmZmVjdChoYW5kbGVyLCB0aGlzLCByZWplY3QsIGUpO1xuXHRcdFx0fSk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHJ1blNpZGVFZmZlY3QgKGhhbmRsZXIsIHRoaXNBcmcsIHByb3BhZ2F0ZSwgdmFsdWUpIHtcblx0XHRcdHZhciByZXN1bHQgPSBoYW5kbGVyLmNhbGwodGhpc0FyZyk7XG5cdFx0XHRyZXR1cm4gbWF5YmVUaGVuYWJsZShyZXN1bHQpXG5cdFx0XHRcdD8gcHJvcGFnYXRlVmFsdWUocmVzdWx0LCBwcm9wYWdhdGUsIHZhbHVlKVxuXHRcdFx0XHQ6IHByb3BhZ2F0ZSh2YWx1ZSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcHJvcGFnYXRlVmFsdWUgKHJlc3VsdCwgcHJvcGFnYXRlLCB4KSB7XG5cdFx0XHRyZXR1cm4gcmVzb2x2ZShyZXN1bHQpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gcHJvcGFnYXRlKHgpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogUmVjb3ZlciBmcm9tIGEgZmFpbHVyZSBieSByZXR1cm5pbmcgYSBkZWZhdWx0VmFsdWUuICBJZiBkZWZhdWx0VmFsdWVcblx0XHQgKiBpcyBhIHByb21pc2UsIGl0J3MgZnVsZmlsbG1lbnQgdmFsdWUgd2lsbCBiZSB1c2VkLiAgSWYgZGVmYXVsdFZhbHVlIGlzXG5cdFx0ICogYSBwcm9taXNlIHRoYXQgcmVqZWN0cywgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCByZWplY3Qgd2l0aCB0aGVcblx0XHQgKiBzYW1lIHJlYXNvbi5cblx0XHQgKiBAcGFyYW0geyp9IGRlZmF1bHRWYWx1ZVxuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlfSBuZXcgcHJvbWlzZVxuXHRcdCAqL1xuXHRcdFByb21pc2UucHJvdG90eXBlWydlbHNlJ10gPSBQcm9taXNlLnByb3RvdHlwZS5vckVsc2UgPSBmdW5jdGlvbihkZWZhdWx0VmFsdWUpIHtcblx0XHRcdHJldHVybiB0aGlzLnRoZW4odm9pZCAwLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIGRlZmF1bHRWYWx1ZTtcblx0XHRcdH0pO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBTaG9ydGN1dCBmb3IgLnRoZW4oZnVuY3Rpb24oKSB7IHJldHVybiB2YWx1ZTsgfSlcblx0XHQgKiBAcGFyYW0gIHsqfSB2YWx1ZVxuXHRcdCAqIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSB0aGF0OlxuXHRcdCAqICAtIGlzIGZ1bGZpbGxlZCBpZiB2YWx1ZSBpcyBub3QgYSBwcm9taXNlLCBvclxuXHRcdCAqICAtIGlmIHZhbHVlIGlzIGEgcHJvbWlzZSwgd2lsbCBmdWxmaWxsIHdpdGggaXRzIHZhbHVlLCBvciByZWplY3Rcblx0XHQgKiAgICB3aXRoIGl0cyByZWFzb24uXG5cdFx0ICovXG5cdFx0UHJvbWlzZS5wcm90b3R5cGVbJ3lpZWxkJ10gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0fSk7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFJ1bnMgYSBzaWRlIGVmZmVjdCB3aGVuIHRoaXMgcHJvbWlzZSBmdWxmaWxscywgd2l0aG91dCBjaGFuZ2luZyB0aGVcblx0XHQgKiBmdWxmaWxsbWVudCB2YWx1ZS5cblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbkZ1bGZpbGxlZFNpZGVFZmZlY3Rcblx0XHQgKiBAcmV0dXJucyB7UHJvbWlzZX1cblx0XHQgKi9cblx0XHRQcm9taXNlLnByb3RvdHlwZS50YXAgPSBmdW5jdGlvbihvbkZ1bGZpbGxlZFNpZGVFZmZlY3QpIHtcblx0XHRcdHJldHVybiB0aGlzLnRoZW4ob25GdWxmaWxsZWRTaWRlRWZmZWN0KVsneWllbGQnXSh0aGlzKTtcblx0XHR9O1xuXG5cdFx0cmV0dXJuIFByb21pc2U7XG5cdH07XG5cblx0ZnVuY3Rpb24gcmVqZWN0SW52YWxpZFByZWRpY2F0ZSgpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdjYXRjaCBwcmVkaWNhdGUgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cdH1cblxuXHRmdW5jdGlvbiBldmFsdWF0ZVByZWRpY2F0ZShlLCBwcmVkaWNhdGUpIHtcblx0XHRyZXR1cm4gaXNFcnJvcihwcmVkaWNhdGUpID8gZSBpbnN0YW5jZW9mIHByZWRpY2F0ZSA6IHByZWRpY2F0ZShlKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGlzRXJyb3IocHJlZGljYXRlKSB7XG5cdFx0cmV0dXJuIHByZWRpY2F0ZSA9PT0gRXJyb3Jcblx0XHRcdHx8IChwcmVkaWNhdGUgIT0gbnVsbCAmJiBwcmVkaWNhdGUucHJvdG90eXBlIGluc3RhbmNlb2YgRXJyb3IpO1xuXHR9XG5cblx0ZnVuY3Rpb24gbWF5YmVUaGVuYWJsZSh4KSB7XG5cdFx0cmV0dXJuICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHggPT09ICdmdW5jdGlvbicpICYmIHggIT09IG51bGw7XG5cdH1cblxuXHRmdW5jdGlvbiBpZGVudGl0eSh4KSB7XG5cdFx0cmV0dXJuIHg7XG5cdH1cblxufSk7XG59KHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7IH0pKTtcbiIsIi8qKiBAbGljZW5zZSBNSVQgTGljZW5zZSAoYykgY29weXJpZ2h0IDIwMTAtMjAxNCBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9ycyAqL1xuLyoqIEBhdXRob3IgQnJpYW4gQ2F2YWxpZXIgKi9cbi8qKiBAYXV0aG9yIEpvaG4gSGFubiAqL1xuLyoqIEBhdXRob3IgSmVmZiBFc2NhbGFudGUgKi9cblxuKGZ1bmN0aW9uKGRlZmluZSkgeyAndXNlIHN0cmljdCc7XG5kZWZpbmUoZnVuY3Rpb24oKSB7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIGZvbGQoUHJvbWlzZSkge1xuXG5cdFx0UHJvbWlzZS5wcm90b3R5cGUuZm9sZCA9IGZ1bmN0aW9uKGYsIHopIHtcblx0XHRcdHZhciBwcm9taXNlID0gdGhpcy5fYmVnZXQoKTtcblxuXHRcdFx0dGhpcy5faGFuZGxlci5mb2xkKGZ1bmN0aW9uKHosIHgsIHRvKSB7XG5cdFx0XHRcdFByb21pc2UuX2hhbmRsZXIoeikuZm9sZChmdW5jdGlvbih4LCB6LCB0bykge1xuXHRcdFx0XHRcdHRvLnJlc29sdmUoZi5jYWxsKHRoaXMsIHosIHgpKTtcblx0XHRcdFx0fSwgeCwgdGhpcywgdG8pO1xuXHRcdFx0fSwgeiwgcHJvbWlzZS5faGFuZGxlci5yZWNlaXZlciwgcHJvbWlzZS5faGFuZGxlcik7XG5cblx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdH07XG5cblx0XHRyZXR1cm4gUHJvbWlzZTtcblx0fTtcblxufSk7XG59KHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7IH0pKTtcbiIsIi8qKiBAbGljZW5zZSBNSVQgTGljZW5zZSAoYykgY29weXJpZ2h0IDIwMTAtMjAxNCBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9ycyAqL1xuLyoqIEBhdXRob3IgQnJpYW4gQ2F2YWxpZXIgKi9cbi8qKiBAYXV0aG9yIEpvaG4gSGFubiAqL1xuXG4oZnVuY3Rpb24oZGVmaW5lKSB7ICd1c2Ugc3RyaWN0JztcbmRlZmluZShmdW5jdGlvbihyZXF1aXJlKSB7XG5cblx0dmFyIGluc3BlY3QgPSByZXF1aXJlKCcuLi9zdGF0ZScpLmluc3BlY3Q7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIGluc3BlY3Rpb24oUHJvbWlzZSkge1xuXG5cdFx0UHJvbWlzZS5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGluc3BlY3QoUHJvbWlzZS5faGFuZGxlcih0aGlzKSk7XG5cdFx0fTtcblxuXHRcdHJldHVybiBQcm9taXNlO1xuXHR9O1xuXG59KTtcbn0odHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24oZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSk7IH0pKTtcbiIsIi8qKiBAbGljZW5zZSBNSVQgTGljZW5zZSAoYykgY29weXJpZ2h0IDIwMTAtMjAxNCBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9ycyAqL1xuLyoqIEBhdXRob3IgQnJpYW4gQ2F2YWxpZXIgKi9cbi8qKiBAYXV0aG9yIEpvaG4gSGFubiAqL1xuXG4oZnVuY3Rpb24oZGVmaW5lKSB7ICd1c2Ugc3RyaWN0JztcbmRlZmluZShmdW5jdGlvbigpIHtcblxuXHRyZXR1cm4gZnVuY3Rpb24gZ2VuZXJhdGUoUHJvbWlzZSkge1xuXG5cdFx0dmFyIHJlc29sdmUgPSBQcm9taXNlLnJlc29sdmU7XG5cblx0XHRQcm9taXNlLml0ZXJhdGUgPSBpdGVyYXRlO1xuXHRcdFByb21pc2UudW5mb2xkID0gdW5mb2xkO1xuXG5cdFx0cmV0dXJuIFByb21pc2U7XG5cblx0XHQvKipcblx0XHQgKiBAZGVwcmVjYXRlZCBVc2UgZ2l0aHViLmNvbS9jdWpvanMvbW9zdCBzdHJlYW1zIGFuZCBtb3N0Lml0ZXJhdGVcblx0XHQgKiBHZW5lcmF0ZSBhIChwb3RlbnRpYWxseSBpbmZpbml0ZSkgc3RyZWFtIG9mIHByb21pc2VkIHZhbHVlczpcblx0XHQgKiB4LCBmKHgpLCBmKGYoeCkpLCBldGMuIHVudGlsIGNvbmRpdGlvbih4KSByZXR1cm5zIHRydWVcblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGEgbmV3IHggZnJvbSB0aGUgcHJldmlvdXMgeFxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbmRpdGlvbiBmdW5jdGlvbiB0aGF0LCBnaXZlbiB0aGUgY3VycmVudCB4LCByZXR1cm5zXG5cdFx0ICogIHRydXRoeSB3aGVuIHRoZSBpdGVyYXRlIHNob3VsZCBzdG9wXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlciBmdW5jdGlvbiB0byBoYW5kbGUgdGhlIHZhbHVlIHByb2R1Y2VkIGJ5IGZcblx0XHQgKiBAcGFyYW0geyp8UHJvbWlzZX0geCBzdGFydGluZyB2YWx1ZSwgbWF5IGJlIGEgcHJvbWlzZVxuXHRcdCAqIEByZXR1cm4ge1Byb21pc2V9IHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgY2FsbCB0byBmIGJlZm9yZVxuXHRcdCAqICBjb25kaXRpb24gcmV0dXJucyB0cnVlXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gaXRlcmF0ZShmLCBjb25kaXRpb24sIGhhbmRsZXIsIHgpIHtcblx0XHRcdHJldHVybiB1bmZvbGQoZnVuY3Rpb24oeCkge1xuXHRcdFx0XHRyZXR1cm4gW3gsIGYoeCldO1xuXHRcdFx0fSwgY29uZGl0aW9uLCBoYW5kbGVyLCB4KTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBAZGVwcmVjYXRlZCBVc2UgZ2l0aHViLmNvbS9jdWpvanMvbW9zdCBzdHJlYW1zIGFuZCBtb3N0LnVuZm9sZFxuXHRcdCAqIEdlbmVyYXRlIGEgKHBvdGVudGlhbGx5IGluZmluaXRlKSBzdHJlYW0gb2YgcHJvbWlzZWQgdmFsdWVzXG5cdFx0ICogYnkgYXBwbHlpbmcgaGFuZGxlcihnZW5lcmF0b3Ioc2VlZCkpIGl0ZXJhdGl2ZWx5IHVudGlsXG5cdFx0ICogY29uZGl0aW9uKHNlZWQpIHJldHVybnMgdHJ1ZS5cblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSB1bnNwb29sIGZ1bmN0aW9uIHRoYXQgZ2VuZXJhdGVzIGEgW3ZhbHVlLCBuZXdTZWVkXVxuXHRcdCAqICBnaXZlbiBhIHNlZWQuXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbn0gY29uZGl0aW9uIGZ1bmN0aW9uIHRoYXQsIGdpdmVuIHRoZSBjdXJyZW50IHNlZWQsIHJldHVybnNcblx0XHQgKiAgdHJ1dGh5IHdoZW4gdGhlIHVuZm9sZCBzaG91bGQgc3RvcFxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgZnVuY3Rpb24gdG8gaGFuZGxlIHRoZSB2YWx1ZSBwcm9kdWNlZCBieSB1bnNwb29sXG5cdFx0ICogQHBhcmFtIHggeyp8UHJvbWlzZX0gc3RhcnRpbmcgdmFsdWUsIG1heSBiZSBhIHByb21pc2Vcblx0XHQgKiBAcmV0dXJuIHtQcm9taXNlfSB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IHZhbHVlIHByb2R1Y2VkIGJ5IHVuc3Bvb2wgYmVmb3JlXG5cdFx0ICogIGNvbmRpdGlvbiByZXR1cm5zIHRydWVcblx0XHQgKi9cblx0XHRmdW5jdGlvbiB1bmZvbGQodW5zcG9vbCwgY29uZGl0aW9uLCBoYW5kbGVyLCB4KSB7XG5cdFx0XHRyZXR1cm4gcmVzb2x2ZSh4KS50aGVuKGZ1bmN0aW9uKHNlZWQpIHtcblx0XHRcdFx0cmV0dXJuIHJlc29sdmUoY29uZGl0aW9uKHNlZWQpKS50aGVuKGZ1bmN0aW9uKGRvbmUpIHtcblx0XHRcdFx0XHRyZXR1cm4gZG9uZSA/IHNlZWQgOiByZXNvbHZlKHVuc3Bvb2woc2VlZCkpLnNwcmVhZChuZXh0KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0ZnVuY3Rpb24gbmV4dChpdGVtLCBuZXdTZWVkKSB7XG5cdFx0XHRcdHJldHVybiByZXNvbHZlKGhhbmRsZXIoaXRlbSkpLnRoZW4oZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHVuZm9sZCh1bnNwb29sLCBjb25kaXRpb24sIGhhbmRsZXIsIG5ld1NlZWQpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cbn0pO1xufSh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbihmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpOyB9KSk7XG4iLCIvKiogQGxpY2Vuc2UgTUlUIExpY2Vuc2UgKGMpIGNvcHlyaWdodCAyMDEwLTIwMTQgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnMgKi9cbi8qKiBAYXV0aG9yIEJyaWFuIENhdmFsaWVyICovXG4vKiogQGF1dGhvciBKb2huIEhhbm4gKi9cblxuKGZ1bmN0aW9uKGRlZmluZSkgeyAndXNlIHN0cmljdCc7XG5kZWZpbmUoZnVuY3Rpb24oKSB7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHByb2dyZXNzKFByb21pc2UpIHtcblxuXHRcdC8qKlxuXHRcdCAqIEBkZXByZWNhdGVkXG5cdFx0ICogUmVnaXN0ZXIgYSBwcm9ncmVzcyBoYW5kbGVyIGZvciB0aGlzIHByb21pc2Vcblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvblByb2dyZXNzXG5cdFx0ICogQHJldHVybnMge1Byb21pc2V9XG5cdFx0ICovXG5cdFx0UHJvbWlzZS5wcm90b3R5cGUucHJvZ3Jlc3MgPSBmdW5jdGlvbihvblByb2dyZXNzKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy50aGVuKHZvaWQgMCwgdm9pZCAwLCBvblByb2dyZXNzKTtcblx0XHR9O1xuXG5cdFx0cmV0dXJuIFByb21pc2U7XG5cdH07XG5cbn0pO1xufSh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbihmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpOyB9KSk7XG4iLCIvKiogQGxpY2Vuc2UgTUlUIExpY2Vuc2UgKGMpIGNvcHlyaWdodCAyMDEwLTIwMTQgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnMgKi9cbi8qKiBAYXV0aG9yIEJyaWFuIENhdmFsaWVyICovXG4vKiogQGF1dGhvciBKb2huIEhhbm4gKi9cblxuKGZ1bmN0aW9uKGRlZmluZSkgeyAndXNlIHN0cmljdCc7XG5kZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSkge1xuXG5cdHZhciBlbnYgPSByZXF1aXJlKCcuLi9lbnYnKTtcblx0dmFyIFRpbWVvdXRFcnJvciA9IHJlcXVpcmUoJy4uL1RpbWVvdXRFcnJvcicpO1xuXG5cdGZ1bmN0aW9uIHNldFRpbWVvdXQoZiwgbXMsIHgsIHkpIHtcblx0XHRyZXR1cm4gZW52LnNldFRpbWVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0Zih4LCB5LCBtcyk7XG5cdFx0fSwgbXMpO1xuXHR9XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHRpbWVkKFByb21pc2UpIHtcblx0XHQvKipcblx0XHQgKiBSZXR1cm4gYSBuZXcgcHJvbWlzZSB3aG9zZSBmdWxmaWxsbWVudCB2YWx1ZSBpcyByZXZlYWxlZCBvbmx5XG5cdFx0ICogYWZ0ZXIgbXMgbWlsbGlzZWNvbmRzXG5cdFx0ICogQHBhcmFtIHtudW1iZXJ9IG1zIG1pbGxpc2Vjb25kc1xuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlfVxuXHRcdCAqL1xuXHRcdFByb21pc2UucHJvdG90eXBlLmRlbGF5ID0gZnVuY3Rpb24obXMpIHtcblx0XHRcdHZhciBwID0gdGhpcy5fYmVnZXQoKTtcblx0XHRcdHRoaXMuX2hhbmRsZXIuZm9sZChoYW5kbGVEZWxheSwgbXMsIHZvaWQgMCwgcC5faGFuZGxlcik7XG5cdFx0XHRyZXR1cm4gcDtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlRGVsYXkobXMsIHgsIGgpIHtcblx0XHRcdHNldFRpbWVvdXQocmVzb2x2ZURlbGF5LCBtcywgeCwgaCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVzb2x2ZURlbGF5KHgsIGgpIHtcblx0XHRcdGgucmVzb2x2ZSh4KTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm4gYSBuZXcgcHJvbWlzZSB0aGF0IHJlamVjdHMgYWZ0ZXIgbXMgbWlsbGlzZWNvbmRzIHVubGVzc1xuXHRcdCAqIHRoaXMgcHJvbWlzZSBmdWxmaWxscyBlYXJsaWVyLCBpbiB3aGljaCBjYXNlIHRoZSByZXR1cm5lZCBwcm9taXNlXG5cdFx0ICogZnVsZmlsbHMgd2l0aCB0aGUgc2FtZSB2YWx1ZS5cblx0XHQgKiBAcGFyYW0ge251bWJlcn0gbXMgbWlsbGlzZWNvbmRzXG5cdFx0ICogQHBhcmFtIHtFcnJvcnwqPX0gcmVhc29uIG9wdGlvbmFsIHJlamVjdGlvbiByZWFzb24gdG8gdXNlLCBkZWZhdWx0c1xuXHRcdCAqICAgdG8gYSBUaW1lb3V0RXJyb3IgaWYgbm90IHByb3ZpZGVkXG5cdFx0ICogQHJldHVybnMge1Byb21pc2V9XG5cdFx0ICovXG5cdFx0UHJvbWlzZS5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uKG1zLCByZWFzb24pIHtcblx0XHRcdHZhciBwID0gdGhpcy5fYmVnZXQoKTtcblx0XHRcdHZhciBoID0gcC5faGFuZGxlcjtcblxuXHRcdFx0dmFyIHQgPSBzZXRUaW1lb3V0KG9uVGltZW91dCwgbXMsIHJlYXNvbiwgcC5faGFuZGxlcik7XG5cblx0XHRcdHRoaXMuX2hhbmRsZXIudmlzaXQoaCxcblx0XHRcdFx0ZnVuY3Rpb24gb25GdWxmaWxsKHgpIHtcblx0XHRcdFx0XHRlbnYuY2xlYXJUaW1lcih0KTtcblx0XHRcdFx0XHR0aGlzLnJlc29sdmUoeCk7IC8vIHRoaXMgPSBoXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGZ1bmN0aW9uIG9uUmVqZWN0KHgpIHtcblx0XHRcdFx0XHRlbnYuY2xlYXJUaW1lcih0KTtcblx0XHRcdFx0XHR0aGlzLnJlamVjdCh4KTsgLy8gdGhpcyA9IGhcblx0XHRcdFx0fSxcblx0XHRcdFx0aC5ub3RpZnkpO1xuXG5cdFx0XHRyZXR1cm4gcDtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gb25UaW1lb3V0KHJlYXNvbiwgaCwgbXMpIHtcblx0XHRcdHZhciBlID0gdHlwZW9mIHJlYXNvbiA9PT0gJ3VuZGVmaW5lZCdcblx0XHRcdFx0PyBuZXcgVGltZW91dEVycm9yKCd0aW1lZCBvdXQgYWZ0ZXIgJyArIG1zICsgJ21zJylcblx0XHRcdFx0OiByZWFzb247XG5cdFx0XHRoLnJlamVjdChlKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gUHJvbWlzZTtcblx0fTtcblxufSk7XG59KHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUpOyB9KSk7XG4iLCIvKiogQGxpY2Vuc2UgTUlUIExpY2Vuc2UgKGMpIGNvcHlyaWdodCAyMDEwLTIwMTQgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnMgKi9cbi8qKiBAYXV0aG9yIEJyaWFuIENhdmFsaWVyICovXG4vKiogQGF1dGhvciBKb2huIEhhbm4gKi9cblxuKGZ1bmN0aW9uKGRlZmluZSkgeyAndXNlIHN0cmljdCc7XG5kZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSkge1xuXG5cdHZhciBzZXRUaW1lciA9IHJlcXVpcmUoJy4uL2VudicpLnNldFRpbWVyO1xuXHR2YXIgZm9ybWF0ID0gcmVxdWlyZSgnLi4vZm9ybWF0Jyk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVuaGFuZGxlZFJlamVjdGlvbihQcm9taXNlKSB7XG5cblx0XHR2YXIgbG9nRXJyb3IgPSBub29wO1xuXHRcdHZhciBsb2dJbmZvID0gbm9vcDtcblx0XHR2YXIgbG9jYWxDb25zb2xlO1xuXG5cdFx0aWYodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHQvLyBBbGlhcyBjb25zb2xlIHRvIHByZXZlbnQgdGhpbmdzIGxpa2UgdWdsaWZ5J3MgZHJvcF9jb25zb2xlIG9wdGlvbiBmcm9tXG5cdFx0XHQvLyByZW1vdmluZyBjb25zb2xlLmxvZy9lcnJvci4gVW5oYW5kbGVkIHJlamVjdGlvbnMgZmFsbCBpbnRvIHRoZSBzYW1lXG5cdFx0XHQvLyBjYXRlZ29yeSBhcyB1bmNhdWdodCBleGNlcHRpb25zLCBhbmQgYnVpbGQgdG9vbHMgc2hvdWxkbid0IHNpbGVuY2UgdGhlbS5cblx0XHRcdGxvY2FsQ29uc29sZSA9IGNvbnNvbGU7XG5cdFx0XHRsb2dFcnJvciA9IHR5cGVvZiBsb2NhbENvbnNvbGUuZXJyb3IgIT09ICd1bmRlZmluZWQnXG5cdFx0XHRcdD8gZnVuY3Rpb24gKGUpIHsgbG9jYWxDb25zb2xlLmVycm9yKGUpOyB9XG5cdFx0XHRcdDogZnVuY3Rpb24gKGUpIHsgbG9jYWxDb25zb2xlLmxvZyhlKTsgfTtcblxuXHRcdFx0bG9nSW5mbyA9IHR5cGVvZiBsb2NhbENvbnNvbGUuaW5mbyAhPT0gJ3VuZGVmaW5lZCdcblx0XHRcdFx0PyBmdW5jdGlvbiAoZSkgeyBsb2NhbENvbnNvbGUuaW5mbyhlKTsgfVxuXHRcdFx0XHQ6IGZ1bmN0aW9uIChlKSB7IGxvY2FsQ29uc29sZS5sb2coZSk7IH07XG5cdFx0fVxuXG5cdFx0UHJvbWlzZS5vblBvdGVudGlhbGx5VW5oYW5kbGVkUmVqZWN0aW9uID0gZnVuY3Rpb24ocmVqZWN0aW9uKSB7XG5cdFx0XHRlbnF1ZXVlKHJlcG9ydCwgcmVqZWN0aW9uKTtcblx0XHR9O1xuXG5cdFx0UHJvbWlzZS5vblBvdGVudGlhbGx5VW5oYW5kbGVkUmVqZWN0aW9uSGFuZGxlZCA9IGZ1bmN0aW9uKHJlamVjdGlvbikge1xuXHRcdFx0ZW5xdWV1ZSh1bnJlcG9ydCwgcmVqZWN0aW9uKTtcblx0XHR9O1xuXG5cdFx0UHJvbWlzZS5vbkZhdGFsUmVqZWN0aW9uID0gZnVuY3Rpb24ocmVqZWN0aW9uKSB7XG5cdFx0XHRlbnF1ZXVlKHRocm93aXQsIHJlamVjdGlvbi52YWx1ZSk7XG5cdFx0fTtcblxuXHRcdHZhciB0YXNrcyA9IFtdO1xuXHRcdHZhciByZXBvcnRlZCA9IFtdO1xuXHRcdHZhciBydW5uaW5nID0gbnVsbDtcblxuXHRcdGZ1bmN0aW9uIHJlcG9ydChyKSB7XG5cdFx0XHRpZighci5oYW5kbGVkKSB7XG5cdFx0XHRcdHJlcG9ydGVkLnB1c2gocik7XG5cdFx0XHRcdGxvZ0Vycm9yKCdQb3RlbnRpYWxseSB1bmhhbmRsZWQgcmVqZWN0aW9uIFsnICsgci5pZCArICddICcgKyBmb3JtYXQuZm9ybWF0RXJyb3Ioci52YWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHVucmVwb3J0KHIpIHtcblx0XHRcdHZhciBpID0gcmVwb3J0ZWQuaW5kZXhPZihyKTtcblx0XHRcdGlmKGkgPj0gMCkge1xuXHRcdFx0XHRyZXBvcnRlZC5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdGxvZ0luZm8oJ0hhbmRsZWQgcHJldmlvdXMgcmVqZWN0aW9uIFsnICsgci5pZCArICddICcgKyBmb3JtYXQuZm9ybWF0T2JqZWN0KHIudmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBlbnF1ZXVlKGYsIHgpIHtcblx0XHRcdHRhc2tzLnB1c2goZiwgeCk7XG5cdFx0XHRpZihydW5uaW5nID09PSBudWxsKSB7XG5cdFx0XHRcdHJ1bm5pbmcgPSBzZXRUaW1lcihmbHVzaCwgMCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZmx1c2goKSB7XG5cdFx0XHRydW5uaW5nID0gbnVsbDtcblx0XHRcdHdoaWxlKHRhc2tzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0dGFza3Muc2hpZnQoKSh0YXNrcy5zaGlmdCgpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gUHJvbWlzZTtcblx0fTtcblxuXHRmdW5jdGlvbiB0aHJvd2l0KGUpIHtcblx0XHR0aHJvdyBlO1xuXHR9XG5cblx0ZnVuY3Rpb24gbm9vcCgpIHt9XG5cbn0pO1xufSh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbihmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKTsgfSkpO1xuIiwiLyoqIEBsaWNlbnNlIE1JVCBMaWNlbnNlIChjKSBjb3B5cmlnaHQgMjAxMC0yMDE0IG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzICovXG4vKiogQGF1dGhvciBCcmlhbiBDYXZhbGllciAqL1xuLyoqIEBhdXRob3IgSm9obiBIYW5uICovXG5cbihmdW5jdGlvbihkZWZpbmUpIHsgJ3VzZSBzdHJpY3QnO1xuZGVmaW5lKGZ1bmN0aW9uKCkge1xuXG5cdHJldHVybiBmdW5jdGlvbiBhZGRXaXRoKFByb21pc2UpIHtcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGEgcHJvbWlzZSB3aG9zZSBoYW5kbGVycyB3aWxsIGJlIGNhbGxlZCB3aXRoIGB0aGlzYCBzZXQgdG9cblx0XHQgKiB0aGUgc3VwcGxpZWQgcmVjZWl2ZXIuICBTdWJzZXF1ZW50IHByb21pc2VzIGRlcml2ZWQgZnJvbSB0aGVcblx0XHQgKiByZXR1cm5lZCBwcm9taXNlIHdpbGwgYWxzbyBoYXZlIHRoZWlyIGhhbmRsZXJzIGNhbGxlZCB3aXRoIHJlY2VpdmVyXG5cdFx0ICogYXMgYHRoaXNgLiBDYWxsaW5nIGB3aXRoYCB3aXRoIHVuZGVmaW5lZCBvciBubyBhcmd1bWVudHMgd2lsbCByZXR1cm5cblx0XHQgKiBhIHByb21pc2Ugd2hvc2UgaGFuZGxlcnMgd2lsbCBhZ2FpbiBiZSBjYWxsZWQgaW4gdGhlIHVzdWFsIFByb21pc2VzL0ErXG5cdFx0ICogd2F5IChubyBgdGhpc2ApIHRodXMgc2FmZWx5IHVuZG9pbmcgYW55IHByZXZpb3VzIGB3aXRoYCBpbiB0aGVcblx0XHQgKiBwcm9taXNlIGNoYWluLlxuXHRcdCAqXG5cdFx0ICogV0FSTklORzogUHJvbWlzZXMgcmV0dXJuZWQgZnJvbSBgd2l0aGAvYHdpdGhUaGlzYCBhcmUgTk9UIFByb21pc2VzL0ErXG5cdFx0ICogY29tcGxpYW50LCBzcGVjaWZpY2FsbHkgdmlvbGF0aW5nIDIuMi41IChodHRwOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTQxKVxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IHJlY2VpdmVyIGB0aGlzYCB2YWx1ZSBmb3IgYWxsIGhhbmRsZXJzIGF0dGFjaGVkIHRvXG5cdFx0ICogIHRoZSByZXR1cm5lZCBwcm9taXNlLlxuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlfVxuXHRcdCAqL1xuXHRcdFByb21pc2UucHJvdG90eXBlWyd3aXRoJ10gPSBQcm9taXNlLnByb3RvdHlwZS53aXRoVGhpcyA9IGZ1bmN0aW9uKHJlY2VpdmVyKSB7XG5cdFx0XHR2YXIgcCA9IHRoaXMuX2JlZ2V0KCk7XG5cdFx0XHR2YXIgY2hpbGQgPSBwLl9oYW5kbGVyO1xuXHRcdFx0Y2hpbGQucmVjZWl2ZXIgPSByZWNlaXZlcjtcblx0XHRcdHRoaXMuX2hhbmRsZXIuY2hhaW4oY2hpbGQsIHJlY2VpdmVyKTtcblx0XHRcdHJldHVybiBwO1xuXHRcdH07XG5cblx0XHRyZXR1cm4gUHJvbWlzZTtcblx0fTtcblxufSk7XG59KHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7IH0pKTtcblxuIiwiLyoqIEBsaWNlbnNlIE1JVCBMaWNlbnNlIChjKSBjb3B5cmlnaHQgMjAxMC0yMDE0IG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzICovXG4vKiogQGF1dGhvciBCcmlhbiBDYXZhbGllciAqL1xuLyoqIEBhdXRob3IgSm9obiBIYW5uICovXG5cbi8qZ2xvYmFsIHByb2Nlc3MsZG9jdW1lbnQsc2V0VGltZW91dCxjbGVhclRpbWVvdXQsTXV0YXRpb25PYnNlcnZlcixXZWJLaXRNdXRhdGlvbk9ic2VydmVyKi9cbihmdW5jdGlvbihkZWZpbmUpIHsgJ3VzZSBzdHJpY3QnO1xuZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0Lypqc2hpbnQgbWF4Y29tcGxleGl0eTo2Ki9cblxuXHQvLyBTbmlmZiBcImJlc3RcIiBhc3luYyBzY2hlZHVsaW5nIG9wdGlvblxuXHQvLyBQcmVmZXIgcHJvY2Vzcy5uZXh0VGljayBvciBNdXRhdGlvbk9ic2VydmVyLCB0aGVuIGNoZWNrIGZvclxuXHQvLyBzZXRUaW1lb3V0LCBhbmQgZmluYWxseSB2ZXJ0eCwgc2luY2UgaXRzIHRoZSBvbmx5IGVudiB0aGF0IGRvZXNuJ3Rcblx0Ly8gaGF2ZSBzZXRUaW1lb3V0XG5cblx0dmFyIE11dGF0aW9uT2JzO1xuXHR2YXIgY2FwdHVyZWRTZXRUaW1lb3V0ID0gdHlwZW9mIHNldFRpbWVvdXQgIT09ICd1bmRlZmluZWQnICYmIHNldFRpbWVvdXQ7XG5cblx0Ly8gRGVmYXVsdCBlbnZcblx0dmFyIHNldFRpbWVyID0gZnVuY3Rpb24oZiwgbXMpIHsgcmV0dXJuIHNldFRpbWVvdXQoZiwgbXMpOyB9O1xuXHR2YXIgY2xlYXJUaW1lciA9IGZ1bmN0aW9uKHQpIHsgcmV0dXJuIGNsZWFyVGltZW91dCh0KTsgfTtcblx0dmFyIGFzYXAgPSBmdW5jdGlvbiAoZikgeyByZXR1cm4gY2FwdHVyZWRTZXRUaW1lb3V0KGYsIDApOyB9O1xuXG5cdC8vIERldGVjdCBzcGVjaWZpYyBlbnZcblx0aWYgKGlzTm9kZSgpKSB7IC8vIE5vZGVcblx0XHRhc2FwID0gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZik7IH07XG5cblx0fSBlbHNlIGlmIChNdXRhdGlvbk9icyA9IGhhc011dGF0aW9uT2JzZXJ2ZXIoKSkgeyAvLyBNb2Rlcm4gYnJvd3NlclxuXHRcdGFzYXAgPSBpbml0TXV0YXRpb25PYnNlcnZlcihNdXRhdGlvbk9icyk7XG5cblx0fSBlbHNlIGlmICghY2FwdHVyZWRTZXRUaW1lb3V0KSB7IC8vIHZlcnQueFxuXHRcdHZhciB2ZXJ0eFJlcXVpcmUgPSByZXF1aXJlO1xuXHRcdHZhciB2ZXJ0eCA9IHZlcnR4UmVxdWlyZSgndmVydHgnKTtcblx0XHRzZXRUaW1lciA9IGZ1bmN0aW9uIChmLCBtcykgeyByZXR1cm4gdmVydHguc2V0VGltZXIobXMsIGYpOyB9O1xuXHRcdGNsZWFyVGltZXIgPSB2ZXJ0eC5jYW5jZWxUaW1lcjtcblx0XHRhc2FwID0gdmVydHgucnVuT25Mb29wIHx8IHZlcnR4LnJ1bk9uQ29udGV4dDtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0c2V0VGltZXI6IHNldFRpbWVyLFxuXHRcdGNsZWFyVGltZXI6IGNsZWFyVGltZXIsXG5cdFx0YXNhcDogYXNhcFxuXHR9O1xuXG5cdGZ1bmN0aW9uIGlzTm9kZSAoKSB7XG5cdFx0cmV0dXJuIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJlxuXHRcdFx0T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXSc7XG5cdH1cblxuXHRmdW5jdGlvbiBoYXNNdXRhdGlvbk9ic2VydmVyICgpIHtcblx0XHRyZXR1cm4gKHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyID09PSAnZnVuY3Rpb24nICYmIE11dGF0aW9uT2JzZXJ2ZXIpIHx8XG5cdFx0XHQodHlwZW9mIFdlYktpdE11dGF0aW9uT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbicgJiYgV2ViS2l0TXV0YXRpb25PYnNlcnZlcik7XG5cdH1cblxuXHRmdW5jdGlvbiBpbml0TXV0YXRpb25PYnNlcnZlcihNdXRhdGlvbk9ic2VydmVyKSB7XG5cdFx0dmFyIHNjaGVkdWxlZDtcblx0XHR2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcblx0XHR2YXIgbyA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHJ1bik7XG5cdFx0by5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTtcblxuXHRcdGZ1bmN0aW9uIHJ1bigpIHtcblx0XHRcdHZhciBmID0gc2NoZWR1bGVkO1xuXHRcdFx0c2NoZWR1bGVkID0gdm9pZCAwO1xuXHRcdFx0ZigpO1xuXHRcdH1cblxuXHRcdHZhciBpID0gMDtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKGYpIHtcblx0XHRcdHNjaGVkdWxlZCA9IGY7XG5cdFx0XHRub2RlLmRhdGEgPSAoaSBePSAxKTtcblx0XHR9O1xuXHR9XG59KTtcbn0odHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24oZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSk7IH0pKTtcbiIsIi8qKiBAbGljZW5zZSBNSVQgTGljZW5zZSAoYykgY29weXJpZ2h0IDIwMTAtMjAxNCBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9ycyAqL1xuLyoqIEBhdXRob3IgQnJpYW4gQ2F2YWxpZXIgKi9cbi8qKiBAYXV0aG9yIEpvaG4gSGFubiAqL1xuXG4oZnVuY3Rpb24oZGVmaW5lKSB7ICd1c2Ugc3RyaWN0JztcbmRlZmluZShmdW5jdGlvbigpIHtcblxuXHRyZXR1cm4ge1xuXHRcdGZvcm1hdEVycm9yOiBmb3JtYXRFcnJvcixcblx0XHRmb3JtYXRPYmplY3Q6IGZvcm1hdE9iamVjdCxcblx0XHR0cnlTdHJpbmdpZnk6IHRyeVN0cmluZ2lmeVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBGb3JtYXQgYW4gZXJyb3IgaW50byBhIHN0cmluZy4gIElmIGUgaXMgYW4gRXJyb3IgYW5kIGhhcyBhIHN0YWNrIHByb3BlcnR5LFxuXHQgKiBpdCdzIHJldHVybmVkLiAgT3RoZXJ3aXNlLCBlIGlzIGZvcm1hdHRlZCB1c2luZyBmb3JtYXRPYmplY3QsIHdpdGggYVxuXHQgKiB3YXJuaW5nIGFkZGVkIGFib3V0IGUgbm90IGJlaW5nIGEgcHJvcGVyIEVycm9yLlxuXHQgKiBAcGFyYW0geyp9IGVcblx0ICogQHJldHVybnMge1N0cmluZ30gZm9ybWF0dGVkIHN0cmluZywgc3VpdGFibGUgZm9yIG91dHB1dCB0byBkZXZlbG9wZXJzXG5cdCAqL1xuXHRmdW5jdGlvbiBmb3JtYXRFcnJvcihlKSB7XG5cdFx0dmFyIHMgPSB0eXBlb2YgZSA9PT0gJ29iamVjdCcgJiYgZSAhPT0gbnVsbCAmJiAoZS5zdGFjayB8fCBlLm1lc3NhZ2UpID8gZS5zdGFjayB8fCBlLm1lc3NhZ2UgOiBmb3JtYXRPYmplY3QoZSk7XG5cdFx0cmV0dXJuIGUgaW5zdGFuY2VvZiBFcnJvciA/IHMgOiBzICsgJyAoV0FSTklORzogbm9uLUVycm9yIHVzZWQpJztcblx0fVxuXG5cdC8qKlxuXHQgKiBGb3JtYXQgYW4gb2JqZWN0LCBkZXRlY3RpbmcgXCJwbGFpblwiIG9iamVjdHMgYW5kIHJ1bm5pbmcgdGhlbSB0aHJvdWdoXG5cdCAqIEpTT04uc3RyaW5naWZ5IGlmIHBvc3NpYmxlLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb1xuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0ZnVuY3Rpb24gZm9ybWF0T2JqZWN0KG8pIHtcblx0XHR2YXIgcyA9IFN0cmluZyhvKTtcblx0XHRpZihzID09PSAnW29iamVjdCBPYmplY3RdJyAmJiB0eXBlb2YgSlNPTiAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHMgPSB0cnlTdHJpbmdpZnkobywgcyk7XG5cdFx0fVxuXHRcdHJldHVybiBzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRyeSB0byByZXR1cm4gdGhlIHJlc3VsdCBvZiBKU09OLnN0cmluZ2lmeSh4KS4gIElmIHRoYXQgZmFpbHMsIHJldHVyblxuXHQgKiBkZWZhdWx0VmFsdWVcblx0ICogQHBhcmFtIHsqfSB4XG5cdCAqIEBwYXJhbSB7Kn0gZGVmYXVsdFZhbHVlXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd8Kn0gSlNPTi5zdHJpbmdpZnkoeCkgb3IgZGVmYXVsdFZhbHVlXG5cdCAqL1xuXHRmdW5jdGlvbiB0cnlTdHJpbmdpZnkoeCwgZGVmYXVsdFZhbHVlKSB7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSh4KTtcblx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdHJldHVybiBkZWZhdWx0VmFsdWU7XG5cdFx0fVxuXHR9XG5cbn0pO1xufSh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbihmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpOyB9KSk7XG4iLCIvKiogQGxpY2Vuc2UgTUlUIExpY2Vuc2UgKGMpIGNvcHlyaWdodCAyMDEwLTIwMTQgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnMgKi9cbi8qKiBAYXV0aG9yIEJyaWFuIENhdmFsaWVyICovXG4vKiogQGF1dGhvciBKb2huIEhhbm4gKi9cblxuKGZ1bmN0aW9uKGRlZmluZSkgeyAndXNlIHN0cmljdCc7XG5kZWZpbmUoZnVuY3Rpb24oKSB7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIG1ha2VQcm9taXNlKGVudmlyb25tZW50KSB7XG5cblx0XHR2YXIgdGFza3MgPSBlbnZpcm9ubWVudC5zY2hlZHVsZXI7XG5cdFx0dmFyIGVtaXRSZWplY3Rpb24gPSBpbml0RW1pdFJlamVjdGlvbigpO1xuXG5cdFx0dmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHxcblx0XHRcdGZ1bmN0aW9uKHByb3RvKSB7XG5cdFx0XHRcdGZ1bmN0aW9uIENoaWxkKCkge31cblx0XHRcdFx0Q2hpbGQucHJvdG90eXBlID0gcHJvdG87XG5cdFx0XHRcdHJldHVybiBuZXcgQ2hpbGQoKTtcblx0XHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBDcmVhdGUgYSBwcm9taXNlIHdob3NlIGZhdGUgaXMgZGV0ZXJtaW5lZCBieSByZXNvbHZlclxuXHRcdCAqIEBjb25zdHJ1Y3RvclxuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlXG5cdFx0ICogQG5hbWUgUHJvbWlzZVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIFByb21pc2UocmVzb2x2ZXIsIGhhbmRsZXIpIHtcblx0XHRcdHRoaXMuX2hhbmRsZXIgPSByZXNvbHZlciA9PT0gSGFuZGxlciA/IGhhbmRsZXIgOiBpbml0KHJlc29sdmVyKTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBSdW4gdGhlIHN1cHBsaWVkIHJlc29sdmVyXG5cdFx0ICogQHBhcmFtIHJlc29sdmVyXG5cdFx0ICogQHJldHVybnMge1BlbmRpbmd9XG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gaW5pdChyZXNvbHZlcikge1xuXHRcdFx0dmFyIGhhbmRsZXIgPSBuZXcgUGVuZGluZygpO1xuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyZXNvbHZlcihwcm9taXNlUmVzb2x2ZSwgcHJvbWlzZVJlamVjdCwgcHJvbWlzZU5vdGlmeSk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdHByb21pc2VSZWplY3QoZSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBoYW5kbGVyO1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIFRyYW5zaXRpb24gZnJvbSBwcmUtcmVzb2x1dGlvbiBzdGF0ZSB0byBwb3N0LXJlc29sdXRpb24gc3RhdGUsIG5vdGlmeWluZ1xuXHRcdFx0ICogYWxsIGxpc3RlbmVycyBvZiB0aGUgdWx0aW1hdGUgZnVsZmlsbG1lbnQgb3IgcmVqZWN0aW9uXG5cdFx0XHQgKiBAcGFyYW0geyp9IHggcmVzb2x1dGlvbiB2YWx1ZVxuXHRcdFx0ICovXG5cdFx0XHRmdW5jdGlvbiBwcm9taXNlUmVzb2x2ZSAoeCkge1xuXHRcdFx0XHRoYW5kbGVyLnJlc29sdmUoeCk7XG5cdFx0XHR9XG5cdFx0XHQvKipcblx0XHRcdCAqIFJlamVjdCB0aGlzIHByb21pc2Ugd2l0aCByZWFzb24sIHdoaWNoIHdpbGwgYmUgdXNlZCB2ZXJiYXRpbVxuXHRcdFx0ICogQHBhcmFtIHtFcnJvcnwqfSByZWFzb24gcmVqZWN0aW9uIHJlYXNvbiwgc3Ryb25nbHkgc3VnZ2VzdGVkXG5cdFx0XHQgKiAgIHRvIGJlIGFuIEVycm9yIHR5cGVcblx0XHRcdCAqL1xuXHRcdFx0ZnVuY3Rpb24gcHJvbWlzZVJlamVjdCAocmVhc29uKSB7XG5cdFx0XHRcdGhhbmRsZXIucmVqZWN0KHJlYXNvbik7XG5cdFx0XHR9XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQGRlcHJlY2F0ZWRcblx0XHRcdCAqIElzc3VlIGEgcHJvZ3Jlc3MgZXZlbnQsIG5vdGlmeWluZyBhbGwgcHJvZ3Jlc3MgbGlzdGVuZXJzXG5cdFx0XHQgKiBAcGFyYW0geyp9IHggcHJvZ3Jlc3MgZXZlbnQgcGF5bG9hZCB0byBwYXNzIHRvIGFsbCBsaXN0ZW5lcnNcblx0XHRcdCAqL1xuXHRcdFx0ZnVuY3Rpb24gcHJvbWlzZU5vdGlmeSAoeCkge1xuXHRcdFx0XHRoYW5kbGVyLm5vdGlmeSh4KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDcmVhdGlvblxuXG5cdFx0UHJvbWlzZS5yZXNvbHZlID0gcmVzb2x2ZTtcblx0XHRQcm9taXNlLnJlamVjdCA9IHJlamVjdDtcblx0XHRQcm9taXNlLm5ldmVyID0gbmV2ZXI7XG5cblx0XHRQcm9taXNlLl9kZWZlciA9IGRlZmVyO1xuXHRcdFByb21pc2UuX2hhbmRsZXIgPSBnZXRIYW5kbGVyO1xuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBhIHRydXN0ZWQgcHJvbWlzZS4gSWYgeCBpcyBhbHJlYWR5IGEgdHJ1c3RlZCBwcm9taXNlLCBpdCBpc1xuXHRcdCAqIHJldHVybmVkLCBvdGhlcndpc2UgcmV0dXJucyBhIG5ldyB0cnVzdGVkIFByb21pc2Ugd2hpY2ggZm9sbG93cyB4LlxuXHRcdCAqIEBwYXJhbSAgeyp9IHhcblx0XHQgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gcmVzb2x2ZSh4KSB7XG5cdFx0XHRyZXR1cm4gaXNQcm9taXNlKHgpID8geFxuXHRcdFx0XHQ6IG5ldyBQcm9taXNlKEhhbmRsZXIsIG5ldyBBc3luYyhnZXRIYW5kbGVyKHgpKSk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJuIGEgcmVqZWN0IHByb21pc2Ugd2l0aCB4IGFzIGl0cyByZWFzb24gKHggaXMgdXNlZCB2ZXJiYXRpbSlcblx0XHQgKiBAcGFyYW0geyp9IHhcblx0XHQgKiBAcmV0dXJucyB7UHJvbWlzZX0gcmVqZWN0ZWQgcHJvbWlzZVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIHJlamVjdCh4KSB7XG5cdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoSGFuZGxlciwgbmV3IEFzeW5jKG5ldyBSZWplY3RlZCh4KSkpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybiBhIHByb21pc2UgdGhhdCByZW1haW5zIHBlbmRpbmcgZm9yZXZlclxuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlfSBmb3JldmVyLXBlbmRpbmcgcHJvbWlzZS5cblx0XHQgKi9cblx0XHRmdW5jdGlvbiBuZXZlcigpIHtcblx0XHRcdHJldHVybiBmb3JldmVyUGVuZGluZ1Byb21pc2U7IC8vIFNob3VsZCBiZSBmcm96ZW5cblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBDcmVhdGVzIGFuIGludGVybmFsIHtwcm9taXNlLCByZXNvbHZlcn0gcGFpclxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHJldHVybnMge1Byb21pc2V9XG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gZGVmZXIoKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoSGFuZGxlciwgbmV3IFBlbmRpbmcoKSk7XG5cdFx0fVxuXG5cdFx0Ly8gVHJhbnNmb3JtYXRpb24gYW5kIGZsb3cgY29udHJvbFxuXG5cdFx0LyoqXG5cdFx0ICogVHJhbnNmb3JtIHRoaXMgcHJvbWlzZSdzIGZ1bGZpbGxtZW50IHZhbHVlLCByZXR1cm5pbmcgYSBuZXcgUHJvbWlzZVxuXHRcdCAqIGZvciB0aGUgdHJhbnNmb3JtZWQgcmVzdWx0LiAgSWYgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZCwgb25SZWplY3RlZFxuXHRcdCAqIGlzIGNhbGxlZCB3aXRoIHRoZSByZWFzb24uICBvblByb2dyZXNzICptYXkqIGJlIGNhbGxlZCB3aXRoIHVwZGF0ZXMgdG93YXJkXG5cdFx0ICogdGhpcyBwcm9taXNlJ3MgZnVsZmlsbG1lbnQuXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbj19IG9uRnVsZmlsbGVkIGZ1bGZpbGxtZW50IGhhbmRsZXJcblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9uPX0gb25SZWplY3RlZCByZWplY3Rpb24gaGFuZGxlclxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb249fSBvblByb2dyZXNzIEBkZXByZWNhdGVkIHByb2dyZXNzIGhhbmRsZXJcblx0XHQgKiBAcmV0dXJuIHtQcm9taXNlfSBuZXcgcHJvbWlzZVxuXHRcdCAqL1xuXHRcdFByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcykge1xuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMuX2hhbmRsZXI7XG5cdFx0XHR2YXIgc3RhdGUgPSBwYXJlbnQuam9pbigpLnN0YXRlKCk7XG5cblx0XHRcdGlmICgodHlwZW9mIG9uRnVsZmlsbGVkICE9PSAnZnVuY3Rpb24nICYmIHN0YXRlID4gMCkgfHxcblx0XHRcdFx0KHR5cGVvZiBvblJlamVjdGVkICE9PSAnZnVuY3Rpb24nICYmIHN0YXRlIDwgMCkpIHtcblx0XHRcdFx0Ly8gU2hvcnQgY2lyY3VpdDogdmFsdWUgd2lsbCBub3QgY2hhbmdlLCBzaW1wbHkgc2hhcmUgaGFuZGxlclxuXHRcdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoSGFuZGxlciwgcGFyZW50KTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHAgPSB0aGlzLl9iZWdldCgpO1xuXHRcdFx0dmFyIGNoaWxkID0gcC5faGFuZGxlcjtcblxuXHRcdFx0cGFyZW50LmNoYWluKGNoaWxkLCBwYXJlbnQucmVjZWl2ZXIsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzKTtcblxuXHRcdFx0cmV0dXJuIHA7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIElmIHRoaXMgcHJvbWlzZSBjYW5ub3QgYmUgZnVsZmlsbGVkIGR1ZSB0byBhbiBlcnJvciwgY2FsbCBvblJlamVjdGVkIHRvXG5cdFx0ICogaGFuZGxlIHRoZSBlcnJvci4gU2hvcnRjdXQgZm9yIC50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZClcblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9uP30gb25SZWplY3RlZFxuXHRcdCAqIEByZXR1cm4ge1Byb21pc2V9XG5cdFx0ICovXG5cdFx0UHJvbWlzZS5wcm90b3R5cGVbJ2NhdGNoJ10gPSBmdW5jdGlvbihvblJlamVjdGVkKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy50aGVuKHZvaWQgMCwgb25SZWplY3RlZCk7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZXMgYSBuZXcsIHBlbmRpbmcgcHJvbWlzZSBvZiB0aGUgc2FtZSB0eXBlIGFzIHRoaXMgcHJvbWlzZVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHJldHVybnMge1Byb21pc2V9XG5cdFx0ICovXG5cdFx0UHJvbWlzZS5wcm90b3R5cGUuX2JlZ2V0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gYmVnZXRGcm9tKHRoaXMuX2hhbmRsZXIsIHRoaXMuY29uc3RydWN0b3IpO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBiZWdldEZyb20ocGFyZW50LCBQcm9taXNlKSB7XG5cdFx0XHR2YXIgY2hpbGQgPSBuZXcgUGVuZGluZyhwYXJlbnQucmVjZWl2ZXIsIHBhcmVudC5qb2luKCkuY29udGV4dCk7XG5cdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoSGFuZGxlciwgY2hpbGQpO1xuXHRcdH1cblxuXHRcdC8vIEFycmF5IGNvbWJpbmF0b3JzXG5cblx0XHRQcm9taXNlLmFsbCA9IGFsbDtcblx0XHRQcm9taXNlLnJhY2UgPSByYWNlO1xuXHRcdFByb21pc2UuX3RyYXZlcnNlID0gdHJhdmVyc2U7XG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm4gYSBwcm9taXNlIHRoYXQgd2lsbCBmdWxmaWxsIHdoZW4gYWxsIHByb21pc2VzIGluIHRoZVxuXHRcdCAqIGlucHV0IGFycmF5IGhhdmUgZnVsZmlsbGVkLCBvciB3aWxsIHJlamVjdCB3aGVuIG9uZSBvZiB0aGVcblx0XHQgKiBwcm9taXNlcyByZWplY3RzLlxuXHRcdCAqIEBwYXJhbSB7YXJyYXl9IHByb21pc2VzIGFycmF5IG9mIHByb21pc2VzXG5cdFx0ICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2UgZm9yIGFycmF5IG9mIGZ1bGZpbGxtZW50IHZhbHVlc1xuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGFsbChwcm9taXNlcykge1xuXHRcdFx0cmV0dXJuIHRyYXZlcnNlV2l0aChzbmQsIG51bGwsIHByb21pc2VzKTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBBcnJheTxQcm9taXNlPFg+PiAtPiBQcm9taXNlPEFycmF5PGYoWCk+PlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbn0gZiBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIHByb21pc2UncyB2YWx1ZVxuXHRcdCAqIEBwYXJhbSB7QXJyYXl9IHByb21pc2VzIGFycmF5IG9mIHByb21pc2VzXG5cdFx0ICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2UgZm9yIHRyYW5zZm9ybWVkIHZhbHVlc1xuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIHRyYXZlcnNlKGYsIHByb21pc2VzKSB7XG5cdFx0XHRyZXR1cm4gdHJhdmVyc2VXaXRoKHRyeUNhdGNoMiwgZiwgcHJvbWlzZXMpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRyYXZlcnNlV2l0aCh0cnlNYXAsIGYsIHByb21pc2VzKSB7XG5cdFx0XHR2YXIgaGFuZGxlciA9IHR5cGVvZiBmID09PSAnZnVuY3Rpb24nID8gbWFwQXQgOiBzZXR0bGVBdDtcblxuXHRcdFx0dmFyIHJlc29sdmVyID0gbmV3IFBlbmRpbmcoKTtcblx0XHRcdHZhciBwZW5kaW5nID0gcHJvbWlzZXMubGVuZ3RoID4+PiAwO1xuXHRcdFx0dmFyIHJlc3VsdHMgPSBuZXcgQXJyYXkocGVuZGluZyk7XG5cblx0XHRcdGZvciAodmFyIGkgPSAwLCB4OyBpIDwgcHJvbWlzZXMubGVuZ3RoICYmICFyZXNvbHZlci5yZXNvbHZlZDsgKytpKSB7XG5cdFx0XHRcdHggPSBwcm9taXNlc1tpXTtcblxuXHRcdFx0XHRpZiAoeCA9PT0gdm9pZCAwICYmICEoaSBpbiBwcm9taXNlcykpIHtcblx0XHRcdFx0XHQtLXBlbmRpbmc7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0cmF2ZXJzZUF0KHByb21pc2VzLCBoYW5kbGVyLCBpLCB4LCByZXNvbHZlcik7XG5cdFx0XHR9XG5cblx0XHRcdGlmKHBlbmRpbmcgPT09IDApIHtcblx0XHRcdFx0cmVzb2x2ZXIuYmVjb21lKG5ldyBGdWxmaWxsZWQocmVzdWx0cykpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoSGFuZGxlciwgcmVzb2x2ZXIpO1xuXG5cdFx0XHRmdW5jdGlvbiBtYXBBdChpLCB4LCByZXNvbHZlcikge1xuXHRcdFx0XHRpZighcmVzb2x2ZXIucmVzb2x2ZWQpIHtcblx0XHRcdFx0XHR0cmF2ZXJzZUF0KHByb21pc2VzLCBzZXR0bGVBdCwgaSwgdHJ5TWFwKGYsIHgsIGkpLCByZXNvbHZlcik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gc2V0dGxlQXQoaSwgeCwgcmVzb2x2ZXIpIHtcblx0XHRcdFx0cmVzdWx0c1tpXSA9IHg7XG5cdFx0XHRcdGlmKC0tcGVuZGluZyA9PT0gMCkge1xuXHRcdFx0XHRcdHJlc29sdmVyLmJlY29tZShuZXcgRnVsZmlsbGVkKHJlc3VsdHMpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRyYXZlcnNlQXQocHJvbWlzZXMsIGhhbmRsZXIsIGksIHgsIHJlc29sdmVyKSB7XG5cdFx0XHRpZiAobWF5YmVUaGVuYWJsZSh4KSkge1xuXHRcdFx0XHR2YXIgaCA9IGdldEhhbmRsZXJNYXliZVRoZW5hYmxlKHgpO1xuXHRcdFx0XHR2YXIgcyA9IGguc3RhdGUoKTtcblxuXHRcdFx0XHRpZiAocyA9PT0gMCkge1xuXHRcdFx0XHRcdGguZm9sZChoYW5kbGVyLCBpLCB2b2lkIDAsIHJlc29sdmVyKTtcblx0XHRcdFx0fSBlbHNlIGlmIChzID4gMCkge1xuXHRcdFx0XHRcdGhhbmRsZXIoaSwgaC52YWx1ZSwgcmVzb2x2ZXIpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlc29sdmVyLmJlY29tZShoKTtcblx0XHRcdFx0XHR2aXNpdFJlbWFpbmluZyhwcm9taXNlcywgaSsxLCBoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGFuZGxlcihpLCB4LCByZXNvbHZlcik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0UHJvbWlzZS5fdmlzaXRSZW1haW5pbmcgPSB2aXNpdFJlbWFpbmluZztcblx0XHRmdW5jdGlvbiB2aXNpdFJlbWFpbmluZyhwcm9taXNlcywgc3RhcnQsIGhhbmRsZXIpIHtcblx0XHRcdGZvcih2YXIgaT1zdGFydDsgaTxwcm9taXNlcy5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRtYXJrQXNIYW5kbGVkKGdldEhhbmRsZXIocHJvbWlzZXNbaV0pLCBoYW5kbGVyKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBtYXJrQXNIYW5kbGVkKGgsIGhhbmRsZXIpIHtcblx0XHRcdGlmKGggPT09IGhhbmRsZXIpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcyA9IGguc3RhdGUoKTtcblx0XHRcdGlmKHMgPT09IDApIHtcblx0XHRcdFx0aC52aXNpdChoLCB2b2lkIDAsIGguX3VucmVwb3J0KTtcblx0XHRcdH0gZWxzZSBpZihzIDwgMCkge1xuXHRcdFx0XHRoLl91bnJlcG9ydCgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEZ1bGZpbGwtcmVqZWN0IGNvbXBldGl0aXZlIHJhY2UuIFJldHVybiBhIHByb21pc2UgdGhhdCB3aWxsIHNldHRsZVxuXHRcdCAqIHRvIHRoZSBzYW1lIHN0YXRlIGFzIHRoZSBlYXJsaWVzdCBpbnB1dCBwcm9taXNlIHRvIHNldHRsZS5cblx0XHQgKlxuXHRcdCAqIFdBUk5JTkc6IFRoZSBFUzYgUHJvbWlzZSBzcGVjIHJlcXVpcmVzIHRoYXQgcmFjZSgpaW5nIGFuIGVtcHR5IGFycmF5XG5cdFx0ICogbXVzdCByZXR1cm4gYSBwcm9taXNlIHRoYXQgaXMgcGVuZGluZyBmb3JldmVyLiAgVGhpcyBpbXBsZW1lbnRhdGlvblxuXHRcdCAqIHJldHVybnMgYSBzaW5nbGV0b24gZm9yZXZlci1wZW5kaW5nIHByb21pc2UsIHRoZSBzYW1lIHNpbmdsZXRvbiB0aGF0IGlzXG5cdFx0ICogcmV0dXJuZWQgYnkgUHJvbWlzZS5uZXZlcigpLCB0aHVzIGNhbiBiZSBjaGVja2VkIHdpdGggPT09XG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge2FycmF5fSBwcm9taXNlcyBhcnJheSBvZiBwcm9taXNlcyB0byByYWNlXG5cdFx0ICogQHJldHVybnMge1Byb21pc2V9IGlmIGlucHV0IGlzIG5vbi1lbXB0eSwgYSBwcm9taXNlIHRoYXQgd2lsbCBzZXR0bGVcblx0XHQgKiB0byB0aGUgc2FtZSBvdXRjb21lIGFzIHRoZSBlYXJsaWVzdCBpbnB1dCBwcm9taXNlIHRvIHNldHRsZS4gaWYgZW1wdHlcblx0XHQgKiBpcyBlbXB0eSwgcmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIG5ldmVyIHNldHRsZS5cblx0XHQgKi9cblx0XHRmdW5jdGlvbiByYWNlKHByb21pc2VzKSB7XG5cdFx0XHRpZih0eXBlb2YgcHJvbWlzZXMgIT09ICdvYmplY3QnIHx8IHByb21pc2VzID09PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiByZWplY3QobmV3IFR5cGVFcnJvcignbm9uLWl0ZXJhYmxlIHBhc3NlZCB0byByYWNlKCknKSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNpZ2gsIHJhY2UoW10pIGlzIHVudGVzdGFibGUgdW5sZXNzIHdlIHJldHVybiAqc29tZXRoaW5nKlxuXHRcdFx0Ly8gdGhhdCBpcyByZWNvZ25pemFibGUgd2l0aG91dCBjYWxsaW5nIC50aGVuKCkgb24gaXQuXG5cdFx0XHRyZXR1cm4gcHJvbWlzZXMubGVuZ3RoID09PSAwID8gbmV2ZXIoKVxuXHRcdFx0XHQgOiBwcm9taXNlcy5sZW5ndGggPT09IDEgPyByZXNvbHZlKHByb21pc2VzWzBdKVxuXHRcdFx0XHQgOiBydW5SYWNlKHByb21pc2VzKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBydW5SYWNlKHByb21pc2VzKSB7XG5cdFx0XHR2YXIgcmVzb2x2ZXIgPSBuZXcgUGVuZGluZygpO1xuXHRcdFx0dmFyIGksIHgsIGg7XG5cdFx0XHRmb3IoaT0wOyBpPHByb21pc2VzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdHggPSBwcm9taXNlc1tpXTtcblx0XHRcdFx0aWYgKHggPT09IHZvaWQgMCAmJiAhKGkgaW4gcHJvbWlzZXMpKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRoID0gZ2V0SGFuZGxlcih4KTtcblx0XHRcdFx0aWYoaC5zdGF0ZSgpICE9PSAwKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZXIuYmVjb21lKGgpO1xuXHRcdFx0XHRcdHZpc2l0UmVtYWluaW5nKHByb21pc2VzLCBpKzEsIGgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGgudmlzaXQocmVzb2x2ZXIsIHJlc29sdmVyLnJlc29sdmUsIHJlc29sdmVyLnJlamVjdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBuZXcgUHJvbWlzZShIYW5kbGVyLCByZXNvbHZlcik7XG5cdFx0fVxuXG5cdFx0Ly8gUHJvbWlzZSBpbnRlcm5hbHNcblx0XHQvLyBCZWxvdyB0aGlzLCBldmVyeXRoaW5nIGlzIEBwcml2YXRlXG5cblx0XHQvKipcblx0XHQgKiBHZXQgYW4gYXBwcm9wcmlhdGUgaGFuZGxlciBmb3IgeCwgd2l0aG91dCBjaGVja2luZyBmb3IgY3ljbGVzXG5cdFx0ICogQHBhcmFtIHsqfSB4XG5cdFx0ICogQHJldHVybnMge29iamVjdH0gaGFuZGxlclxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGdldEhhbmRsZXIoeCkge1xuXHRcdFx0aWYoaXNQcm9taXNlKHgpKSB7XG5cdFx0XHRcdHJldHVybiB4Ll9oYW5kbGVyLmpvaW4oKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXliZVRoZW5hYmxlKHgpID8gZ2V0SGFuZGxlclVudHJ1c3RlZCh4KSA6IG5ldyBGdWxmaWxsZWQoeCk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogR2V0IGEgaGFuZGxlciBmb3IgdGhlbmFibGUgeC5cblx0XHQgKiBOT1RFOiBZb3UgbXVzdCBvbmx5IGNhbGwgdGhpcyBpZiBtYXliZVRoZW5hYmxlKHgpID09IHRydWVcblx0XHQgKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbnxQcm9taXNlfSB4XG5cdFx0ICogQHJldHVybnMge29iamVjdH0gaGFuZGxlclxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGdldEhhbmRsZXJNYXliZVRoZW5hYmxlKHgpIHtcblx0XHRcdHJldHVybiBpc1Byb21pc2UoeCkgPyB4Ll9oYW5kbGVyLmpvaW4oKSA6IGdldEhhbmRsZXJVbnRydXN0ZWQoeCk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogR2V0IGEgaGFuZGxlciBmb3IgcG90ZW50aWFsbHkgdW50cnVzdGVkIHRoZW5hYmxlIHhcblx0XHQgKiBAcGFyYW0geyp9IHhcblx0XHQgKiBAcmV0dXJucyB7b2JqZWN0fSBoYW5kbGVyXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gZ2V0SGFuZGxlclVudHJ1c3RlZCh4KSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR2YXIgdW50cnVzdGVkVGhlbiA9IHgudGhlbjtcblx0XHRcdFx0cmV0dXJuIHR5cGVvZiB1bnRydXN0ZWRUaGVuID09PSAnZnVuY3Rpb24nXG5cdFx0XHRcdFx0PyBuZXcgVGhlbmFibGUodW50cnVzdGVkVGhlbiwgeClcblx0XHRcdFx0XHQ6IG5ldyBGdWxmaWxsZWQoeCk7XG5cdFx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBSZWplY3RlZChlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBIYW5kbGVyIGZvciBhIHByb21pc2UgdGhhdCBpcyBwZW5kaW5nIGZvcmV2ZXJcblx0XHQgKiBAY29uc3RydWN0b3Jcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBIYW5kbGVyKCkge31cblxuXHRcdEhhbmRsZXIucHJvdG90eXBlLndoZW5cblx0XHRcdD0gSGFuZGxlci5wcm90b3R5cGUuYmVjb21lXG5cdFx0XHQ9IEhhbmRsZXIucHJvdG90eXBlLm5vdGlmeSAvLyBkZXByZWNhdGVkXG5cdFx0XHQ9IEhhbmRsZXIucHJvdG90eXBlLmZhaWxcblx0XHRcdD0gSGFuZGxlci5wcm90b3R5cGUuX3VucmVwb3J0XG5cdFx0XHQ9IEhhbmRsZXIucHJvdG90eXBlLl9yZXBvcnRcblx0XHRcdD0gbm9vcDtcblxuXHRcdEhhbmRsZXIucHJvdG90eXBlLl9zdGF0ZSA9IDA7XG5cblx0XHRIYW5kbGVyLnByb3RvdHlwZS5zdGF0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3N0YXRlO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBSZWN1cnNpdmVseSBjb2xsYXBzZSBoYW5kbGVyIGNoYWluIHRvIGZpbmQgdGhlIGhhbmRsZXJcblx0XHQgKiBuZWFyZXN0IHRvIHRoZSBmdWxseSByZXNvbHZlZCB2YWx1ZS5cblx0XHQgKiBAcmV0dXJucyB7b2JqZWN0fSBoYW5kbGVyIG5lYXJlc3QgdGhlIGZ1bGx5IHJlc29sdmVkIHZhbHVlXG5cdFx0ICovXG5cdFx0SGFuZGxlci5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGggPSB0aGlzO1xuXHRcdFx0d2hpbGUoaC5oYW5kbGVyICE9PSB2b2lkIDApIHtcblx0XHRcdFx0aCA9IGguaGFuZGxlcjtcblx0XHRcdH1cblx0XHRcdHJldHVybiBoO1xuXHRcdH07XG5cblx0XHRIYW5kbGVyLnByb3RvdHlwZS5jaGFpbiA9IGZ1bmN0aW9uKHRvLCByZWNlaXZlciwgZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3MpIHtcblx0XHRcdHRoaXMud2hlbih7XG5cdFx0XHRcdHJlc29sdmVyOiB0byxcblx0XHRcdFx0cmVjZWl2ZXI6IHJlY2VpdmVyLFxuXHRcdFx0XHRmdWxmaWxsZWQ6IGZ1bGZpbGxlZCxcblx0XHRcdFx0cmVqZWN0ZWQ6IHJlamVjdGVkLFxuXHRcdFx0XHRwcm9ncmVzczogcHJvZ3Jlc3Ncblx0XHRcdH0pO1xuXHRcdH07XG5cblx0XHRIYW5kbGVyLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uKHJlY2VpdmVyLCBmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzcykge1xuXHRcdFx0dGhpcy5jaGFpbihmYWlsSWZSZWplY3RlZCwgcmVjZWl2ZXIsIGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzKTtcblx0XHR9O1xuXG5cdFx0SGFuZGxlci5wcm90b3R5cGUuZm9sZCA9IGZ1bmN0aW9uKGYsIHosIGMsIHRvKSB7XG5cdFx0XHR0aGlzLndoZW4obmV3IEZvbGQoZiwgeiwgYywgdG8pKTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGFuZGxlciB0aGF0IGludm9rZXMgZmFpbCgpIG9uIGFueSBoYW5kbGVyIGl0IGJlY29tZXNcblx0XHQgKiBAY29uc3RydWN0b3Jcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBGYWlsSWZSZWplY3RlZCgpIHt9XG5cblx0XHRpbmhlcml0KEhhbmRsZXIsIEZhaWxJZlJlamVjdGVkKTtcblxuXHRcdEZhaWxJZlJlamVjdGVkLnByb3RvdHlwZS5iZWNvbWUgPSBmdW5jdGlvbihoKSB7XG5cdFx0XHRoLmZhaWwoKTtcblx0XHR9O1xuXG5cdFx0dmFyIGZhaWxJZlJlamVjdGVkID0gbmV3IEZhaWxJZlJlamVjdGVkKCk7XG5cblx0XHQvKipcblx0XHQgKiBIYW5kbGVyIHRoYXQgbWFuYWdlcyBhIHF1ZXVlIG9mIGNvbnN1bWVycyB3YWl0aW5nIG9uIGEgcGVuZGluZyBwcm9taXNlXG5cdFx0ICogQGNvbnN0cnVjdG9yXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gUGVuZGluZyhyZWNlaXZlciwgaW5oZXJpdGVkQ29udGV4dCkge1xuXHRcdFx0UHJvbWlzZS5jcmVhdGVDb250ZXh0KHRoaXMsIGluaGVyaXRlZENvbnRleHQpO1xuXG5cdFx0XHR0aGlzLmNvbnN1bWVycyA9IHZvaWQgMDtcblx0XHRcdHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcblx0XHRcdHRoaXMuaGFuZGxlciA9IHZvaWQgMDtcblx0XHRcdHRoaXMucmVzb2x2ZWQgPSBmYWxzZTtcblx0XHR9XG5cblx0XHRpbmhlcml0KEhhbmRsZXIsIFBlbmRpbmcpO1xuXG5cdFx0UGVuZGluZy5wcm90b3R5cGUuX3N0YXRlID0gMDtcblxuXHRcdFBlbmRpbmcucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbih4KSB7XG5cdFx0XHR0aGlzLmJlY29tZShnZXRIYW5kbGVyKHgpKTtcblx0XHR9O1xuXG5cdFx0UGVuZGluZy5wcm90b3R5cGUucmVqZWN0ID0gZnVuY3Rpb24oeCkge1xuXHRcdFx0aWYodGhpcy5yZXNvbHZlZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuYmVjb21lKG5ldyBSZWplY3RlZCh4KSk7XG5cdFx0fTtcblxuXHRcdFBlbmRpbmcucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICghdGhpcy5yZXNvbHZlZCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblxuXHRcdFx0dmFyIGggPSB0aGlzO1xuXG5cdFx0XHR3aGlsZSAoaC5oYW5kbGVyICE9PSB2b2lkIDApIHtcblx0XHRcdFx0aCA9IGguaGFuZGxlcjtcblx0XHRcdFx0aWYgKGggPT09IHRoaXMpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5oYW5kbGVyID0gY3ljbGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gaDtcblx0XHR9O1xuXG5cdFx0UGVuZGluZy5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcSA9IHRoaXMuY29uc3VtZXJzO1xuXHRcdFx0dmFyIGhhbmRsZXIgPSB0aGlzLmhhbmRsZXI7XG5cdFx0XHR0aGlzLmhhbmRsZXIgPSB0aGlzLmhhbmRsZXIuam9pbigpO1xuXHRcdFx0dGhpcy5jb25zdW1lcnMgPSB2b2lkIDA7XG5cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcS5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRoYW5kbGVyLndoZW4ocVtpXSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdFBlbmRpbmcucHJvdG90eXBlLmJlY29tZSA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcblx0XHRcdGlmKHRoaXMucmVzb2x2ZWQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnJlc29sdmVkID0gdHJ1ZTtcblx0XHRcdHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG5cdFx0XHRpZih0aGlzLmNvbnN1bWVycyAhPT0gdm9pZCAwKSB7XG5cdFx0XHRcdHRhc2tzLmVucXVldWUodGhpcyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmKHRoaXMuY29udGV4dCAhPT0gdm9pZCAwKSB7XG5cdFx0XHRcdGhhbmRsZXIuX3JlcG9ydCh0aGlzLmNvbnRleHQpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRQZW5kaW5nLnByb3RvdHlwZS53aGVuID0gZnVuY3Rpb24oY29udGludWF0aW9uKSB7XG5cdFx0XHRpZih0aGlzLnJlc29sdmVkKSB7XG5cdFx0XHRcdHRhc2tzLmVucXVldWUobmV3IENvbnRpbnVhdGlvblRhc2soY29udGludWF0aW9uLCB0aGlzLmhhbmRsZXIpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmKHRoaXMuY29uc3VtZXJzID09PSB2b2lkIDApIHtcblx0XHRcdFx0XHR0aGlzLmNvbnN1bWVycyA9IFtjb250aW51YXRpb25dO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuY29uc3VtZXJzLnB1c2goY29udGludWF0aW9uKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBAZGVwcmVjYXRlZFxuXHRcdCAqL1xuXHRcdFBlbmRpbmcucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uKHgpIHtcblx0XHRcdGlmKCF0aGlzLnJlc29sdmVkKSB7XG5cdFx0XHRcdHRhc2tzLmVucXVldWUobmV3IFByb2dyZXNzVGFzayh4LCB0aGlzKSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdFBlbmRpbmcucHJvdG90eXBlLmZhaWwgPSBmdW5jdGlvbihjb250ZXh0KSB7XG5cdFx0XHR2YXIgYyA9IHR5cGVvZiBjb250ZXh0ID09PSAndW5kZWZpbmVkJyA/IHRoaXMuY29udGV4dCA6IGNvbnRleHQ7XG5cdFx0XHR0aGlzLnJlc29sdmVkICYmIHRoaXMuaGFuZGxlci5qb2luKCkuZmFpbChjKTtcblx0XHR9O1xuXG5cdFx0UGVuZGluZy5wcm90b3R5cGUuX3JlcG9ydCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcblx0XHRcdHRoaXMucmVzb2x2ZWQgJiYgdGhpcy5oYW5kbGVyLmpvaW4oKS5fcmVwb3J0KGNvbnRleHQpO1xuXHRcdH07XG5cblx0XHRQZW5kaW5nLnByb3RvdHlwZS5fdW5yZXBvcnQgPSBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMucmVzb2x2ZWQgJiYgdGhpcy5oYW5kbGVyLmpvaW4oKS5fdW5yZXBvcnQoKTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogV3JhcCBhbm90aGVyIGhhbmRsZXIgYW5kIGZvcmNlIGl0IGludG8gYSBmdXR1cmUgc3RhY2tcblx0XHQgKiBAcGFyYW0ge29iamVjdH0gaGFuZGxlclxuXHRcdCAqIEBjb25zdHJ1Y3RvclxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIEFzeW5jKGhhbmRsZXIpIHtcblx0XHRcdHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG5cdFx0fVxuXG5cdFx0aW5oZXJpdChIYW5kbGVyLCBBc3luYyk7XG5cblx0XHRBc3luYy5wcm90b3R5cGUud2hlbiA9IGZ1bmN0aW9uKGNvbnRpbnVhdGlvbikge1xuXHRcdFx0dGFza3MuZW5xdWV1ZShuZXcgQ29udGludWF0aW9uVGFzayhjb250aW51YXRpb24sIHRoaXMpKTtcblx0XHR9O1xuXG5cdFx0QXN5bmMucHJvdG90eXBlLl9yZXBvcnQgPSBmdW5jdGlvbihjb250ZXh0KSB7XG5cdFx0XHR0aGlzLmpvaW4oKS5fcmVwb3J0KGNvbnRleHQpO1xuXHRcdH07XG5cblx0XHRBc3luYy5wcm90b3R5cGUuX3VucmVwb3J0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmpvaW4oKS5fdW5yZXBvcnQoKTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGFuZGxlciB0aGF0IHdyYXBzIGFuIHVudHJ1c3RlZCB0aGVuYWJsZSBhbmQgYXNzaW1pbGF0ZXMgaXQgaW4gYSBmdXR1cmUgc3RhY2tcblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSB0aGVuXG5cdFx0ICogQHBhcmFtIHt7dGhlbjogZnVuY3Rpb259fSB0aGVuYWJsZVxuXHRcdCAqIEBjb25zdHJ1Y3RvclxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIFRoZW5hYmxlKHRoZW4sIHRoZW5hYmxlKSB7XG5cdFx0XHRQZW5kaW5nLmNhbGwodGhpcyk7XG5cdFx0XHR0YXNrcy5lbnF1ZXVlKG5ldyBBc3NpbWlsYXRlVGFzayh0aGVuLCB0aGVuYWJsZSwgdGhpcykpO1xuXHRcdH1cblxuXHRcdGluaGVyaXQoUGVuZGluZywgVGhlbmFibGUpO1xuXG5cdFx0LyoqXG5cdFx0ICogSGFuZGxlciBmb3IgYSBmdWxmaWxsZWQgcHJvbWlzZVxuXHRcdCAqIEBwYXJhbSB7Kn0geCBmdWxmaWxsbWVudCB2YWx1ZVxuXHRcdCAqIEBjb25zdHJ1Y3RvclxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIEZ1bGZpbGxlZCh4KSB7XG5cdFx0XHRQcm9taXNlLmNyZWF0ZUNvbnRleHQodGhpcyk7XG5cdFx0XHR0aGlzLnZhbHVlID0geDtcblx0XHR9XG5cblx0XHRpbmhlcml0KEhhbmRsZXIsIEZ1bGZpbGxlZCk7XG5cblx0XHRGdWxmaWxsZWQucHJvdG90eXBlLl9zdGF0ZSA9IDE7XG5cblx0XHRGdWxmaWxsZWQucHJvdG90eXBlLmZvbGQgPSBmdW5jdGlvbihmLCB6LCBjLCB0bykge1xuXHRcdFx0cnVuQ29udGludWF0aW9uMyhmLCB6LCB0aGlzLCBjLCB0byk7XG5cdFx0fTtcblxuXHRcdEZ1bGZpbGxlZC5wcm90b3R5cGUud2hlbiA9IGZ1bmN0aW9uKGNvbnQpIHtcblx0XHRcdHJ1bkNvbnRpbnVhdGlvbjEoY29udC5mdWxmaWxsZWQsIHRoaXMsIGNvbnQucmVjZWl2ZXIsIGNvbnQucmVzb2x2ZXIpO1xuXHRcdH07XG5cblx0XHR2YXIgZXJyb3JJZCA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBIYW5kbGVyIGZvciBhIHJlamVjdGVkIHByb21pc2Vcblx0XHQgKiBAcGFyYW0geyp9IHggcmVqZWN0aW9uIHJlYXNvblxuXHRcdCAqIEBjb25zdHJ1Y3RvclxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIFJlamVjdGVkKHgpIHtcblx0XHRcdFByb21pc2UuY3JlYXRlQ29udGV4dCh0aGlzKTtcblxuXHRcdFx0dGhpcy5pZCA9ICsrZXJyb3JJZDtcblx0XHRcdHRoaXMudmFsdWUgPSB4O1xuXHRcdFx0dGhpcy5oYW5kbGVkID0gZmFsc2U7XG5cdFx0XHR0aGlzLnJlcG9ydGVkID0gZmFsc2U7XG5cblx0XHRcdHRoaXMuX3JlcG9ydCgpO1xuXHRcdH1cblxuXHRcdGluaGVyaXQoSGFuZGxlciwgUmVqZWN0ZWQpO1xuXG5cdFx0UmVqZWN0ZWQucHJvdG90eXBlLl9zdGF0ZSA9IC0xO1xuXG5cdFx0UmVqZWN0ZWQucHJvdG90eXBlLmZvbGQgPSBmdW5jdGlvbihmLCB6LCBjLCB0bykge1xuXHRcdFx0dG8uYmVjb21lKHRoaXMpO1xuXHRcdH07XG5cblx0XHRSZWplY3RlZC5wcm90b3R5cGUud2hlbiA9IGZ1bmN0aW9uKGNvbnQpIHtcblx0XHRcdGlmKHR5cGVvZiBjb250LnJlamVjdGVkID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHRoaXMuX3VucmVwb3J0KCk7XG5cdFx0XHR9XG5cdFx0XHRydW5Db250aW51YXRpb24xKGNvbnQucmVqZWN0ZWQsIHRoaXMsIGNvbnQucmVjZWl2ZXIsIGNvbnQucmVzb2x2ZXIpO1xuXHRcdH07XG5cblx0XHRSZWplY3RlZC5wcm90b3R5cGUuX3JlcG9ydCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcblx0XHRcdHRhc2tzLmFmdGVyUXVldWUobmV3IFJlcG9ydFRhc2sodGhpcywgY29udGV4dCkpO1xuXHRcdH07XG5cblx0XHRSZWplY3RlZC5wcm90b3R5cGUuX3VucmVwb3J0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZih0aGlzLmhhbmRsZWQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5oYW5kbGVkID0gdHJ1ZTtcblx0XHRcdHRhc2tzLmFmdGVyUXVldWUobmV3IFVucmVwb3J0VGFzayh0aGlzKSk7XG5cdFx0fTtcblxuXHRcdFJlamVjdGVkLnByb3RvdHlwZS5mYWlsID0gZnVuY3Rpb24oY29udGV4dCkge1xuXHRcdFx0dGhpcy5yZXBvcnRlZCA9IHRydWU7XG5cdFx0XHRlbWl0UmVqZWN0aW9uKCd1bmhhbmRsZWRSZWplY3Rpb24nLCB0aGlzKTtcblx0XHRcdFByb21pc2Uub25GYXRhbFJlamVjdGlvbih0aGlzLCBjb250ZXh0ID09PSB2b2lkIDAgPyB0aGlzLmNvbnRleHQgOiBjb250ZXh0KTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gUmVwb3J0VGFzayhyZWplY3Rpb24sIGNvbnRleHQpIHtcblx0XHRcdHRoaXMucmVqZWN0aW9uID0gcmVqZWN0aW9uO1xuXHRcdFx0dGhpcy5jb250ZXh0ID0gY29udGV4dDtcblx0XHR9XG5cblx0XHRSZXBvcnRUYXNrLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmKCF0aGlzLnJlamVjdGlvbi5oYW5kbGVkICYmICF0aGlzLnJlamVjdGlvbi5yZXBvcnRlZCkge1xuXHRcdFx0XHR0aGlzLnJlamVjdGlvbi5yZXBvcnRlZCA9IHRydWU7XG5cdFx0XHRcdGVtaXRSZWplY3Rpb24oJ3VuaGFuZGxlZFJlamVjdGlvbicsIHRoaXMucmVqZWN0aW9uKSB8fFxuXHRcdFx0XHRcdFByb21pc2Uub25Qb3RlbnRpYWxseVVuaGFuZGxlZFJlamVjdGlvbih0aGlzLnJlamVjdGlvbiwgdGhpcy5jb250ZXh0KTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gVW5yZXBvcnRUYXNrKHJlamVjdGlvbikge1xuXHRcdFx0dGhpcy5yZWplY3Rpb24gPSByZWplY3Rpb247XG5cdFx0fVxuXG5cdFx0VW5yZXBvcnRUYXNrLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmKHRoaXMucmVqZWN0aW9uLnJlcG9ydGVkKSB7XG5cdFx0XHRcdGVtaXRSZWplY3Rpb24oJ3JlamVjdGlvbkhhbmRsZWQnLCB0aGlzLnJlamVjdGlvbikgfHxcblx0XHRcdFx0XHRQcm9taXNlLm9uUG90ZW50aWFsbHlVbmhhbmRsZWRSZWplY3Rpb25IYW5kbGVkKHRoaXMucmVqZWN0aW9uKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Ly8gVW5oYW5kbGVkIHJlamVjdGlvbiBob29rc1xuXHRcdC8vIEJ5IGRlZmF1bHQsIGV2ZXJ5dGhpbmcgaXMgYSBub29wXG5cblx0XHRQcm9taXNlLmNyZWF0ZUNvbnRleHRcblx0XHRcdD0gUHJvbWlzZS5lbnRlckNvbnRleHRcblx0XHRcdD0gUHJvbWlzZS5leGl0Q29udGV4dFxuXHRcdFx0PSBQcm9taXNlLm9uUG90ZW50aWFsbHlVbmhhbmRsZWRSZWplY3Rpb25cblx0XHRcdD0gUHJvbWlzZS5vblBvdGVudGlhbGx5VW5oYW5kbGVkUmVqZWN0aW9uSGFuZGxlZFxuXHRcdFx0PSBQcm9taXNlLm9uRmF0YWxSZWplY3Rpb25cblx0XHRcdD0gbm9vcDtcblxuXHRcdC8vIEVycm9ycyBhbmQgc2luZ2xldG9uc1xuXG5cdFx0dmFyIGZvcmV2ZXJQZW5kaW5nSGFuZGxlciA9IG5ldyBIYW5kbGVyKCk7XG5cdFx0dmFyIGZvcmV2ZXJQZW5kaW5nUHJvbWlzZSA9IG5ldyBQcm9taXNlKEhhbmRsZXIsIGZvcmV2ZXJQZW5kaW5nSGFuZGxlcik7XG5cblx0XHRmdW5jdGlvbiBjeWNsZSgpIHtcblx0XHRcdHJldHVybiBuZXcgUmVqZWN0ZWQobmV3IFR5cGVFcnJvcignUHJvbWlzZSBjeWNsZScpKTtcblx0XHR9XG5cblx0XHQvLyBUYXNrIHJ1bm5lcnNcblxuXHRcdC8qKlxuXHRcdCAqIFJ1biBhIHNpbmdsZSBjb25zdW1lclxuXHRcdCAqIEBjb25zdHJ1Y3RvclxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIENvbnRpbnVhdGlvblRhc2soY29udGludWF0aW9uLCBoYW5kbGVyKSB7XG5cdFx0XHR0aGlzLmNvbnRpbnVhdGlvbiA9IGNvbnRpbnVhdGlvbjtcblx0XHRcdHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG5cdFx0fVxuXG5cdFx0Q29udGludWF0aW9uVGFzay5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmhhbmRsZXIuam9pbigpLndoZW4odGhpcy5jb250aW51YXRpb24pO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBSdW4gYSBxdWV1ZSBvZiBwcm9ncmVzcyBoYW5kbGVyc1xuXHRcdCAqIEBjb25zdHJ1Y3RvclxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIFByb2dyZXNzVGFzayh2YWx1ZSwgaGFuZGxlcikge1xuXHRcdFx0dGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcblx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHR9XG5cblx0XHRQcm9ncmVzc1Rhc2sucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHEgPSB0aGlzLmhhbmRsZXIuY29uc3VtZXJzO1xuXHRcdFx0aWYocSA9PT0gdm9pZCAwKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICh2YXIgYywgaSA9IDA7IGkgPCBxLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdGMgPSBxW2ldO1xuXHRcdFx0XHRydW5Ob3RpZnkoYy5wcm9ncmVzcywgdGhpcy52YWx1ZSwgdGhpcy5oYW5kbGVyLCBjLnJlY2VpdmVyLCBjLnJlc29sdmVyKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogQXNzaW1pbGF0ZSBhIHRoZW5hYmxlLCBzZW5kaW5nIGl0J3MgdmFsdWUgdG8gcmVzb2x2ZXJcblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSB0aGVuXG5cdFx0ICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHRoZW5hYmxlXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IHJlc29sdmVyXG5cdFx0ICogQGNvbnN0cnVjdG9yXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gQXNzaW1pbGF0ZVRhc2sodGhlbiwgdGhlbmFibGUsIHJlc29sdmVyKSB7XG5cdFx0XHR0aGlzLl90aGVuID0gdGhlbjtcblx0XHRcdHRoaXMudGhlbmFibGUgPSB0aGVuYWJsZTtcblx0XHRcdHRoaXMucmVzb2x2ZXIgPSByZXNvbHZlcjtcblx0XHR9XG5cblx0XHRBc3NpbWlsYXRlVGFzay5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaCA9IHRoaXMucmVzb2x2ZXI7XG5cdFx0XHR0cnlBc3NpbWlsYXRlKHRoaXMuX3RoZW4sIHRoaXMudGhlbmFibGUsIF9yZXNvbHZlLCBfcmVqZWN0LCBfbm90aWZ5KTtcblxuXHRcdFx0ZnVuY3Rpb24gX3Jlc29sdmUoeCkgeyBoLnJlc29sdmUoeCk7IH1cblx0XHRcdGZ1bmN0aW9uIF9yZWplY3QoeCkgIHsgaC5yZWplY3QoeCk7IH1cblx0XHRcdGZ1bmN0aW9uIF9ub3RpZnkoeCkgIHsgaC5ub3RpZnkoeCk7IH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gdHJ5QXNzaW1pbGF0ZSh0aGVuLCB0aGVuYWJsZSwgcmVzb2x2ZSwgcmVqZWN0LCBub3RpZnkpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHRoZW4uY2FsbCh0aGVuYWJsZSwgcmVzb2x2ZSwgcmVqZWN0LCBub3RpZnkpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRyZWplY3QoZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogRm9sZCBhIGhhbmRsZXIgdmFsdWUgd2l0aCB6XG5cdFx0ICogQGNvbnN0cnVjdG9yXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gRm9sZChmLCB6LCBjLCB0bykge1xuXHRcdFx0dGhpcy5mID0gZjsgdGhpcy56ID0gejsgdGhpcy5jID0gYzsgdGhpcy50byA9IHRvO1xuXHRcdFx0dGhpcy5yZXNvbHZlciA9IGZhaWxJZlJlamVjdGVkO1xuXHRcdFx0dGhpcy5yZWNlaXZlciA9IHRoaXM7XG5cdFx0fVxuXG5cdFx0Rm9sZC5wcm90b3R5cGUuZnVsZmlsbGVkID0gZnVuY3Rpb24oeCkge1xuXHRcdFx0dGhpcy5mLmNhbGwodGhpcy5jLCB0aGlzLnosIHgsIHRoaXMudG8pO1xuXHRcdH07XG5cblx0XHRGb2xkLnByb3RvdHlwZS5yZWplY3RlZCA9IGZ1bmN0aW9uKHgpIHtcblx0XHRcdHRoaXMudG8ucmVqZWN0KHgpO1xuXHRcdH07XG5cblx0XHRGb2xkLnByb3RvdHlwZS5wcm9ncmVzcyA9IGZ1bmN0aW9uKHgpIHtcblx0XHRcdHRoaXMudG8ubm90aWZ5KHgpO1xuXHRcdH07XG5cblx0XHQvLyBPdGhlciBoZWxwZXJzXG5cblx0XHQvKipcblx0XHQgKiBAcGFyYW0geyp9IHhcblx0XHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZmYgeCBpcyBhIHRydXN0ZWQgUHJvbWlzZVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGlzUHJvbWlzZSh4KSB7XG5cdFx0XHRyZXR1cm4geCBpbnN0YW5jZW9mIFByb21pc2U7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogVGVzdCBqdXN0IGVub3VnaCB0byBydWxlIG91dCBwcmltaXRpdmVzLCBpbiBvcmRlciB0byB0YWtlIGZhc3RlclxuXHRcdCAqIHBhdGhzIGluIHNvbWUgY29kZVxuXHRcdCAqIEBwYXJhbSB7Kn0geFxuXHRcdCAqIEByZXR1cm5zIHtib29sZWFufSBmYWxzZSBpZmYgeCBpcyBndWFyYW50ZWVkICpub3QqIHRvIGJlIGEgdGhlbmFibGVcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBtYXliZVRoZW5hYmxlKHgpIHtcblx0XHRcdHJldHVybiAodHlwZW9mIHggPT09ICdvYmplY3QnIHx8IHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nKSAmJiB4ICE9PSBudWxsO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJ1bkNvbnRpbnVhdGlvbjEoZiwgaCwgcmVjZWl2ZXIsIG5leHQpIHtcblx0XHRcdGlmKHR5cGVvZiBmICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHJldHVybiBuZXh0LmJlY29tZShoKTtcblx0XHRcdH1cblxuXHRcdFx0UHJvbWlzZS5lbnRlckNvbnRleHQoaCk7XG5cdFx0XHR0cnlDYXRjaFJlamVjdChmLCBoLnZhbHVlLCByZWNlaXZlciwgbmV4dCk7XG5cdFx0XHRQcm9taXNlLmV4aXRDb250ZXh0KCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcnVuQ29udGludWF0aW9uMyhmLCB4LCBoLCByZWNlaXZlciwgbmV4dCkge1xuXHRcdFx0aWYodHlwZW9mIGYgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0cmV0dXJuIG5leHQuYmVjb21lKGgpO1xuXHRcdFx0fVxuXG5cdFx0XHRQcm9taXNlLmVudGVyQ29udGV4dChoKTtcblx0XHRcdHRyeUNhdGNoUmVqZWN0MyhmLCB4LCBoLnZhbHVlLCByZWNlaXZlciwgbmV4dCk7XG5cdFx0XHRQcm9taXNlLmV4aXRDb250ZXh0KCk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogQGRlcHJlY2F0ZWRcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBydW5Ob3RpZnkoZiwgeCwgaCwgcmVjZWl2ZXIsIG5leHQpIHtcblx0XHRcdGlmKHR5cGVvZiBmICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHJldHVybiBuZXh0Lm5vdGlmeSh4KTtcblx0XHRcdH1cblxuXHRcdFx0UHJvbWlzZS5lbnRlckNvbnRleHQoaCk7XG5cdFx0XHR0cnlDYXRjaFJldHVybihmLCB4LCByZWNlaXZlciwgbmV4dCk7XG5cdFx0XHRQcm9taXNlLmV4aXRDb250ZXh0KCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHJ5Q2F0Y2gyKGYsIGEsIGIpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHJldHVybiBmKGEsIGIpO1xuXHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdHJldHVybiByZWplY3QoZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJuIGYuY2FsbCh0aGlzQXJnLCB4KSwgb3IgaWYgaXQgdGhyb3dzIHJldHVybiBhIHJlamVjdGVkIHByb21pc2UgZm9yXG5cdFx0ICogdGhlIHRocm93biBleGNlcHRpb25cblx0XHQgKi9cblx0XHRmdW5jdGlvbiB0cnlDYXRjaFJlamVjdChmLCB4LCB0aGlzQXJnLCBuZXh0KSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRuZXh0LmJlY29tZShnZXRIYW5kbGVyKGYuY2FsbCh0aGlzQXJnLCB4KSkpO1xuXHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdG5leHQuYmVjb21lKG5ldyBSZWplY3RlZChlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogU2FtZSBhcyBhYm92ZSwgYnV0IGluY2x1ZGVzIHRoZSBleHRyYSBhcmd1bWVudCBwYXJhbWV0ZXIuXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gdHJ5Q2F0Y2hSZWplY3QzKGYsIHgsIHksIHRoaXNBcmcsIG5leHQpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGYuY2FsbCh0aGlzQXJnLCB4LCB5LCBuZXh0KTtcblx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRuZXh0LmJlY29tZShuZXcgUmVqZWN0ZWQoZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEBkZXByZWNhdGVkXG5cdFx0ICogUmV0dXJuIGYuY2FsbCh0aGlzQXJnLCB4KSwgb3IgaWYgaXQgdGhyb3dzLCAqcmV0dXJuKiB0aGUgZXhjZXB0aW9uXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gdHJ5Q2F0Y2hSZXR1cm4oZiwgeCwgdGhpc0FyZywgbmV4dCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0bmV4dC5ub3RpZnkoZi5jYWxsKHRoaXNBcmcsIHgpKTtcblx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRuZXh0Lm5vdGlmeShlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpbmhlcml0KFBhcmVudCwgQ2hpbGQpIHtcblx0XHRcdENoaWxkLnByb3RvdHlwZSA9IG9iamVjdENyZWF0ZShQYXJlbnQucHJvdG90eXBlKTtcblx0XHRcdENoaWxkLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENoaWxkO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHNuZCh4LCB5KSB7XG5cdFx0XHRyZXR1cm4geTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBub29wKCkge31cblxuXHRcdGZ1bmN0aW9uIGluaXRFbWl0UmVqZWN0aW9uKCkge1xuXHRcdFx0LypnbG9iYWwgcHJvY2Vzcywgc2VsZiwgQ3VzdG9tRXZlbnQqL1xuXHRcdFx0aWYodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MgIT09IG51bGxcblx0XHRcdFx0JiYgdHlwZW9mIHByb2Nlc3MuZW1pdCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHQvLyBSZXR1cm5pbmcgZmFsc3kgaGVyZSBtZWFucyB0byBjYWxsIHRoZSBkZWZhdWx0XG5cdFx0XHRcdC8vIG9uUG90ZW50aWFsbHlVbmhhbmRsZWRSZWplY3Rpb24gQVBJLiAgVGhpcyBpcyBzYWZlIGV2ZW4gaW5cblx0XHRcdFx0Ly8gYnJvd3NlcmlmeSBzaW5jZSBwcm9jZXNzLmVtaXQgYWx3YXlzIHJldHVybnMgZmFsc3kgaW4gYnJvd3NlcmlmeTpcblx0XHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2RlZnVuY3R6b21iaWUvbm9kZS1wcm9jZXNzL2Jsb2IvbWFzdGVyL2Jyb3dzZXIuanMjTDQwLUw0NlxuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24odHlwZSwgcmVqZWN0aW9uKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHR5cGUgPT09ICd1bmhhbmRsZWRSZWplY3Rpb24nXG5cdFx0XHRcdFx0XHQ/IHByb2Nlc3MuZW1pdCh0eXBlLCByZWplY3Rpb24udmFsdWUsIHJlamVjdGlvbilcblx0XHRcdFx0XHRcdDogcHJvY2Vzcy5lbWl0KHR5cGUsIHJlamVjdGlvbik7XG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2UgaWYodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBDdXN0b21FdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRyZXR1cm4gKGZ1bmN0aW9uKG5vb3AsIHNlbGYsIEN1c3RvbUV2ZW50KSB7XG5cdFx0XHRcdFx0dmFyIGhhc0N1c3RvbUV2ZW50ID0gZmFsc2U7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdHZhciBldiA9IG5ldyBDdXN0b21FdmVudCgndW5oYW5kbGVkUmVqZWN0aW9uJyk7XG5cdFx0XHRcdFx0XHRoYXNDdXN0b21FdmVudCA9IGV2IGluc3RhbmNlb2YgQ3VzdG9tRXZlbnQ7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZSkge31cblxuXHRcdFx0XHRcdHJldHVybiAhaGFzQ3VzdG9tRXZlbnQgPyBub29wIDogZnVuY3Rpb24odHlwZSwgcmVqZWN0aW9uKSB7XG5cdFx0XHRcdFx0XHR2YXIgZXYgPSBuZXcgQ3VzdG9tRXZlbnQodHlwZSwge1xuXHRcdFx0XHRcdFx0XHRkZXRhaWw6IHtcblx0XHRcdFx0XHRcdFx0XHRyZWFzb246IHJlamVjdGlvbi52YWx1ZSxcblx0XHRcdFx0XHRcdFx0XHRrZXk6IHJlamVjdGlvblxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRidWJibGVzOiBmYWxzZSxcblx0XHRcdFx0XHRcdFx0Y2FuY2VsYWJsZTogdHJ1ZVxuXHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdHJldHVybiAhc2VsZi5kaXNwYXRjaEV2ZW50KGV2KTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9KG5vb3AsIHNlbGYsIEN1c3RvbUV2ZW50KSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBub29wO1xuXHRcdH1cblxuXHRcdHJldHVybiBQcm9taXNlO1xuXHR9O1xufSk7XG59KHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7IH0pKTtcbiIsIi8qKiBAbGljZW5zZSBNSVQgTGljZW5zZSAoYykgY29weXJpZ2h0IDIwMTAtMjAxNCBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9ycyAqL1xuLyoqIEBhdXRob3IgQnJpYW4gQ2F2YWxpZXIgKi9cbi8qKiBAYXV0aG9yIEpvaG4gSGFubiAqL1xuXG4oZnVuY3Rpb24oZGVmaW5lKSB7ICd1c2Ugc3RyaWN0JztcbmRlZmluZShmdW5jdGlvbigpIHtcblxuXHRyZXR1cm4ge1xuXHRcdHBlbmRpbmc6IHRvUGVuZGluZ1N0YXRlLFxuXHRcdGZ1bGZpbGxlZDogdG9GdWxmaWxsZWRTdGF0ZSxcblx0XHRyZWplY3RlZDogdG9SZWplY3RlZFN0YXRlLFxuXHRcdGluc3BlY3Q6IGluc3BlY3Rcblx0fTtcblxuXHRmdW5jdGlvbiB0b1BlbmRpbmdTdGF0ZSgpIHtcblx0XHRyZXR1cm4geyBzdGF0ZTogJ3BlbmRpbmcnIH07XG5cdH1cblxuXHRmdW5jdGlvbiB0b1JlamVjdGVkU3RhdGUoZSkge1xuXHRcdHJldHVybiB7IHN0YXRlOiAncmVqZWN0ZWQnLCByZWFzb246IGUgfTtcblx0fVxuXG5cdGZ1bmN0aW9uIHRvRnVsZmlsbGVkU3RhdGUoeCkge1xuXHRcdHJldHVybiB7IHN0YXRlOiAnZnVsZmlsbGVkJywgdmFsdWU6IHggfTtcblx0fVxuXG5cdGZ1bmN0aW9uIGluc3BlY3QoaGFuZGxlcikge1xuXHRcdHZhciBzdGF0ZSA9IGhhbmRsZXIuc3RhdGUoKTtcblx0XHRyZXR1cm4gc3RhdGUgPT09IDAgPyB0b1BlbmRpbmdTdGF0ZSgpXG5cdFx0XHQgOiBzdGF0ZSA+IDAgICA/IHRvRnVsZmlsbGVkU3RhdGUoaGFuZGxlci52YWx1ZSlcblx0XHRcdCAgICAgICAgICAgICAgIDogdG9SZWplY3RlZFN0YXRlKGhhbmRsZXIudmFsdWUpO1xuXHR9XG5cbn0pO1xufSh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbihmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpOyB9KSk7XG4iLCIvKiogQGxpY2Vuc2UgTUlUIExpY2Vuc2UgKGMpIGNvcHlyaWdodCAyMDEwLTIwMTQgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnMgKi9cblxuLyoqXG4gKiBQcm9taXNlcy9BKyBhbmQgd2hlbigpIGltcGxlbWVudGF0aW9uXG4gKiB3aGVuIGlzIHBhcnQgb2YgdGhlIGN1am9KUyBmYW1pbHkgb2YgbGlicmFyaWVzIChodHRwOi8vY3Vqb2pzLmNvbS8pXG4gKiBAYXV0aG9yIEJyaWFuIENhdmFsaWVyXG4gKiBAYXV0aG9yIEpvaG4gSGFublxuICovXG4oZnVuY3Rpb24oZGVmaW5lKSB7ICd1c2Ugc3RyaWN0JztcbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuXG5cdHZhciB0aW1lZCA9IHJlcXVpcmUoJy4vbGliL2RlY29yYXRvcnMvdGltZWQnKTtcblx0dmFyIGFycmF5ID0gcmVxdWlyZSgnLi9saWIvZGVjb3JhdG9ycy9hcnJheScpO1xuXHR2YXIgZmxvdyA9IHJlcXVpcmUoJy4vbGliL2RlY29yYXRvcnMvZmxvdycpO1xuXHR2YXIgZm9sZCA9IHJlcXVpcmUoJy4vbGliL2RlY29yYXRvcnMvZm9sZCcpO1xuXHR2YXIgaW5zcGVjdCA9IHJlcXVpcmUoJy4vbGliL2RlY29yYXRvcnMvaW5zcGVjdCcpO1xuXHR2YXIgZ2VuZXJhdGUgPSByZXF1aXJlKCcuL2xpYi9kZWNvcmF0b3JzL2l0ZXJhdGUnKTtcblx0dmFyIHByb2dyZXNzID0gcmVxdWlyZSgnLi9saWIvZGVjb3JhdG9ycy9wcm9ncmVzcycpO1xuXHR2YXIgd2l0aFRoaXMgPSByZXF1aXJlKCcuL2xpYi9kZWNvcmF0b3JzL3dpdGgnKTtcblx0dmFyIHVuaGFuZGxlZFJlamVjdGlvbiA9IHJlcXVpcmUoJy4vbGliL2RlY29yYXRvcnMvdW5oYW5kbGVkUmVqZWN0aW9uJyk7XG5cdHZhciBUaW1lb3V0RXJyb3IgPSByZXF1aXJlKCcuL2xpYi9UaW1lb3V0RXJyb3InKTtcblxuXHR2YXIgUHJvbWlzZSA9IFthcnJheSwgZmxvdywgZm9sZCwgZ2VuZXJhdGUsIHByb2dyZXNzLFxuXHRcdGluc3BlY3QsIHdpdGhUaGlzLCB0aW1lZCwgdW5oYW5kbGVkUmVqZWN0aW9uXVxuXHRcdC5yZWR1Y2UoZnVuY3Rpb24oUHJvbWlzZSwgZmVhdHVyZSkge1xuXHRcdFx0cmV0dXJuIGZlYXR1cmUoUHJvbWlzZSk7XG5cdFx0fSwgcmVxdWlyZSgnLi9saWIvUHJvbWlzZScpKTtcblxuXHR2YXIgYXBwbHkgPSByZXF1aXJlKCcuL2xpYi9hcHBseScpKFByb21pc2UpO1xuXG5cdC8vIFB1YmxpYyBBUElcblxuXHR3aGVuLnByb21pc2UgICAgID0gcHJvbWlzZTsgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIHBlbmRpbmcgcHJvbWlzZVxuXHR3aGVuLnJlc29sdmUgICAgID0gUHJvbWlzZS5yZXNvbHZlOyAgICAgIC8vIENyZWF0ZSBhIHJlc29sdmVkIHByb21pc2Vcblx0d2hlbi5yZWplY3QgICAgICA9IFByb21pc2UucmVqZWN0OyAgICAgICAvLyBDcmVhdGUgYSByZWplY3RlZCBwcm9taXNlXG5cblx0d2hlbi5saWZ0ICAgICAgICA9IGxpZnQ7ICAgICAgICAgICAgICAgICAvLyBsaWZ0IGEgZnVuY3Rpb24gdG8gcmV0dXJuIHByb21pc2VzXG5cdHdoZW5bJ3RyeSddICAgICAgPSBhdHRlbXB0OyAgICAgICAgICAgICAgLy8gY2FsbCBhIGZ1bmN0aW9uIGFuZCByZXR1cm4gYSBwcm9taXNlXG5cdHdoZW4uYXR0ZW1wdCAgICAgPSBhdHRlbXB0OyAgICAgICAgICAgICAgLy8gYWxpYXMgZm9yIHdoZW4udHJ5XG5cblx0d2hlbi5pdGVyYXRlICAgICA9IFByb21pc2UuaXRlcmF0ZTsgICAgICAvLyBERVBSRUNBVEVEICh1c2UgY3Vqb2pzL21vc3Qgc3RyZWFtcykgR2VuZXJhdGUgYSBzdHJlYW0gb2YgcHJvbWlzZXNcblx0d2hlbi51bmZvbGQgICAgICA9IFByb21pc2UudW5mb2xkOyAgICAgICAvLyBERVBSRUNBVEVEICh1c2UgY3Vqb2pzL21vc3Qgc3RyZWFtcykgR2VuZXJhdGUgYSBzdHJlYW0gb2YgcHJvbWlzZXNcblxuXHR3aGVuLmpvaW4gICAgICAgID0gam9pbjsgICAgICAgICAgICAgICAgIC8vIEpvaW4gMiBvciBtb3JlIHByb21pc2VzXG5cblx0d2hlbi5hbGwgICAgICAgICA9IGFsbDsgICAgICAgICAgICAgICAgICAvLyBSZXNvbHZlIGEgbGlzdCBvZiBwcm9taXNlc1xuXHR3aGVuLnNldHRsZSAgICAgID0gc2V0dGxlOyAgICAgICAgICAgICAgIC8vIFNldHRsZSBhIGxpc3Qgb2YgcHJvbWlzZXNcblxuXHR3aGVuLmFueSAgICAgICAgID0gbGlmdChQcm9taXNlLmFueSk7ICAgIC8vIE9uZS13aW5uZXIgcmFjZVxuXHR3aGVuLnNvbWUgICAgICAgID0gbGlmdChQcm9taXNlLnNvbWUpOyAgIC8vIE11bHRpLXdpbm5lciByYWNlXG5cdHdoZW4ucmFjZSAgICAgICAgPSBsaWZ0KFByb21pc2UucmFjZSk7ICAgLy8gRmlyc3QtdG8tc2V0dGxlIHJhY2VcblxuXHR3aGVuLm1hcCAgICAgICAgID0gbWFwOyAgICAgICAgICAgICAgICAgIC8vIEFycmF5Lm1hcCgpIGZvciBwcm9taXNlc1xuXHR3aGVuLmZpbHRlciAgICAgID0gZmlsdGVyOyAgICAgICAgICAgICAgIC8vIEFycmF5LmZpbHRlcigpIGZvciBwcm9taXNlc1xuXHR3aGVuLnJlZHVjZSAgICAgID0gbGlmdChQcm9taXNlLnJlZHVjZSk7ICAgICAgIC8vIEFycmF5LnJlZHVjZSgpIGZvciBwcm9taXNlc1xuXHR3aGVuLnJlZHVjZVJpZ2h0ID0gbGlmdChQcm9taXNlLnJlZHVjZVJpZ2h0KTsgIC8vIEFycmF5LnJlZHVjZVJpZ2h0KCkgZm9yIHByb21pc2VzXG5cblx0d2hlbi5pc1Byb21pc2VMaWtlID0gaXNQcm9taXNlTGlrZTsgICAgICAvLyBJcyBzb21ldGhpbmcgcHJvbWlzZS1saWtlLCBha2EgdGhlbmFibGVcblxuXHR3aGVuLlByb21pc2UgICAgID0gUHJvbWlzZTsgICAgICAgICAgICAgIC8vIFByb21pc2UgY29uc3RydWN0b3Jcblx0d2hlbi5kZWZlciAgICAgICA9IGRlZmVyOyAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSB7cHJvbWlzZSwgcmVzb2x2ZSwgcmVqZWN0fSB0dXBsZVxuXG5cdC8vIEVycm9yIHR5cGVzXG5cblx0d2hlbi5UaW1lb3V0RXJyb3IgPSBUaW1lb3V0RXJyb3I7XG5cblx0LyoqXG5cdCAqIEdldCBhIHRydXN0ZWQgcHJvbWlzZSBmb3IgeCwgb3IgYnkgdHJhbnNmb3JtaW5nIHggd2l0aCBvbkZ1bGZpbGxlZFxuXHQgKlxuXHQgKiBAcGFyYW0geyp9IHhcblx0ICogQHBhcmFtIHtmdW5jdGlvbj99IG9uRnVsZmlsbGVkIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCB3aGVuIHggaXNcblx0ICogICBzdWNjZXNzZnVsbHkgZnVsZmlsbGVkLiAgSWYgcHJvbWlzZU9yVmFsdWUgaXMgYW4gaW1tZWRpYXRlIHZhbHVlLCBjYWxsYmFja1xuXHQgKiAgIHdpbGwgYmUgaW52b2tlZCBpbW1lZGlhdGVseS5cblx0ICogQHBhcmFtIHtmdW5jdGlvbj99IG9uUmVqZWN0ZWQgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIHdoZW4geCBpc1xuXHQgKiAgIHJlamVjdGVkLlxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9uP30gb25Qcm9ncmVzcyBjYWxsYmFjayB0byBiZSBjYWxsZWQgd2hlbiBwcm9ncmVzcyB1cGRhdGVzXG5cdCAqICAgYXJlIGlzc3VlZCBmb3IgeC4gQGRlcHJlY2F0ZWRcblx0ICogQHJldHVybnMge1Byb21pc2V9IGEgbmV3IHByb21pc2UgdGhhdCB3aWxsIGZ1bGZpbGwgd2l0aCB0aGUgcmV0dXJuXG5cdCAqICAgdmFsdWUgb2YgY2FsbGJhY2sgb3IgZXJyYmFjayBvciB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiBwcm9taXNlT3JWYWx1ZSBpZlxuXHQgKiAgIGNhbGxiYWNrIGFuZC9vciBlcnJiYWNrIGlzIG5vdCBzdXBwbGllZC5cblx0ICovXG5cdGZ1bmN0aW9uIHdoZW4oeCwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MpIHtcblx0XHR2YXIgcCA9IFByb21pc2UucmVzb2x2ZSh4KTtcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcblx0XHRcdHJldHVybiBwO1xuXHRcdH1cblxuXHRcdHJldHVybiBwLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcgcHJvbWlzZSB3aG9zZSBmYXRlIGlzIGRldGVybWluZWQgYnkgcmVzb2x2ZXIuXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IHJlc29sdmVyIGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCwgbm90aWZ5KVxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSB3aG9zZSBmYXRlIGlzIGRldGVybWluZSBieSByZXNvbHZlclxuXHQgKi9cblx0ZnVuY3Rpb24gcHJvbWlzZShyZXNvbHZlcikge1xuXHRcdHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlcik7XG5cdH1cblxuXHQvKipcblx0ICogTGlmdCB0aGUgc3VwcGxpZWQgZnVuY3Rpb24sIGNyZWF0aW5nIGEgdmVyc2lvbiBvZiBmIHRoYXQgcmV0dXJuc1xuXHQgKiBwcm9taXNlcywgYW5kIGFjY2VwdHMgcHJvbWlzZXMgYXMgYXJndW1lbnRzLlxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmXG5cdCAqIEByZXR1cm5zIHtGdW5jdGlvbn0gdmVyc2lvbiBvZiBmIHRoYXQgcmV0dXJucyBwcm9taXNlc1xuXHQgKi9cblx0ZnVuY3Rpb24gbGlmdChmKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0Zm9yKHZhciBpPTAsIGw9YXJndW1lbnRzLmxlbmd0aCwgYT1uZXcgQXJyYXkobCk7IGk8bDsgKytpKSB7XG5cdFx0XHRcdGFbaV0gPSBhcmd1bWVudHNbaV07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYXBwbHkoZiwgdGhpcywgYSk7XG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDYWxsIGYgaW4gYSBmdXR1cmUgdHVybiwgd2l0aCB0aGUgc3VwcGxpZWQgYXJncywgYW5kIHJldHVybiBhIHByb21pc2Vcblx0ICogZm9yIHRoZSByZXN1bHQuXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGZcblx0ICogQHJldHVybnMge1Byb21pc2V9XG5cdCAqL1xuXHRmdW5jdGlvbiBhdHRlbXB0KGYgLyosIGFyZ3MuLi4gKi8pIHtcblx0XHQvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuXHRcdGZvcih2YXIgaT0wLCBsPWFyZ3VtZW50cy5sZW5ndGgtMSwgYT1uZXcgQXJyYXkobCk7IGk8bDsgKytpKSB7XG5cdFx0XHRhW2ldID0gYXJndW1lbnRzW2krMV07XG5cdFx0fVxuXHRcdHJldHVybiBhcHBseShmLCB0aGlzLCBhKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEge3Byb21pc2UsIHJlc29sdmVyfSBwYWlyLCBlaXRoZXIgb3IgYm90aCBvZiB3aGljaFxuXHQgKiBtYXkgYmUgZ2l2ZW4gb3V0IHNhZmVseSB0byBjb25zdW1lcnMuXG5cdCAqIEByZXR1cm4ge3twcm9taXNlOiBQcm9taXNlLCByZXNvbHZlOiBmdW5jdGlvbiwgcmVqZWN0OiBmdW5jdGlvbiwgbm90aWZ5OiBmdW5jdGlvbn19XG5cdCAqL1xuXHRmdW5jdGlvbiBkZWZlcigpIHtcblx0XHRyZXR1cm4gbmV3IERlZmVycmVkKCk7XG5cdH1cblxuXHRmdW5jdGlvbiBEZWZlcnJlZCgpIHtcblx0XHR2YXIgcCA9IFByb21pc2UuX2RlZmVyKCk7XG5cblx0XHRmdW5jdGlvbiByZXNvbHZlKHgpIHsgcC5faGFuZGxlci5yZXNvbHZlKHgpOyB9XG5cdFx0ZnVuY3Rpb24gcmVqZWN0KHgpIHsgcC5faGFuZGxlci5yZWplY3QoeCk7IH1cblx0XHRmdW5jdGlvbiBub3RpZnkoeCkgeyBwLl9oYW5kbGVyLm5vdGlmeSh4KTsgfVxuXG5cdFx0dGhpcy5wcm9taXNlID0gcDtcblx0XHR0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xuXHRcdHRoaXMucmVqZWN0ID0gcmVqZWN0O1xuXHRcdHRoaXMubm90aWZ5ID0gbm90aWZ5O1xuXHRcdHRoaXMucmVzb2x2ZXIgPSB7IHJlc29sdmU6IHJlc29sdmUsIHJlamVjdDogcmVqZWN0LCBub3RpZnk6IG5vdGlmeSB9O1xuXHR9XG5cblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgeCBpcyBwcm9taXNlLWxpa2UsIGkuZS4gYSB0aGVuYWJsZSBvYmplY3Rcblx0ICogTk9URTogV2lsbCByZXR1cm4gdHJ1ZSBmb3IgKmFueSB0aGVuYWJsZSBvYmplY3QqLCBhbmQgaXNuJ3QgdHJ1bHlcblx0ICogc2FmZSwgc2luY2UgaXQgbWF5IGF0dGVtcHQgdG8gYWNjZXNzIHRoZSBgdGhlbmAgcHJvcGVydHkgb2YgeCAoaS5lLlxuXHQgKiAgY2xldmVyL21hbGljaW91cyBnZXR0ZXJzIG1heSBkbyB3ZWlyZCB0aGluZ3MpXG5cdCAqIEBwYXJhbSB7Kn0geCBhbnl0aGluZ1xuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB4IGlzIHByb21pc2UtbGlrZVxuXHQgKi9cblx0ZnVuY3Rpb24gaXNQcm9taXNlTGlrZSh4KSB7XG5cdFx0cmV0dXJuIHggJiYgdHlwZW9mIHgudGhlbiA9PT0gJ2Z1bmN0aW9uJztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm4gYSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIG9ubHkgb25jZSBhbGwgdGhlIHN1cHBsaWVkIGFyZ3VtZW50c1xuXHQgKiBoYXZlIHJlc29sdmVkLiBUaGUgcmVzb2x1dGlvbiB2YWx1ZSBvZiB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGJlIGFuIGFycmF5XG5cdCAqIGNvbnRhaW5pbmcgdGhlIHJlc29sdXRpb24gdmFsdWVzIG9mIGVhY2ggb2YgdGhlIGFyZ3VtZW50cy5cblx0ICogQHBhcmFtIHsuLi4qfSBhcmd1bWVudHMgbWF5IGJlIGEgbWl4IG9mIHByb21pc2VzIGFuZCB2YWx1ZXNcblx0ICogQHJldHVybnMge1Byb21pc2V9XG5cdCAqL1xuXHRmdW5jdGlvbiBqb2luKC8qIC4uLnByb21pc2VzICovKSB7XG5cdFx0cmV0dXJuIFByb21pc2UuYWxsKGFyZ3VtZW50cyk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJuIGEgcHJvbWlzZSB0aGF0IHdpbGwgZnVsZmlsbCBvbmNlIGFsbCBpbnB1dCBwcm9taXNlcyBoYXZlXG5cdCAqIGZ1bGZpbGxlZCwgb3IgcmVqZWN0IHdoZW4gYW55IG9uZSBpbnB1dCBwcm9taXNlIHJlamVjdHMuXG5cdCAqIEBwYXJhbSB7YXJyYXl8UHJvbWlzZX0gcHJvbWlzZXMgYXJyYXkgKG9yIHByb21pc2UgZm9yIGFuIGFycmF5KSBvZiBwcm9taXNlc1xuXHQgKiBAcmV0dXJucyB7UHJvbWlzZX1cblx0ICovXG5cdGZ1bmN0aW9uIGFsbChwcm9taXNlcykge1xuXHRcdHJldHVybiB3aGVuKHByb21pc2VzLCBQcm9taXNlLmFsbCk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJuIGEgcHJvbWlzZSB0aGF0IHdpbGwgYWx3YXlzIGZ1bGZpbGwgd2l0aCBhbiBhcnJheSBjb250YWluaW5nXG5cdCAqIHRoZSBvdXRjb21lIHN0YXRlcyBvZiBhbGwgaW5wdXQgcHJvbWlzZXMuICBUaGUgcmV0dXJuZWQgcHJvbWlzZVxuXHQgKiB3aWxsIG9ubHkgcmVqZWN0IGlmIGBwcm9taXNlc2AgaXRzZWxmIGlzIGEgcmVqZWN0ZWQgcHJvbWlzZS5cblx0ICogQHBhcmFtIHthcnJheXxQcm9taXNlfSBwcm9taXNlcyBhcnJheSAob3IgcHJvbWlzZSBmb3IgYW4gYXJyYXkpIG9mIHByb21pc2VzXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIGZvciBhcnJheSBvZiBzZXR0bGVkIHN0YXRlIGRlc2NyaXB0b3JzXG5cdCAqL1xuXHRmdW5jdGlvbiBzZXR0bGUocHJvbWlzZXMpIHtcblx0XHRyZXR1cm4gd2hlbihwcm9taXNlcywgUHJvbWlzZS5zZXR0bGUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFByb21pc2UtYXdhcmUgYXJyYXkgbWFwIGZ1bmN0aW9uLCBzaW1pbGFyIHRvIGBBcnJheS5wcm90b3R5cGUubWFwKClgLFxuXHQgKiBidXQgaW5wdXQgYXJyYXkgbWF5IGNvbnRhaW4gcHJvbWlzZXMgb3IgdmFsdWVzLlxuXHQgKiBAcGFyYW0ge0FycmF5fFByb21pc2V9IHByb21pc2VzIGFycmF5IG9mIGFueXRoaW5nLCBtYXkgY29udGFpbiBwcm9taXNlcyBhbmQgdmFsdWVzXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb24oeDoqLCBpbmRleDpOdW1iZXIpOip9IG1hcEZ1bmMgbWFwIGZ1bmN0aW9uIHdoaWNoIG1heVxuXHQgKiAgcmV0dXJuIGEgcHJvbWlzZSBvciB2YWx1ZVxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSB0aGF0IHdpbGwgZnVsZmlsbCB3aXRoIGFuIGFycmF5IG9mIG1hcHBlZCB2YWx1ZXNcblx0ICogIG9yIHJlamVjdCBpZiBhbnkgaW5wdXQgcHJvbWlzZSByZWplY3RzLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKHByb21pc2VzLCBtYXBGdW5jKSB7XG5cdFx0cmV0dXJuIHdoZW4ocHJvbWlzZXMsIGZ1bmN0aW9uKHByb21pc2VzKSB7XG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5tYXAocHJvbWlzZXMsIG1hcEZ1bmMpO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEZpbHRlciB0aGUgcHJvdmlkZWQgYXJyYXkgb2YgcHJvbWlzZXMgdXNpbmcgdGhlIHByb3ZpZGVkIHByZWRpY2F0ZS4gIElucHV0IG1heVxuXHQgKiBjb250YWluIHByb21pc2VzIGFuZCB2YWx1ZXNcblx0ICogQHBhcmFtIHtBcnJheXxQcm9taXNlfSBwcm9taXNlcyBhcnJheSBvZiBwcm9taXNlcyBhbmQgdmFsdWVzXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb24oeDoqLCBpbmRleDpOdW1iZXIpOmJvb2xlYW59IHByZWRpY2F0ZSBmaWx0ZXJpbmcgcHJlZGljYXRlLlxuXHQgKiAgTXVzdCByZXR1cm4gdHJ1dGh5IChvciBwcm9taXNlIGZvciB0cnV0aHkpIGZvciBpdGVtcyB0byByZXRhaW4uXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIHRoYXQgd2lsbCBmdWxmaWxsIHdpdGggYW4gYXJyYXkgY29udGFpbmluZyBhbGwgaXRlbXNcblx0ICogIGZvciB3aGljaCBwcmVkaWNhdGUgcmV0dXJuZWQgdHJ1dGh5LlxuXHQgKi9cblx0ZnVuY3Rpb24gZmlsdGVyKHByb21pc2VzLCBwcmVkaWNhdGUpIHtcblx0XHRyZXR1cm4gd2hlbihwcm9taXNlcywgZnVuY3Rpb24ocHJvbWlzZXMpIHtcblx0XHRcdHJldHVybiBQcm9taXNlLmZpbHRlcihwcm9taXNlcywgcHJlZGljYXRlKTtcblx0XHR9KTtcblx0fVxuXG5cdHJldHVybiB3aGVuO1xufSk7XG59KSh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbiAoZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSk7IH0pO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDEzIHRoZSBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9yc1xuICogQGxpY2Vuc2UgTUlULCBzZWUgTElDRU5TRS50eHQgZm9yIGRldGFpbHNcbiAqXG4gKiBAYXV0aG9yIFNjb3R0IEFuZHJld3NcbiAqL1xuXG4oZnVuY3Rpb24gKGRlZmluZSkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0ZGVmaW5lKGZ1bmN0aW9uICgvKiByZXF1aXJlICovKSB7XG5cblx0XHRyZXR1cm4ge1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIEZpbmQgb2JqZWN0cyB3aXRoaW4gYSBncmFwaCB0aGUgY29udGFpbiBhIHByb3BlcnR5IG9mIGEgY2VydGFpbiBuYW1lLlxuXHRcdFx0ICpcblx0XHRcdCAqIE5PVEU6IHRoaXMgbWV0aG9kIHdpbGwgbm90IGRpc2NvdmVyIG9iamVjdCBncmFwaCBjeWNsZXMuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHsqfSBvYmogb2JqZWN0IHRvIHNlYXJjaCBvblxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IHByb3AgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gc2VhcmNoIGZvclxuXHRcdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdG8gcmVjZWl2ZSB0aGUgZm91bmQgcHJvcGVydGllcyBhbmQgdGhlaXIgcGFyZW50XG5cdFx0XHQgKi9cblx0XHRcdGZpbmRQcm9wZXJ0aWVzOiBmdW5jdGlvbiBmaW5kUHJvcGVydGllcyhvYmosIHByb3AsIGNhbGxiYWNrKSB7XG5cdFx0XHRcdGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHsgcmV0dXJuOyB9XG5cdFx0XHRcdGlmIChwcm9wIGluIG9iaikge1xuXHRcdFx0XHRcdGNhbGxiYWNrKG9ialtwcm9wXSwgb2JqLCBwcm9wKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0XHRcdGZpbmRQcm9wZXJ0aWVzKG9ialtrZXldLCBwcm9wLCBjYWxsYmFjayk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHR9KTtcblxufShcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24gKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUpOyB9XG5cdC8vIEJvaWxlcnBsYXRlIGZvciBBTUQgYW5kIE5vZGVcbikpO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDEzIHRoZSBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9yc1xuICogQGxpY2Vuc2UgTUlULCBzZWUgTElDRU5TRS50eHQgZm9yIGRldGFpbHNcbiAqXG4gKiBAYXV0aG9yIFNjb3R0IEFuZHJld3NcbiAqL1xuXG4oZnVuY3Rpb24gKGRlZmluZSkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0ZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cblx0XHR2YXIgd2hlbjtcblxuXHRcdHdoZW4gPSByZXF1aXJlKCd3aGVuJyk7XG5cblx0XHQvKipcblx0XHQgKiBDcmVhdGUgYSBwcm9taXNlIHdob3NlIHdvcmsgaXMgc3RhcnRlZCBvbmx5IHdoZW4gYSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQuXG5cdFx0ICpcblx0XHQgKiBUaGUgd29yayBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWQgYXQgbW9zdCBvbmNlLiBUaHJvd24gdmFsdWVzIHdpbGwgcmVzdWx0XG5cdFx0ICogaW4gcHJvbWlzZSByZWplY3Rpb24uXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSB3b3JrIGZ1bmN0aW9uIHdob3NlIG91cHV0IGlzIHVzZWQgdG8gcmVzb2x2ZSB0aGVcblx0XHQgKiAgIHJldHVybmVkIHByb21pc2UuXG5cdFx0ICogQHJldHVybnMge1Byb21pc2V9IGEgbGF6eSBwcm9taXNlXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gbGF6eVByb21pc2Uod29yaykge1xuXHRcdFx0dmFyIGRlZmVyLCBzdGFydGVkLCByZXNvbHZlciwgcHJvbWlzZSwgdGhlbjtcblxuXHRcdFx0ZGVmZXIgPSB3aGVuLmRlZmVyKCk7XG5cdFx0XHRzdGFydGVkID0gZmFsc2U7XG5cblx0XHRcdHJlc29sdmVyID0gZGVmZXIucmVzb2x2ZXI7XG5cdFx0XHRwcm9taXNlID0gZGVmZXIucHJvbWlzZTtcblx0XHRcdHRoZW4gPSBwcm9taXNlLnRoZW47XG5cblx0XHRcdHByb21pc2UudGhlbiA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYgKCFzdGFydGVkKSB7XG5cdFx0XHRcdFx0c3RhcnRlZCA9IHRydWU7XG5cdFx0XHRcdFx0d2hlbi5hdHRlbXB0KHdvcmspLnRoZW4ocmVzb2x2ZXIucmVzb2x2ZSwgcmVzb2x2ZXIucmVqZWN0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhlbi5hcHBseShwcm9taXNlLCBhcmd1bWVudHMpO1xuXHRcdFx0fTtcblxuXHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGxhenlQcm9taXNlO1xuXG5cdH0pO1xuXG59KFxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbiAoZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSk7IH1cblx0Ly8gQm9pbGVycGxhdGUgZm9yIEFNRCBhbmQgTm9kZVxuKSk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTItMjAxMyB0aGUgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnNcbiAqIEBsaWNlbnNlIE1JVCwgc2VlIExJQ0VOU0UudHh0IGZvciBkZXRhaWxzXG4gKlxuICogQGF1dGhvciBTY290dCBBbmRyZXdzXG4gKi9cblxuKGZ1bmN0aW9uIChkZWZpbmUpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdC8vIGRlcml2ZWQgZnJvbSBkb2pvLm1peGluXG5cdGRlZmluZShmdW5jdGlvbiAoLyogcmVxdWlyZSAqLykge1xuXG5cdFx0dmFyIGVtcHR5ID0ge307XG5cblx0XHQvKipcblx0XHQgKiBNaXggdGhlIHByb3BlcnRpZXMgZnJvbSB0aGUgc291cmNlIG9iamVjdCBpbnRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG5cdFx0ICogV2hlbiB0aGUgc2FtZSBwcm9wZXJ0eSBvY2N1cnMgaW4gbW9yZSB0aGVuIG9uZSBvYmplY3QsIHRoZSByaWdodCBtb3N0XG5cdFx0ICogdmFsdWUgd2lucy5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0IHRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZXMgdGhlIG9iamVjdHMgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uICBNYXkgYmUgMSB0byBOIGFyZ3VtZW50cywgYnV0IG5vdCBhbiBBcnJheS5cblx0XHQgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBkZXN0aW5hdGlvbiBvYmplY3Rcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBtaXhpbihkZXN0IC8qLCBzb3VyY2VzLi4uICovKSB7XG5cdFx0XHR2YXIgaSwgbCwgc291cmNlLCBuYW1lO1xuXG5cdFx0XHRpZiAoIWRlc3QpIHsgZGVzdCA9IHt9OyB9XG5cdFx0XHRmb3IgKGkgPSAxLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMSkge1xuXHRcdFx0XHRzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRcdGZvciAobmFtZSBpbiBzb3VyY2UpIHtcblx0XHRcdFx0XHRpZiAoIShuYW1lIGluIGRlc3QpIHx8IChkZXN0W25hbWVdICE9PSBzb3VyY2VbbmFtZV0gJiYgKCEobmFtZSBpbiBlbXB0eSkgfHwgZW1wdHlbbmFtZV0gIT09IHNvdXJjZVtuYW1lXSkpKSB7XG5cdFx0XHRcdFx0XHRkZXN0W25hbWVdID0gc291cmNlW25hbWVdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGVzdDsgLy8gT2JqZWN0XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1peGluO1xuXG5cdH0pO1xuXG59KFxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbiAoZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSk7IH1cblx0Ly8gQm9pbGVycGxhdGUgZm9yIEFNRCBhbmQgTm9kZVxuKSk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTIgdGhlIG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzXG4gKiBAbGljZW5zZSBNSVQsIHNlZSBMSUNFTlNFLnR4dCBmb3IgZGV0YWlsc1xuICpcbiAqIEBhdXRob3IgU2NvdHQgQW5kcmV3c1xuICovXG5cbihmdW5jdGlvbiAoZGVmaW5lKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHRkZWZpbmUoZnVuY3Rpb24gKC8qIHJlcXVpcmUgKi8pIHtcblxuXHRcdC8qKlxuXHRcdCAqIE5vcm1hbGl6ZSBIVFRQIGhlYWRlciBuYW1lcyB1c2luZyB0aGUgcHNldWRvIGNhbWVsIGNhc2UuXG5cdFx0ICpcblx0XHQgKiBGb3IgZXhhbXBsZTpcblx0XHQgKiAgIGNvbnRlbnQtdHlwZSAgICAgICAgIC0+IENvbnRlbnQtVHlwZVxuXHRcdCAqICAgYWNjZXB0cyAgICAgICAgICAgICAgLT4gQWNjZXB0c1xuXHRcdCAqICAgeC1jdXN0b20taGVhZGVyLW5hbWUgLT4gWC1DdXN0b20tSGVhZGVyLU5hbWVcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSByYXcgaGVhZGVyIG5hbWVcblx0XHQgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBub3JtYWxpemVkIGhlYWRlciBuYW1lXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gbm9ybWFsaXplSGVhZGVyTmFtZShuYW1lKSB7XG5cdFx0XHRyZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpXG5cdFx0XHRcdC5zcGxpdCgnLScpXG5cdFx0XHRcdC5tYXAoZnVuY3Rpb24gKGNodW5rKSB7IHJldHVybiBjaHVuay5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGNodW5rLnNsaWNlKDEpOyB9KVxuXHRcdFx0XHQuam9pbignLScpO1xuXHRcdH1cblxuXHRcdHJldHVybiBub3JtYWxpemVIZWFkZXJOYW1lO1xuXG5cdH0pO1xuXG59KFxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbiAoZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSk7IH1cblx0Ly8gQm9pbGVycGxhdGUgZm9yIEFNRCBhbmQgTm9kZVxuKSk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSB0aGUgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnNcbiAqIEBsaWNlbnNlIE1JVCwgc2VlIExJQ0VOU0UudHh0IGZvciBkZXRhaWxzXG4gKlxuICogQGF1dGhvciBTY290dCBBbmRyZXdzXG4gKi9cblxuKGZ1bmN0aW9uIChkZWZpbmUpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdGRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuXG5cdFx0dmFyIHdoZW4gPSByZXF1aXJlKCd3aGVuJyksXG5cdFx0XHRub3JtYWxpemVIZWFkZXJOYW1lID0gcmVxdWlyZSgnLi9ub3JtYWxpemVIZWFkZXJOYW1lJyk7XG5cblx0XHRmdW5jdGlvbiBwcm9wZXJ0eShwcm9taXNlLCBuYW1lKSB7XG5cdFx0XHRyZXR1cm4gcHJvbWlzZS50aGVuKFxuXHRcdFx0XHRmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgJiYgdmFsdWVbbmFtZV07XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRcdHJldHVybiB3aGVuLnJlamVjdCh2YWx1ZSAmJiB2YWx1ZVtuYW1lXSk7XG5cdFx0XHRcdH1cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogT2J0YWluIHRoZSByZXNwb25zZSBlbnRpdHlcblx0XHQgKlxuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlfSBmb3IgdGhlIHJlc3BvbnNlIGVudGl0eVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGVudGl0eSgpIHtcblx0XHRcdC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG5cdFx0XHRyZXR1cm4gcHJvcGVydHkodGhpcywgJ2VudGl0eScpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIE9idGFpbiB0aGUgcmVzcG9uc2Ugc3RhdHVzXG5cdFx0ICpcblx0XHQgKiBAcmV0dXJucyB7UHJvbWlzZX0gZm9yIHRoZSByZXNwb25zZSBzdGF0dXNcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBzdGF0dXMoKSB7XG5cdFx0XHQvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuXHRcdFx0cmV0dXJuIHByb3BlcnR5KHByb3BlcnR5KHRoaXMsICdzdGF0dXMnKSwgJ2NvZGUnKTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBPYnRhaW4gdGhlIHJlc3BvbnNlIGhlYWRlcnMgbWFwXG5cdFx0ICpcblx0XHQgKiBAcmV0dXJucyB7UHJvbWlzZX0gZm9yIHRoZSByZXNwb25zZSBoZWFkZXJzIG1hcFxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGhlYWRlcnMoKSB7XG5cdFx0XHQvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuXHRcdFx0cmV0dXJuIHByb3BlcnR5KHRoaXMsICdoZWFkZXJzJyk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogT2J0YWluIGEgc3BlY2lmaWMgcmVzcG9uc2UgaGVhZGVyXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gaGVhZGVyTmFtZSB0aGUgaGVhZGVyIHRvIHJldHJpZXZlXG5cdFx0ICogQHJldHVybnMge1Byb21pc2V9IGZvciB0aGUgcmVzcG9uc2UgaGVhZGVyJ3MgdmFsdWVcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBoZWFkZXIoaGVhZGVyTmFtZSkge1xuXHRcdFx0Lypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cblx0XHRcdGhlYWRlck5hbWUgPSBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlck5hbWUpO1xuXHRcdFx0cmV0dXJuIHByb3BlcnR5KHRoaXMuaGVhZGVycygpLCBoZWFkZXJOYW1lKTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBGb2xsb3cgYSByZWxhdGVkIHJlc291cmNlXG5cdFx0ICpcblx0XHQgKiBUaGUgcmVsYXRpb25zaGlwIHRvIGZvbGxvdyBtYXkgYmUgZGVmaW5lIGFzIGEgcGxhaW4gc3RyaW5nLCBhbiBvYmplY3Rcblx0XHQgKiB3aXRoIHRoZSByZWwgYW5kIHBhcmFtcywgb3IgYW4gYXJyYXkgY29udGFpbmluZyBvbmUgb3IgbW9yZSBlbnRyaWVzXG5cdFx0ICogd2l0aCB0aGUgcHJldmlvdXMgZm9ybXMuXG5cdFx0ICpcblx0XHQgKiBFeGFtcGxlczpcblx0XHQgKiAgIHJlc3BvbnNlLmZvbGxvdygnbmV4dCcpXG5cdFx0ICpcblx0XHQgKiAgIHJlc3BvbnNlLmZvbGxvdyh7IHJlbDogJ25leHQnLCBwYXJhbXM6IHsgcGFnZVNpemU6IDEwMCB9IH0pXG5cdFx0ICpcblx0XHQgKiAgIHJlc3BvbnNlLmZvbGxvdyhbXG5cdFx0ICogICAgICAgeyByZWw6ICdpdGVtcycsIHBhcmFtczogeyBwcm9qZWN0aW9uOiAnbm9JbWFnZXMnIH0gfSxcblx0XHQgKiAgICAgICAnc2VhcmNoJyxcblx0XHQgKiAgICAgICB7IHJlbDogJ2ZpbmRCeUdhbGxlcnlJc051bGwnLCBwYXJhbXM6IHsgcHJvamVjdGlvbjogJ25vSW1hZ2VzJyB9IH0sXG5cdFx0ICogICAgICAgJ2l0ZW1zJ1xuXHRcdCAqICAgXSlcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdHxBcnJheX0gcmVscyBvbmUsIG9yIG1vcmUsIHJlbGF0aW9uc2hpcHMgdG8gZm9sbG93XG5cdFx0ICogQHJldHVybnMgUmVzcG9uc2VQcm9taXNlPFJlc3BvbnNlPiByZWxhdGVkIHJlc291cmNlXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gZm9sbG93KHJlbHMpIHtcblx0XHRcdC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG5cdFx0XHRyZWxzID0gW10uY29uY2F0KHJlbHMpO1xuXHRcdFx0cmV0dXJuIG1ha2Uod2hlbi5yZWR1Y2UocmVscywgZnVuY3Rpb24gKHJlc3BvbnNlLCByZWwpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiByZWwgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0cmVsID0geyByZWw6IHJlbCB9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0eXBlb2YgcmVzcG9uc2UuZW50aXR5LmNsaWVudEZvciAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignSHlwZXJtZWRpYSByZXNwb25zZSBleHBlY3RlZCcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBjbGllbnQgPSByZXNwb25zZS5lbnRpdHkuY2xpZW50Rm9yKHJlbC5yZWwpO1xuXHRcdFx0XHRyZXR1cm4gY2xpZW50KHsgcGFyYW1zOiByZWwucGFyYW1zIH0pO1xuXHRcdFx0fSwgdGhpcykpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFdyYXAgYSBQcm9taXNlIGFzIGFuIFJlc3BvbnNlUHJvbWlzZVxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtQcm9taXNlPFJlc3BvbnNlPn0gcHJvbWlzZSB0aGUgcHJvbWlzZSBmb3IgYW4gSFRUUCBSZXNwb25zZVxuXHRcdCAqIEByZXR1cm5zIHtSZXNwb25zZVByb21pc2U8UmVzcG9uc2U+fSB3cmFwcGVkIHByb21pc2UgZm9yIFJlc3BvbnNlIHdpdGggYWRkaXRpb25hbCBoZWxwZXIgbWV0aG9kc1xuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIG1ha2UocHJvbWlzZSkge1xuXHRcdFx0cHJvbWlzZS5zdGF0dXMgPSBzdGF0dXM7XG5cdFx0XHRwcm9taXNlLmhlYWRlcnMgPSBoZWFkZXJzO1xuXHRcdFx0cHJvbWlzZS5oZWFkZXIgPSBoZWFkZXI7XG5cdFx0XHRwcm9taXNlLmVudGl0eSA9IGVudGl0eTtcblx0XHRcdHByb21pc2UuZm9sbG93ID0gZm9sbG93O1xuXHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVzcG9uc2VQcm9taXNlKCkge1xuXHRcdFx0cmV0dXJuIG1ha2Uod2hlbi5hcHBseSh3aGVuLCBhcmd1bWVudHMpKTtcblx0XHR9XG5cblx0XHRyZXNwb25zZVByb21pc2UubWFrZSA9IG1ha2U7XG5cdFx0cmVzcG9uc2VQcm9taXNlLnJlamVjdCA9IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRcdHJldHVybiBtYWtlKHdoZW4ucmVqZWN0KHZhbCkpO1xuXHRcdH07XG5cdFx0cmVzcG9uc2VQcm9taXNlLnByb21pc2UgPSBmdW5jdGlvbiAoZnVuYykge1xuXHRcdFx0cmV0dXJuIG1ha2Uod2hlbi5wcm9taXNlKGZ1bmMpKTtcblx0XHR9O1xuXG5cdFx0cmV0dXJuIHJlc3BvbnNlUHJvbWlzZTtcblxuXHR9KTtcblxufShcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24gKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUpOyB9XG5cdC8vIEJvaWxlcnBsYXRlIGZvciBBTUQgYW5kIE5vZGVcbikpO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE1IHRoZSBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9yc1xuICogQGxpY2Vuc2UgTUlULCBzZWUgTElDRU5TRS50eHQgZm9yIGRldGFpbHNcbiAqXG4gKiBAYXV0aG9yIFNjb3R0IEFuZHJld3NcbiAqL1xuXG4oZnVuY3Rpb24gKGRlZmluZSkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0ZGVmaW5lKGZ1bmN0aW9uICgvKiByZXF1aXJlICovKSB7XG5cblx0XHR2YXIgY2hhck1hcDtcblxuXHRcdGNoYXJNYXAgPSAoZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHN0cmluZ3MgPSB7XG5cdFx0XHRcdGFscGhhOiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eicsXG5cdFx0XHRcdGRpZ2l0OiAnMDEyMzQ1Njc4OSdcblx0XHRcdH07XG5cblx0XHRcdHN0cmluZ3MuZ2VuRGVsaW1zID0gJzovPyNbXUAnO1xuXHRcdFx0c3RyaW5ncy5zdWJEZWxpbXMgPSAnISQmXFwnKCkqKyw7PSc7XG5cdFx0XHRzdHJpbmdzLnJlc2VydmVkID0gc3RyaW5ncy5nZW5EZWxpbXMgKyBzdHJpbmdzLnN1YkRlbGltcztcblx0XHRcdHN0cmluZ3MudW5yZXNlcnZlZCA9IHN0cmluZ3MuYWxwaGEgKyBzdHJpbmdzLmRpZ2l0ICsgJy0uX34nO1xuXHRcdFx0c3RyaW5ncy51cmwgPSBzdHJpbmdzLnJlc2VydmVkICsgc3RyaW5ncy51bnJlc2VydmVkO1xuXHRcdFx0c3RyaW5ncy5zY2hlbWUgPSBzdHJpbmdzLmFscGhhICsgc3RyaW5ncy5kaWdpdCArICcrLS4nO1xuXHRcdFx0c3RyaW5ncy51c2VyaW5mbyA9IHN0cmluZ3MudW5yZXNlcnZlZCArIHN0cmluZ3Muc3ViRGVsaW1zICsgJzonO1xuXHRcdFx0c3RyaW5ncy5ob3N0ID0gc3RyaW5ncy51bnJlc2VydmVkICsgc3RyaW5ncy5zdWJEZWxpbXM7XG5cdFx0XHRzdHJpbmdzLnBvcnQgPSBzdHJpbmdzLmRpZ2l0O1xuXHRcdFx0c3RyaW5ncy5wY2hhciA9IHN0cmluZ3MudW5yZXNlcnZlZCArIHN0cmluZ3Muc3ViRGVsaW1zICsgJzpAJztcblx0XHRcdHN0cmluZ3Muc2VnbWVudCA9IHN0cmluZ3MucGNoYXI7XG5cdFx0XHRzdHJpbmdzLnBhdGggPSBzdHJpbmdzLnNlZ21lbnQgKyAnLyc7XG5cdFx0XHRzdHJpbmdzLnF1ZXJ5ID0gc3RyaW5ncy5wY2hhciArICcvPyc7XG5cdFx0XHRzdHJpbmdzLmZyYWdtZW50ID0gc3RyaW5ncy5wY2hhciArICcvPyc7XG5cblx0XHRcdHJldHVybiBPYmplY3Qua2V5cyhzdHJpbmdzKS5yZWR1Y2UoZnVuY3Rpb24gKGNoYXJNYXAsIHNldCkge1xuXHRcdFx0XHRjaGFyTWFwW3NldF0gPSBzdHJpbmdzW3NldF0uc3BsaXQoJycpLnJlZHVjZShmdW5jdGlvbiAoY2hhcnMsIG15Q2hhcikge1xuXHRcdFx0XHRcdGNoYXJzW215Q2hhcl0gPSB0cnVlO1xuXHRcdFx0XHRcdHJldHVybiBjaGFycztcblx0XHRcdFx0fSwge30pO1xuXHRcdFx0XHRyZXR1cm4gY2hhck1hcDtcblx0XHRcdH0sIHt9KTtcblx0XHR9KCkpO1xuXG5cdFx0ZnVuY3Rpb24gZW5jb2RlKHN0ciwgYWxsb3dlZCkge1xuXHRcdFx0aWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignU3RyaW5nIHJlcXVpcmVkIGZvciBVUkwgZW5jb2RpbmcnKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBzdHIuc3BsaXQoJycpLm1hcChmdW5jdGlvbiAobXlDaGFyKSB7XG5cdFx0XHRcdGlmIChhbGxvd2VkLmhhc093blByb3BlcnR5KG15Q2hhcikpIHtcblx0XHRcdFx0XHRyZXR1cm4gbXlDaGFyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBjb2RlID0gbXlDaGFyLmNoYXJDb2RlQXQoMCk7XG5cdFx0XHRcdGlmIChjb2RlIDw9IDEyNykge1xuXHRcdFx0XHRcdHZhciBlbmNvZGVkID0gY29kZS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcblx0XHRcdFx0XHRyZXR1cm4gJyUnICsgKGVuY29kZWQubGVuZ3RoICUgMiA9PT0gMSA/ICcwJyA6ICcnKSArIGVuY29kZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChteUNoYXIpLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pLmpvaW4oJycpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG1ha2VFbmNvZGVyKGFsbG93ZWQpIHtcblx0XHRcdGFsbG93ZWQgPSBhbGxvd2VkIHx8IGNoYXJNYXAudW5yZXNlcnZlZDtcblx0XHRcdHJldHVybiBmdW5jdGlvbiAoc3RyKSB7XG5cdFx0XHRcdHJldHVybiBlbmNvZGUoc3RyLCBhbGxvd2VkKTtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZGVjb2RlKHN0cikge1xuXHRcdFx0cmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIpO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cblx0XHRcdC8qXG5cdFx0XHQgKiBEZWNvZGUgVVJMIGVuY29kZWQgc3RyaW5nc1xuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBVUkwgZW5jb2RlZCBzdHJpbmdcblx0XHRcdCAqIEByZXR1cm5zIHtzdHJpbmd9IFVSTCBkZWNvZGVkIHN0cmluZ1xuXHRcdFx0ICovXG5cdFx0XHRkZWNvZGU6IGRlY29kZSxcblxuXHRcdFx0Lypcblx0XHRcdCAqIFVSTCBlbmNvZGUgYSBzdHJpbmdcblx0XHRcdCAqXG5cdFx0XHQgKiBBbGwgYnV0IGFscGhhLW51bWVyaWNzIGFuZCBhIHZlcnkgbGltaXRlZCBzZXQgb2YgcHVuY3R1YXRpb24gLSAuIF8gfiBhcmVcblx0XHRcdCAqIGVuY29kZWQuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyB0byBlbmNvZGVcblx0XHRcdCAqIEByZXR1cm5zIHtzdHJpbmd9IFVSTCBlbmNvZGVkIHN0cmluZ1xuXHRcdFx0ICovXG5cdFx0XHRlbmNvZGU6IG1ha2VFbmNvZGVyKCksXG5cblx0XHRcdC8qXG5cdFx0XHQqIFVSTCBlbmNvZGUgYSBVUkxcblx0XHRcdCpcblx0XHRcdCogQWxsIGNoYXJhY3RlciBwZXJtaXR0ZWQgYW55d2hlcmUgaW4gYSBVUkwgYXJlIGxlZnQgdW5lbmNvZGVkIGV2ZW5cblx0XHRcdCogaWYgdGhhdCBjaGFyYWN0ZXIgaXMgbm90IHBlcm1pdHRlZCBpbiB0aGF0IHBvcnRpb24gb2YgYSBVUkwuXG5cdFx0XHQqXG5cdFx0XHQqIE5vdGU6IFRoaXMgbWV0aG9kIGlzIHR5cGljYWxseSBub3Qgd2hhdCB5b3Ugd2FudC5cblx0XHRcdCpcblx0XHRcdCogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyB0byBlbmNvZGVcblx0XHRcdCogQHJldHVybnMge3N0cmluZ30gVVJMIGVuY29kZWQgc3RyaW5nXG5cdFx0XHQqL1xuXHRcdFx0ZW5jb2RlVVJMOiBtYWtlRW5jb2RlcihjaGFyTWFwLnVybCksXG5cblx0XHRcdC8qXG5cdFx0XHQgKiBVUkwgZW5jb2RlIHRoZSBzY2hlbWUgcG9ydGlvbiBvZiBhIFVSTFxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgdG8gZW5jb2RlXG5cdFx0XHQgKiBAcmV0dXJucyB7c3RyaW5nfSBVUkwgZW5jb2RlZCBzdHJpbmdcblx0XHRcdCAqL1xuXHRcdFx0ZW5jb2RlU2NoZW1lOiBtYWtlRW5jb2RlcihjaGFyTWFwLnNjaGVtZSksXG5cblx0XHRcdC8qXG5cdFx0XHQgKiBVUkwgZW5jb2RlIHRoZSB1c2VyIGluZm8gcG9ydGlvbiBvZiBhIFVSTFxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgdG8gZW5jb2RlXG5cdFx0XHQgKiBAcmV0dXJucyB7c3RyaW5nfSBVUkwgZW5jb2RlZCBzdHJpbmdcblx0XHRcdCAqL1xuXHRcdFx0ZW5jb2RlVXNlckluZm86IG1ha2VFbmNvZGVyKGNoYXJNYXAudXNlcmluZm8pLFxuXG5cdFx0XHQvKlxuXHRcdFx0ICogVVJMIGVuY29kZSB0aGUgaG9zdCBwb3J0aW9uIG9mIGEgVVJMXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyB0byBlbmNvZGVcblx0XHRcdCAqIEByZXR1cm5zIHtzdHJpbmd9IFVSTCBlbmNvZGVkIHN0cmluZ1xuXHRcdFx0ICovXG5cdFx0XHRlbmNvZGVIb3N0OiBtYWtlRW5jb2RlcihjaGFyTWFwLmhvc3QpLFxuXG5cdFx0XHQvKlxuXHRcdFx0ICogVVJMIGVuY29kZSB0aGUgcG9ydCBwb3J0aW9uIG9mIGEgVVJMXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyB0byBlbmNvZGVcblx0XHRcdCAqIEByZXR1cm5zIHtzdHJpbmd9IFVSTCBlbmNvZGVkIHN0cmluZ1xuXHRcdFx0ICovXG5cdFx0XHRlbmNvZGVQb3J0OiBtYWtlRW5jb2RlcihjaGFyTWFwLnBvcnQpLFxuXG5cdFx0XHQvKlxuXHRcdFx0ICogVVJMIGVuY29kZSBhIHBhdGggc2VnbWVudCBwb3J0aW9uIG9mIGEgVVJMXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyB0byBlbmNvZGVcblx0XHRcdCAqIEByZXR1cm5zIHtzdHJpbmd9IFVSTCBlbmNvZGVkIHN0cmluZ1xuXHRcdFx0ICovXG5cdFx0XHRlbmNvZGVQYXRoU2VnbWVudDogbWFrZUVuY29kZXIoY2hhck1hcC5zZWdtZW50KSxcblxuXHRcdFx0Lypcblx0XHRcdCAqIFVSTCBlbmNvZGUgdGhlIHBhdGggcG9ydGlvbiBvZiBhIFVSTFxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgdG8gZW5jb2RlXG5cdFx0XHQgKiBAcmV0dXJucyB7c3RyaW5nfSBVUkwgZW5jb2RlZCBzdHJpbmdcblx0XHRcdCAqL1xuXHRcdFx0ZW5jb2RlUGF0aDogbWFrZUVuY29kZXIoY2hhck1hcC5wYXRoKSxcblxuXHRcdFx0Lypcblx0XHRcdCAqIFVSTCBlbmNvZGUgdGhlIHF1ZXJ5IHBvcnRpb24gb2YgYSBVUkxcblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIHRvIGVuY29kZVxuXHRcdFx0ICogQHJldHVybnMge3N0cmluZ30gVVJMIGVuY29kZWQgc3RyaW5nXG5cdFx0XHQgKi9cblx0XHRcdGVuY29kZVF1ZXJ5OiBtYWtlRW5jb2RlcihjaGFyTWFwLnF1ZXJ5KSxcblxuXHRcdFx0Lypcblx0XHRcdCAqIFVSTCBlbmNvZGUgdGhlIGZyYWdtZW50IHBvcnRpb24gb2YgYSBVUkxcblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIHRvIGVuY29kZVxuXHRcdFx0ICogQHJldHVybnMge3N0cmluZ30gVVJMIGVuY29kZWQgc3RyaW5nXG5cdFx0XHQgKi9cblx0XHRcdGVuY29kZUZyYWdtZW50OiBtYWtlRW5jb2RlcihjaGFyTWFwLmZyYWdtZW50KVxuXG5cdFx0fTtcblxuXHR9KTtcblxufShcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24gKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUpOyB9XG5cdC8vIEJvaWxlcnBsYXRlIGZvciBBTUQgYW5kIE5vZGVcbikpO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE1IHRoZSBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9yc1xuICogQGxpY2Vuc2UgTUlULCBzZWUgTElDRU5TRS50eHQgZm9yIGRldGFpbHNcbiAqXG4gKiBAYXV0aG9yIFNjb3R0IEFuZHJld3NcbiAqL1xuXG4oZnVuY3Rpb24gKGRlZmluZSkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIHVuZGVmO1xuXG5cdGRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuXG5cdFx0dmFyIHVyaUVuY29kZXIsIG9wZXJhdGlvbnMsIHByZWZpeFJFO1xuXG5cdFx0dXJpRW5jb2RlciA9IHJlcXVpcmUoJy4vdXJpRW5jb2RlcicpO1xuXG5cdFx0cHJlZml4UkUgPSAvXihbXjpdKik6KFswLTldKykkLztcblx0XHRvcGVyYXRpb25zID0ge1xuXHRcdFx0Jyc6ICB7IGZpcnN0OiAnJywgIHNlcGFyYXRvcjogJywnLCBuYW1lZDogZmFsc2UsIGVtcHR5OiAnJywgIGVuY29kZXI6IHVyaUVuY29kZXIuZW5jb2RlIH0sXG5cdFx0XHQnKyc6IHsgZmlyc3Q6ICcnLCAgc2VwYXJhdG9yOiAnLCcsIG5hbWVkOiBmYWxzZSwgZW1wdHk6ICcnLCAgZW5jb2RlcjogdXJpRW5jb2Rlci5lbmNvZGVVUkwgfSxcblx0XHRcdCcjJzogeyBmaXJzdDogJyMnLCBzZXBhcmF0b3I6ICcsJywgbmFtZWQ6IGZhbHNlLCBlbXB0eTogJycsICBlbmNvZGVyOiB1cmlFbmNvZGVyLmVuY29kZVVSTCB9LFxuXHRcdFx0Jy4nOiB7IGZpcnN0OiAnLicsIHNlcGFyYXRvcjogJy4nLCBuYW1lZDogZmFsc2UsIGVtcHR5OiAnJywgIGVuY29kZXI6IHVyaUVuY29kZXIuZW5jb2RlIH0sXG5cdFx0XHQnLyc6IHsgZmlyc3Q6ICcvJywgc2VwYXJhdG9yOiAnLycsIG5hbWVkOiBmYWxzZSwgZW1wdHk6ICcnLCAgZW5jb2RlcjogdXJpRW5jb2Rlci5lbmNvZGUgfSxcblx0XHRcdCc7JzogeyBmaXJzdDogJzsnLCBzZXBhcmF0b3I6ICc7JywgbmFtZWQ6IHRydWUsICBlbXB0eTogJycsICBlbmNvZGVyOiB1cmlFbmNvZGVyLmVuY29kZSB9LFxuXHRcdFx0Jz8nOiB7IGZpcnN0OiAnPycsIHNlcGFyYXRvcjogJyYnLCBuYW1lZDogdHJ1ZSwgIGVtcHR5OiAnPScsIGVuY29kZXI6IHVyaUVuY29kZXIuZW5jb2RlIH0sXG5cdFx0XHQnJic6IHsgZmlyc3Q6ICcmJywgc2VwYXJhdG9yOiAnJicsIG5hbWVkOiB0cnVlLCAgZW1wdHk6ICc9JywgZW5jb2RlcjogdXJpRW5jb2Rlci5lbmNvZGUgfSxcblx0XHRcdCc9JzogeyByZXNlcnZlZDogdHJ1ZSB9LFxuXHRcdFx0JywnOiB7IHJlc2VydmVkOiB0cnVlIH0sXG5cdFx0XHQnISc6IHsgcmVzZXJ2ZWQ6IHRydWUgfSxcblx0XHRcdCdAJzogeyByZXNlcnZlZDogdHJ1ZSB9LFxuXHRcdFx0J3wnOiB7IHJlc2VydmVkOiB0cnVlIH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gYXBwbHkob3BlcmF0aW9uLCBleHByZXNzaW9uLCBwYXJhbXMpIHtcblx0XHRcdC8qanNoaW50IG1heGNvbXBsZXhpdHk6MTEgKi9cblx0XHRcdHJldHVybiBleHByZXNzaW9uLnNwbGl0KCcsJykucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIHZhcmlhYmxlKSB7XG5cdFx0XHRcdHZhciBvcHRzLCB2YWx1ZTtcblxuXHRcdFx0XHRvcHRzID0ge307XG5cdFx0XHRcdGlmICh2YXJpYWJsZS5zbGljZSgtMSkgPT09ICcqJykge1xuXHRcdFx0XHRcdHZhcmlhYmxlID0gdmFyaWFibGUuc2xpY2UoMCwgLTEpO1xuXHRcdFx0XHRcdG9wdHMuZXhwbG9kZSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHByZWZpeFJFLnRlc3QodmFyaWFibGUpKSB7XG5cdFx0XHRcdFx0dmFyIHByZWZpeCA9IHByZWZpeFJFLmV4ZWModmFyaWFibGUpO1xuXHRcdFx0XHRcdHZhcmlhYmxlID0gcHJlZml4WzFdO1xuXHRcdFx0XHRcdG9wdHMubWF4TGVuZ3RoID0gcGFyc2VJbnQocHJlZml4WzJdKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhcmlhYmxlID0gdXJpRW5jb2Rlci5kZWNvZGUodmFyaWFibGUpO1xuXHRcdFx0XHR2YWx1ZSA9IHBhcmFtc1t2YXJpYWJsZV07XG5cblx0XHRcdFx0aWYgKHZhbHVlID09PSB1bmRlZiB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRcdFx0cmVzdWx0ICs9IHZhbHVlLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCB2YWx1ZSkge1xuXHRcdFx0XHRcdFx0aWYgKHJlc3VsdC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0ICs9IG9wdHMuZXhwbG9kZSA/IG9wZXJhdGlvbi5zZXBhcmF0b3IgOiAnLCc7XG5cdFx0XHRcdFx0XHRcdGlmIChvcGVyYXRpb24ubmFtZWQgJiYgb3B0cy5leHBsb2RlKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0ICs9IG9wZXJhdGlvbi5lbmNvZGVyKHZhcmlhYmxlKTtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHQgKz0gdmFsdWUubGVuZ3RoID8gJz0nIDogb3BlcmF0aW9uLmVtcHR5O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0ICs9IG9wZXJhdGlvbi5maXJzdDtcblx0XHRcdFx0XHRcdFx0aWYgKG9wZXJhdGlvbi5uYW1lZCkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdCArPSBvcGVyYXRpb24uZW5jb2Rlcih2YXJpYWJsZSk7XG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0ICs9IHZhbHVlLmxlbmd0aCA/ICc9JyA6IG9wZXJhdGlvbi5lbXB0eTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmVzdWx0ICs9IG9wZXJhdGlvbi5lbmNvZGVyKHZhbHVlKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHRcdFx0fSwgJycpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHRyZXN1bHQgKz0gT2JqZWN0LmtleXModmFsdWUpLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBuYW1lKSB7XG5cdFx0XHRcdFx0XHRpZiAocmVzdWx0Lmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHQgKz0gb3B0cy5leHBsb2RlID8gb3BlcmF0aW9uLnNlcGFyYXRvciA6ICcsJztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHQgKz0gb3BlcmF0aW9uLmZpcnN0O1xuXHRcdFx0XHRcdFx0XHRpZiAob3BlcmF0aW9uLm5hbWVkICYmICFvcHRzLmV4cGxvZGUpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHQgKz0gb3BlcmF0aW9uLmVuY29kZXIodmFyaWFibGUpO1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdCArPSB2YWx1ZVtuYW1lXS5sZW5ndGggPyAnPScgOiBvcGVyYXRpb24uZW1wdHk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJlc3VsdCArPSBvcGVyYXRpb24uZW5jb2RlcihuYW1lKTtcblx0XHRcdFx0XHRcdHJlc3VsdCArPSBvcHRzLmV4cGxvZGUgPyAnPScgOiAnLCc7XG5cdFx0XHRcdFx0XHRyZXN1bHQgKz0gb3BlcmF0aW9uLmVuY29kZXIodmFsdWVbbmFtZV0pO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdFx0XHR9LCAnJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuXHRcdFx0XHRcdGlmIChvcHRzLm1heExlbmd0aCkge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5zbGljZSgwLCBvcHRzLm1heExlbmd0aCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJlc3VsdCArPSByZXN1bHQubGVuZ3RoID8gb3BlcmF0aW9uLnNlcGFyYXRvciA6IG9wZXJhdGlvbi5maXJzdDtcblx0XHRcdFx0XHRpZiAob3BlcmF0aW9uLm5hbWVkKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQgKz0gb3BlcmF0aW9uLmVuY29kZXIodmFyaWFibGUpO1xuXHRcdFx0XHRcdFx0cmVzdWx0ICs9IHZhbHVlLmxlbmd0aCA/ICc9JyA6IG9wZXJhdGlvbi5lbXB0eTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVzdWx0ICs9IG9wZXJhdGlvbi5lbmNvZGVyKHZhbHVlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHR9LCAnJyk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZXhwYW5kRXhwcmVzc2lvbihleHByZXNzaW9uLCBwYXJhbXMpIHtcblx0XHRcdHZhciBvcGVyYXRpb247XG5cblx0XHRcdG9wZXJhdGlvbiA9IG9wZXJhdGlvbnNbZXhwcmVzc2lvbi5zbGljZSgwLDEpXTtcblx0XHRcdGlmIChvcGVyYXRpb24pIHtcblx0XHRcdFx0ZXhwcmVzc2lvbiA9IGV4cHJlc3Npb24uc2xpY2UoMSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0b3BlcmF0aW9uID0gb3BlcmF0aW9uc1snJ107XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvcGVyYXRpb24ucmVzZXJ2ZWQpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdSZXNlcnZlZCBleHByZXNzaW9uIG9wZXJhdGlvbnMgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGFwcGx5KG9wZXJhdGlvbiwgZXhwcmVzc2lvbiwgcGFyYW1zKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBleHBhbmRUZW1wbGF0ZSh0ZW1wbGF0ZSwgcGFyYW1zKSB7XG5cdFx0XHR2YXIgc3RhcnQsIGVuZCwgdXJpO1xuXG5cdFx0XHR1cmkgPSAnJztcblx0XHRcdGVuZCA9IDA7XG5cdFx0XHR3aGlsZSAodHJ1ZSkge1xuXHRcdFx0XHRzdGFydCA9IHRlbXBsYXRlLmluZGV4T2YoJ3snLCBlbmQpO1xuXHRcdFx0XHRpZiAoc3RhcnQgPT09IC0xKSB7XG5cdFx0XHRcdFx0Ly8gbm8gbW9yZSBleHByZXNzaW9uc1xuXHRcdFx0XHRcdHVyaSArPSB0ZW1wbGF0ZS5zbGljZShlbmQpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHVyaSArPSB0ZW1wbGF0ZS5zbGljZShlbmQsIHN0YXJ0KTtcblx0XHRcdFx0ZW5kID0gdGVtcGxhdGUuaW5kZXhPZignfScsIHN0YXJ0KSArIDE7XG5cdFx0XHRcdHVyaSArPSBleHBhbmRFeHByZXNzaW9uKHRlbXBsYXRlLnNsaWNlKHN0YXJ0ICsgMSwgZW5kIC0gMSksIHBhcmFtcyk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB1cmk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBFeHBhbmQgYSBVUkkgVGVtcGxhdGUgd2l0aCBwYXJhbWV0ZXJzIHRvIGZvcm0gYSBVUkkuXG5cdFx0XHQgKlxuXHRcdFx0ICogRnVsbCBpbXBsZW1lbnRhdGlvbiAobGV2ZWwgNCkgb2YgcmZjNjU3MC5cblx0XHRcdCAqIEBzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY1NzBcblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gdGVtcGxhdGUgVVJJIHRlbXBsYXRlXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gcGFyYW1zIHRvIGFwcGx5IHRvIHRoZSB0ZW1wbGF0ZSBkdXJyaW5nIGV4cGFudGlvblxuXHRcdFx0ICogQHJldHVybnMge3N0cmluZ30gZXhwYW5kZWQgVVJJXG5cdFx0XHQgKi9cblx0XHRcdGV4cGFuZDogZXhwYW5kVGVtcGxhdGVcblxuXHRcdH07XG5cblx0fSk7XG5cbn0oXG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uIChmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKTsgfVxuXHQvLyBCb2lsZXJwbGF0ZSBmb3IgQU1EIGFuZCBOb2RlXG4pKTtcbiIsIjsvKiEgc2hvd2Rvd24gMTktMTAtMjAxNSAqL1xyXG4oZnVuY3Rpb24oKXtcclxuLyoqXHJcbiAqIENyZWF0ZWQgYnkgVGl2aWUgb24gMTMtMDctMjAxNS5cclxuICovXHJcblxyXG5mdW5jdGlvbiBnZXREZWZhdWx0T3B0cyhzaW1wbGUpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcclxuICAgIG9taXRFeHRyYVdMSW5Db2RlQmxvY2tzOiB7XHJcbiAgICAgIGRlZmF1bHQ6IGZhbHNlLFxyXG4gICAgICBkZXNjcmliZTogJ09taXQgdGhlIGRlZmF1bHQgZXh0cmEgd2hpdGVsaW5lIGFkZGVkIHRvIGNvZGUgYmxvY2tzJyxcclxuICAgICAgdHlwZTogJ2Jvb2xlYW4nXHJcbiAgICB9LFxyXG4gICAgbm9IZWFkZXJJZDoge1xyXG4gICAgICBkZWZhdWx0OiBmYWxzZSxcclxuICAgICAgZGVzY3JpYmU6ICdUdXJuIG9uL29mZiBnZW5lcmF0ZWQgaGVhZGVyIGlkJyxcclxuICAgICAgdHlwZTogJ2Jvb2xlYW4nXHJcbiAgICB9LFxyXG4gICAgcHJlZml4SGVhZGVySWQ6IHtcclxuICAgICAgZGVmYXVsdDogZmFsc2UsXHJcbiAgICAgIGRlc2NyaWJlOiAnU3BlY2lmeSBhIHByZWZpeCB0byBnZW5lcmF0ZWQgaGVhZGVyIGlkcycsXHJcbiAgICAgIHR5cGU6ICdzdHJpbmcnXHJcbiAgICB9LFxyXG4gICAgaGVhZGVyTGV2ZWxTdGFydDoge1xyXG4gICAgICBkZWZhdWx0OiBmYWxzZSxcclxuICAgICAgZGVzY3JpYmU6ICdUaGUgaGVhZGVyIGJsb2NrcyBsZXZlbCBzdGFydCcsXHJcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJ1xyXG4gICAgfSxcclxuICAgIHBhcnNlSW1nRGltZW5zaW9uczoge1xyXG4gICAgICBkZWZhdWx0OiBmYWxzZSxcclxuICAgICAgZGVzY3JpYmU6ICdUdXJuIG9uL29mZiBpbWFnZSBkaW1lbnNpb24gcGFyc2luZycsXHJcbiAgICAgIHR5cGU6ICdib29sZWFuJ1xyXG4gICAgfSxcclxuICAgIHNpbXBsaWZpZWRBdXRvTGluazoge1xyXG4gICAgICBkZWZhdWx0OiBmYWxzZSxcclxuICAgICAgZGVzY3JpYmU6ICdUdXJuIG9uL29mZiBHRk0gYXV0b2xpbmsgc3R5bGUnLFxyXG4gICAgICB0eXBlOiAnYm9vbGVhbidcclxuICAgIH0sXHJcbiAgICBsaXRlcmFsTWlkV29yZFVuZGVyc2NvcmVzOiB7XHJcbiAgICAgIGRlZmF1bHQ6IGZhbHNlLFxyXG4gICAgICBkZXNjcmliZTogJ1BhcnNlIG1pZHdvcmQgdW5kZXJzY29yZXMgYXMgbGl0ZXJhbCB1bmRlcnNjb3JlcycsXHJcbiAgICAgIHR5cGU6ICdib29sZWFuJ1xyXG4gICAgfSxcclxuICAgIHN0cmlrZXRocm91Z2g6IHtcclxuICAgICAgZGVmYXVsdDogZmFsc2UsXHJcbiAgICAgIGRlc2NyaWJlOiAnVHVybiBvbi9vZmYgc3RyaWtldGhyb3VnaCBzdXBwb3J0JyxcclxuICAgICAgdHlwZTogJ2Jvb2xlYW4nXHJcbiAgICB9LFxyXG4gICAgdGFibGVzOiB7XHJcbiAgICAgIGRlZmF1bHQ6IGZhbHNlLFxyXG4gICAgICBkZXNjcmliZTogJ1R1cm4gb24vb2ZmIHRhYmxlcyBzdXBwb3J0JyxcclxuICAgICAgdHlwZTogJ2Jvb2xlYW4nXHJcbiAgICB9LFxyXG4gICAgdGFibGVzSGVhZGVySWQ6IHtcclxuICAgICAgZGVmYXVsdDogZmFsc2UsXHJcbiAgICAgIGRlc2NyaWJlOiAnQWRkIGFuIGlkIHRvIHRhYmxlIGhlYWRlcnMnLFxyXG4gICAgICB0eXBlOiAnYm9vbGVhbidcclxuICAgIH0sXHJcbiAgICBnaENvZGVCbG9ja3M6IHtcclxuICAgICAgZGVmYXVsdDogdHJ1ZSxcclxuICAgICAgZGVzY3JpYmU6ICdUdXJuIG9uL29mZiBHRk0gZmVuY2VkIGNvZGUgYmxvY2tzIHN1cHBvcnQnLFxyXG4gICAgICB0eXBlOiAnYm9vbGVhbidcclxuICAgIH0sXHJcbiAgICB0YXNrbGlzdHM6IHtcclxuICAgICAgZGVmYXVsdDogZmFsc2UsXHJcbiAgICAgIGRlc2NyaWJlOiAnVHVybiBvbi9vZmYgR0ZNIHRhc2tsaXN0IHN1cHBvcnQnLFxyXG4gICAgICB0eXBlOiAnYm9vbGVhbidcclxuICAgIH0sXHJcbiAgICBzbW9vdGhMaXZlUHJldmlldzoge1xyXG4gICAgICBkZWZhdWx0OiBmYWxzZSxcclxuICAgICAgZGVzY3JpYmU6ICdQcmV2ZW50cyB3ZWlyZCBlZmZlY3RzIGluIGxpdmUgcHJldmlld3MgZHVlIHRvIGluY29tcGxldGUgaW5wdXQnLFxyXG4gICAgICB0eXBlOiAnYm9vbGVhbidcclxuICAgIH1cclxuICB9O1xyXG4gIGlmIChzaW1wbGUgPT09IGZhbHNlKSB7XHJcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkZWZhdWx0T3B0aW9ucykpO1xyXG4gIH1cclxuICB2YXIgcmV0ID0ge307XHJcbiAgZm9yICh2YXIgb3B0IGluIGRlZmF1bHRPcHRpb25zKSB7XHJcbiAgICBpZiAoZGVmYXVsdE9wdGlvbnMuaGFzT3duUHJvcGVydHkob3B0KSkge1xyXG4gICAgICByZXRbb3B0XSA9IGRlZmF1bHRPcHRpb25zW29wdF0uZGVmYXVsdDtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJldDtcclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZWQgYnkgVGl2aWUgb24gMDYtMDEtMjAxNS5cclxuICovXHJcblxyXG4vLyBQcml2YXRlIHByb3BlcnRpZXNcclxudmFyIHNob3dkb3duID0ge30sXHJcbiAgICBwYXJzZXJzID0ge30sXHJcbiAgICBleHRlbnNpb25zID0ge30sXHJcbiAgICBnbG9iYWxPcHRpb25zID0gZ2V0RGVmYXVsdE9wdHModHJ1ZSksXHJcbiAgICBmbGF2b3IgPSB7XHJcbiAgICAgIGdpdGh1Yjoge1xyXG4gICAgICAgIG9taXRFeHRyYVdMSW5Db2RlQmxvY2tzOiAgIHRydWUsXHJcbiAgICAgICAgcHJlZml4SGVhZGVySWQ6ICAgICAgICAgICAgJ3VzZXItY29udGVudC0nLFxyXG4gICAgICAgIHNpbXBsaWZpZWRBdXRvTGluazogICAgICAgIHRydWUsXHJcbiAgICAgICAgbGl0ZXJhbE1pZFdvcmRVbmRlcnNjb3JlczogdHJ1ZSxcclxuICAgICAgICBzdHJpa2V0aHJvdWdoOiAgICAgICAgICAgICB0cnVlLFxyXG4gICAgICAgIHRhYmxlczogICAgICAgICAgICAgICAgICAgIHRydWUsXHJcbiAgICAgICAgdGFibGVzSGVhZGVySWQ6ICAgICAgICAgICAgdHJ1ZSxcclxuICAgICAgICBnaENvZGVCbG9ja3M6ICAgICAgICAgICAgICB0cnVlLFxyXG4gICAgICAgIHRhc2tsaXN0czogICAgICAgICAgICAgICAgIHRydWVcclxuICAgICAgfSxcclxuICAgICAgdmFuaWxsYTogZ2V0RGVmYXVsdE9wdHModHJ1ZSlcclxuICAgIH07XHJcblxyXG4vKipcclxuICogaGVscGVyIG5hbWVzcGFjZVxyXG4gKiBAdHlwZSB7e319XHJcbiAqL1xyXG5zaG93ZG93bi5oZWxwZXIgPSB7fTtcclxuXHJcbi8qKlxyXG4gKiBUT0RPIExFR0FDWSBTVVBQT1JUIENPREVcclxuICogQHR5cGUge3t9fVxyXG4gKi9cclxuc2hvd2Rvd24uZXh0ZW5zaW9ucyA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIFNldCBhIGdsb2JhbCBvcHRpb25cclxuICogQHN0YXRpY1xyXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcclxuICogQHJldHVybnMge3Nob3dkb3dufVxyXG4gKi9cclxuc2hvd2Rvd24uc2V0T3B0aW9uID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAndXNlIHN0cmljdCc7XHJcbiAgZ2xvYmFsT3B0aW9uc1trZXldID0gdmFsdWU7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IGEgZ2xvYmFsIG9wdGlvblxyXG4gKiBAc3RhdGljXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcclxuICogQHJldHVybnMgeyp9XHJcbiAqL1xyXG5zaG93ZG93bi5nZXRPcHRpb24gPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG4gIHJldHVybiBnbG9iYWxPcHRpb25zW2tleV07XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBnbG9iYWwgb3B0aW9uc1xyXG4gKiBAc3RhdGljXHJcbiAqIEByZXR1cm5zIHt7fX1cclxuICovXHJcbnNob3dkb3duLmdldE9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG4gIHJldHVybiBnbG9iYWxPcHRpb25zO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlc2V0IGdsb2JhbCBvcHRpb25zIHRvIHRoZSBkZWZhdWx0IHZhbHVlc1xyXG4gKiBAc3RhdGljXHJcbiAqL1xyXG5zaG93ZG93bi5yZXNldE9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG4gIGdsb2JhbE9wdGlvbnMgPSBnZXREZWZhdWx0T3B0cyh0cnVlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXQgdGhlIGZsYXZvciBzaG93ZG93biBzaG91bGQgdXNlIGFzIGRlZmF1bHRcclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcclxuICovXHJcbnNob3dkb3duLnNldEZsYXZvciA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG4gIGlmIChmbGF2b3IuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcclxuICAgIHZhciBwcmVzZXQgPSBmbGF2b3JbbmFtZV07XHJcbiAgICBmb3IgKHZhciBvcHRpb24gaW4gcHJlc2V0KSB7XHJcbiAgICAgIGlmIChwcmVzZXQuaGFzT3duUHJvcGVydHkob3B0aW9uKSkge1xyXG4gICAgICAgIGdsb2JhbE9wdGlvbnNbb3B0aW9uXSA9IHByZXNldFtvcHRpb25dO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgZGVmYXVsdCBvcHRpb25zXHJcbiAqIEBzdGF0aWNcclxuICogQHBhcmFtIHtib29sZWFufSBbc2ltcGxlPXRydWVdXHJcbiAqIEByZXR1cm5zIHt7fX1cclxuICovXHJcbnNob3dkb3duLmdldERlZmF1bHRPcHRpb25zID0gZnVuY3Rpb24gKHNpbXBsZSkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuICByZXR1cm4gZ2V0RGVmYXVsdE9wdHMoc2ltcGxlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgb3Igc2V0IGEgc3ViUGFyc2VyXHJcbiAqXHJcbiAqIHN1YlBhcnNlcihuYW1lKSAgICAgICAtIEdldCBhIHJlZ2lzdGVyZWQgc3ViUGFyc2VyXHJcbiAqIHN1YlBhcnNlcihuYW1lLCBmdW5jKSAtIFJlZ2lzdGVyIGEgc3ViUGFyc2VyXHJcbiAqIEBzdGF0aWNcclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcclxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2Z1bmNdXHJcbiAqIEByZXR1cm5zIHsqfVxyXG4gKi9cclxuc2hvd2Rvd24uc3ViUGFyc2VyID0gZnVuY3Rpb24gKG5hbWUsIGZ1bmMpIHtcclxuICAndXNlIHN0cmljdCc7XHJcbiAgaWYgKHNob3dkb3duLmhlbHBlci5pc1N0cmluZyhuYW1lKSkge1xyXG4gICAgaWYgKHR5cGVvZiBmdW5jICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICBwYXJzZXJzW25hbWVdID0gZnVuYztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChwYXJzZXJzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlcnNbbmFtZV07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1N1YlBhcnNlciBuYW1lZCAnICsgbmFtZSArICcgbm90IHJlZ2lzdGVyZWQhJyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyBvciByZWdpc3RlcnMgYW4gZXh0ZW5zaW9uXHJcbiAqIEBzdGF0aWNcclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcclxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb249fSBleHRcclxuICogQHJldHVybnMgeyp9XHJcbiAqL1xyXG5zaG93ZG93bi5leHRlbnNpb24gPSBmdW5jdGlvbiAobmFtZSwgZXh0KSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICBpZiAoIXNob3dkb3duLmhlbHBlci5pc1N0cmluZyhuYW1lKSkge1xyXG4gICAgdGhyb3cgRXJyb3IoJ0V4dGVuc2lvbiBcXCduYW1lXFwnIG11c3QgYmUgYSBzdHJpbmcnKTtcclxuICB9XHJcblxyXG4gIG5hbWUgPSBzaG93ZG93bi5oZWxwZXIuc3RkRXh0TmFtZShuYW1lKTtcclxuXHJcbiAgLy8gR2V0dGVyXHJcbiAgaWYgKHNob3dkb3duLmhlbHBlci5pc1VuZGVmaW5lZChleHQpKSB7XHJcbiAgICBpZiAoIWV4dGVuc2lvbnMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcclxuICAgICAgdGhyb3cgRXJyb3IoJ0V4dGVuc2lvbiBuYW1lZCAnICsgbmFtZSArICcgaXMgbm90IHJlZ2lzdGVyZWQhJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXh0ZW5zaW9uc1tuYW1lXTtcclxuXHJcbiAgICAvLyBTZXR0ZXJcclxuICB9IGVsc2Uge1xyXG4gICAgLy8gRXhwYW5kIGV4dGVuc2lvbiBpZiBpdCdzIHdyYXBwZWQgaW4gYSBmdW5jdGlvblxyXG4gICAgaWYgKHR5cGVvZiBleHQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgZXh0ID0gZXh0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRW5zdXJlIGV4dGVuc2lvbiBpcyBhbiBhcnJheVxyXG4gICAgaWYgKCFzaG93ZG93bi5oZWxwZXIuaXNBcnJheShleHQpKSB7XHJcbiAgICAgIGV4dCA9IFtleHRdO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB2YWxpZEV4dGVuc2lvbiA9IHZhbGlkYXRlKGV4dCwgbmFtZSk7XHJcblxyXG4gICAgaWYgKHZhbGlkRXh0ZW5zaW9uLnZhbGlkKSB7XHJcbiAgICAgIGV4dGVuc2lvbnNbbmFtZV0gPSBleHQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHJvdyBFcnJvcih2YWxpZEV4dGVuc2lvbi5lcnJvcik7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldHMgYWxsIGV4dGVuc2lvbnMgcmVnaXN0ZXJlZFxyXG4gKiBAcmV0dXJucyB7e319XHJcbiAqL1xyXG5zaG93ZG93bi5nZXRBbGxFeHRlbnNpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuICByZXR1cm4gZXh0ZW5zaW9ucztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmUgYW4gZXh0ZW5zaW9uXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXHJcbiAqL1xyXG5zaG93ZG93bi5yZW1vdmVFeHRlbnNpb24gPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuICBkZWxldGUgZXh0ZW5zaW9uc1tuYW1lXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIGFsbCBleHRlbnNpb25zXHJcbiAqL1xyXG5zaG93ZG93bi5yZXNldEV4dGVuc2lvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG4gIGV4dGVuc2lvbnMgPSB7fTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBWYWxpZGF0ZSBleHRlbnNpb25cclxuICogQHBhcmFtIHthcnJheX0gZXh0ZW5zaW9uXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXHJcbiAqIEByZXR1cm5zIHt7dmFsaWQ6IGJvb2xlYW4sIGVycm9yOiBzdHJpbmd9fVxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGUoZXh0ZW5zaW9uLCBuYW1lKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICB2YXIgZXJyTXNnID0gKG5hbWUpID8gJ0Vycm9yIGluICcgKyBuYW1lICsgJyBleHRlbnNpb24tPicgOiAnRXJyb3IgaW4gdW5uYW1lZCBleHRlbnNpb24nLFxyXG4gICAgcmV0ID0ge1xyXG4gICAgICB2YWxpZDogdHJ1ZSxcclxuICAgICAgZXJyb3I6ICcnXHJcbiAgICB9O1xyXG5cclxuICBpZiAoIXNob3dkb3duLmhlbHBlci5pc0FycmF5KGV4dGVuc2lvbikpIHtcclxuICAgIGV4dGVuc2lvbiA9IFtleHRlbnNpb25dO1xyXG4gIH1cclxuXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHRlbnNpb24ubGVuZ3RoOyArK2kpIHtcclxuICAgIHZhciBiYXNlTXNnID0gZXJyTXNnICsgJyBzdWItZXh0ZW5zaW9uICcgKyBpICsgJzogJyxcclxuICAgICAgICBleHQgPSBleHRlbnNpb25baV07XHJcbiAgICBpZiAodHlwZW9mIGV4dCAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgcmV0LnZhbGlkID0gZmFsc2U7XHJcbiAgICAgIHJldC5lcnJvciA9IGJhc2VNc2cgKyAnbXVzdCBiZSBhbiBvYmplY3QsIGJ1dCAnICsgdHlwZW9mIGV4dCArICcgZ2l2ZW4nO1xyXG4gICAgICByZXR1cm4gcmV0O1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghc2hvd2Rvd24uaGVscGVyLmlzU3RyaW5nKGV4dC50eXBlKSkge1xyXG4gICAgICByZXQudmFsaWQgPSBmYWxzZTtcclxuICAgICAgcmV0LmVycm9yID0gYmFzZU1zZyArICdwcm9wZXJ0eSBcInR5cGVcIiBtdXN0IGJlIGEgc3RyaW5nLCBidXQgJyArIHR5cGVvZiBleHQudHlwZSArICcgZ2l2ZW4nO1xyXG4gICAgICByZXR1cm4gcmV0O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB0eXBlID0gZXh0LnR5cGUgPSBleHQudHlwZS50b0xvd2VyQ2FzZSgpO1xyXG5cclxuICAgIC8vIG5vcm1hbGl6ZSBleHRlbnNpb24gdHlwZVxyXG4gICAgaWYgKHR5cGUgPT09ICdsYW5ndWFnZScpIHtcclxuICAgICAgdHlwZSA9IGV4dC50eXBlID0gJ2xhbmcnO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlID09PSAnaHRtbCcpIHtcclxuICAgICAgdHlwZSA9IGV4dC50eXBlID0gJ291dHB1dCc7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGUgIT09ICdsYW5nJyAmJiB0eXBlICE9PSAnb3V0cHV0JyAmJiB0eXBlICE9PSAnbGlzdGVuZXInKSB7XHJcbiAgICAgIHJldC52YWxpZCA9IGZhbHNlO1xyXG4gICAgICByZXQuZXJyb3IgPSBiYXNlTXNnICsgJ3R5cGUgJyArIHR5cGUgKyAnIGlzIG5vdCByZWNvZ25pemVkLiBWYWxpZCB2YWx1ZXM6IFwibGFuZy9sYW5ndWFnZVwiLCBcIm91dHB1dC9odG1sXCIgb3IgXCJsaXN0ZW5lclwiJztcclxuICAgICAgcmV0dXJuIHJldDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZSA9PT0gJ2xpc3RlbmVyJykge1xyXG4gICAgICBpZiAoc2hvd2Rvd24uaGVscGVyLmlzVW5kZWZpbmVkKGV4dC5saXN0ZW5lcnMpKSB7XHJcbiAgICAgICAgcmV0LnZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgcmV0LmVycm9yID0gYmFzZU1zZyArICcuIEV4dGVuc2lvbnMgb2YgdHlwZSBcImxpc3RlbmVyXCIgbXVzdCBoYXZlIGEgcHJvcGVydHkgY2FsbGVkIFwibGlzdGVuZXJzXCInO1xyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChzaG93ZG93bi5oZWxwZXIuaXNVbmRlZmluZWQoZXh0LmZpbHRlcikgJiYgc2hvd2Rvd24uaGVscGVyLmlzVW5kZWZpbmVkKGV4dC5yZWdleCkpIHtcclxuICAgICAgICByZXQudmFsaWQgPSBmYWxzZTtcclxuICAgICAgICByZXQuZXJyb3IgPSBiYXNlTXNnICsgdHlwZSArICcgZXh0ZW5zaW9ucyBtdXN0IGRlZmluZSBlaXRoZXIgYSBcInJlZ2V4XCIgcHJvcGVydHkgb3IgYSBcImZpbHRlclwiIG1ldGhvZCc7XHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChleHQubGlzdGVuZXJzKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgZXh0Lmxpc3RlbmVycyAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICByZXQudmFsaWQgPSBmYWxzZTtcclxuICAgICAgICByZXQuZXJyb3IgPSBiYXNlTXNnICsgJ1wibGlzdGVuZXJzXCIgcHJvcGVydHkgbXVzdCBiZSBhbiBvYmplY3QgYnV0ICcgKyB0eXBlb2YgZXh0Lmxpc3RlbmVycyArICcgZ2l2ZW4nO1xyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgIH1cclxuICAgICAgZm9yICh2YXIgbG4gaW4gZXh0Lmxpc3RlbmVycykge1xyXG4gICAgICAgIGlmIChleHQubGlzdGVuZXJzLmhhc093blByb3BlcnR5KGxuKSkge1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiBleHQubGlzdGVuZXJzW2xuXSAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICByZXQudmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgcmV0LmVycm9yID0gYmFzZU1zZyArICdcImxpc3RlbmVyc1wiIHByb3BlcnR5IG11c3QgYmUgYW4gaGFzaCBvZiBbZXZlbnQgbmFtZV06IFtjYWxsYmFja10uIGxpc3RlbmVycy4nICsgbG4gK1xyXG4gICAgICAgICAgICAgICcgbXVzdCBiZSBhIGZ1bmN0aW9uIGJ1dCAnICsgdHlwZW9mIGV4dC5saXN0ZW5lcnNbbG5dICsgJyBnaXZlbic7XHJcbiAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGV4dC5maWx0ZXIpIHtcclxuICAgICAgaWYgKHR5cGVvZiBleHQuZmlsdGVyICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgcmV0LnZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgcmV0LmVycm9yID0gYmFzZU1zZyArICdcImZpbHRlclwiIG11c3QgYmUgYSBmdW5jdGlvbiwgYnV0ICcgKyB0eXBlb2YgZXh0LmZpbHRlciArICcgZ2l2ZW4nO1xyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoZXh0LnJlZ2V4KSB7XHJcbiAgICAgIGlmIChzaG93ZG93bi5oZWxwZXIuaXNTdHJpbmcoZXh0LnJlZ2V4KSkge1xyXG4gICAgICAgIGV4dC5yZWdleCA9IG5ldyBSZWdFeHAoZXh0LnJlZ2V4LCAnZycpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghZXh0LnJlZ2V4IGluc3RhbmNlb2YgUmVnRXhwKSB7XHJcbiAgICAgICAgcmV0LnZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgcmV0LmVycm9yID0gYmFzZU1zZyArICdcInJlZ2V4XCIgcHJvcGVydHkgbXVzdCBlaXRoZXIgYmUgYSBzdHJpbmcgb3IgYSBSZWdFeHAgb2JqZWN0LCBidXQgJyArIHR5cGVvZiBleHQucmVnZXggKyAnIGdpdmVuJztcclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzaG93ZG93bi5oZWxwZXIuaXNVbmRlZmluZWQoZXh0LnJlcGxhY2UpKSB7XHJcbiAgICAgICAgcmV0LnZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgcmV0LmVycm9yID0gYmFzZU1zZyArICdcInJlZ2V4XCIgZXh0ZW5zaW9ucyBtdXN0IGltcGxlbWVudCBhIHJlcGxhY2Ugc3RyaW5nIG9yIGZ1bmN0aW9uJztcclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZXQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBWYWxpZGF0ZSBleHRlbnNpb25cclxuICogQHBhcmFtIHtvYmplY3R9IGV4dFxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbnNob3dkb3duLnZhbGlkYXRlRXh0ZW5zaW9uID0gZnVuY3Rpb24gKGV4dCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgdmFyIHZhbGlkYXRlRXh0ZW5zaW9uID0gdmFsaWRhdGUoZXh0LCBudWxsKTtcclxuICBpZiAoIXZhbGlkYXRlRXh0ZW5zaW9uLnZhbGlkKSB7XHJcbiAgICBjb25zb2xlLndhcm4odmFsaWRhdGVFeHRlbnNpb24uZXJyb3IpO1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBzaG93ZG93bmpzIGhlbHBlciBmdW5jdGlvbnNcclxuICovXHJcblxyXG5pZiAoIXNob3dkb3duLmhhc093blByb3BlcnR5KCdoZWxwZXInKSkge1xyXG4gIHNob3dkb3duLmhlbHBlciA9IHt9O1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdmFyIGlzIHN0cmluZ1xyXG4gKiBAc3RhdGljXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBhXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuc2hvd2Rvd24uaGVscGVyLmlzU3RyaW5nID0gZnVuY3Rpb24gaXNTdHJpbmcoYSkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuICByZXR1cm4gKHR5cGVvZiBhID09PSAnc3RyaW5nJyB8fCBhIGluc3RhbmNlb2YgU3RyaW5nKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBGb3JFYWNoIGhlbHBlciBmdW5jdGlvblxyXG4gKiBAc3RhdGljXHJcbiAqIEBwYXJhbSB7Kn0gb2JqXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXHJcbiAqL1xyXG5zaG93ZG93bi5oZWxwZXIuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2gob2JqLCBjYWxsYmFjaykge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuICBpZiAodHlwZW9mIG9iai5mb3JFYWNoID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICBvYmouZm9yRWFjaChjYWxsYmFjayk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNhbGxiYWNrKG9ialtpXSwgaSwgb2JqKTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogaXNBcnJheSBoZWxwZXIgZnVuY3Rpb25cclxuICogQHN0YXRpY1xyXG4gKiBAcGFyYW0geyp9IGFcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5zaG93ZG93bi5oZWxwZXIuaXNBcnJheSA9IGZ1bmN0aW9uIGlzQXJyYXkoYSkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuICByZXR1cm4gYS5jb25zdHJ1Y3RvciA9PT0gQXJyYXk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdmFsdWUgaXMgdW5kZWZpbmVkXHJcbiAqIEBzdGF0aWNcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLCBlbHNlIGBmYWxzZWAuXHJcbiAqL1xyXG5zaG93ZG93bi5oZWxwZXIuaXNVbmRlZmluZWQgPSBmdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTdGFuZGFyZGlkaXplIGV4dGVuc2lvbiBuYW1lXHJcbiAqIEBzdGF0aWNcclxuICogQHBhcmFtIHtzdHJpbmd9IHMgZXh0ZW5zaW9uIG5hbWVcclxuICogQHJldHVybnMge3N0cmluZ31cclxuICovXHJcbnNob3dkb3duLmhlbHBlci5zdGRFeHROYW1lID0gZnVuY3Rpb24gKHMpIHtcclxuICAndXNlIHN0cmljdCc7XHJcbiAgcmV0dXJuIHMucmVwbGFjZSgvW18tXXx8XFxzL2csICcnKS50b0xvd2VyQ2FzZSgpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gZXNjYXBlQ2hhcmFjdGVyc0NhbGxiYWNrKHdob2xlTWF0Y2gsIG0xKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG4gIHZhciBjaGFyQ29kZVRvRXNjYXBlID0gbTEuY2hhckNvZGVBdCgwKTtcclxuICByZXR1cm4gJ35FJyArIGNoYXJDb2RlVG9Fc2NhcGUgKyAnRSc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDYWxsYmFjayB1c2VkIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIHdoZW4gcGFzc2luZyB0aHJvdWdoIFN0cmluZy5yZXBsYWNlXHJcbiAqIEBzdGF0aWNcclxuICogQHBhcmFtIHtzdHJpbmd9IHdob2xlTWF0Y2hcclxuICogQHBhcmFtIHtzdHJpbmd9IG0xXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqL1xyXG5zaG93ZG93bi5oZWxwZXIuZXNjYXBlQ2hhcmFjdGVyc0NhbGxiYWNrID0gZXNjYXBlQ2hhcmFjdGVyc0NhbGxiYWNrO1xyXG5cclxuLyoqXHJcbiAqIEVzY2FwZSBjaGFyYWN0ZXJzIGluIGEgc3RyaW5nXHJcbiAqIEBzdGF0aWNcclxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcclxuICogQHBhcmFtIHtzdHJpbmd9IGNoYXJzVG9Fc2NhcGVcclxuICogQHBhcmFtIHtib29sZWFufSBhZnRlckJhY2tzbGFzaFxyXG4gKiBAcmV0dXJucyB7WE1MfHN0cmluZ3x2b2lkfCp9XHJcbiAqL1xyXG5zaG93ZG93bi5oZWxwZXIuZXNjYXBlQ2hhcmFjdGVycyA9IGZ1bmN0aW9uIGVzY2FwZUNoYXJhY3RlcnModGV4dCwgY2hhcnNUb0VzY2FwZSwgYWZ0ZXJCYWNrc2xhc2gpIHtcclxuICAndXNlIHN0cmljdCc7XHJcbiAgLy8gRmlyc3Qgd2UgaGF2ZSB0byBlc2NhcGUgdGhlIGVzY2FwZSBjaGFyYWN0ZXJzIHNvIHRoYXRcclxuICAvLyB3ZSBjYW4gYnVpbGQgYSBjaGFyYWN0ZXIgY2xhc3Mgb3V0IG9mIHRoZW1cclxuICB2YXIgcmVnZXhTdHJpbmcgPSAnKFsnICsgY2hhcnNUb0VzY2FwZS5yZXBsYWNlKC8oW1xcW1xcXVxcXFxdKS9nLCAnXFxcXCQxJykgKyAnXSknO1xyXG5cclxuICBpZiAoYWZ0ZXJCYWNrc2xhc2gpIHtcclxuICAgIHJlZ2V4U3RyaW5nID0gJ1xcXFxcXFxcJyArIHJlZ2V4U3RyaW5nO1xyXG4gIH1cclxuXHJcbiAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cChyZWdleFN0cmluZywgJ2cnKTtcclxuICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHJlZ2V4LCBlc2NhcGVDaGFyYWN0ZXJzQ2FsbGJhY2spO1xyXG5cclxuICByZXR1cm4gdGV4dDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBtYXRjaFJlY3Vyc2l2ZVJlZ0V4cFxyXG4gKlxyXG4gKiAoYykgMjAwNyBTdGV2ZW4gTGV2aXRoYW4gPHN0ZXZlbmxldml0aGFuLmNvbT5cclxuICogTUlUIExpY2Vuc2VcclxuICpcclxuICogQWNjZXB0cyBhIHN0cmluZyB0byBzZWFyY2gsIGEgbGVmdCBhbmQgcmlnaHQgZm9ybWF0IGRlbGltaXRlclxyXG4gKiBhcyByZWdleCBwYXR0ZXJucywgYW5kIG9wdGlvbmFsIHJlZ2V4IGZsYWdzLiBSZXR1cm5zIGFuIGFycmF5XHJcbiAqIG9mIG1hdGNoZXMsIGFsbG93aW5nIG5lc3RlZCBpbnN0YW5jZXMgb2YgbGVmdC9yaWdodCBkZWxpbWl0ZXJzLlxyXG4gKiBVc2UgdGhlIFwiZ1wiIGZsYWcgdG8gcmV0dXJuIGFsbCBtYXRjaGVzLCBvdGhlcndpc2Ugb25seSB0aGVcclxuICogZmlyc3QgaXMgcmV0dXJuZWQuIEJlIGNhcmVmdWwgdG8gZW5zdXJlIHRoYXQgdGhlIGxlZnQgYW5kXHJcbiAqIHJpZ2h0IGZvcm1hdCBkZWxpbWl0ZXJzIHByb2R1Y2UgbXV0dWFsbHkgZXhjbHVzaXZlIG1hdGNoZXMuXHJcbiAqIEJhY2tyZWZlcmVuY2VzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGhpbiB0aGUgcmlnaHQgZGVsaW1pdGVyXHJcbiAqIGR1ZSB0byBob3cgaXQgaXMgaW50ZXJuYWxseSBjb21iaW5lZCB3aXRoIHRoZSBsZWZ0IGRlbGltaXRlci5cclxuICogV2hlbiBtYXRjaGluZyBzdHJpbmdzIHdob3NlIGZvcm1hdCBkZWxpbWl0ZXJzIGFyZSB1bmJhbGFuY2VkXHJcbiAqIHRvIHRoZSBsZWZ0IG9yIHJpZ2h0LCB0aGUgb3V0cHV0IGlzIGludGVudGlvbmFsbHkgYXMgYVxyXG4gKiBjb252ZW50aW9uYWwgcmVnZXggbGlicmFyeSB3aXRoIHJlY3Vyc2lvbiBzdXBwb3J0IHdvdWxkXHJcbiAqIHByb2R1Y2UsIGUuZy4gXCI8PHg+XCIgYW5kIFwiPHg+PlwiIGJvdGggcHJvZHVjZSBbXCJ4XCJdIHdoZW4gdXNpbmdcclxuICogXCI8XCIgYW5kIFwiPlwiIGFzIHRoZSBkZWxpbWl0ZXJzIChib3RoIHN0cmluZ3MgY29udGFpbiBhIHNpbmdsZSxcclxuICogYmFsYW5jZWQgaW5zdGFuY2Ugb2YgXCI8eD5cIikuXHJcbiAqXHJcbiAqIGV4YW1wbGVzOlxyXG4gKiBtYXRjaFJlY3Vyc2l2ZVJlZ0V4cChcInRlc3RcIiwgXCJcXFxcKFwiLCBcIlxcXFwpXCIpXHJcbiAqIHJldHVybnM6IFtdXHJcbiAqIG1hdGNoUmVjdXJzaXZlUmVnRXhwKFwiPHQ8PGU+PjxzPj50PD5cIiwgXCI8XCIsIFwiPlwiLCBcImdcIilcclxuICogcmV0dXJuczogW1widDw8ZT4+PHM+XCIsIFwiXCJdXHJcbiAqIG1hdGNoUmVjdXJzaXZlUmVnRXhwKFwiPGRpdiBpZD1cXFwieFxcXCI+dGVzdDwvZGl2PlwiLCBcIjxkaXZcXFxcYltePl0qPlwiLCBcIjwvZGl2PlwiLCBcImdpXCIpXHJcbiAqIHJldHVybnM6IFtcInRlc3RcIl1cclxuICovXHJcbnNob3dkb3duLmhlbHBlci5tYXRjaFJlY3Vyc2l2ZVJlZ0V4cCA9IGZ1bmN0aW9uIChzdHIsIGxlZnQsIHJpZ2h0LCBmbGFncykge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuICB2YXJcdGYgPSBmbGFncyB8fCAnJyxcclxuICAgIGcgPSBmLmluZGV4T2YoJ2cnKSA+IC0xLFxyXG4gICAgeCA9IG5ldyBSZWdFeHAobGVmdCArICd8JyArIHJpZ2h0LCBmKSxcclxuICAgIGwgPSBuZXcgUmVnRXhwKGxlZnQsIGYucmVwbGFjZSgvZy9nLCAnJykpLFxyXG4gICAgYSA9IFtdLFxyXG4gICAgdCwgcywgbSwgc3RhcnQsIGVuZDtcclxuXHJcbiAgZG8ge1xyXG4gICAgdCA9IDA7XHJcbiAgICB3aGlsZSAoKG0gPSB4LmV4ZWMoc3RyKSkpIHtcclxuICAgICAgaWYgKGwudGVzdChtWzBdKSkge1xyXG4gICAgICAgIGlmICghKHQrKykpIHtcclxuICAgICAgICAgIHN0YXJ0ID0gbVswXTtcclxuICAgICAgICAgIHMgPSB4Lmxhc3RJbmRleDtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAodCkge1xyXG4gICAgICAgIGlmICghLS10KSB7XHJcbiAgICAgICAgICBlbmQgPSBtWzBdO1xyXG4gICAgICAgICAgdmFyIG1hdGNoID0gc3RyLnNsaWNlKHMsIG0uaW5kZXgpO1xyXG4gICAgICAgICAgYS5wdXNoKFtzdGFydCArIG1hdGNoICsgZW5kLCBtYXRjaF0pO1xyXG4gICAgICAgICAgaWYgKCFnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gd2hpbGUgKHQgJiYgKHgubGFzdEluZGV4ID0gcykpO1xyXG5cclxuICByZXR1cm4gYTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBQT0xZRklMTFNcclxuICovXHJcbmlmIChzaG93ZG93bi5oZWxwZXIuaXNVbmRlZmluZWQoY29uc29sZSkpIHtcclxuICBjb25zb2xlID0ge1xyXG4gICAgd2FybjogZnVuY3Rpb24gKG1zZykge1xyXG4gICAgICAndXNlIHN0cmljdCc7XHJcbiAgICAgIGFsZXJ0KG1zZyk7XHJcbiAgICB9LFxyXG4gICAgbG9nOiBmdW5jdGlvbiAobXNnKSB7XHJcbiAgICAgICd1c2Ugc3RyaWN0JztcclxuICAgICAgYWxlcnQobXNnKTtcclxuICAgIH0sXHJcbiAgICBlcnJvcjogZnVuY3Rpb24gKG1zZykge1xyXG4gICAgICAndXNlIHN0cmljdCc7XHJcbiAgICAgIHRocm93IG1zZztcclxuICAgIH1cclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlZCBieSBFc3RldmFvIG9uIDMxLTA1LTIwMTUuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFNob3dkb3duIENvbnZlcnRlciBjbGFzc1xyXG4gKiBAY2xhc3NcclxuICogQHBhcmFtIHtvYmplY3R9IFtjb252ZXJ0ZXJPcHRpb25zXVxyXG4gKiBAcmV0dXJucyB7Q29udmVydGVyfVxyXG4gKi9cclxuc2hvd2Rvd24uQ29udmVydGVyID0gZnVuY3Rpb24gKGNvbnZlcnRlck9wdGlvbnMpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIHZhclxyXG4gICAgICAvKipcclxuICAgICAgICogT3B0aW9ucyB1c2VkIGJ5IHRoaXMgY29udmVydGVyXHJcbiAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAqIEB0eXBlIHt7fX1cclxuICAgICAgICovXHJcbiAgICAgIG9wdGlvbnMgPSB7fSxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBMYW5ndWFnZSBleHRlbnNpb25zIHVzZWQgYnkgdGhpcyBjb252ZXJ0ZXJcclxuICAgICAgICogQHByaXZhdGVcclxuICAgICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICAgKi9cclxuICAgICAgbGFuZ0V4dGVuc2lvbnMgPSBbXSxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBPdXRwdXQgbW9kaWZpZXJzIGV4dGVuc2lvbnMgdXNlZCBieSB0aGlzIGNvbnZlcnRlclxyXG4gICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgICAqL1xyXG4gICAgICBvdXRwdXRNb2RpZmllcnMgPSBbXSxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBFdmVudCBsaXN0ZW5lcnNcclxuICAgICAgICogQHByaXZhdGVcclxuICAgICAgICogQHR5cGUge3t9fVxyXG4gICAgICAgKi9cclxuICAgICAgbGlzdGVuZXJzID0ge307XHJcblxyXG4gIF9jb25zdHJ1Y3RvcigpO1xyXG5cclxuICAvKipcclxuICAgKiBDb252ZXJ0ZXIgY29uc3RydWN0b3JcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIF9jb25zdHJ1Y3RvcigpIHtcclxuICAgIGNvbnZlcnRlck9wdGlvbnMgPSBjb252ZXJ0ZXJPcHRpb25zIHx8IHt9O1xyXG5cclxuICAgIGZvciAodmFyIGdPcHQgaW4gZ2xvYmFsT3B0aW9ucykge1xyXG4gICAgICBpZiAoZ2xvYmFsT3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShnT3B0KSkge1xyXG4gICAgICAgIG9wdGlvbnNbZ09wdF0gPSBnbG9iYWxPcHRpb25zW2dPcHRdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTWVyZ2Ugb3B0aW9uc1xyXG4gICAgaWYgKHR5cGVvZiBjb252ZXJ0ZXJPcHRpb25zID09PSAnb2JqZWN0Jykge1xyXG4gICAgICBmb3IgKHZhciBvcHQgaW4gY29udmVydGVyT3B0aW9ucykge1xyXG4gICAgICAgIGlmIChjb252ZXJ0ZXJPcHRpb25zLmhhc093blByb3BlcnR5KG9wdCkpIHtcclxuICAgICAgICAgIG9wdGlvbnNbb3B0XSA9IGNvbnZlcnRlck9wdGlvbnNbb3B0XTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRocm93IEVycm9yKCdDb252ZXJ0ZXIgZXhwZWN0cyB0aGUgcGFzc2VkIHBhcmFtZXRlciB0byBiZSBhbiBvYmplY3QsIGJ1dCAnICsgdHlwZW9mIGNvbnZlcnRlck9wdGlvbnMgK1xyXG4gICAgICAnIHdhcyBwYXNzZWQgaW5zdGVhZC4nKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAob3B0aW9ucy5leHRlbnNpb25zKSB7XHJcbiAgICAgIHNob3dkb3duLmhlbHBlci5mb3JFYWNoKG9wdGlvbnMuZXh0ZW5zaW9ucywgX3BhcnNlRXh0ZW5zaW9uKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhcnNlIGV4dGVuc2lvblxyXG4gICAqIEBwYXJhbSB7Kn0gZXh0XHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lPScnXVxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gX3BhcnNlRXh0ZW5zaW9uKGV4dCwgbmFtZSkge1xyXG5cclxuICAgIG5hbWUgPSBuYW1lIHx8IG51bGw7XHJcbiAgICAvLyBJZiBpdCdzIGEgc3RyaW5nLCB0aGUgZXh0ZW5zaW9uIHdhcyBwcmV2aW91c2x5IGxvYWRlZFxyXG4gICAgaWYgKHNob3dkb3duLmhlbHBlci5pc1N0cmluZyhleHQpKSB7XHJcbiAgICAgIGV4dCA9IHNob3dkb3duLmhlbHBlci5zdGRFeHROYW1lKGV4dCk7XHJcbiAgICAgIG5hbWUgPSBleHQ7XHJcblxyXG4gICAgICAvLyBMRUdBQ1lfU1VQUE9SVCBDT0RFXHJcbiAgICAgIGlmIChzaG93ZG93bi5leHRlbnNpb25zW2V4dF0pIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ0RFUFJFQ0FUSU9OIFdBUk5JTkc6ICcgKyBleHQgKyAnIGlzIGFuIG9sZCBleHRlbnNpb24gdGhhdCB1c2VzIGEgZGVwcmVjYXRlZCBsb2FkaW5nIG1ldGhvZC4nICtcclxuICAgICAgICAgICdQbGVhc2UgaW5mb3JtIHRoZSBkZXZlbG9wZXIgdGhhdCB0aGUgZXh0ZW5zaW9uIHNob3VsZCBiZSB1cGRhdGVkIScpO1xyXG4gICAgICAgIGxlZ2FjeUV4dGVuc2lvbkxvYWRpbmcoc2hvd2Rvd24uZXh0ZW5zaW9uc1tleHRdLCBleHQpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgLy8gRU5EIExFR0FDWSBTVVBQT1JUIENPREVcclxuXHJcbiAgICAgIH0gZWxzZSBpZiAoIXNob3dkb3duLmhlbHBlci5pc1VuZGVmaW5lZChleHRlbnNpb25zW2V4dF0pKSB7XHJcbiAgICAgICAgZXh0ID0gZXh0ZW5zaW9uc1tleHRdO1xyXG5cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBFcnJvcignRXh0ZW5zaW9uIFwiJyArIGV4dCArICdcIiBjb3VsZCBub3QgYmUgbG9hZGVkLiBJdCB3YXMgZWl0aGVyIG5vdCBmb3VuZCBvciBpcyBub3QgYSB2YWxpZCBleHRlbnNpb24uJyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBleHQgPSBleHQoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXNob3dkb3duLmhlbHBlci5pc0FycmF5KGV4dCkpIHtcclxuICAgICAgZXh0ID0gW2V4dF07XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHZhbGlkRXh0ID0gdmFsaWRhdGUoZXh0LCBuYW1lKTtcclxuICAgIGlmICghdmFsaWRFeHQudmFsaWQpIHtcclxuICAgICAgdGhyb3cgRXJyb3IodmFsaWRFeHQuZXJyb3IpO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXh0Lmxlbmd0aDsgKytpKSB7XHJcbiAgICAgIHN3aXRjaCAoZXh0W2ldLnR5cGUpIHtcclxuXHJcbiAgICAgICAgY2FzZSAnbGFuZyc6XHJcbiAgICAgICAgICBsYW5nRXh0ZW5zaW9ucy5wdXNoKGV4dFtpXSk7XHJcbiAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSAnb3V0cHV0JzpcclxuICAgICAgICAgIG91dHB1dE1vZGlmaWVycy5wdXNoKGV4dFtpXSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBpZiAoZXh0W2ldLmhhc093blByb3BlcnR5KGxpc3RlbmVycykpIHtcclxuICAgICAgICBmb3IgKHZhciBsbiBpbiBleHRbaV0ubGlzdGVuZXJzKSB7XHJcbiAgICAgICAgICBpZiAoZXh0W2ldLmxpc3RlbmVycy5oYXNPd25Qcm9wZXJ0eShsbikpIHtcclxuICAgICAgICAgICAgbGlzdGVuKGxuLCBleHRbaV0ubGlzdGVuZXJzW2xuXSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTEVHQUNZX1NVUFBPUlRcclxuICAgKiBAcGFyYW0geyp9IGV4dFxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gbGVnYWN5RXh0ZW5zaW9uTG9hZGluZyhleHQsIG5hbWUpIHtcclxuICAgIGlmICh0eXBlb2YgZXh0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIGV4dCA9IGV4dChuZXcgc2hvd2Rvd24uQ29udmVydGVyKCkpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFzaG93ZG93bi5oZWxwZXIuaXNBcnJheShleHQpKSB7XHJcbiAgICAgIGV4dCA9IFtleHRdO1xyXG4gICAgfVxyXG4gICAgdmFyIHZhbGlkID0gdmFsaWRhdGUoZXh0LCBuYW1lKTtcclxuXHJcbiAgICBpZiAoIXZhbGlkLnZhbGlkKSB7XHJcbiAgICAgIHRocm93IEVycm9yKHZhbGlkLmVycm9yKTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4dC5sZW5ndGg7ICsraSkge1xyXG4gICAgICBzd2l0Y2ggKGV4dFtpXS50eXBlKSB7XHJcbiAgICAgICAgY2FzZSAnbGFuZyc6XHJcbiAgICAgICAgICBsYW5nRXh0ZW5zaW9ucy5wdXNoKGV4dFtpXSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdvdXRwdXQnOlxyXG4gICAgICAgICAgb3V0cHV0TW9kaWZpZXJzLnB1c2goZXh0W2ldKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6Ly8gc2hvdWxkIG5ldmVyIHJlYWNoIGhlcmVcclxuICAgICAgICAgIHRocm93IEVycm9yKCdFeHRlbnNpb24gbG9hZGVyIGVycm9yOiBUeXBlIHVucmVjb2duaXplZCEhIScpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMaXN0ZW4gdG8gYW4gZXZlbnRcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gbGlzdGVuKG5hbWUsIGNhbGxiYWNrKSB7XHJcbiAgICBpZiAoIXNob3dkb3duLmhlbHBlci5pc1N0cmluZyhuYW1lKSkge1xyXG4gICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBhcmd1bWVudCBpbiBjb252ZXJ0ZXIubGlzdGVuKCkgbWV0aG9kOiBuYW1lIG11c3QgYmUgYSBzdHJpbmcsIGJ1dCAnICsgdHlwZW9mIG5hbWUgKyAnIGdpdmVuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBhcmd1bWVudCBpbiBjb252ZXJ0ZXIubGlzdGVuKCkgbWV0aG9kOiBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24sIGJ1dCAnICsgdHlwZW9mIGNhbGxiYWNrICsgJyBnaXZlbicpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghbGlzdGVuZXJzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XHJcbiAgICAgIGxpc3RlbmVyc1tuYW1lXSA9IFtdO1xyXG4gICAgfVxyXG4gICAgbGlzdGVuZXJzW25hbWVdLnB1c2goY2FsbGJhY2spO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGlzcGF0Y2ggYW4gZXZlbnRcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnROYW1lIEV2ZW50IG5hbWVcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUZXh0XHJcbiAgICogQHBhcmFtIHt7fX0gb3B0aW9ucyBDb252ZXJ0ZXIgT3B0aW9uc1xyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICovXHJcbiAgdGhpcy5fZGlzcGF0Y2ggPSBmdW5jdGlvbiBkaXNwYXRjaCAoZXZ0TmFtZSwgdGV4dCwgb3B0aW9ucykge1xyXG4gICAgaWYgKGxpc3RlbmVycy5oYXNPd25Qcm9wZXJ0eShldnROYW1lKSkge1xyXG4gICAgICBmb3IgKHZhciBlaSA9IDA7IGVpIDwgbGlzdGVuZXJzW2V2dE5hbWVdLmxlbmd0aDsgKytlaSkge1xyXG4gICAgICAgIHZhciBuVGV4dCA9IGxpc3RlbmVyc1tldnROYW1lXVtlaV0oZXZ0TmFtZSwgdGV4dCwgdGhpcywgb3B0aW9ucyk7XHJcbiAgICAgICAgaWYgKG5UZXh0ICYmIHR5cGVvZiBuVGV4dCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgIHRleHQgPSBuVGV4dDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0ZXh0O1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIExpc3RlbiB0byBhbiBldmVudFxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXHJcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcclxuICAgKiBAcmV0dXJucyB7c2hvd2Rvd24uQ29udmVydGVyfVxyXG4gICAqL1xyXG4gIHRoaXMubGlzdGVuID0gZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrKSB7XHJcbiAgICBsaXN0ZW4obmFtZSwgY2FsbGJhY2spO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ29udmVydHMgYSBtYXJrZG93biBzdHJpbmcgaW50byBIVE1MXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcclxuICAgKiBAcmV0dXJucyB7Kn1cclxuICAgKi9cclxuICB0aGlzLm1ha2VIdG1sID0gZnVuY3Rpb24gKHRleHQpIHtcclxuICAgIC8vY2hlY2sgaWYgdGV4dCBpcyBub3QgZmFsc3lcclxuICAgIGlmICghdGV4dCkge1xyXG4gICAgICByZXR1cm4gdGV4dDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZ2xvYmFscyA9IHtcclxuICAgICAgZ0h0bWxCbG9ja3M6ICAgICBbXSxcclxuICAgICAgZ0h0bWxTcGFuczogICAgICBbXSxcclxuICAgICAgZ1VybHM6ICAgICAgICAgICB7fSxcclxuICAgICAgZ1RpdGxlczogICAgICAgICB7fSxcclxuICAgICAgZ0RpbWVuc2lvbnM6ICAgICB7fSxcclxuICAgICAgZ0xpc3RMZXZlbDogICAgICAwLFxyXG4gICAgICBoYXNoTGlua0NvdW50czogIHt9LFxyXG4gICAgICBsYW5nRXh0ZW5zaW9uczogIGxhbmdFeHRlbnNpb25zLFxyXG4gICAgICBvdXRwdXRNb2RpZmllcnM6IG91dHB1dE1vZGlmaWVycyxcclxuICAgICAgY29udmVydGVyOiAgICAgICB0aGlzXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIGF0dGFja2xhYjogUmVwbGFjZSB+IHdpdGggflRcclxuICAgIC8vIFRoaXMgbGV0cyB1cyB1c2UgdGlsZGUgYXMgYW4gZXNjYXBlIGNoYXIgdG8gYXZvaWQgbWQ1IGhhc2hlc1xyXG4gICAgLy8gVGhlIGNob2ljZSBvZiBjaGFyYWN0ZXIgaXMgYXJiaXRyYXJ5OyBhbnl0aGluZyB0aGF0IGlzbid0XHJcbiAgICAvLyBtYWdpYyBpbiBNYXJrZG93biB3aWxsIHdvcmsuXHJcbiAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9+L2csICd+VCcpO1xyXG5cclxuICAgIC8vIGF0dGFja2xhYjogUmVwbGFjZSAkIHdpdGggfkRcclxuICAgIC8vIFJlZ0V4cCBpbnRlcnByZXRzICQgYXMgYSBzcGVjaWFsIGNoYXJhY3RlclxyXG4gICAgLy8gd2hlbiBpdCdzIGluIGEgcmVwbGFjZW1lbnQgc3RyaW5nXHJcbiAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXCQvZywgJ35EJyk7XHJcblxyXG4gICAgLy8gU3RhbmRhcmRpemUgbGluZSBlbmRpbmdzXHJcbiAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHJcXG4vZywgJ1xcbicpOyAvLyBET1MgdG8gVW5peFxyXG4gICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxyL2csICdcXG4nKTsgLy8gTWFjIHRvIFVuaXhcclxuXHJcbiAgICAvLyBNYWtlIHN1cmUgdGV4dCBiZWdpbnMgYW5kIGVuZHMgd2l0aCBhIGNvdXBsZSBvZiBuZXdsaW5lczpcclxuICAgIHRleHQgPSAnXFxuXFxuJyArIHRleHQgKyAnXFxuXFxuJztcclxuXHJcbiAgICAvLyBkZXRhYlxyXG4gICAgdGV4dCA9IHNob3dkb3duLnN1YlBhcnNlcignZGV0YWInKSh0ZXh0LCBvcHRpb25zLCBnbG9iYWxzKTtcclxuXHJcbiAgICAvLyBzdHJpcEJsYW5rTGluZXNcclxuICAgIHRleHQgPSBzaG93ZG93bi5zdWJQYXJzZXIoJ3N0cmlwQmxhbmtMaW5lcycpKHRleHQsIG9wdGlvbnMsIGdsb2JhbHMpO1xyXG5cclxuICAgIC8vcnVuIGxhbmd1YWdlRXh0ZW5zaW9uc1xyXG4gICAgc2hvd2Rvd24uaGVscGVyLmZvckVhY2gobGFuZ0V4dGVuc2lvbnMsIGZ1bmN0aW9uIChleHQpIHtcclxuICAgICAgdGV4dCA9IHNob3dkb3duLnN1YlBhcnNlcigncnVuRXh0ZW5zaW9uJykoZXh0LCB0ZXh0LCBvcHRpb25zLCBnbG9iYWxzKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIHJ1biB0aGUgc3ViIHBhcnNlcnNcclxuICAgIHRleHQgPSBzaG93ZG93bi5zdWJQYXJzZXIoJ2dpdGh1YkNvZGVCbG9ja3MnKSh0ZXh0LCBvcHRpb25zLCBnbG9iYWxzKTtcclxuICAgIHRleHQgPSBzaG93ZG93bi5zdWJQYXJzZXIoJ2hhc2hIVE1MQmxvY2tzJykodGV4dCwgb3B0aW9ucywgZ2xvYmFscyk7XHJcbiAgICB0ZXh0ID0gc2hvd2Rvd24uc3ViUGFyc2VyKCdoYXNoSFRNTFNwYW5zJykodGV4dCwgb3B0aW9ucywgZ2xvYmFscyk7XHJcbiAgICB0ZXh0ID0gc2hvd2Rvd24uc3ViUGFyc2VyKCdzdHJpcExpbmtEZWZpbml0aW9ucycpKHRleHQsIG9wdGlvbnMsIGdsb2JhbHMpO1xyXG4gICAgdGV4dCA9IHNob3dkb3duLnN1YlBhcnNlcignYmxvY2tHYW11dCcpKHRleHQsIG9wdGlvbnMsIGdsb2JhbHMpO1xyXG4gICAgdGV4dCA9IHNob3dkb3duLnN1YlBhcnNlcigndW5oYXNoSFRNTFNwYW5zJykodGV4dCwgb3B0aW9ucywgZ2xvYmFscyk7XHJcbiAgICB0ZXh0ID0gc2hvd2Rvd24uc3ViUGFyc2VyKCd1bmVzY2FwZVNwZWNpYWxDaGFycycpKHRleHQsIG9wdGlvbnMsIGdsb2JhbHMpO1xyXG5cclxuICAgIC8vIGF0dGFja2xhYjogUmVzdG9yZSBkb2xsYXIgc2lnbnNcclxuICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL35EL2csICckJCcpO1xyXG5cclxuICAgIC8vIGF0dGFja2xhYjogUmVzdG9yZSB0aWxkZXNcclxuICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL35UL2csICd+Jyk7XHJcblxyXG4gICAgLy8gUnVuIG91dHB1dCBtb2RpZmllcnNcclxuICAgIHNob3dkb3duLmhlbHBlci5mb3JFYWNoKG91dHB1dE1vZGlmaWVycywgZnVuY3Rpb24gKGV4dCkge1xyXG4gICAgICB0ZXh0ID0gc2hvd2Rvd24uc3ViUGFyc2VyKCdydW5FeHRlbnNpb24nKShleHQsIHRleHQsIG9wdGlvbnMsIGdsb2JhbHMpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHRleHQ7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IGFuIG9wdGlvbiBvZiB0aGlzIENvbnZlcnRlciBpbnN0YW5jZVxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcclxuICAgKiBAcGFyYW0geyp9IHZhbHVlXHJcbiAgICovXHJcbiAgdGhpcy5zZXRPcHRpb24gPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgb3B0aW9uc1trZXldID0gdmFsdWU7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBvcHRpb24gb2YgdGhpcyBDb252ZXJ0ZXIgaW5zdGFuY2VcclxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XHJcbiAgICogQHJldHVybnMgeyp9XHJcbiAgICovXHJcbiAgdGhpcy5nZXRPcHRpb24gPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICByZXR1cm4gb3B0aW9uc1trZXldO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgb3B0aW9ucyBvZiB0aGlzIENvbnZlcnRlciBpbnN0YW5jZVxyXG4gICAqIEByZXR1cm5zIHt7fX1cclxuICAgKi9cclxuICB0aGlzLmdldE9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gb3B0aW9ucztcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBBZGQgZXh0ZW5zaW9uIHRvIFRISVMgY29udmVydGVyXHJcbiAgICogQHBhcmFtIHt7fX0gZXh0ZW5zaW9uXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lPW51bGxdXHJcbiAgICovXHJcbiAgdGhpcy5hZGRFeHRlbnNpb24gPSBmdW5jdGlvbiAoZXh0ZW5zaW9uLCBuYW1lKSB7XHJcbiAgICBuYW1lID0gbmFtZSB8fCBudWxsO1xyXG4gICAgX3BhcnNlRXh0ZW5zaW9uKGV4dGVuc2lvbiwgbmFtZSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVXNlIGEgZ2xvYmFsIHJlZ2lzdGVyZWQgZXh0ZW5zaW9uIHdpdGggVEhJUyBjb252ZXJ0ZXJcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXh0ZW5zaW9uTmFtZSBOYW1lIG9mIHRoZSBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgZXh0ZW5zaW9uXHJcbiAgICovXHJcbiAgdGhpcy51c2VFeHRlbnNpb24gPSBmdW5jdGlvbiAoZXh0ZW5zaW9uTmFtZSkge1xyXG4gICAgX3BhcnNlRXh0ZW5zaW9uKGV4dGVuc2lvbk5hbWUpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCB0aGUgZmxhdm9yIFRISVMgY29udmVydGVyIHNob3VsZCB1c2VcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxyXG4gICAqL1xyXG4gIHRoaXMuc2V0Rmxhdm9yID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgIGlmIChmbGF2b3IuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcclxuICAgICAgdmFyIHByZXNldCA9IGZsYXZvcltuYW1lXTtcclxuICAgICAgZm9yICh2YXIgb3B0aW9uIGluIHByZXNldCkge1xyXG4gICAgICAgIGlmIChwcmVzZXQuaGFzT3duUHJvcGVydHkob3B0aW9uKSkge1xyXG4gICAgICAgICAgb3B0aW9uc1tvcHRpb25dID0gcHJlc2V0W29wdGlvbl07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlIGFuIGV4dGVuc2lvbiBmcm9tIFRISVMgY29udmVydGVyLlxyXG4gICAqIE5vdGU6IFRoaXMgaXMgYSBjb3N0bHkgb3BlcmF0aW9uLiBJdCdzIGJldHRlciB0byBpbml0aWFsaXplIGEgbmV3IGNvbnZlcnRlclxyXG4gICAqIGFuZCBzcGVjaWZ5IHRoZSBleHRlbnNpb25zIHlvdSB3aXNoIHRvIHVzZVxyXG4gICAqIEBwYXJhbSB7QXJyYXl9IGV4dGVuc2lvblxyXG4gICAqL1xyXG4gIHRoaXMucmVtb3ZlRXh0ZW5zaW9uID0gZnVuY3Rpb24gKGV4dGVuc2lvbikge1xyXG4gICAgaWYgKCFzaG93ZG93bi5oZWxwZXIuaXNBcnJheShleHRlbnNpb24pKSB7XHJcbiAgICAgIGV4dGVuc2lvbiA9IFtleHRlbnNpb25dO1xyXG4gICAgfVxyXG4gICAgZm9yICh2YXIgYSA9IDA7IGEgPCBleHRlbnNpb24ubGVuZ3RoOyArK2EpIHtcclxuICAgICAgdmFyIGV4dCA9IGV4dGVuc2lvblthXTtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYW5nRXh0ZW5zaW9ucy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGlmIChsYW5nRXh0ZW5zaW9uc1tpXSA9PT0gZXh0KSB7XHJcbiAgICAgICAgICBsYW5nRXh0ZW5zaW9uc1tpXS5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBvdXRwdXRNb2RpZmllcnMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBpZiAob3V0cHV0TW9kaWZpZXJzW2lpXSA9PT0gZXh0KSB7XHJcbiAgICAgICAgICBvdXRwdXRNb2RpZmllcnNbaWldLnNwbGljZShpLCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBHZXQgYWxsIGV4dGVuc2lvbiBvZiBUSElTIGNvbnZlcnRlclxyXG4gICAqIEByZXR1cm5zIHt7bGFuZ3VhZ2U6IEFycmF5LCBvdXRwdXQ6IEFycmF5fX1cclxuICAgKi9cclxuICB0aGlzLmdldEFsbEV4dGVuc2lvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBsYW5ndWFnZTogbGFuZ0V4dGVuc2lvbnMsXHJcbiAgICAgIG91dHB1dDogb3V0cHV0TW9kaWZpZXJzXHJcbiAgICB9O1xyXG4gIH07XHJcbn07XHJcblxyXG4vKipcclxuICogVHVybiBNYXJrZG93biBsaW5rIHNob3J0Y3V0cyBpbnRvIFhIVE1MIDxhPiB0YWdzLlxyXG4gKi9cclxuc2hvd2Rvd24uc3ViUGFyc2VyKCdhbmNob3JzJywgZnVuY3Rpb24gKHRleHQsIG9wdGlvbnMsIGdsb2JhbHMpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIHRleHQgPSBnbG9iYWxzLmNvbnZlcnRlci5fZGlzcGF0Y2goJ2FuY2hvcnMuYmVmb3JlJywgdGV4dCwgb3B0aW9ucyk7XHJcblxyXG4gIHZhciB3cml0ZUFuY2hvclRhZyA9IGZ1bmN0aW9uICh3aG9sZU1hdGNoLCBtMSwgbTIsIG0zLCBtNCwgbTUsIG02LCBtNykge1xyXG4gICAgaWYgKHNob3dkb3duLmhlbHBlci5pc1VuZGVmaW5lZChtNykpIHtcclxuICAgICAgbTcgPSAnJztcclxuICAgIH1cclxuICAgIHdob2xlTWF0Y2ggPSBtMTtcclxuICAgIHZhciBsaW5rVGV4dCA9IG0yLFxyXG4gICAgICAgIGxpbmtJZCA9IG0zLnRvTG93ZXJDYXNlKCksXHJcbiAgICAgICAgdXJsID0gbTQsXHJcbiAgICAgICAgdGl0bGUgPSBtNztcclxuXHJcbiAgICBpZiAoIXVybCkge1xyXG4gICAgICBpZiAoIWxpbmtJZCkge1xyXG4gICAgICAgIC8vIGxvd2VyLWNhc2UgYW5kIHR1cm4gZW1iZWRkZWQgbmV3bGluZXMgaW50byBzcGFjZXNcclxuICAgICAgICBsaW5rSWQgPSBsaW5rVGV4dC50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLyA/XFxuL2csICcgJyk7XHJcbiAgICAgIH1cclxuICAgICAgdXJsID0gJyMnICsgbGlua0lkO1xyXG5cclxuICAgICAgaWYgKCFzaG93ZG93bi5oZWxwZXIuaXNVbmRlZmluZWQoZ2xvYmFscy5nVXJsc1tsaW5rSWRdKSkge1xyXG4gICAgICAgIHVybCA9IGdsb2JhbHMuZ1VybHNbbGlua0lkXTtcclxuICAgICAgICBpZiAoIXNob3dkb3duLmhlbHBlci5pc1VuZGVmaW5lZChnbG9iYWxzLmdUaXRsZXNbbGlua0lkXSkpIHtcclxuICAgICAgICAgIHRpdGxlID0gZ2xvYmFscy5nVGl0bGVzW2xpbmtJZF07XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmICh3aG9sZU1hdGNoLnNlYXJjaCgvXFwoXFxzKlxcKSQvbSkgPiAtMSkge1xyXG4gICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciBleHBsaWNpdCBlbXB0eSB1cmxcclxuICAgICAgICAgIHVybCA9ICcnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm4gd2hvbGVNYXRjaDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB1cmwgPSBzaG93ZG93bi5oZWxwZXIuZXNjYXBlQ2hhcmFjdGVycyh1cmwsICcqXycsIGZhbHNlKTtcclxuICAgIHZhciByZXN1bHQgPSAnPGEgaHJlZj1cIicgKyB1cmwgKyAnXCInO1xyXG5cclxuICAgIGlmICh0aXRsZSAhPT0gJycgJiYgdGl0bGUgIT09IG51bGwpIHtcclxuICAgICAgdGl0bGUgPSB0aXRsZS5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XHJcbiAgICAgIHRpdGxlID0gc2hvd2Rvd24uaGVscGVyLmVzY2FwZUNoYXJhY3RlcnModGl0bGUsICcqXycsIGZhbHNlKTtcclxuICAgICAgcmVzdWx0ICs9ICcgdGl0bGU9XCInICsgdGl0bGUgKyAnXCInO1xyXG4gICAgfVxyXG5cclxuICAgIHJlc3VsdCArPSAnPicgKyBsaW5rVGV4dCArICc8L2E+JztcclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH07XHJcblxyXG4gIC8vIEZpcnN0LCBoYW5kbGUgcmVmZXJlbmNlLXN0eWxlIGxpbmtzOiBbbGluayB0ZXh0XSBbaWRdXHJcbiAgLypcclxuICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXHJcbiAgIChcdFx0XHRcdFx0XHRcdC8vIHdyYXAgd2hvbGUgbWF0Y2ggaW4gJDFcclxuICAgXFxbXHJcbiAgIChcclxuICAgKD86XHJcbiAgIFxcW1teXFxdXSpcXF1cdFx0Ly8gYWxsb3cgYnJhY2tldHMgbmVzdGVkIG9uZSBsZXZlbFxyXG4gICB8XHJcbiAgIFteXFxbXVx0XHRcdC8vIG9yIGFueXRoaW5nIGVsc2VcclxuICAgKSpcclxuICAgKVxyXG4gICBcXF1cclxuXHJcbiAgIFsgXT9cdFx0XHRcdFx0Ly8gb25lIG9wdGlvbmFsIHNwYWNlXHJcbiAgICg/OlxcblsgXSopP1x0XHRcdFx0Ly8gb25lIG9wdGlvbmFsIG5ld2xpbmUgZm9sbG93ZWQgYnkgc3BhY2VzXHJcblxyXG4gICBcXFtcclxuICAgKC4qPylcdFx0XHRcdFx0Ly8gaWQgPSAkM1xyXG4gICBcXF1cclxuICAgKSgpKCkoKSgpXHRcdFx0XHRcdC8vIHBhZCByZW1haW5pbmcgYmFja3JlZmVyZW5jZXNcclxuICAgL2csX0RvQW5jaG9yc19jYWxsYmFjayk7XHJcbiAgICovXHJcbiAgdGV4dCA9IHRleHQucmVwbGFjZSgvKFxcWygoPzpcXFtbXlxcXV0qXXxbXlxcW1xcXV0pKildWyBdPyg/OlxcblsgXSopP1xcWyguKj8pXSkoKSgpKCkoKS9nLCB3cml0ZUFuY2hvclRhZyk7XHJcblxyXG4gIC8vXHJcbiAgLy8gTmV4dCwgaW5saW5lLXN0eWxlIGxpbmtzOiBbbGluayB0ZXh0XSh1cmwgXCJvcHRpb25hbCB0aXRsZVwiKVxyXG4gIC8vXHJcblxyXG4gIC8qXHJcbiAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xyXG4gICAoXHRcdFx0XHRcdFx0Ly8gd3JhcCB3aG9sZSBtYXRjaCBpbiAkMVxyXG4gICBcXFtcclxuICAgKFxyXG4gICAoPzpcclxuICAgXFxbW15cXF1dKlxcXVx0Ly8gYWxsb3cgYnJhY2tldHMgbmVzdGVkIG9uZSBsZXZlbFxyXG4gICB8XHJcbiAgIFteXFxbXFxdXVx0XHRcdC8vIG9yIGFueXRoaW5nIGVsc2VcclxuICAgKVxyXG4gICApXHJcbiAgIFxcXVxyXG4gICBcXChcdFx0XHRcdFx0XHQvLyBsaXRlcmFsIHBhcmVuXHJcbiAgIFsgXFx0XSpcclxuICAgKClcdFx0XHRcdFx0XHQvLyBubyBpZCwgc28gbGVhdmUgJDMgZW1wdHlcclxuICAgPD8oLio/KT4/XHRcdFx0XHQvLyBocmVmID0gJDRcclxuICAgWyBcXHRdKlxyXG4gICAoXHRcdFx0XHRcdFx0Ly8gJDVcclxuICAgKFsnXCJdKVx0XHRcdFx0Ly8gcXVvdGUgY2hhciA9ICQ2XHJcbiAgICguKj8pXHRcdFx0XHQvLyBUaXRsZSA9ICQ3XHJcbiAgIFxcNlx0XHRcdFx0XHQvLyBtYXRjaGluZyBxdW90ZVxyXG4gICBbIFxcdF0qXHRcdFx0XHQvLyBpZ25vcmUgYW55IHNwYWNlcy90YWJzIGJldHdlZW4gY2xvc2luZyBxdW90ZSBhbmQgKVxyXG4gICApP1x0XHRcdFx0XHRcdC8vIHRpdGxlIGlzIG9wdGlvbmFsXHJcbiAgIFxcKVxyXG4gICApXHJcbiAgIC9nLHdyaXRlQW5jaG9yVGFnKTtcclxuICAgKi9cclxuICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC8oXFxbKCg/OlxcW1teXFxdXSpdfFteXFxbXFxdXSkqKV1cXChbIFxcdF0qKCk8PyguKj8oPzpcXCguKj9cXCkuKj8pPyk+P1sgXFx0XSooKFsnXCJdKSguKj8pXFw2WyBcXHRdKik/XFwpKS9nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgd3JpdGVBbmNob3JUYWcpO1xyXG5cclxuICAvL1xyXG4gIC8vIExhc3QsIGhhbmRsZSByZWZlcmVuY2Utc3R5bGUgc2hvcnRjdXRzOiBbbGluayB0ZXh0XVxyXG4gIC8vIFRoZXNlIG11c3QgY29tZSBsYXN0IGluIGNhc2UgeW91J3ZlIGFsc28gZ290IFtsaW5rIHRlc3RdWzFdXHJcbiAgLy8gb3IgW2xpbmsgdGVzdF0oL2ZvbylcclxuICAvL1xyXG5cclxuICAvKlxyXG4gICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cclxuICAgKCAgICAgICAgICAgICAgICAvLyB3cmFwIHdob2xlIG1hdGNoIGluICQxXHJcbiAgIFxcW1xyXG4gICAoW15cXFtcXF1dKykgICAgICAgLy8gbGluayB0ZXh0ID0gJDI7IGNhbid0IGNvbnRhaW4gJ1snIG9yICddJ1xyXG4gICBcXF1cclxuICAgKSgpKCkoKSgpKCkgICAgICAvLyBwYWQgcmVzdCBvZiBiYWNrcmVmZXJlbmNlc1xyXG4gICAvZywgd3JpdGVBbmNob3JUYWcpO1xyXG4gICAqL1xyXG4gIHRleHQgPSB0ZXh0LnJlcGxhY2UoLyhcXFsoW15cXFtcXF1dKyldKSgpKCkoKSgpKCkvZywgd3JpdGVBbmNob3JUYWcpO1xyXG5cclxuICB0ZXh0ID0gZ2xvYmFscy5jb252ZXJ0ZXIuX2Rpc3BhdGNoKCdhbmNob3JzLmFmdGVyJywgdGV4dCwgb3B0aW9ucyk7XHJcbiAgcmV0dXJuIHRleHQ7XHJcbn0pO1xyXG5cclxuc2hvd2Rvd24uc3ViUGFyc2VyKCdhdXRvTGlua3MnLCBmdW5jdGlvbiAodGV4dCwgb3B0aW9ucywgZ2xvYmFscykge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgdGV4dCA9IGdsb2JhbHMuY29udmVydGVyLl9kaXNwYXRjaCgnYXV0b0xpbmtzLmJlZm9yZScsIHRleHQsIG9wdGlvbnMpO1xyXG5cclxuICB2YXIgc2ltcGxlVVJMUmVnZXggID0gL1xcYigoKGh0dHBzP3xmdHB8ZGljdCk6XFwvXFwvfHd3d1xcLilbXidcIj5cXHNdK1xcLlteJ1wiPlxcc10rKSg/PVxcc3wkKSg/IVtcIjw+XSkvZ2ksXHJcbiAgICAgIGRlbGltVXJsUmVnZXggICA9IC88KCgoaHR0cHM/fGZ0cHxkaWN0KTpcXC9cXC98d3d3XFwuKVteJ1wiPlxcc10rKT4vZ2ksXHJcbiAgICAgIHNpbXBsZU1haWxSZWdleCA9IC8oPzpefFsgXFxuXFx0XSkoW0EtWmEtejAtOSEjJCUmJyorLS89P15fYFxce3x9flxcLl0rQFstYS16MC05XSsoXFwuWy1hLXowLTldKykqXFwuW2Etel0rKSg/OiR8WyBcXG5cXHRdKS9naSxcclxuICAgICAgZGVsaW1NYWlsUmVnZXggID0gLzwoPzptYWlsdG86KT8oWy0uXFx3XStAWy1hLXowLTldKyhcXC5bLWEtejAtOV0rKSpcXC5bYS16XSspPi9naTtcclxuXHJcbiAgdGV4dCA9IHRleHQucmVwbGFjZShkZWxpbVVybFJlZ2V4LCAnPGEgaHJlZj1cXFwiJDFcXFwiPiQxPC9hPicpO1xyXG4gIHRleHQgPSB0ZXh0LnJlcGxhY2UoZGVsaW1NYWlsUmVnZXgsIHJlcGxhY2VNYWlsKTtcclxuICAvL3NpbXBsZVVSTFJlZ2V4ICA9IC9cXGIoKChodHRwcz98ZnRwfGRpY3QpOlxcL1xcL3x3d3dcXC4pWy0uK346PyNAISQmJygpKiw7PVtcXF1cXHddKylcXGIvZ2ksXHJcbiAgLy8gRW1haWwgYWRkcmVzc2VzOiA8YWRkcmVzc0Bkb21haW4uZm9vPlxyXG5cclxuICBpZiAob3B0aW9ucy5zaW1wbGlmaWVkQXV0b0xpbmspIHtcclxuICAgIHRleHQgPSB0ZXh0LnJlcGxhY2Uoc2ltcGxlVVJMUmVnZXgsICc8YSBocmVmPVxcXCIkMVxcXCI+JDE8L2E+Jyk7XHJcbiAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHNpbXBsZU1haWxSZWdleCwgcmVwbGFjZU1haWwpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVwbGFjZU1haWwod2hvbGVNYXRjaCwgbTEpIHtcclxuICAgIHZhciB1bmVzY2FwZWRTdHIgPSBzaG93ZG93bi5zdWJQYXJzZXIoJ3VuZXNjYXBlU3BlY2lhbENoYXJzJykobTEpO1xyXG4gICAgcmV0dXJuIHNob3dkb3duLnN1YlBhcnNlcignZW5jb2RlRW1haWxBZGRyZXNzJykodW5lc2NhcGVkU3RyKTtcclxuICB9XHJcblxyXG4gIHRleHQgPSBnbG9iYWxzLmNvbnZlcnRlci5fZGlzcGF0Y2goJ2F1dG9MaW5rcy5hZnRlcicsIHRleHQsIG9wdGlvbnMpO1xyXG5cclxuICByZXR1cm4gdGV4dDtcclxufSk7XHJcblxyXG4vKipcclxuICogVGhlc2UgYXJlIGFsbCB0aGUgdHJhbnNmb3JtYXRpb25zIHRoYXQgZm9ybSBibG9jay1sZXZlbFxyXG4gKiB0YWdzIGxpa2UgcGFyYWdyYXBocywgaGVhZGVycywgYW5kIGxpc3QgaXRlbXMuXHJcbiAqL1xyXG5zaG93ZG93bi5zdWJQYXJzZXIoJ2Jsb2NrR2FtdXQnLCBmdW5jdGlvbiAodGV4dCwgb3B0aW9ucywgZ2xvYmFscykge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgdGV4dCA9IGdsb2JhbHMuY29udmVydGVyLl9kaXNwYXRjaCgnYmxvY2tHYW11dC5iZWZvcmUnLCB0ZXh0LCBvcHRpb25zKTtcclxuXHJcbiAgLy8gd2UgcGFyc2UgYmxvY2txdW90ZXMgZmlyc3Qgc28gdGhhdCB3ZSBjYW4gaGF2ZSBoZWFkaW5ncyBhbmQgaHJzXHJcbiAgLy8gaW5zaWRlIGJsb2NrcXVvdGVzXHJcbiAgdGV4dCA9IHNob3dkb3duLnN1YlBhcnNlcignYmxvY2tRdW90ZXMnKSh0ZXh0LCBvcHRpb25zLCBnbG9iYWxzKTtcclxuICB0ZXh0ID0gc2hvd2Rvd24uc3ViUGFyc2VyKCdoZWFkZXJzJykodGV4dCwgb3B0aW9ucywgZ2xvYmFscyk7XHJcblxyXG4gIC8vIERvIEhvcml6b250YWwgUnVsZXM6XHJcbiAgdmFyIGtleSA9IHNob3dkb3duLnN1YlBhcnNlcignaGFzaEJsb2NrJykoJzxociAvPicsIG9wdGlvbnMsIGdsb2JhbHMpO1xyXG4gIHRleHQgPSB0ZXh0LnJlcGxhY2UoL15bIF17MCwyfShbIF0/XFwqWyBdPyl7Myx9WyBcXHRdKiQvZ20sIGtleSk7XHJcbiAgdGV4dCA9IHRleHQucmVwbGFjZSgvXlsgXXswLDJ9KFsgXT9cXC1bIF0/KXszLH1bIFxcdF0qJC9nbSwga2V5KTtcclxuICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9eWyBdezAsMn0oWyBdP19bIF0/KXszLH1bIFxcdF0qJC9nbSwga2V5KTtcclxuXHJcbiAgdGV4dCA9IHNob3dkb3duLnN1YlBhcnNlcignbGlzdHMnKSh0ZXh0LCBvcHRpb25zLCBnbG9iYWxzKTtcclxuICB0ZXh0ID0gc2hvd2Rvd24uc3ViUGFyc2VyKCdjb2RlQmxvY2tzJykodGV4dCwgb3B0aW9ucywgZ2xvYmFscyk7XHJcbiAgdGV4dCA9IHNob3dkb3duLnN1YlBhcnNlcigndGFibGVzJykodGV4dCwgb3B0aW9ucywgZ2xvYmFscyk7XHJcblxyXG4gIC8vIFdlIGFscmVhZHkgcmFuIF9IYXNoSFRNTEJsb2NrcygpIGJlZm9yZSwgaW4gTWFya2Rvd24oKSwgYnV0IHRoYXRcclxuICAvLyB3YXMgdG8gZXNjYXBlIHJhdyBIVE1MIGluIHRoZSBvcmlnaW5hbCBNYXJrZG93biBzb3VyY2UuIFRoaXMgdGltZSxcclxuICAvLyB3ZSdyZSBlc2NhcGluZyB0aGUgbWFya3VwIHdlJ3ZlIGp1c3QgY3JlYXRlZCwgc28gdGhhdCB3ZSBkb24ndCB3cmFwXHJcbiAgLy8gPHA+IHRhZ3MgYXJvdW5kIGJsb2NrLWxldmVsIHRhZ3MuXHJcbiAgdGV4dCA9IHNob3dkb3duLnN1YlBhcnNlcignaGFzaEhUTUxCbG9ja3MnKSh0ZXh0LCBvcHRpb25zLCBnbG9iYWxzKTtcclxuICB0ZXh0ID0gc2hvd2Rvd24uc3ViUGFyc2VyKCdwYXJhZ3JhcGhzJykodGV4dCwgb3B0aW9ucywgZ2xvYmFscyk7XHJcblxyXG4gIHRleHQgPSBnbG9iYWxzLmNvbnZlcnRlci5fZGlzcGF0Y2goJ2Jsb2NrR2FtdXQuYWZ0ZXInLCB0ZXh0LCBvcHRpb25zKTtcclxuXHJcbiAgcmV0dXJuIHRleHQ7XHJcbn0pO1xyXG5cclxuc2hvd2Rvd24uc3ViUGFyc2VyKCdibG9ja1F1b3RlcycsIGZ1bmN0aW9uICh0ZXh0LCBvcHRpb25zLCBnbG9iYWxzKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICB0ZXh0ID0gZ2xvYmFscy5jb252ZXJ0ZXIuX2Rpc3BhdGNoKCdibG9ja1F1b3Rlcy5iZWZvcmUnLCB0ZXh0LCBvcHRpb25zKTtcclxuICAvKlxyXG4gICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cclxuICAgKFx0XHRcdFx0XHRcdFx0XHQvLyBXcmFwIHdob2xlIG1hdGNoIGluICQxXHJcbiAgIChcclxuICAgXlsgXFx0XSo+WyBcXHRdP1x0XHRcdC8vICc+JyBhdCB0aGUgc3RhcnQgb2YgYSBsaW5lXHJcbiAgIC4rXFxuXHRcdFx0XHRcdC8vIHJlc3Qgb2YgdGhlIGZpcnN0IGxpbmVcclxuICAgKC4rXFxuKSpcdFx0XHRcdFx0Ly8gc3Vic2VxdWVudCBjb25zZWN1dGl2ZSBsaW5lc1xyXG4gICBcXG4qXHRcdFx0XHRcdFx0Ly8gYmxhbmtzXHJcbiAgICkrXHJcbiAgIClcclxuICAgL2dtLCBmdW5jdGlvbigpey4uLn0pO1xyXG4gICAqL1xyXG5cclxuICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC8oKF5bIFxcdF17MCwzfT5bIFxcdF0/LitcXG4oLitcXG4pKlxcbiopKykvZ20sIGZ1bmN0aW9uICh3aG9sZU1hdGNoLCBtMSkge1xyXG4gICAgdmFyIGJxID0gbTE7XHJcblxyXG4gICAgLy8gYXR0YWNrbGFiOiBoYWNrIGFyb3VuZCBLb25xdWVyb3IgMy41LjQgYnVnOlxyXG4gICAgLy8gXCItLS0tLS0tLS0tYnVnXCIucmVwbGFjZSgvXi0vZyxcIlwiKSA9PSBcImJ1Z1wiXHJcbiAgICBicSA9IGJxLnJlcGxhY2UoL15bIFxcdF0qPlsgXFx0XT8vZ20sICd+MCcpOyAvLyB0cmltIG9uZSBsZXZlbCBvZiBxdW90aW5nXHJcblxyXG4gICAgLy8gYXR0YWNrbGFiOiBjbGVhbiB1cCBoYWNrXHJcbiAgICBicSA9IGJxLnJlcGxhY2UoL34wL2csICcnKTtcclxuXHJcbiAgICBicSA9IGJxLnJlcGxhY2UoL15bIFxcdF0rJC9nbSwgJycpOyAvLyB0cmltIHdoaXRlc3BhY2Utb25seSBsaW5lc1xyXG4gICAgYnEgPSBzaG93ZG93bi5zdWJQYXJzZXIoJ2dpdGh1YkNvZGVCbG9ja3MnKShicSwgb3B0aW9ucywgZ2xvYmFscyk7XHJcbiAgICBicSA9IHNob3dkb3duLnN1YlBhcnNlcignYmxvY2tHYW11dCcpKGJxLCBvcHRpb25zLCBnbG9iYWxzKTsgLy8gcmVjdXJzZVxyXG5cclxuICAgIGJxID0gYnEucmVwbGFjZSgvKF58XFxuKS9nLCAnJDEgICcpO1xyXG4gICAgLy8gVGhlc2UgbGVhZGluZyBzcGFjZXMgc2NyZXcgd2l0aCA8cHJlPiBjb250ZW50LCBzbyB3ZSBuZWVkIHRvIGZpeCB0aGF0OlxyXG4gICAgYnEgPSBicS5yZXBsYWNlKC8oXFxzKjxwcmU+W15cXHJdKz88XFwvcHJlPikvZ20sIGZ1bmN0aW9uICh3aG9sZU1hdGNoLCBtMSkge1xyXG4gICAgICB2YXIgcHJlID0gbTE7XHJcbiAgICAgIC8vIGF0dGFja2xhYjogaGFjayBhcm91bmQgS29ucXVlcm9yIDMuNS40IGJ1ZzpcclxuICAgICAgcHJlID0gcHJlLnJlcGxhY2UoL14gIC9tZywgJ34wJyk7XHJcbiAgICAgIHByZSA9IHByZS5yZXBsYWNlKC9+MC9nLCAnJyk7XHJcbiAgICAgIHJldHVybiBwcmU7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gc2hvd2Rvd24uc3ViUGFyc2VyKCdoYXNoQmxvY2snKSgnPGJsb2NrcXVvdGU+XFxuJyArIGJxICsgJ1xcbjwvYmxvY2txdW90ZT4nLCBvcHRpb25zLCBnbG9iYWxzKTtcclxuICB9KTtcclxuXHJcbiAgdGV4dCA9IGdsb2JhbHMuY29udmVydGVyLl9kaXNwYXRjaCgnYmxvY2tRdW90ZXMuYWZ0ZXInLCB0ZXh0LCBvcHRpb25zKTtcclxuICByZXR1cm4gdGV4dDtcclxufSk7XHJcblxyXG4vKipcclxuICogUHJvY2VzcyBNYXJrZG93biBgPHByZT48Y29kZT5gIGJsb2Nrcy5cclxuICovXHJcbnNob3dkb3duLnN1YlBhcnNlcignY29kZUJsb2NrcycsIGZ1bmN0aW9uICh0ZXh0LCBvcHRpb25zLCBnbG9iYWxzKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICB0ZXh0ID0gZ2xvYmFscy5jb252ZXJ0ZXIuX2Rpc3BhdGNoKCdjb2RlQmxvY2tzLmJlZm9yZScsIHRleHQsIG9wdGlvbnMpO1xyXG4gIC8qXHJcbiAgIHRleHQgPSB0ZXh0LnJlcGxhY2UodGV4dCxcclxuICAgLyg/OlxcblxcbnxeKVxyXG4gICAoXHRcdFx0XHRcdFx0XHRcdC8vICQxID0gdGhlIGNvZGUgYmxvY2sgLS0gb25lIG9yIG1vcmUgbGluZXMsIHN0YXJ0aW5nIHdpdGggYSBzcGFjZS90YWJcclxuICAgKD86XHJcbiAgICg/OlsgXXs0fXxcXHQpXHRcdFx0Ly8gTGluZXMgbXVzdCBzdGFydCB3aXRoIGEgdGFiIG9yIGEgdGFiLXdpZHRoIG9mIHNwYWNlcyAtIGF0dGFja2xhYjogZ190YWJfd2lkdGhcclxuICAgLipcXG4rXHJcbiAgICkrXHJcbiAgIClcclxuICAgKFxcbipbIF17MCwzfVteIFxcdFxcbl18KD89fjApKVx0Ly8gYXR0YWNrbGFiOiBnX3RhYl93aWR0aFxyXG4gICAvZyxmdW5jdGlvbigpey4uLn0pO1xyXG4gICAqL1xyXG5cclxuICAvLyBhdHRhY2tsYWI6IHNlbnRpbmVsIHdvcmthcm91bmRzIGZvciBsYWNrIG9mIFxcQSBhbmQgXFxaLCBzYWZhcmlcXGtodG1sIGJ1Z1xyXG4gIHRleHQgKz0gJ34wJztcclxuXHJcbiAgdmFyIHBhdHRlcm4gPSAvKD86XFxuXFxufF4pKCg/Oig/OlsgXXs0fXxcXHQpLipcXG4rKSspKFxcbipbIF17MCwzfVteIFxcdFxcbl18KD89fjApKS9nO1xyXG4gIHRleHQgPSB0ZXh0LnJlcGxhY2UocGF0dGVybiwgZnVuY3Rpb24gKHdob2xlTWF0Y2gsIG0xLCBtMikge1xyXG4gICAgdmFyIGNvZGVibG9jayA9IG0xLFxyXG4gICAgICAgIG5leHRDaGFyID0gbTIsXHJcbiAgICAgICAgZW5kID0gJ1xcbic7XHJcblxyXG4gICAgY29kZWJsb2NrID0gc2hvd2Rvd24uc3ViUGFyc2VyKCdvdXRkZW50JykoY29kZWJsb2NrKTtcclxuICAgIGNvZGVibG9jayA9IHNob3dkb3duLnN1YlBhcnNlcignZW5jb2RlQ29kZScpKGNvZGVibG9jayk7XHJcbiAgICBjb2RlYmxvY2sgPSBzaG93ZG93bi5zdWJQYXJzZXIoJ2RldGFiJykoY29kZWJsb2NrKTtcclxuICAgIGNvZGVibG9jayA9IGNvZGVibG9jay5yZXBsYWNlKC9eXFxuKy9nLCAnJyk7IC8vIHRyaW0gbGVhZGluZyBuZXdsaW5lc1xyXG4gICAgY29kZWJsb2NrID0gY29kZWJsb2NrLnJlcGxhY2UoL1xcbiskL2csICcnKTsgLy8gdHJpbSB0cmFpbGluZyBuZXdsaW5lc1xyXG5cclxuICAgIGlmIChvcHRpb25zLm9taXRFeHRyYVdMSW5Db2RlQmxvY2tzKSB7XHJcbiAgICAgIGVuZCA9ICcnO1xyXG4gICAgfVxyXG5cclxuICAgIGNvZGVibG9jayA9ICc8cHJlPjxjb2RlPicgKyBjb2RlYmxvY2sgKyBlbmQgKyAnPC9jb2RlPjwvcHJlPic7XHJcblxyXG4gICAgcmV0dXJuIHNob3dkb3duLnN1YlBhcnNlcignaGFzaEJsb2NrJykoY29kZWJsb2NrLCBvcHRpb25zLCBnbG9iYWxzKSArIG5leHRDaGFyO1xyXG4gIH0pO1xyXG5cclxuICAvLyBhdHRhY2tsYWI6IHN0cmlwIHNlbnRpbmVsXHJcbiAgdGV4dCA9IHRleHQucmVwbGFjZSgvfjAvLCAnJyk7XHJcblxyXG4gIHRleHQgPSBnbG9iYWxzLmNvbnZlcnRlci5fZGlzcGF0Y2goJ2NvZGVCbG9ja3MuYWZ0ZXInLCB0ZXh0LCBvcHRpb25zKTtcclxuICByZXR1cm4gdGV4dDtcclxufSk7XHJcblxyXG4vKipcclxuICpcclxuICogICAqICBCYWNrdGljayBxdW90ZXMgYXJlIHVzZWQgZm9yIDxjb2RlPjwvY29kZT4gc3BhbnMuXHJcbiAqXHJcbiAqICAgKiAgWW91IGNhbiB1c2UgbXVsdGlwbGUgYmFja3RpY2tzIGFzIHRoZSBkZWxpbWl0ZXJzIGlmIHlvdSB3YW50IHRvXHJcbiAqICAgICBpbmNsdWRlIGxpdGVyYWwgYmFja3RpY2tzIGluIHRoZSBjb2RlIHNwYW4uIFNvLCB0aGlzIGlucHV0OlxyXG4gKlxyXG4gKiAgICAgICAgIEp1c3QgdHlwZSBgYGZvbyBgYmFyYCBiYXpgYCBhdCB0aGUgcHJvbXB0LlxyXG4gKlxyXG4gKiAgICAgICBXaWxsIHRyYW5zbGF0ZSB0bzpcclxuICpcclxuICogICAgICAgICA8cD5KdXN0IHR5cGUgPGNvZGU+Zm9vIGBiYXJgIGJhejwvY29kZT4gYXQgdGhlIHByb21wdC48L3A+XHJcbiAqXHJcbiAqICAgIFRoZXJlJ3Mgbm8gYXJiaXRyYXJ5IGxpbWl0IHRvIHRoZSBudW1iZXIgb2YgYmFja3RpY2tzIHlvdVxyXG4gKiAgICBjYW4gdXNlIGFzIGRlbGltdGVycy4gSWYgeW91IG5lZWQgdGhyZWUgY29uc2VjdXRpdmUgYmFja3RpY2tzXHJcbiAqICAgIGluIHlvdXIgY29kZSwgdXNlIGZvdXIgZm9yIGRlbGltaXRlcnMsIGV0Yy5cclxuICpcclxuICogICogIFlvdSBjYW4gdXNlIHNwYWNlcyB0byBnZXQgbGl0ZXJhbCBiYWNrdGlja3MgYXQgdGhlIGVkZ2VzOlxyXG4gKlxyXG4gKiAgICAgICAgIC4uLiB0eXBlIGBgIGBiYXJgIGBgIC4uLlxyXG4gKlxyXG4gKiAgICAgICBUdXJucyB0bzpcclxuICpcclxuICogICAgICAgICAuLi4gdHlwZSA8Y29kZT5gYmFyYDwvY29kZT4gLi4uXHJcbiAqL1xyXG5zaG93ZG93bi5zdWJQYXJzZXIoJ2NvZGVTcGFucycsIGZ1bmN0aW9uICh0ZXh0LCBvcHRpb25zLCBnbG9iYWxzKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICB0ZXh0ID0gZ2xvYmFscy5jb252ZXJ0ZXIuX2Rpc3BhdGNoKCdjb2RlU3BhbnMuYmVmb3JlJywgdGV4dCwgb3B0aW9ucyk7XHJcblxyXG4gIC8qXHJcbiAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xyXG4gICAoXnxbXlxcXFxdKVx0XHRcdFx0XHQvLyBDaGFyYWN0ZXIgYmVmb3JlIG9wZW5pbmcgYCBjYW4ndCBiZSBhIGJhY2tzbGFzaFxyXG4gICAoYCspXHRcdFx0XHRcdFx0Ly8gJDIgPSBPcGVuaW5nIHJ1biBvZiBgXHJcbiAgIChcdFx0XHRcdFx0XHRcdC8vICQzID0gVGhlIGNvZGUgYmxvY2tcclxuICAgW15cXHJdKj9cclxuICAgW15gXVx0XHRcdFx0XHQvLyBhdHRhY2tsYWI6IHdvcmsgYXJvdW5kIGxhY2sgb2YgbG9va2JlaGluZFxyXG4gICApXHJcbiAgIFxcMlx0XHRcdFx0XHRcdFx0Ly8gTWF0Y2hpbmcgY2xvc2VyXHJcbiAgICg/IWApXHJcbiAgIC9nbSwgZnVuY3Rpb24oKXsuLi59KTtcclxuICAgKi9cclxuICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC8oXnxbXlxcXFxdKShgKykoW15cXHJdKj9bXmBdKVxcMig/IWApL2dtLFxyXG4gICAgZnVuY3Rpb24gKHdob2xlTWF0Y2gsIG0xLCBtMiwgbTMpIHtcclxuICAgICAgdmFyIGMgPSBtMztcclxuICAgICAgYyA9IGMucmVwbGFjZSgvXihbIFxcdF0qKS9nLCAnJyk7XHQvLyBsZWFkaW5nIHdoaXRlc3BhY2VcclxuICAgICAgYyA9IGMucmVwbGFjZSgvWyBcXHRdKiQvZywgJycpO1x0Ly8gdHJhaWxpbmcgd2hpdGVzcGFjZVxyXG4gICAgICBjID0gc2hvd2Rvd24uc3ViUGFyc2VyKCdlbmNvZGVDb2RlJykoYyk7XHJcbiAgICAgIHJldHVybiBtMSArICc8Y29kZT4nICsgYyArICc8L2NvZGU+JztcclxuICAgIH1cclxuICApO1xyXG5cclxuICB0ZXh0ID0gZ2xvYmFscy5jb252ZXJ0ZXIuX2Rpc3BhdGNoKCdjb2RlU3BhbnMuYWZ0ZXInLCB0ZXh0LCBvcHRpb25zKTtcclxuICByZXR1cm4gdGV4dDtcclxufSk7XHJcblxyXG4vKipcclxuICogQ29udmVydCBhbGwgdGFicyB0byBzcGFjZXNcclxuICovXHJcbnNob3dkb3duLnN1YlBhcnNlcignZGV0YWInLCBmdW5jdGlvbiAodGV4dCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgLy8gZXhwYW5kIGZpcnN0IG4tMSB0YWJzXHJcbiAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFx0KD89XFx0KS9nLCAnICAgICcpOyAvLyBnX3RhYl93aWR0aFxyXG5cclxuICAvLyByZXBsYWNlIHRoZSBudGggd2l0aCB0d28gc2VudGluZWxzXHJcbiAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFx0L2csICd+QX5CJyk7XHJcblxyXG4gIC8vIHVzZSB0aGUgc2VudGluZWwgdG8gYW5jaG9yIG91ciByZWdleCBzbyBpdCBkb2Vzbid0IGV4cGxvZGVcclxuICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9+QiguKz8pfkEvZywgZnVuY3Rpb24gKHdob2xlTWF0Y2gsIG0xKSB7XHJcbiAgICB2YXIgbGVhZGluZ1RleHQgPSBtMSxcclxuICAgICAgICBudW1TcGFjZXMgPSA0IC0gbGVhZGluZ1RleHQubGVuZ3RoICUgNDsgIC8vIGdfdGFiX3dpZHRoXHJcblxyXG4gICAgLy8gdGhlcmUgKm11c3QqIGJlIGEgYmV0dGVyIHdheSB0byBkbyB0aGlzOlxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1TcGFjZXM7IGkrKykge1xyXG4gICAgICBsZWFkaW5nVGV4dCArPSAnICc7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGxlYWRpbmdUZXh0O1xyXG4gIH0pO1xyXG5cclxuICAvLyBjbGVhbiB1cCBzZW50aW5lbHNcclxuICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9+QS9nLCAnICAgICcpOyAgLy8gZ190YWJfd2lkdGhcclxuICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9+Qi9nLCAnJyk7XHJcblxyXG4gIHJldHVybiB0ZXh0O1xyXG5cclxufSk7XHJcblxyXG4vKipcclxuICogU21hcnQgcHJvY2Vzc2luZyBmb3IgYW1wZXJzYW5kcyBhbmQgYW5nbGUgYnJhY2tldHMgdGhhdCBuZWVkIHRvIGJlIGVuY29kZWQuXHJcbiAqL1xyXG5zaG93ZG93bi5zdWJQYXJzZXIoJ2VuY29kZUFtcHNBbmRBbmdsZXMnLCBmdW5jdGlvbiAodGV4dCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuICAvLyBBbXBlcnNhbmQtZW5jb2RpbmcgYmFzZWQgZW50aXJlbHkgb24gTmF0IElyb25zJ3MgQW1wdXRhdG9yIE1UIHBsdWdpbjpcclxuICAvLyBodHRwOi8vYnVtcHBvLm5ldC9wcm9qZWN0cy9hbXB1dGF0b3IvXHJcbiAgdGV4dCA9IHRleHQucmVwbGFjZSgvJig/ISM/W3hYXT8oPzpbMC05YS1mQS1GXSt8XFx3Kyk7KS9nLCAnJmFtcDsnKTtcclxuXHJcbiAgLy8gRW5jb2RlIG5ha2VkIDwnc1xyXG4gIHRleHQgPSB0ZXh0LnJlcGxhY2UoLzwoPyFbYS16XFwvP1xcJCFdKS9naSwgJyZsdDsnKTtcclxuXHJcbiAgcmV0dXJuIHRleHQ7XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHN0cmluZywgd2l0aCBhZnRlciBwcm9jZXNzaW5nIHRoZSBmb2xsb3dpbmcgYmFja3NsYXNoIGVzY2FwZSBzZXF1ZW5jZXMuXHJcbiAqXHJcbiAqIGF0dGFja2xhYjogVGhlIHBvbGl0ZSB3YXkgdG8gZG8gdGhpcyBpcyB3aXRoIHRoZSBuZXcgZXNjYXBlQ2hhcmFjdGVycygpIGZ1bmN0aW9uOlxyXG4gKlxyXG4gKiAgICB0ZXh0ID0gZXNjYXBlQ2hhcmFjdGVycyh0ZXh0LFwiXFxcXFwiLHRydWUpO1xyXG4gKiAgICB0ZXh0ID0gZXNjYXBlQ2hhcmFjdGVycyh0ZXh0LFwiYCpfe31bXSgpPiMrLS4hXCIsdHJ1ZSk7XHJcbiAqXHJcbiAqIC4uLmJ1dCB3ZSdyZSBzaWRlc3RlcHBpbmcgaXRzIHVzZSBvZiB0aGUgKHNsb3cpIFJlZ0V4cCBjb25zdHJ1Y3RvclxyXG4gKiBhcyBhbiBvcHRpbWl6YXRpb24gZm9yIEZpcmVmb3guICBUaGlzIGZ1bmN0aW9uIGdldHMgY2FsbGVkIGEgTE9ULlxyXG4gKi9cclxuc2hvd2Rvd24uc3ViUGFyc2VyKCdlbmNvZGVCYWNrc2xhc2hFc2NhcGVzJywgZnVuY3Rpb24gKHRleHQpIHtcclxuICAndXNlIHN0cmljdCc7XHJcbiAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxcXChcXFxcKS9nLCBzaG93ZG93bi5oZWxwZXIuZXNjYXBlQ2hhcmFjdGVyc0NhbGxiYWNrKTtcclxuICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXFxcKFtgKl97fVxcW1xcXSgpPiMrLS4hXSkvZywgc2hvd2Rvd24uaGVscGVyLmVzY2FwZUNoYXJhY3RlcnNDYWxsYmFjayk7XHJcbiAgcmV0dXJuIHRleHQ7XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEVuY29kZS9lc2NhcGUgY2VydGFpbiBjaGFyYWN0ZXJzIGluc2lkZSBNYXJrZG93biBjb2RlIHJ1bnMuXHJcbiAqIFRoZSBwb2ludCBpcyB0aGF0IGluIGNvZGUsIHRoZXNlIGNoYXJhY3RlcnMgYXJlIGxpdGVyYWxzLFxyXG4gKiBhbmQgbG9zZSB0aGVpciBzcGVjaWFsIE1hcmtkb3duIG1lYW5pbmdzLlxyXG4gKi9cclxuc2hvd2Rvd24uc3ViUGFyc2VyKCdlbmNvZGVDb2RlJywgZnVuY3Rpb24gKHRleHQpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIC8vIEVuY29kZSBhbGwgYW1wZXJzYW5kczsgSFRNTCBlbnRpdGllcyBhcmUgbm90XHJcbiAgLy8gZW50aXRpZXMgd2l0aGluIGEgTWFya2Rvd24gY29kZSBzcGFuLlxyXG4gIHRleHQgPSB0ZXh0LnJlcGxhY2UoLyYvZywgJyZhbXA7Jyk7XHJcblxyXG4gIC8vIERvIHRoZSBhbmdsZSBicmFja2V0IHNvbmcgYW5kIGRhbmNlOlxyXG4gIHRleHQgPSB0ZXh0LnJlcGxhY2UoLzwvZywgJyZsdDsnKTtcclxuICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC8+L2csICcmZ3Q7Jyk7XHJcblxyXG4gIC8vIE5vdywgZXNjYXBlIGNoYXJhY3RlcnMgdGhhdCBhcmUgbWFnaWMgaW4gTWFya2Rvd246XHJcbiAgdGV4dCA9IHNob3dkb3duLmhlbHBlci5lc2NhcGVDaGFyYWN0ZXJzKHRleHQsICcqX3t9W11cXFxcJywgZmFsc2UpO1xyXG5cclxuICAvLyBqaiB0aGUgbGluZSBhYm92ZSBicmVha3MgdGhpczpcclxuICAvLy0tLVxyXG4gIC8vKiBJdGVtXHJcbiAgLy8gICAxLiBTdWJpdGVtXHJcbiAgLy8gICAgICAgICAgICBzcGVjaWFsIGNoYXI6ICpcclxuICAvLyAtLS1cclxuXHJcbiAgcmV0dXJuIHRleHQ7XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqICBJbnB1dDogYW4gZW1haWwgYWRkcmVzcywgZS5nLiBcImZvb0BleGFtcGxlLmNvbVwiXHJcbiAqXHJcbiAqICBPdXRwdXQ6IHRoZSBlbWFpbCBhZGRyZXNzIGFzIGEgbWFpbHRvIGxpbmssIHdpdGggZWFjaCBjaGFyYWN0ZXJcclxuICogICAgb2YgdGhlIGFkZHJlc3MgZW5jb2RlZCBhcyBlaXRoZXIgYSBkZWNpbWFsIG9yIGhleCBlbnRpdHksIGluXHJcbiAqICAgIHRoZSBob3BlcyBvZiBmb2lsaW5nIG1vc3QgYWRkcmVzcyBoYXJ2ZXN0aW5nIHNwYW0gYm90cy4gRS5nLjpcclxuICpcclxuICogICAgPGEgaHJlZj1cIiYjeDZEOyYjOTc7JiMxMDU7JiMxMDg7JiN4NzQ7JiMxMTE7OiYjMTAyOyYjMTExOyYjMTExOyYjNjQ7JiMxMDE7XHJcbiAqICAgICAgIHgmI3g2MTsmIzEwOTsmI3g3MDsmIzEwODsmI3g2NTsmI3gyRTsmIzk5OyYjMTExOyYjMTA5O1wiPiYjMTAyOyYjMTExOyYjMTExO1xyXG4gKiAgICAgICAmIzY0OyYjMTAxO3gmI3g2MTsmIzEwOTsmI3g3MDsmIzEwODsmI3g2NTsmI3gyRTsmIzk5OyYjMTExOyYjMTA5OzwvYT5cclxuICpcclxuICogIEJhc2VkIG9uIGEgZmlsdGVyIGJ5IE1hdHRoZXcgV2lja2xpbmUsIHBvc3RlZCB0byB0aGUgQkJFZGl0LVRhbGtcclxuICogIG1haWxpbmcgbGlzdDogPGh0dHA6Ly90aW55dXJsLmNvbS95dTd1ZT5cclxuICpcclxuICovXHJcbnNob3dkb3duLnN1YlBhcnNlcignZW5jb2RlRW1haWxBZGRyZXNzJywgZnVuY3Rpb24gKGFkZHIpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIHZhciBlbmNvZGUgPSBbXHJcbiAgICBmdW5jdGlvbiAoY2gpIHtcclxuICAgICAgcmV0dXJuICcmIycgKyBjaC5jaGFyQ29kZUF0KDApICsgJzsnO1xyXG4gICAgfSxcclxuICAgIGZ1bmN0aW9uIChjaCkge1xyXG4gICAgICByZXR1cm4gJyYjeCcgKyBjaC5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSArICc7JztcclxuICAgIH0sXHJcbiAgICBmdW5jdGlvbiAoY2gpIHtcclxuICAgICAgcmV0dXJuIGNoO1xyXG4gICAgfVxyXG4gIF07XHJcblxyXG4gIGFkZHIgPSAnbWFpbHRvOicgKyBhZGRyO1xyXG5cclxuICBhZGRyID0gYWRkci5yZXBsYWNlKC8uL2csIGZ1bmN0aW9uIChjaCkge1xyXG4gICAgaWYgKGNoID09PSAnQCcpIHtcclxuICAgICAgLy8gdGhpcyAqbXVzdCogYmUgZW5jb2RlZC4gSSBpbnNpc3QuXHJcbiAgICAgIGNoID0gZW5jb2RlW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDIpXShjaCk7XHJcbiAgICB9IGVsc2UgaWYgKGNoICE9PSAnOicpIHtcclxuICAgICAgLy8gbGVhdmUgJzonIGFsb25lICh0byBzcG90IG1haWx0bzogbGF0ZXIpXHJcbiAgICAgIHZhciByID0gTWF0aC5yYW5kb20oKTtcclxuICAgICAgLy8gcm91Z2hseSAxMCUgcmF3LCA0NSUgaGV4LCA0NSUgZGVjXHJcbiAgICAgIGNoID0gKFxyXG4gICAgICAgIHIgPiAwLjkgPyBlbmNvZGVbMl0oY2gpIDogciA+IDAuNDUgPyBlbmNvZGVbMV0oY2gpIDogZW5jb2RlWzBdKGNoKVxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNoO1xyXG4gIH0pO1xyXG5cclxuICBhZGRyID0gJzxhIGhyZWY9XCInICsgYWRkciArICdcIj4nICsgYWRkciArICc8L2E+JztcclxuICBhZGRyID0gYWRkci5yZXBsYWNlKC9cIj4uKzovZywgJ1wiPicpOyAvLyBzdHJpcCB0aGUgbWFpbHRvOiBmcm9tIHRoZSB2aXNpYmxlIHBhcnRcclxuXHJcbiAgcmV0dXJuIGFkZHI7XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIFdpdGhpbiB0YWdzIC0tIG1lYW5pbmcgYmV0d2VlbiA8IGFuZCA+IC0tIGVuY29kZSBbXFwgYCAqIF9dIHNvIHRoZXlcclxuICogZG9uJ3QgY29uZmxpY3Qgd2l0aCB0aGVpciB1c2UgaW4gTWFya2Rvd24gZm9yIGNvZGUsIGl0YWxpY3MgYW5kIHN0cm9uZy5cclxuICovXHJcbnNob3dkb3duLnN1YlBhcnNlcignZXNjYXBlU3BlY2lhbENoYXJzV2l0aGluVGFnQXR0cmlidXRlcycsIGZ1bmN0aW9uICh0ZXh0KSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAvLyBCdWlsZCBhIHJlZ2V4IHRvIGZpbmQgSFRNTCB0YWdzIGFuZCBjb21tZW50cy4gIFNlZSBGcmllZGwnc1xyXG4gIC8vIFwiTWFzdGVyaW5nIFJlZ3VsYXIgRXhwcmVzc2lvbnNcIiwgMm5kIEVkLiwgcHAuIDIwMC0yMDEuXHJcbiAgdmFyIHJlZ2V4ID0gLyg8W2EtelxcLyEkXShcIlteXCJdKlwifCdbXiddKid8W14nXCI+XSkqPnw8ISgtLS4qPy0tXFxzKikrPikvZ2k7XHJcblxyXG4gIHRleHQgPSB0ZXh0LnJlcGxhY2UocmVnZXgsIGZ1bmN0aW9uICh3aG9sZU1hdGNoKSB7XHJcbiAgICB2YXIgdGFnID0gd2hvbGVNYXRjaC5yZXBsYWNlKC8oLik8XFwvP2NvZGU+KD89LikvZywgJyQxYCcpO1xyXG4gICAgdGFnID0gc2hvd2Rvd24uaGVscGVyLmVzY2FwZUNoYXJhY3RlcnModGFnLCAnXFxcXGAqXycsIGZhbHNlKTtcclxuICAgIHJldHVybiB0YWc7XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiB0ZXh0O1xyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBIYW5kbGUgZ2l0aHViIGNvZGVibG9ja3MgcHJpb3IgdG8gcnVubmluZyBIYXNoSFRNTCBzbyB0aGF0XHJcbiAqIEhUTUwgY29udGFpbmVkIHdpdGhpbiB0aGUgY29kZWJsb2NrIGdldHMgZXNjYXBlZCBwcm9wZXJseVxyXG4gKiBFeGFtcGxlOlxyXG4gKiBgYGBydWJ5XHJcbiAqICAgICBkZWYgaGVsbG9fd29ybGQoeClcclxuICogICAgICAgcHV0cyBcIkhlbGxvLCAje3h9XCJcclxuICogICAgIGVuZFxyXG4gKiBgYGBcclxuICovXHJcbnNob3dkb3duLnN1YlBhcnNlcignZ2l0aHViQ29kZUJsb2NrcycsIGZ1bmN0aW9uICh0ZXh0LCBvcHRpb25zLCBnbG9iYWxzKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAvLyBlYXJseSBleGl0IGlmIG9wdGlvbiBpcyBub3QgZW5hYmxlZFxyXG4gIGlmICghb3B0aW9ucy5naENvZGVCbG9ja3MpIHtcclxuICAgIHJldHVybiB0ZXh0O1xyXG4gIH1cclxuXHJcbiAgdGV4dCA9IGdsb2JhbHMuY29udmVydGVyLl9kaXNwYXRjaCgnZ2l0aHViQ29kZUJsb2Nrcy5iZWZvcmUnLCB0ZXh0LCBvcHRpb25zKTtcclxuXHJcbiAgdGV4dCArPSAnfjAnO1xyXG5cclxuICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC8oPzpefFxcbilgYGAoLiopXFxuKFtcXHNcXFNdKj8pXFxuYGBgL2csIGZ1bmN0aW9uICh3aG9sZU1hdGNoLCBsYW5ndWFnZSwgY29kZWJsb2NrKSB7XHJcbiAgICB2YXIgZW5kID0gKG9wdGlvbnMub21pdEV4dHJhV0xJbkNvZGVCbG9ja3MpID8gJycgOiAnXFxuJztcclxuXHJcbiAgICBjb2RlYmxvY2sgPSBzaG93ZG93bi5zdWJQYXJzZXIoJ2VuY29kZUNvZGUnKShjb2RlYmxvY2spO1xyXG4gICAgY29kZWJsb2NrID0gc2hvd2Rvd24uc3ViUGFyc2VyKCdkZXRhYicpKGNvZGVibG9jayk7XHJcbiAgICBjb2RlYmxvY2sgPSBjb2RlYmxvY2sucmVwbGFjZSgvXlxcbisvZywgJycpOyAvLyB0cmltIGxlYWRpbmcgbmV3bGluZXNcclxuICAgIGNvZGVibG9jayA9IGNvZGVibG9jay5yZXBsYWNlKC9cXG4rJC9nLCAnJyk7IC8vIHRyaW0gdHJhaWxpbmcgd2hpdGVzcGFjZVxyXG5cclxuICAgIGNvZGVibG9jayA9ICc8cHJlPjxjb2RlJyArIChsYW5ndWFnZSA/ICcgY2xhc3M9XCInICsgbGFuZ3VhZ2UgKyAnIGxhbmd1YWdlLScgKyBsYW5ndWFnZSArICdcIicgOiAnJykgKyAnPicgKyBjb2RlYmxvY2sgKyBlbmQgKyAnPC9jb2RlPjwvcHJlPic7XHJcblxyXG4gICAgcmV0dXJuIHNob3dkb3duLnN1YlBhcnNlcignaGFzaEJsb2NrJykoY29kZWJsb2NrLCBvcHRpb25zLCBnbG9iYWxzKTtcclxuICB9KTtcclxuXHJcbiAgLy8gYXR0YWNrbGFiOiBzdHJpcCBzZW50aW5lbFxyXG4gIHRleHQgPSB0ZXh0LnJlcGxhY2UoL34wLywgJycpO1xyXG5cclxuICB0ZXh0ID0gZ2xvYmFscy5jb252ZXJ0ZXIuX2Rpc3BhdGNoKCdnaXRodWJDb2RlQmxvY2tzLmFmdGVyJywgdGV4dCwgb3B0aW9ucyk7XHJcblxyXG4gIHJldHVybiB0ZXh0O1xyXG59KTtcclxuXHJcbnNob3dkb3duLnN1YlBhcnNlcignaGFzaEJsb2NrJywgZnVuY3Rpb24gKHRleHQsIG9wdGlvbnMsIGdsb2JhbHMpIHtcclxuICAndXNlIHN0cmljdCc7XHJcbiAgdGV4dCA9IHRleHQucmVwbGFjZSgvKF5cXG4rfFxcbiskKS9nLCAnJyk7XHJcbiAgcmV0dXJuICdcXG5cXG5+SycgKyAoZ2xvYmFscy5nSHRtbEJsb2Nrcy5wdXNoKHRleHQpIC0gMSkgKyAnS1xcblxcbic7XHJcbn0pO1xyXG5cclxuc2hvd2Rvd24uc3ViUGFyc2VyKCdoYXNoRWxlbWVudCcsIGZ1bmN0aW9uICh0ZXh0LCBvcHRpb25zLCBnbG9iYWxzKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICByZXR1cm4gZnVuY3Rpb24gKHdob2xlTWF0Y2gsIG0xKSB7XHJcbiAgICB2YXIgYmxvY2tUZXh0ID0gbTE7XHJcblxyXG4gICAgLy8gVW5kbyBkb3VibGUgbGluZXNcclxuICAgIGJsb2NrVGV4dCA9IGJsb2NrVGV4dC5yZXBsYWNlKC9cXG5cXG4vZywgJ1xcbicpO1xyXG4gICAgYmxvY2tUZXh0ID0gYmxvY2tUZXh0LnJlcGxhY2UoL15cXG4vLCAnJyk7XHJcblxyXG4gICAgLy8gc3RyaXAgdHJhaWxpbmcgYmxhbmsgbGluZXNcclxuICAgIGJsb2NrVGV4dCA9IGJsb2NrVGV4dC5yZXBsYWNlKC9cXG4rJC9nLCAnJyk7XHJcblxyXG4gICAgLy8gUmVwbGFjZSB0aGUgZWxlbWVudCB0ZXh0IHdpdGggYSBtYXJrZXIgKFwifkt4S1wiIHdoZXJlIHggaXMgaXRzIGtleSlcclxuICAgIGJsb2NrVGV4dCA9ICdcXG5cXG5+SycgKyAoZ2xvYmFscy5nSHRtbEJsb2Nrcy5wdXNoKGJsb2NrVGV4dCkgLSAxKSArICdLXFxuXFxuJztcclxuXHJcbiAgICByZXR1cm4gYmxvY2tUZXh0O1xyXG4gIH07XHJcbn0pO1xyXG5cclxuc2hvd2Rvd24uc3ViUGFyc2VyKCdoYXNoSFRNTEJsb2NrcycsIGZ1bmN0aW9uICh0ZXh0LCBvcHRpb25zLCBnbG9iYWxzKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAvLyBhdHRhY2tsYWI6IERvdWJsZSB1cCBibGFuayBsaW5lcyB0byByZWR1Y2UgbG9va2Fyb3VuZFxyXG4gIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcbi9nLCAnXFxuXFxuJyk7XHJcblxyXG4gIC8vIEhhc2hpZnkgSFRNTCBibG9ja3M6XHJcbiAgLy8gV2Ugb25seSB3YW50IHRvIGRvIHRoaXMgZm9yIGJsb2NrLWxldmVsIEhUTUwgdGFncywgc3VjaCBhcyBoZWFkZXJzLFxyXG4gIC8vIGxpc3RzLCBhbmQgdGFibGVzLiBUaGF0J3MgYmVjYXVzZSB3ZSBzdGlsbCB3YW50IHRvIHdyYXAgPHA+cyBhcm91bmRcclxuICAvLyBcInBhcmFncmFwaHNcIiB0aGF0IGFyZSB3cmFwcGVkIGluIG5vbi1ibG9jay1sZXZlbCB0YWdzLCBzdWNoIGFzIGFuY2hvcnMsXHJcbiAgLy8gcGhyYXNlIGVtcGhhc2lzLCBhbmQgc3BhbnMuIFRoZSBsaXN0IG9mIHRhZ3Mgd2UncmUgbG9va2luZyBmb3IgaXNcclxuICAvLyBoYXJkLWNvZGVkOlxyXG4gIC8vdmFyIGJsb2NrX3RhZ3NfYSA9XHJcbiAgLy8gJ3B8ZGl2fGhbMS02XXxibG9ja3F1b3RlfHByZXx0YWJsZXxkbHxvbHx1bHxzY3JpcHR8bm9zY3JpcHR8Zm9ybXxmaWVsZHNldHxpZnJhbWV8bWF0aHxpbnN8ZGVsfHN0eWxlfHNlY3Rpb258aGVhZGVyfGZvb3RlcnxuYXZ8YXJ0aWNsZXxhc2lkZSc7XHJcbiAgLy8gdmFyIGJsb2NrX3RhZ3NfYiA9XHJcbiAgLy8gJ3B8ZGl2fGhbMS02XXxibG9ja3F1b3RlfHByZXx0YWJsZXxkbHxvbHx1bHxzY3JpcHR8bm9zY3JpcHR8Zm9ybXxmaWVsZHNldHxpZnJhbWV8bWF0aHxzdHlsZXxzZWN0aW9ufGhlYWRlcnxmb290ZXJ8bmF2fGFydGljbGV8YXNpZGUnO1xyXG5cclxuICAvLyBGaXJzdCwgbG9vayBmb3IgbmVzdGVkIGJsb2NrcywgZS5nLjpcclxuICAvLyAgIDxkaXY+XHJcbiAgLy8gICAgIDxkaXY+XHJcbiAgLy8gICAgIHRhZ3MgZm9yIGlubmVyIGJsb2NrIG11c3QgYmUgaW5kZW50ZWQuXHJcbiAgLy8gICAgIDwvZGl2PlxyXG4gIC8vICAgPC9kaXY+XHJcbiAgLy9cclxuICAvLyBUaGUgb3V0ZXJtb3N0IHRhZ3MgbXVzdCBzdGFydCBhdCB0aGUgbGVmdCBtYXJnaW4gZm9yIHRoaXMgdG8gbWF0Y2gsIGFuZFxyXG4gIC8vIHRoZSBpbm5lciBuZXN0ZWQgZGl2cyBtdXN0IGJlIGluZGVudGVkLlxyXG4gIC8vIFdlIG5lZWQgdG8gZG8gdGhpcyBiZWZvcmUgdGhlIG5leHQsIG1vcmUgbGliZXJhbCBtYXRjaCwgYmVjYXVzZSB0aGUgbmV4dFxyXG4gIC8vIG1hdGNoIHdpbGwgc3RhcnQgYXQgdGhlIGZpcnN0IGA8ZGl2PmAgYW5kIHN0b3AgYXQgdGhlIGZpcnN0IGA8L2Rpdj5gLlxyXG5cclxuICAvLyBhdHRhY2tsYWI6IFRoaXMgcmVnZXggY2FuIGJlIGV4cGVuc2l2ZSB3aGVuIGl0IGZhaWxzLlxyXG4gIC8qXHJcbiAgIHZhciB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cclxuICAgKFx0XHRcdFx0XHRcdC8vIHNhdmUgaW4gJDFcclxuICAgXlx0XHRcdFx0XHQvLyBzdGFydCBvZiBsaW5lICAod2l0aCAvbSlcclxuICAgPCgkYmxvY2tfdGFnc19hKVx0Ly8gc3RhcnQgdGFnID0gJDJcclxuICAgXFxiXHRcdFx0XHRcdC8vIHdvcmQgYnJlYWtcclxuICAgLy8gYXR0YWNrbGFiOiBoYWNrIGFyb3VuZCBraHRtbC9wY3JlIGJ1Zy4uLlxyXG4gICBbXlxccl0qP1xcblx0XHRcdC8vIGFueSBudW1iZXIgb2YgbGluZXMsIG1pbmltYWxseSBtYXRjaGluZ1xyXG4gICA8L1xcMj5cdFx0XHRcdC8vIHRoZSBtYXRjaGluZyBlbmQgdGFnXHJcbiAgIFsgXFx0XSpcdFx0XHRcdC8vIHRyYWlsaW5nIHNwYWNlcy90YWJzXHJcbiAgICg/PVxcbispXHRcdFx0XHQvLyBmb2xsb3dlZCBieSBhIG5ld2xpbmVcclxuICAgKVx0XHRcdFx0XHRcdC8vIGF0dGFja2xhYjogdGhlcmUgYXJlIHNlbnRpbmVsIG5ld2xpbmVzIGF0IGVuZCBvZiBkb2N1bWVudFxyXG4gICAvZ20sZnVuY3Rpb24oKXsuLi59fTtcclxuICAgKi9cclxuICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9eKDwocHxkaXZ8aFsxLTZdfGJsb2NrcXVvdGV8cHJlfHRhYmxlfGRsfG9sfHVsfHNjcmlwdHxub3NjcmlwdHxmb3JtfGZpZWxkc2V0fGlmcmFtZXxtYXRofGluc3xkZWwpXFxiW15cXHJdKj9cXG48XFwvXFwyPlsgXFx0XSooPz1cXG4rKSkvZ20sXHJcbiAgICAgICAgICAgICAgICAgICAgICBzaG93ZG93bi5zdWJQYXJzZXIoJ2hhc2hFbGVtZW50JykodGV4dCwgb3B0aW9ucywgZ2xvYmFscykpO1xyXG5cclxuICAvL1xyXG4gIC8vIE5vdyBtYXRjaCBtb3JlIGxpYmVyYWxseSwgc2ltcGx5IGZyb20gYFxcbjx0YWc+YCB0byBgPC90YWc+XFxuYFxyXG4gIC8vXHJcblxyXG4gIC8qXHJcbiAgIHZhciB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cclxuICAgKFx0XHRcdFx0XHRcdC8vIHNhdmUgaW4gJDFcclxuICAgXlx0XHRcdFx0XHQvLyBzdGFydCBvZiBsaW5lICAod2l0aCAvbSlcclxuICAgPCgkYmxvY2tfdGFnc19iKVx0Ly8gc3RhcnQgdGFnID0gJDJcclxuICAgXFxiXHRcdFx0XHRcdC8vIHdvcmQgYnJlYWtcclxuICAgLy8gYXR0YWNrbGFiOiBoYWNrIGFyb3VuZCBraHRtbC9wY3JlIGJ1Zy4uLlxyXG4gICBbXlxccl0qP1x0XHRcdFx0Ly8gYW55IG51bWJlciBvZiBsaW5lcywgbWluaW1hbGx5IG1hdGNoaW5nXHJcbiAgIDwvXFwyPlx0XHRcdFx0Ly8gdGhlIG1hdGNoaW5nIGVuZCB0YWdcclxuICAgWyBcXHRdKlx0XHRcdFx0Ly8gdHJhaWxpbmcgc3BhY2VzL3RhYnNcclxuICAgKD89XFxuKylcdFx0XHRcdC8vIGZvbGxvd2VkIGJ5IGEgbmV3bGluZVxyXG4gICApXHRcdFx0XHRcdFx0Ly8gYXR0YWNrbGFiOiB0aGVyZSBhcmUgc2VudGluZWwgbmV3bGluZXMgYXQgZW5kIG9mIGRvY3VtZW50XHJcbiAgIC9nbSxmdW5jdGlvbigpey4uLn19O1xyXG4gICAqL1xyXG4gIHRleHQgPSB0ZXh0LnJlcGxhY2UoL14oPChwfGRpdnxoWzEtNl18YmxvY2txdW90ZXxwcmV8dGFibGV8ZGx8b2x8dWx8c2NyaXB0fG5vc2NyaXB0fGZvcm18ZmllbGRzZXR8aWZyYW1lfG1hdGh8c3R5bGV8c2VjdGlvbnxoZWFkZXJ8Zm9vdGVyfG5hdnxhcnRpY2xlfGFzaWRlfGFkZHJlc3N8YXVkaW98Y2FudmFzfGZpZ3VyZXxoZ3JvdXB8b3V0cHV0fHZpZGVvKVxcYlteXFxyXSo/PFxcL1xcMj5bIFxcdF0qKD89XFxuKylcXG4pL2dtLFxyXG4gICAgICAgICAgICAgICAgICAgICAgc2hvd2Rvd24uc3ViUGFyc2VyKCdoYXNoRWxlbWVudCcpKHRleHQsIG9wdGlvbnMsIGdsb2JhbHMpKTtcclxuXHJcbiAgLy8gU3BlY2lhbCBjYXNlIGp1c3QgZm9yIDxociAvPi4gSXQgd2FzIGVhc2llciB0byBtYWtlIGEgc3BlY2lhbCBjYXNlIHRoYW5cclxuICAvLyB0byBtYWtlIHRoZSBvdGhlciByZWdleCBtb3JlIGNvbXBsaWNhdGVkLlxyXG5cclxuICAvKlxyXG4gICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cclxuICAgKFx0XHRcdFx0XHRcdC8vIHNhdmUgaW4gJDFcclxuICAgXFxuXFxuXHRcdFx0XHQvLyBTdGFydGluZyBhZnRlciBhIGJsYW5rIGxpbmVcclxuICAgWyBdezAsM31cclxuICAgKDwoaHIpXHRcdFx0XHQvLyBzdGFydCB0YWcgPSAkMlxyXG4gICBcXGJcdFx0XHRcdFx0Ly8gd29yZCBicmVha1xyXG4gICAoW148Pl0pKj9cdFx0XHQvL1xyXG4gICBcXC8/PilcdFx0XHRcdC8vIHRoZSBtYXRjaGluZyBlbmQgdGFnXHJcbiAgIFsgXFx0XSpcclxuICAgKD89XFxuezIsfSlcdFx0XHQvLyBmb2xsb3dlZCBieSBhIGJsYW5rIGxpbmVcclxuICAgKVxyXG4gICAvZyxzaG93ZG93bi5zdWJQYXJzZXIoJ2hhc2hFbGVtZW50JykodGV4dCwgb3B0aW9ucywgZ2xvYmFscykpO1xyXG4gICAqL1xyXG4gIHRleHQgPSB0ZXh0LnJlcGxhY2UoLyhcXG5bIF17MCwzfSg8KGhyKVxcYihbXjw+XSkqP1xcLz8+KVsgXFx0XSooPz1cXG57Mix9KSkvZyxcclxuICAgICAgICAgICAgICAgICAgICAgIHNob3dkb3duLnN1YlBhcnNlcignaGFzaEVsZW1lbnQnKSh0ZXh0LCBvcHRpb25zLCBnbG9iYWxzKSk7XHJcblxyXG4gIC8vIFNwZWNpYWwgY2FzZSBmb3Igc3RhbmRhbG9uZSBIVE1MIGNvbW1lbnRzOlxyXG5cclxuICAvKlxyXG4gICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cclxuICAgKFx0XHRcdFx0XHRcdC8vIHNhdmUgaW4gJDFcclxuICAgXFxuXFxuXHRcdFx0XHQvLyBTdGFydGluZyBhZnRlciBhIGJsYW5rIGxpbmVcclxuICAgWyBdezAsM31cdFx0XHQvLyBhdHRhY2tsYWI6IGdfdGFiX3dpZHRoIC0gMVxyXG4gICA8IVxyXG4gICAoLS1bXlxccl0qPy0tXFxzKikrXHJcbiAgID5cclxuICAgWyBcXHRdKlxyXG4gICAoPz1cXG57Mix9KVx0XHRcdC8vIGZvbGxvd2VkIGJ5IGEgYmxhbmsgbGluZVxyXG4gICApXHJcbiAgIC9nLHNob3dkb3duLnN1YlBhcnNlcignaGFzaEVsZW1lbnQnKSh0ZXh0LCBvcHRpb25zLCBnbG9iYWxzKSk7XHJcbiAgICovXHJcbiAgdGV4dCA9IHRleHQucmVwbGFjZSgvKFxcblxcblsgXXswLDN9PCEoLS1bXlxccl0qPy0tXFxzKikrPlsgXFx0XSooPz1cXG57Mix9KSkvZyxcclxuICAgICAgICAgICAgICAgICAgICAgIHNob3dkb3duLnN1YlBhcnNlcignaGFzaEVsZW1lbnQnKSh0ZXh0LCBvcHRpb25zLCBnbG9iYWxzKSk7XHJcblxyXG4gIC8vIFBIUCBhbmQgQVNQLXN0eWxlIHByb2Nlc3NvciBpbnN0cnVjdGlvbnMgKDw/Li4uPz4gYW5kIDwlLi4uJT4pXHJcblxyXG4gIC8qXHJcbiAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xyXG4gICAoPzpcclxuICAgXFxuXFxuXHRcdFx0XHQvLyBTdGFydGluZyBhZnRlciBhIGJsYW5rIGxpbmVcclxuICAgKVxyXG4gICAoXHRcdFx0XHRcdFx0Ly8gc2F2ZSBpbiAkMVxyXG4gICBbIF17MCwzfVx0XHRcdC8vIGF0dGFja2xhYjogZ190YWJfd2lkdGggLSAxXHJcbiAgICg/OlxyXG4gICA8KFs/JV0pXHRcdFx0Ly8gJDJcclxuICAgW15cXHJdKj9cclxuICAgXFwyPlxyXG4gICApXHJcbiAgIFsgXFx0XSpcclxuICAgKD89XFxuezIsfSlcdFx0XHQvLyBmb2xsb3dlZCBieSBhIGJsYW5rIGxpbmVcclxuICAgKVxyXG4gICAvZyxzaG93ZG93bi5zdWJQYXJzZXIoJ2hhc2hFbGVtZW50JykodGV4dCwgb3B0aW9ucywgZ2xvYmFscykpO1xyXG4gICAqL1xyXG4gIHRleHQgPSB0ZXh0LnJlcGxhY2UoLyg/OlxcblxcbikoWyBdezAsM30oPzo8KFs/JV0pW15cXHJdKj9cXDI+KVsgXFx0XSooPz1cXG57Mix9KSkvZyxcclxuICAgICAgICAgICAgICAgICAgICAgIHNob3dkb3duLnN1YlBhcnNlcignaGFzaEVsZW1lbnQnKSh0ZXh0LCBvcHRpb25zLCBnbG9iYWxzKSk7XHJcblxyXG4gIC8vIGF0dGFja2xhYjogVW5kbyBkb3VibGUgbGluZXMgKHNlZSBjb21tZW50IGF0IHRvcCBvZiB0aGlzIGZ1bmN0aW9uKVxyXG4gIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcblxcbi9nLCAnXFxuJyk7XHJcbiAgcmV0dXJuIHRleHQ7XHJcblxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBIYXNoIHNwYW4gZWxlbWVudHMgdGhhdCBzaG91bGQgbm90IGJlIHBhcnNlZCBhcyBtYXJrZG93blxyXG4gKi9cclxuc2hvd2Rvd24uc3ViUGFyc2VyKCdoYXNoSFRNTFNwYW5zJywgZnVuY3Rpb24gKHRleHQsIGNvbmZpZywgZ2xvYmFscykge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgdmFyIG1hdGNoZXMgPSBzaG93ZG93bi5oZWxwZXIubWF0Y2hSZWN1cnNpdmVSZWdFeHAodGV4dCwgJzxjb2RlXFxcXGJbXj5dKj4nLCAnPC9jb2RlPicsICdnaScpO1xyXG5cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdGNoZXMubGVuZ3RoOyArK2kpIHtcclxuICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UobWF0Y2hlc1tpXVswXSwgJ35MJyArIChnbG9iYWxzLmdIdG1sU3BhbnMucHVzaChtYXRjaGVzW2ldWzBdKSAtIDEpICsgJ0wnKTtcclxuICB9XHJcbiAgcmV0dXJuIHRleHQ7XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIFVuaGFzaCBIVE1MIHNwYW5zXHJcbiAqL1xyXG5zaG93ZG93bi5zdWJQYXJzZXIoJ3VuaGFzaEhUTUxTcGFucycsIGZ1bmN0aW9uICh0ZXh0LCBjb25maWcsIGdsb2JhbHMpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZ2xvYmFscy5nSHRtbFNwYW5zLmxlbmd0aDsgKytpKSB7XHJcbiAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKCd+TCcgKyBpICsgJ0wnLCBnbG9iYWxzLmdIdG1sU3BhbnNbaV0pO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRleHQ7XHJcbn0pO1xyXG5cclxuc2hvd2Rvd24uc3ViUGFyc2VyKCdoZWFkZXJzJywgZnVuY3Rpb24gKHRleHQsIG9wdGlvbnMsIGdsb2JhbHMpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIHRleHQgPSBnbG9iYWxzLmNvbnZlcnRlci5fZGlzcGF0Y2goJ2hlYWRlcnMuYmVmb3JlJywgdGV4dCwgb3B0aW9ucyk7XHJcblxyXG4gIHZhciBwcmVmaXhIZWFkZXIgPSBvcHRpb25zLnByZWZpeEhlYWRlcklkLFxyXG4gICAgICBoZWFkZXJMZXZlbFN0YXJ0ID0gKGlzTmFOKHBhcnNlSW50KG9wdGlvbnMuaGVhZGVyTGV2ZWxTdGFydCkpKSA/IDEgOiBwYXJzZUludChvcHRpb25zLmhlYWRlckxldmVsU3RhcnQpLFxyXG5cclxuICAvLyBTZXQgdGV4dC1zdHlsZSBoZWFkZXJzOlxyXG4gIC8vXHRIZWFkZXIgMVxyXG4gIC8vXHQ9PT09PT09PVxyXG4gIC8vXHJcbiAgLy9cdEhlYWRlciAyXHJcbiAgLy9cdC0tLS0tLS0tXHJcbiAgLy9cclxuICAgICAgc2V0ZXh0UmVnZXhIMSA9IChvcHRpb25zLnNtb290aExpdmVQcmV2aWV3KSA/IC9eKC4rKVsgXFx0XSpcXG49ezIsfVsgXFx0XSpcXG4rL2dtIDogL14oLispWyBcXHRdKlxcbj0rWyBcXHRdKlxcbisvZ20sXHJcbiAgICAgIHNldGV4dFJlZ2V4SDIgPSAob3B0aW9ucy5zbW9vdGhMaXZlUHJldmlldykgPyAvXiguKylbIFxcdF0qXFxuLXsyLH1bIFxcdF0qXFxuKy9nbSA6IC9eKC4rKVsgXFx0XSpcXG4tK1sgXFx0XSpcXG4rL2dtO1xyXG5cclxuICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHNldGV4dFJlZ2V4SDEsIGZ1bmN0aW9uICh3aG9sZU1hdGNoLCBtMSkge1xyXG5cclxuICAgIHZhciBzcGFuR2FtdXQgPSBzaG93ZG93bi5zdWJQYXJzZXIoJ3NwYW5HYW11dCcpKG0xLCBvcHRpb25zLCBnbG9iYWxzKSxcclxuICAgICAgICBoSUQgPSAob3B0aW9ucy5ub0hlYWRlcklkKSA/ICcnIDogJyBpZD1cIicgKyBoZWFkZXJJZChtMSkgKyAnXCInLFxyXG4gICAgICAgIGhMZXZlbCA9IGhlYWRlckxldmVsU3RhcnQsXHJcbiAgICAgICAgaGFzaEJsb2NrID0gJzxoJyArIGhMZXZlbCArIGhJRCArICc+JyArIHNwYW5HYW11dCArICc8L2gnICsgaExldmVsICsgJz4nO1xyXG4gICAgcmV0dXJuIHNob3dkb3duLnN1YlBhcnNlcignaGFzaEJsb2NrJykoaGFzaEJsb2NrLCBvcHRpb25zLCBnbG9iYWxzKTtcclxuICB9KTtcclxuXHJcbiAgdGV4dCA9IHRleHQucmVwbGFjZShzZXRleHRSZWdleEgyLCBmdW5jdGlvbiAobWF0Y2hGb3VuZCwgbTEpIHtcclxuICAgIHZhciBzcGFuR2FtdXQgPSBzaG93ZG93bi5zdWJQYXJzZXIoJ3NwYW5HYW11dCcpKG0xLCBvcHRpb25zLCBnbG9iYWxzKSxcclxuICAgICAgICBoSUQgPSAob3B0aW9ucy5ub0hlYWRlcklkKSA/ICcnIDogJyBpZD1cIicgKyBoZWFkZXJJZChtMSkgKyAnXCInLFxyXG4gICAgICAgIGhMZXZlbCA9IGhlYWRlckxldmVsU3RhcnQgKyAxLFxyXG4gICAgICBoYXNoQmxvY2sgPSAnPGgnICsgaExldmVsICsgaElEICsgJz4nICsgc3BhbkdhbXV0ICsgJzwvaCcgKyBoTGV2ZWwgKyAnPic7XHJcbiAgICByZXR1cm4gc2hvd2Rvd24uc3ViUGFyc2VyKCdoYXNoQmxvY2snKShoYXNoQmxvY2ssIG9wdGlvbnMsIGdsb2JhbHMpO1xyXG4gIH0pO1xyXG5cclxuICAvLyBhdHgtc3R5bGUgaGVhZGVyczpcclxuICAvLyAgIyBIZWFkZXIgMVxyXG4gIC8vICAjIyBIZWFkZXIgMlxyXG4gIC8vICAjIyBIZWFkZXIgMiB3aXRoIGNsb3NpbmcgaGFzaGVzICMjXHJcbiAgLy8gIC4uLlxyXG4gIC8vICAjIyMjIyMgSGVhZGVyIDZcclxuICAvL1xyXG4gIHRleHQgPSB0ZXh0LnJlcGxhY2UoL14oI3sxLDZ9KVsgXFx0XSooLis/KVsgXFx0XSojKlxcbisvZ20sIGZ1bmN0aW9uICh3aG9sZU1hdGNoLCBtMSwgbTIpIHtcclxuICAgIHZhciBzcGFuID0gc2hvd2Rvd24uc3ViUGFyc2VyKCdzcGFuR2FtdXQnKShtMiwgb3B0aW9ucywgZ2xvYmFscyksXHJcbiAgICAgICAgaElEID0gKG9wdGlvbnMubm9IZWFkZXJJZCkgPyAnJyA6ICcgaWQ9XCInICsgaGVhZGVySWQobTIpICsgJ1wiJyxcclxuICAgICAgICBoTGV2ZWwgPSBoZWFkZXJMZXZlbFN0YXJ0IC0gMSArIG0xLmxlbmd0aCxcclxuICAgICAgICBoZWFkZXIgPSAnPGgnICsgaExldmVsICsgaElEICsgJz4nICsgc3BhbiArICc8L2gnICsgaExldmVsICsgJz4nO1xyXG5cclxuICAgIHJldHVybiBzaG93ZG93bi5zdWJQYXJzZXIoJ2hhc2hCbG9jaycpKGhlYWRlciwgb3B0aW9ucywgZ2xvYmFscyk7XHJcbiAgfSk7XHJcblxyXG4gIGZ1bmN0aW9uIGhlYWRlcklkKG0pIHtcclxuICAgIHZhciB0aXRsZSwgZXNjYXBlZElkID0gbS5yZXBsYWNlKC9bXlxcd10vZywgJycpLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgaWYgKGdsb2JhbHMuaGFzaExpbmtDb3VudHNbZXNjYXBlZElkXSkge1xyXG4gICAgICB0aXRsZSA9IGVzY2FwZWRJZCArICctJyArIChnbG9iYWxzLmhhc2hMaW5rQ291bnRzW2VzY2FwZWRJZF0rKyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aXRsZSA9IGVzY2FwZWRJZDtcclxuICAgICAgZ2xvYmFscy5oYXNoTGlua0NvdW50c1tlc2NhcGVkSWRdID0gMTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQcmVmaXggaWQgdG8gcHJldmVudCBjYXVzaW5nIGluYWR2ZXJ0ZW50IHByZS1leGlzdGluZyBzdHlsZSBtYXRjaGVzLlxyXG4gICAgaWYgKHByZWZpeEhlYWRlciA9PT0gdHJ1ZSkge1xyXG4gICAgICBwcmVmaXhIZWFkZXIgPSAnc2VjdGlvbic7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNob3dkb3duLmhlbHBlci5pc1N0cmluZyhwcmVmaXhIZWFkZXIpKSB7XHJcbiAgICAgIHJldHVybiBwcmVmaXhIZWFkZXIgKyB0aXRsZTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aXRsZTtcclxuICB9XHJcblxyXG4gIHRleHQgPSBnbG9iYWxzLmNvbnZlcnRlci5fZGlzcGF0Y2goJ2hlYWRlcnMuYWZ0ZXInLCB0ZXh0LCBvcHRpb25zKTtcclxuICByZXR1cm4gdGV4dDtcclxufSk7XHJcblxyXG4vKipcclxuICogVHVybiBNYXJrZG93biBpbWFnZSBzaG9ydGN1dHMgaW50byA8aW1nPiB0YWdzLlxyXG4gKi9cclxuc2hvd2Rvd24uc3ViUGFyc2VyKCdpbWFnZXMnLCBmdW5jdGlvbiAodGV4dCwgb3B0aW9ucywgZ2xvYmFscykge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgdGV4dCA9IGdsb2JhbHMuY29udmVydGVyLl9kaXNwYXRjaCgnaW1hZ2VzLmJlZm9yZScsIHRleHQsIG9wdGlvbnMpO1xyXG5cclxuICB2YXIgaW5saW5lUmVnRXhwICAgID0gLyFcXFsoLio/KV1cXHM/XFwoWyBcXHRdKigpPD8oXFxTKz8pPj8oPzogPShbKlxcZF0rW0EtWmEteiVdezAsNH0peChbKlxcZF0rW0EtWmEteiVdezAsNH0pKT9bIFxcdF0qKD86KFsnXCJdKSguKj8pXFw2WyBcXHRdKik/XFwpL2csXHJcbiAgICAgIHJlZmVyZW5jZVJlZ0V4cCA9IC8hXFxbKC4qPyldWyBdPyg/OlxcblsgXSopP1xcWyguKj8pXSgpKCkoKSgpKCkvZztcclxuXHJcbiAgZnVuY3Rpb24gd3JpdGVJbWFnZVRhZyAod2hvbGVNYXRjaCwgYWx0VGV4dCwgbGlua0lkLCB1cmwsIHdpZHRoLCBoZWlnaHQsIG01LCB0aXRsZSkge1xyXG5cclxuICAgIHZhciBnVXJscyAgID0gZ2xvYmFscy5nVXJscyxcclxuICAgICAgICBnVGl0bGVzID0gZ2xvYmFscy5nVGl0bGVzLFxyXG4gICAgICAgIGdEaW1zICAgPSBnbG9iYWxzLmdEaW1lbnNpb25zO1xyXG5cclxuICAgIGxpbmtJZCA9IGxpbmtJZC50b0xvd2VyQ2FzZSgpO1xyXG5cclxuICAgIGlmICghdGl0bGUpIHtcclxuICAgICAgdGl0bGUgPSAnJztcclxuICAgIH1cclxuXHJcbiAgICBpZiAodXJsID09PSAnJyB8fCB1cmwgPT09IG51bGwpIHtcclxuICAgICAgaWYgKGxpbmtJZCA9PT0gJycgfHwgbGlua0lkID09PSBudWxsKSB7XHJcbiAgICAgICAgLy8gbG93ZXItY2FzZSBhbmQgdHVybiBlbWJlZGRlZCBuZXdsaW5lcyBpbnRvIHNwYWNlc1xyXG4gICAgICAgIGxpbmtJZCA9IGFsdFRleHQudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8gP1xcbi9nLCAnICcpO1xyXG4gICAgICB9XHJcbiAgICAgIHVybCA9ICcjJyArIGxpbmtJZDtcclxuXHJcbiAgICAgIGlmICghc2hvd2Rvd24uaGVscGVyLmlzVW5kZWZpbmVkKGdVcmxzW2xpbmtJZF0pKSB7XHJcbiAgICAgICAgdXJsID0gZ1VybHNbbGlua0lkXTtcclxuICAgICAgICBpZiAoIXNob3dkb3duLmhlbHBlci5pc1VuZGVmaW5lZChnVGl0bGVzW2xpbmtJZF0pKSB7XHJcbiAgICAgICAgICB0aXRsZSA9IGdUaXRsZXNbbGlua0lkXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFzaG93ZG93bi5oZWxwZXIuaXNVbmRlZmluZWQoZ0RpbXNbbGlua0lkXSkpIHtcclxuICAgICAgICAgIHdpZHRoID0gZ0RpbXNbbGlua0lkXS53aWR0aDtcclxuICAgICAgICAgIGhlaWdodCA9IGdEaW1zW2xpbmtJZF0uaGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gd2hvbGVNYXRjaDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGFsdFRleHQgPSBhbHRUZXh0LnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKTtcclxuICAgIGFsdFRleHQgPSBzaG93ZG93bi5oZWxwZXIuZXNjYXBlQ2hhcmFjdGVycyhhbHRUZXh0LCAnKl8nLCBmYWxzZSk7XHJcbiAgICB1cmwgPSBzaG93ZG93bi5oZWxwZXIuZXNjYXBlQ2hhcmFjdGVycyh1cmwsICcqXycsIGZhbHNlKTtcclxuICAgIHZhciByZXN1bHQgPSAnPGltZyBzcmM9XCInICsgdXJsICsgJ1wiIGFsdD1cIicgKyBhbHRUZXh0ICsgJ1wiJztcclxuXHJcbiAgICBpZiAodGl0bGUpIHtcclxuICAgICAgdGl0bGUgPSB0aXRsZS5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XHJcbiAgICAgIHRpdGxlID0gc2hvd2Rvd24uaGVscGVyLmVzY2FwZUNoYXJhY3RlcnModGl0bGUsICcqXycsIGZhbHNlKTtcclxuICAgICAgcmVzdWx0ICs9ICcgdGl0bGU9XCInICsgdGl0bGUgKyAnXCInO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh3aWR0aCAmJiBoZWlnaHQpIHtcclxuICAgICAgd2lkdGggID0gKHdpZHRoID09PSAnKicpID8gJ2F1dG8nIDogd2lkdGg7XHJcbiAgICAgIGhlaWdodCA9IChoZWlnaHQgPT09ICcqJykgPyAnYXV0bycgOiBoZWlnaHQ7XHJcblxyXG4gICAgICByZXN1bHQgKz0gJyB3aWR0aD1cIicgKyB3aWR0aCArICdcIic7XHJcbiAgICAgIHJlc3VsdCArPSAnIGhlaWdodD1cIicgKyBoZWlnaHQgKyAnXCInO1xyXG4gICAgfVxyXG5cclxuICAgIHJlc3VsdCArPSAnIC8+JztcclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcbiAgLy8gRmlyc3QsIGhhbmRsZSByZWZlcmVuY2Utc3R5bGUgbGFiZWxlZCBpbWFnZXM6ICFbYWx0IHRleHRdW2lkXVxyXG4gIHRleHQgPSB0ZXh0LnJlcGxhY2UocmVmZXJlbmNlUmVnRXhwLCB3cml0ZUltYWdlVGFnKTtcclxuXHJcbiAgLy8gTmV4dCwgaGFuZGxlIGlubGluZSBpbWFnZXM6ICAhW2FsdCB0ZXh0XSh1cmwgPTx3aWR0aD54PGhlaWdodD4gXCJvcHRpb25hbCB0aXRsZVwiKVxyXG4gIHRleHQgPSB0ZXh0LnJlcGxhY2UoaW5saW5lUmVnRXhwLCB3cml0ZUltYWdlVGFnKTtcclxuXHJcbiAgdGV4dCA9IGdsb2JhbHMuY29udmVydGVyLl9kaXNwYXRjaCgnaW1hZ2VzLmFmdGVyJywgdGV4dCwgb3B0aW9ucyk7XHJcbiAgcmV0dXJuIHRleHQ7XHJcbn0pO1xyXG5cclxuc2hvd2Rvd24uc3ViUGFyc2VyKCdpdGFsaWNzQW5kQm9sZCcsIGZ1bmN0aW9uICh0ZXh0LCBvcHRpb25zLCBnbG9iYWxzKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICB0ZXh0ID0gZ2xvYmFscy5jb252ZXJ0ZXIuX2Rpc3BhdGNoKCdpdGFsaWNzQW5kQm9sZC5iZWZvcmUnLCB0ZXh0LCBvcHRpb25zKTtcclxuXHJcbiAgaWYgKG9wdGlvbnMubGl0ZXJhbE1pZFdvcmRVbmRlcnNjb3Jlcykge1xyXG4gICAgLy91bmRlcnNjb3Jlc1xyXG4gICAgLy8gU2luY2Ugd2UgYXJlIGNvbnN1bWluZyBhIFxccyBjaGFyYWN0ZXIsIHdlIG5lZWQgdG8gYWRkIGl0XHJcbiAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC8oXnxcXHN8PnxcXGIpX18oPz1cXFMpKFteXSs/KV9fKD89XFxifDx8XFxzfCQpL2dtLCAnJDE8c3Ryb25nPiQyPC9zdHJvbmc+Jyk7XHJcbiAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC8oXnxcXHN8PnxcXGIpXyg/PVxcUykoW15dKz8pXyg/PVxcYnw8fFxcc3wkKS9nbSwgJyQxPGVtPiQyPC9lbT4nKTtcclxuICAgIC8vYXN0ZXJpc2tzXHJcbiAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC8oXFwqXFwqKSg/PVxcUykoW15cXHJdKj9cXFNbKl0qKVxcMS9nLCAnPHN0cm9uZz4kMjwvc3Ryb25nPicpO1xyXG4gICAgdGV4dCA9IHRleHQucmVwbGFjZSgvKFxcKikoPz1cXFMpKFteXFxyXSo/XFxTKVxcMS9nLCAnPGVtPiQyPC9lbT4nKTtcclxuXHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIDxzdHJvbmc+IG11c3QgZ28gZmlyc3Q6XHJcbiAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC8oXFwqXFwqfF9fKSg/PVxcUykoW15cXHJdKj9cXFNbKl9dKilcXDEvZywgJzxzdHJvbmc+JDI8L3N0cm9uZz4nKTtcclxuICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoLyhcXCp8XykoPz1cXFMpKFteXFxyXSo/XFxTKVxcMS9nLCAnPGVtPiQyPC9lbT4nKTtcclxuICB9XHJcblxyXG4gIHRleHQgPSBnbG9iYWxzLmNvbnZlcnRlci5fZGlzcGF0Y2goJ2l0YWxpY3NBbmRCb2xkLmFmdGVyJywgdGV4dCwgb3B0aW9ucyk7XHJcbiAgcmV0dXJuIHRleHQ7XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEZvcm0gSFRNTCBvcmRlcmVkIChudW1iZXJlZCkgYW5kIHVub3JkZXJlZCAoYnVsbGV0ZWQpIGxpc3RzLlxyXG4gKi9cclxuc2hvd2Rvd24uc3ViUGFyc2VyKCdsaXN0cycsIGZ1bmN0aW9uICh0ZXh0LCBvcHRpb25zLCBnbG9iYWxzKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICB0ZXh0ID0gZ2xvYmFscy5jb252ZXJ0ZXIuX2Rpc3BhdGNoKCdsaXN0cy5iZWZvcmUnLCB0ZXh0LCBvcHRpb25zKTtcclxuICAvKipcclxuICAgKiBQcm9jZXNzIHRoZSBjb250ZW50cyBvZiBhIHNpbmdsZSBvcmRlcmVkIG9yIHVub3JkZXJlZCBsaXN0LCBzcGxpdHRpbmcgaXRcclxuICAgKiBpbnRvIGluZGl2aWR1YWwgbGlzdCBpdGVtcy5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGlzdFN0clxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdHJpbVRyYWlsaW5nXHJcbiAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgKi9cclxuICBmdW5jdGlvbiBwcm9jZXNzTGlzdEl0ZW1zIChsaXN0U3RyLCB0cmltVHJhaWxpbmcpIHtcclxuICAgIC8vIFRoZSAkZ19saXN0X2xldmVsIGdsb2JhbCBrZWVwcyB0cmFjayBvZiB3aGVuIHdlJ3JlIGluc2lkZSBhIGxpc3QuXHJcbiAgICAvLyBFYWNoIHRpbWUgd2UgZW50ZXIgYSBsaXN0LCB3ZSBpbmNyZW1lbnQgaXQ7IHdoZW4gd2UgbGVhdmUgYSBsaXN0LFxyXG4gICAgLy8gd2UgZGVjcmVtZW50LiBJZiBpdCdzIHplcm8sIHdlJ3JlIG5vdCBpbiBhIGxpc3QgYW55bW9yZS5cclxuICAgIC8vXHJcbiAgICAvLyBXZSBkbyB0aGlzIGJlY2F1c2Ugd2hlbiB3ZSdyZSBub3QgaW5zaWRlIGEgbGlzdCwgd2Ugd2FudCB0byB0cmVhdFxyXG4gICAgLy8gc29tZXRoaW5nIGxpa2UgdGhpczpcclxuICAgIC8vXHJcbiAgICAvLyAgICBJIHJlY29tbWVuZCB1cGdyYWRpbmcgdG8gdmVyc2lvblxyXG4gICAgLy8gICAgOC4gT29wcywgbm93IHRoaXMgbGluZSBpcyB0cmVhdGVkXHJcbiAgICAvLyAgICBhcyBhIHN1Yi1saXN0LlxyXG4gICAgLy9cclxuICAgIC8vIEFzIGEgc2luZ2xlIHBhcmFncmFwaCwgZGVzcGl0ZSB0aGUgZmFjdCB0aGF0IHRoZSBzZWNvbmQgbGluZSBzdGFydHNcclxuICAgIC8vIHdpdGggYSBkaWdpdC1wZXJpb2Qtc3BhY2Ugc2VxdWVuY2UuXHJcbiAgICAvL1xyXG4gICAgLy8gV2hlcmVhcyB3aGVuIHdlJ3JlIGluc2lkZSBhIGxpc3QgKG9yIHN1Yi1saXN0KSwgdGhhdCBsaW5lIHdpbGwgYmVcclxuICAgIC8vIHRyZWF0ZWQgYXMgdGhlIHN0YXJ0IG9mIGEgc3ViLWxpc3QuIFdoYXQgYSBrbHVkZ2UsIGh1aD8gVGhpcyBpc1xyXG4gICAgLy8gYW4gYXNwZWN0IG9mIE1hcmtkb3duJ3Mgc3ludGF4IHRoYXQncyBoYXJkIHRvIHBhcnNlIHBlcmZlY3RseVxyXG4gICAgLy8gd2l0aG91dCByZXNvcnRpbmcgdG8gbWluZC1yZWFkaW5nLiBQZXJoYXBzIHRoZSBzb2x1dGlvbiBpcyB0b1xyXG4gICAgLy8gY2hhbmdlIHRoZSBzeW50YXggcnVsZXMgc3VjaCB0aGF0IHN1Yi1saXN0cyBtdXN0IHN0YXJ0IHdpdGggYVxyXG4gICAgLy8gc3RhcnRpbmcgY2FyZGluYWwgbnVtYmVyOyBlLmcuIFwiMS5cIiBvciBcImEuXCIuXHJcbiAgICBnbG9iYWxzLmdMaXN0TGV2ZWwrKztcclxuXHJcbiAgICAvLyB0cmltIHRyYWlsaW5nIGJsYW5rIGxpbmVzOlxyXG4gICAgbGlzdFN0ciA9IGxpc3RTdHIucmVwbGFjZSgvXFxuezIsfSQvLCAnXFxuJyk7XHJcblxyXG4gICAgLy8gYXR0YWNrbGFiOiBhZGQgc2VudGluZWwgdG8gZW11bGF0ZSBcXHpcclxuICAgIGxpc3RTdHIgKz0gJ34wJztcclxuXHJcbiAgICB2YXIgcmd4ID0gLyhcXG4pPyheWyBcXHRdKikoWyorLV18XFxkK1suXSlbIFxcdF0rKChcXFsoeHwgKT9dKT9bIFxcdF0qW15cXHJdKz8oXFxuezEsMn0pKSg/PVxcbioofjB8XFwyKFsqKy1dfFxcZCtbLl0pWyBcXHRdKykpL2dtLFxyXG4gICAgICAgIGlzUGFyYWdyYXBoZWQgPSAoL1xcblsgXFx0XSpcXG4oPyF+MCkvLnRlc3QobGlzdFN0cikpO1xyXG5cclxuICAgIGxpc3RTdHIgPSBsaXN0U3RyLnJlcGxhY2Uocmd4LCBmdW5jdGlvbiAod2hvbGVNYXRjaCwgbTEsIG0yLCBtMywgbTQsIHRhc2tidG4sIGNoZWNrZWQpIHtcclxuICAgICAgY2hlY2tlZCA9IChjaGVja2VkICYmIGNoZWNrZWQudHJpbSgpICE9PSAnJyk7XHJcbiAgICAgIHZhciBpdGVtID0gc2hvd2Rvd24uc3ViUGFyc2VyKCdvdXRkZW50JykobTQsIG9wdGlvbnMsIGdsb2JhbHMpLFxyXG4gICAgICAgICAgYnVsbGV0U3R5bGUgPSAnJztcclxuXHJcbiAgICAgIC8vIFN1cHBvcnQgZm9yIGdpdGh1YiB0YXNrbGlzdHNcclxuICAgICAgaWYgKHRhc2tidG4gJiYgb3B0aW9ucy50YXNrbGlzdHMpIHtcclxuICAgICAgICBidWxsZXRTdHlsZSA9ICcgY2xhc3M9XCJ0YXNrLWxpc3QtaXRlbVwiIHN0eWxlPVwibGlzdC1zdHlsZS10eXBlOiBub25lO1wiJztcclxuICAgICAgICBpdGVtID0gaXRlbS5yZXBsYWNlKC9eWyBcXHRdKlxcWyh4fCApP10vbSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgdmFyIG90cCA9ICc8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgZGlzYWJsZWQgc3R5bGU9XCJtYXJnaW46IDBweCAwLjM1ZW0gMC4yNWVtIC0xLjZlbTsgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcIic7XHJcbiAgICAgICAgICBpZiAoY2hlY2tlZCkge1xyXG4gICAgICAgICAgICBvdHAgKz0gJyBjaGVja2VkJztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIG90cCArPSAnPic7XHJcbiAgICAgICAgICByZXR1cm4gb3RwO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIG0xIC0gTGVhZGluZyBsaW5lIG9yXHJcbiAgICAgIC8vIEhhcyBhIGRvdWJsZSByZXR1cm4gKG11bHRpIHBhcmFncmFwaCkgb3JcclxuICAgICAgLy8gSGFzIHN1Ymxpc3RcclxuICAgICAgaWYgKG0xIHx8IChpdGVtLnNlYXJjaCgvXFxuezIsfS8pID4gLTEpKSB7XHJcbiAgICAgICAgaXRlbSA9IHNob3dkb3duLnN1YlBhcnNlcignZ2l0aHViQ29kZUJsb2NrcycpKGl0ZW0sIG9wdGlvbnMsIGdsb2JhbHMpO1xyXG4gICAgICAgIGl0ZW0gPSBzaG93ZG93bi5zdWJQYXJzZXIoJ2Jsb2NrR2FtdXQnKShpdGVtLCBvcHRpb25zLCBnbG9iYWxzKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBSZWN1cnNpb24gZm9yIHN1Yi1saXN0czpcclxuICAgICAgICBpdGVtID0gc2hvd2Rvd24uc3ViUGFyc2VyKCdsaXN0cycpKGl0ZW0sIG9wdGlvbnMsIGdsb2JhbHMpO1xyXG4gICAgICAgIGl0ZW0gPSBpdGVtLnJlcGxhY2UoL1xcbiQvLCAnJyk7IC8vIGNob21wKGl0ZW0pXHJcbiAgICAgICAgaWYgKGlzUGFyYWdyYXBoZWQpIHtcclxuICAgICAgICAgIGl0ZW0gPSBzaG93ZG93bi5zdWJQYXJzZXIoJ3BhcmFncmFwaHMnKShpdGVtLCBvcHRpb25zLCBnbG9iYWxzKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaXRlbSA9IHNob3dkb3duLnN1YlBhcnNlcignc3BhbkdhbXV0JykoaXRlbSwgb3B0aW9ucywgZ2xvYmFscyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGl0ZW0gPSAgJ1xcbjxsaScgKyBidWxsZXRTdHlsZSArICc+JyArIGl0ZW0gKyAnPC9saT5cXG4nO1xyXG4gICAgICByZXR1cm4gaXRlbTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIGF0dGFja2xhYjogc3RyaXAgc2VudGluZWxcclxuICAgIGxpc3RTdHIgPSBsaXN0U3RyLnJlcGxhY2UoL34wL2csICcnKTtcclxuXHJcbiAgICBnbG9iYWxzLmdMaXN0TGV2ZWwtLTtcclxuXHJcbiAgICBpZiAodHJpbVRyYWlsaW5nKSB7XHJcbiAgICAgIGxpc3RTdHIgPSBsaXN0U3RyLnJlcGxhY2UoL1xccyskLywgJycpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBsaXN0U3RyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgYW5kIHBhcnNlIGNvbnNlY3V0aXZlIGxpc3RzIChiZXR0ZXIgZml4IGZvciBpc3N1ZSAjMTQyKVxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsaXN0XHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxpc3RUeXBlXHJcbiAgICogQHBhcmFtIHtib29sZWFufSB0cmltVHJhaWxpbmdcclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHBhcnNlQ29uc2VjdXRpdmVMaXN0cyhsaXN0LCBsaXN0VHlwZSwgdHJpbVRyYWlsaW5nKSB7XHJcbiAgICAvLyBjaGVjayBpZiB3ZSBjYXVnaHQgMiBvciBtb3JlIGNvbnNlY3V0aXZlIGxpc3RzIGJ5IG1pc3Rha2VcclxuICAgIC8vIHdlIHVzZSB0aGUgY291bnRlclJneCwgbWVhbmluZyBpZiBsaXN0VHlwZSBpcyBVTCB3ZSBsb29rIGZvciBVTCBhbmQgdmljZSB2ZXJzYVxyXG4gICAgdmFyIGNvdW50ZXJSeGcgPSAobGlzdFR5cGUgPT09ICd1bCcpID8gL14gezAsMn1cXGQrXFwuWyBcXHRdL2dtIDogL14gezAsMn1bKistXVsgXFx0XS9nbSxcclxuICAgICAgc3ViTGlzdHMgPSBbXSxcclxuICAgICAgcmVzdWx0ID0gJyc7XHJcblxyXG4gICAgaWYgKGxpc3Quc2VhcmNoKGNvdW50ZXJSeGcpICE9PSAtMSkge1xyXG4gICAgICAoZnVuY3Rpb24gcGFyc2VDTCh0eHQpIHtcclxuICAgICAgICB2YXIgcG9zID0gdHh0LnNlYXJjaChjb3VudGVyUnhnKTtcclxuICAgICAgICBpZiAocG9zICE9PSAtMSkge1xyXG4gICAgICAgICAgLy8gc2xpY2VcclxuICAgICAgICAgIHJlc3VsdCArPSAnXFxuXFxuPCcgKyBsaXN0VHlwZSArICc+JyArIHByb2Nlc3NMaXN0SXRlbXModHh0LnNsaWNlKDAsIHBvcyksICEhdHJpbVRyYWlsaW5nKSArICc8LycgKyBsaXN0VHlwZSArICc+XFxuXFxuJztcclxuXHJcbiAgICAgICAgICAvLyBpbnZlcnQgY291bnRlclR5cGUgYW5kIGxpc3RUeXBlXHJcbiAgICAgICAgICBsaXN0VHlwZSA9IChsaXN0VHlwZSA9PT0gJ3VsJykgPyAnb2wnIDogJ3VsJztcclxuICAgICAgICAgIGNvdW50ZXJSeGcgPSAobGlzdFR5cGUgPT09ICd1bCcpID8gL14gezAsMn1cXGQrXFwuWyBcXHRdL2dtIDogL14gezAsMn1bKistXVsgXFx0XS9nbTtcclxuXHJcbiAgICAgICAgICAvL3JlY3Vyc2VcclxuICAgICAgICAgIHBhcnNlQ0wodHh0LnNsaWNlKHBvcykpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXN1bHQgKz0gJ1xcblxcbjwnICsgbGlzdFR5cGUgKyAnPicgKyBwcm9jZXNzTGlzdEl0ZW1zKHR4dCwgISF0cmltVHJhaWxpbmcpICsgJzwvJyArIGxpc3RUeXBlICsgJz5cXG5cXG4nO1xyXG4gICAgICAgIH1cclxuICAgICAgfSkobGlzdCk7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3ViTGlzdHMubGVuZ3RoOyArK2kpIHtcclxuXHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJlc3VsdCA9ICdcXG5cXG48JyArIGxpc3RUeXBlICsgJz4nICsgcHJvY2Vzc0xpc3RJdGVtcyhsaXN0LCAhIXRyaW1UcmFpbGluZykgKyAnPC8nICsgbGlzdFR5cGUgKyAnPlxcblxcbic7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG4gIC8vIGF0dGFja2xhYjogYWRkIHNlbnRpbmVsIHRvIGhhY2sgYXJvdW5kIGtodG1sL3NhZmFyaSBidWc6XHJcbiAgLy8gaHR0cDovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTEyMzFcclxuICB0ZXh0ICs9ICd+MCc7XHJcblxyXG4gIC8vIFJlLXVzYWJsZSBwYXR0ZXJuIHRvIG1hdGNoIGFueSBlbnRpcmUgdWwgb3Igb2wgbGlzdDpcclxuICB2YXIgd2hvbGVMaXN0ID0gL14oKFsgXXswLDN9KFsqKy1dfFxcZCtbLl0pWyBcXHRdKylbXlxccl0rPyh+MHxcXG57Mix9KD89XFxTKSg/IVsgXFx0XSooPzpbKistXXxcXGQrWy5dKVsgXFx0XSspKSkvZ207XHJcblxyXG4gIGlmIChnbG9iYWxzLmdMaXN0TGV2ZWwpIHtcclxuICAgIHRleHQgPSB0ZXh0LnJlcGxhY2Uod2hvbGVMaXN0LCBmdW5jdGlvbiAod2hvbGVNYXRjaCwgbGlzdCwgbTIpIHtcclxuICAgICAgdmFyIGxpc3RUeXBlID0gKG0yLnNlYXJjaCgvWyorLV0vZykgPiAtMSkgPyAndWwnIDogJ29sJztcclxuICAgICAgcmV0dXJuIHBhcnNlQ29uc2VjdXRpdmVMaXN0cyhsaXN0LCBsaXN0VHlwZSwgdHJ1ZSk7XHJcbiAgICB9KTtcclxuICB9IGVsc2Uge1xyXG4gICAgd2hvbGVMaXN0ID0gLyhcXG5cXG58Xlxcbj8pKChbIF17MCwzfShbKistXXxcXGQrWy5dKVsgXFx0XSspW15cXHJdKz8ofjB8XFxuezIsfSg/PVxcUykoPyFbIFxcdF0qKD86WyorLV18XFxkK1suXSlbIFxcdF0rKSkpL2dtO1xyXG4gICAgLy93aG9sZUxpc3QgPSAvKFxcblxcbnxeXFxuPykoIHswLDN9KFsqKy1dfFxcZCtcXC4pWyBcXHRdK1tcXHNcXFNdKz8pKD89KH4wKXwoXFxuXFxuKD8hXFx0fCB7Mix9fCB7MCwzfShbKistXXxcXGQrXFwuKVsgXFx0XSkpKS9nO1xyXG4gICAgdGV4dCA9IHRleHQucmVwbGFjZSh3aG9sZUxpc3QsIGZ1bmN0aW9uICh3aG9sZU1hdGNoLCBtMSwgbGlzdCwgbTMpIHtcclxuXHJcbiAgICAgIHZhciBsaXN0VHlwZSA9IChtMy5zZWFyY2goL1sqKy1dL2cpID4gLTEpID8gJ3VsJyA6ICdvbCc7XHJcbiAgICAgIHJldHVybiBwYXJzZUNvbnNlY3V0aXZlTGlzdHMobGlzdCwgbGlzdFR5cGUpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLyBhdHRhY2tsYWI6IHN0cmlwIHNlbnRpbmVsXHJcbiAgdGV4dCA9IHRleHQucmVwbGFjZSgvfjAvLCAnJyk7XHJcblxyXG4gIHRleHQgPSBnbG9iYWxzLmNvbnZlcnRlci5fZGlzcGF0Y2goJ2xpc3RzLmFmdGVyJywgdGV4dCwgb3B0aW9ucyk7XHJcbiAgcmV0dXJuIHRleHQ7XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSBvbmUgbGV2ZWwgb2YgbGluZS1sZWFkaW5nIHRhYnMgb3Igc3BhY2VzXHJcbiAqL1xyXG5zaG93ZG93bi5zdWJQYXJzZXIoJ291dGRlbnQnLCBmdW5jdGlvbiAodGV4dCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgLy8gYXR0YWNrbGFiOiBoYWNrIGFyb3VuZCBLb25xdWVyb3IgMy41LjQgYnVnOlxyXG4gIC8vIFwiLS0tLS0tLS0tLWJ1Z1wiLnJlcGxhY2UoL14tL2csXCJcIikgPT0gXCJidWdcIlxyXG4gIHRleHQgPSB0ZXh0LnJlcGxhY2UoL14oXFx0fFsgXXsxLDR9KS9nbSwgJ34wJyk7IC8vIGF0dGFja2xhYjogZ190YWJfd2lkdGhcclxuXHJcbiAgLy8gYXR0YWNrbGFiOiBjbGVhbiB1cCBoYWNrXHJcbiAgdGV4dCA9IHRleHQucmVwbGFjZSgvfjAvZywgJycpO1xyXG5cclxuICByZXR1cm4gdGV4dDtcclxufSk7XHJcblxyXG4vKipcclxuICpcclxuICovXHJcbnNob3dkb3duLnN1YlBhcnNlcigncGFyYWdyYXBocycsIGZ1bmN0aW9uICh0ZXh0LCBvcHRpb25zLCBnbG9iYWxzKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICB0ZXh0ID0gZ2xvYmFscy5jb252ZXJ0ZXIuX2Rpc3BhdGNoKCdwYXJhZ3JhcGhzLmJlZm9yZScsIHRleHQsIG9wdGlvbnMpO1xyXG4gIC8vIFN0cmlwIGxlYWRpbmcgYW5kIHRyYWlsaW5nIGxpbmVzOlxyXG4gIHRleHQgPSB0ZXh0LnJlcGxhY2UoL15cXG4rL2csICcnKTtcclxuICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXG4rJC9nLCAnJyk7XHJcblxyXG4gIHZhciBncmFmcyA9IHRleHQuc3BsaXQoL1xcbnsyLH0vZyksXHJcbiAgICAgIGdyYWZzT3V0ID0gW10sXHJcbiAgICAgIGVuZCA9IGdyYWZzLmxlbmd0aDsgLy8gV3JhcCA8cD4gdGFnc1xyXG5cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVuZDsgaSsrKSB7XHJcbiAgICB2YXIgc3RyID0gZ3JhZnNbaV07XHJcblxyXG4gICAgLy8gaWYgdGhpcyBpcyBhbiBIVE1MIG1hcmtlciwgY29weSBpdFxyXG4gICAgaWYgKHN0ci5zZWFyY2goL35LKFxcZCspSy9nKSA+PSAwKSB7XHJcbiAgICAgIGdyYWZzT3V0LnB1c2goc3RyKTtcclxuICAgIH0gZWxzZSBpZiAoc3RyLnNlYXJjaCgvXFxTLykgPj0gMCkge1xyXG4gICAgICBzdHIgPSBzaG93ZG93bi5zdWJQYXJzZXIoJ3NwYW5HYW11dCcpKHN0ciwgb3B0aW9ucywgZ2xvYmFscyk7XHJcbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9eKFsgXFx0XSopL2csICc8cD4nKTtcclxuICAgICAgc3RyICs9ICc8L3A+JztcclxuICAgICAgZ3JhZnNPdXQucHVzaChzdHIpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqIFVuaGFzaGlmeSBIVE1MIGJsb2NrcyAqL1xyXG4gIGVuZCA9IGdyYWZzT3V0Lmxlbmd0aDtcclxuICBmb3IgKGkgPSAwOyBpIDwgZW5kOyBpKyspIHtcclxuICAgIC8vIGlmIHRoaXMgaXMgYSBtYXJrZXIgZm9yIGFuIGh0bWwgYmxvY2suLi5cclxuICAgIHdoaWxlIChncmFmc091dFtpXS5zZWFyY2goL35LKFxcZCspSy8pID49IDApIHtcclxuICAgICAgdmFyIGJsb2NrVGV4dCA9IGdsb2JhbHMuZ0h0bWxCbG9ja3NbUmVnRXhwLiQxXTtcclxuICAgICAgYmxvY2tUZXh0ID0gYmxvY2tUZXh0LnJlcGxhY2UoL1xcJC9nLCAnJCQkJCcpOyAvLyBFc2NhcGUgYW55IGRvbGxhciBzaWduc1xyXG4gICAgICBncmFmc091dFtpXSA9IGdyYWZzT3V0W2ldLnJlcGxhY2UoL35LXFxkK0svLCBibG9ja1RleHQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdGV4dCA9IGdsb2JhbHMuY29udmVydGVyLl9kaXNwYXRjaCgncGFyYWdyYXBocy5hZnRlcicsIHRleHQsIG9wdGlvbnMpO1xyXG4gIHJldHVybiBncmFmc091dC5qb2luKCdcXG5cXG4nKTtcclxufSk7XHJcblxyXG4vKipcclxuICogUnVuIGV4dGVuc2lvblxyXG4gKi9cclxuc2hvd2Rvd24uc3ViUGFyc2VyKCdydW5FeHRlbnNpb24nLCBmdW5jdGlvbiAoZXh0LCB0ZXh0LCBvcHRpb25zLCBnbG9iYWxzKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICBpZiAoZXh0LmZpbHRlcikge1xyXG4gICAgdGV4dCA9IGV4dC5maWx0ZXIodGV4dCwgZ2xvYmFscy5jb252ZXJ0ZXIsIG9wdGlvbnMpO1xyXG5cclxuICB9IGVsc2UgaWYgKGV4dC5yZWdleCkge1xyXG4gICAgLy8gVE9ETyByZW1vdmUgdGhpcyB3aGVuIG9sZCBleHRlbnNpb24gbG9hZGluZyBtZWNoYW5pc20gaXMgZGVwcmVjYXRlZFxyXG4gICAgdmFyIHJlID0gZXh0LnJlZ2V4O1xyXG4gICAgaWYgKCFyZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xyXG4gICAgICByZSA9IG5ldyBSZWdFeHAocmUsICdnJyk7XHJcbiAgICB9XHJcbiAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHJlLCBleHQucmVwbGFjZSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGV4dDtcclxufSk7XHJcblxyXG4vKipcclxuICogVGhlc2UgYXJlIGFsbCB0aGUgdHJhbnNmb3JtYXRpb25zIHRoYXQgb2NjdXIgKndpdGhpbiogYmxvY2stbGV2ZWxcclxuICogdGFncyBsaWtlIHBhcmFncmFwaHMsIGhlYWRlcnMsIGFuZCBsaXN0IGl0ZW1zLlxyXG4gKi9cclxuc2hvd2Rvd24uc3ViUGFyc2VyKCdzcGFuR2FtdXQnLCBmdW5jdGlvbiAodGV4dCwgb3B0aW9ucywgZ2xvYmFscykge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgdGV4dCA9IGdsb2JhbHMuY29udmVydGVyLl9kaXNwYXRjaCgnc3BhbkdhbXV0LmJlZm9yZScsIHRleHQsIG9wdGlvbnMpO1xyXG4gIHRleHQgPSBzaG93ZG93bi5zdWJQYXJzZXIoJ2NvZGVTcGFucycpKHRleHQsIG9wdGlvbnMsIGdsb2JhbHMpO1xyXG4gIHRleHQgPSBzaG93ZG93bi5zdWJQYXJzZXIoJ2VzY2FwZVNwZWNpYWxDaGFyc1dpdGhpblRhZ0F0dHJpYnV0ZXMnKSh0ZXh0LCBvcHRpb25zLCBnbG9iYWxzKTtcclxuICB0ZXh0ID0gc2hvd2Rvd24uc3ViUGFyc2VyKCdlbmNvZGVCYWNrc2xhc2hFc2NhcGVzJykodGV4dCwgb3B0aW9ucywgZ2xvYmFscyk7XHJcblxyXG4gIC8vIFByb2Nlc3MgYW5jaG9yIGFuZCBpbWFnZSB0YWdzLiBJbWFnZXMgbXVzdCBjb21lIGZpcnN0LFxyXG4gIC8vIGJlY2F1c2UgIVtmb29dW2ZdIGxvb2tzIGxpa2UgYW4gYW5jaG9yLlxyXG4gIHRleHQgPSBzaG93ZG93bi5zdWJQYXJzZXIoJ2ltYWdlcycpKHRleHQsIG9wdGlvbnMsIGdsb2JhbHMpO1xyXG4gIHRleHQgPSBzaG93ZG93bi5zdWJQYXJzZXIoJ2FuY2hvcnMnKSh0ZXh0LCBvcHRpb25zLCBnbG9iYWxzKTtcclxuXHJcbiAgLy8gTWFrZSBsaW5rcyBvdXQgb2YgdGhpbmdzIGxpa2UgYDxodHRwOi8vZXhhbXBsZS5jb20vPmBcclxuICAvLyBNdXN0IGNvbWUgYWZ0ZXIgX0RvQW5jaG9ycygpLCBiZWNhdXNlIHlvdSBjYW4gdXNlIDwgYW5kID5cclxuICAvLyBkZWxpbWl0ZXJzIGluIGlubGluZSBsaW5rcyBsaWtlIFt0aGlzXSg8dXJsPikuXHJcbiAgdGV4dCA9IHNob3dkb3duLnN1YlBhcnNlcignYXV0b0xpbmtzJykodGV4dCwgb3B0aW9ucywgZ2xvYmFscyk7XHJcbiAgdGV4dCA9IHNob3dkb3duLnN1YlBhcnNlcignZW5jb2RlQW1wc0FuZEFuZ2xlcycpKHRleHQsIG9wdGlvbnMsIGdsb2JhbHMpO1xyXG4gIHRleHQgPSBzaG93ZG93bi5zdWJQYXJzZXIoJ2l0YWxpY3NBbmRCb2xkJykodGV4dCwgb3B0aW9ucywgZ2xvYmFscyk7XHJcbiAgdGV4dCA9IHNob3dkb3duLnN1YlBhcnNlcignc3RyaWtldGhyb3VnaCcpKHRleHQsIG9wdGlvbnMsIGdsb2JhbHMpO1xyXG5cclxuICAvLyBEbyBoYXJkIGJyZWFrczpcclxuICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC8gICtcXG4vZywgJyA8YnIgLz5cXG4nKTtcclxuXHJcbiAgdGV4dCA9IGdsb2JhbHMuY29udmVydGVyLl9kaXNwYXRjaCgnc3BhbkdhbXV0LmFmdGVyJywgdGV4dCwgb3B0aW9ucyk7XHJcbiAgcmV0dXJuIHRleHQ7XHJcbn0pO1xyXG5cclxuc2hvd2Rvd24uc3ViUGFyc2VyKCdzdHJpa2V0aHJvdWdoJywgZnVuY3Rpb24gKHRleHQsIG9wdGlvbnMsIGdsb2JhbHMpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIGlmIChvcHRpb25zLnN0cmlrZXRocm91Z2gpIHtcclxuICAgIHRleHQgPSBnbG9iYWxzLmNvbnZlcnRlci5fZGlzcGF0Y2goJ3N0cmlrZXRocm91Z2guYmVmb3JlJywgdGV4dCwgb3B0aW9ucyk7XHJcbiAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC8oPzp+VCl7Mn0oW15+XSspKD86flQpezJ9L2csICc8ZGVsPiQxPC9kZWw+Jyk7XHJcbiAgICB0ZXh0ID0gZ2xvYmFscy5jb252ZXJ0ZXIuX2Rpc3BhdGNoKCdzdHJpa2V0aHJvdWdoLmFmdGVyJywgdGV4dCwgb3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGV4dDtcclxufSk7XHJcblxyXG4vKipcclxuICogU3RyaXAgYW55IGxpbmVzIGNvbnNpc3Rpbmcgb25seSBvZiBzcGFjZXMgYW5kIHRhYnMuXHJcbiAqIFRoaXMgbWFrZXMgc3Vic2VxdWVudCByZWdleHMgZWFzaWVyIHRvIHdyaXRlLCBiZWNhdXNlIHdlIGNhblxyXG4gKiBtYXRjaCBjb25zZWN1dGl2ZSBibGFuayBsaW5lcyB3aXRoIC9cXG4rLyBpbnN0ZWFkIG9mIHNvbWV0aGluZ1xyXG4gKiBjb250b3J0ZWQgbGlrZSAvWyBcXHRdKlxcbisvXHJcbiAqL1xyXG5zaG93ZG93bi5zdWJQYXJzZXIoJ3N0cmlwQmxhbmtMaW5lcycsIGZ1bmN0aW9uICh0ZXh0KSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG4gIHJldHVybiB0ZXh0LnJlcGxhY2UoL15bIFxcdF0rJC9tZywgJycpO1xyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBTdHJpcHMgbGluayBkZWZpbml0aW9ucyBmcm9tIHRleHQsIHN0b3JlcyB0aGUgVVJMcyBhbmQgdGl0bGVzIGluXHJcbiAqIGhhc2ggcmVmZXJlbmNlcy5cclxuICogTGluayBkZWZzIGFyZSBpbiB0aGUgZm9ybTogXltpZF06IHVybCBcIm9wdGlvbmFsIHRpdGxlXCJcclxuICpcclxuICogXlsgXXswLDN9XFxbKC4rKVxcXTogLy8gaWQgPSAkMSAgYXR0YWNrbGFiOiBnX3RhYl93aWR0aCAtIDFcclxuICogWyBcXHRdKlxyXG4gKiBcXG4/ICAgICAgICAgICAgICAgICAgLy8gbWF5YmUgKm9uZSogbmV3bGluZVxyXG4gKiBbIFxcdF0qXHJcbiAqIDw/KFxcUys/KT4/ICAgICAgICAgIC8vIHVybCA9ICQyXHJcbiAqIFsgXFx0XSpcclxuICogXFxuPyAgICAgICAgICAgICAgICAvLyBtYXliZSBvbmUgbmV3bGluZVxyXG4gKiBbIFxcdF0qXHJcbiAqICg/OlxyXG4gKiAoXFxuKikgICAgICAgICAgICAgIC8vIGFueSBsaW5lcyBza2lwcGVkID0gJDMgYXR0YWNrbGFiOiBsb29rYmVoaW5kIHJlbW92ZWRcclxuICogW1wiKF1cclxuICogKC4rPykgICAgICAgICAgICAgIC8vIHRpdGxlID0gJDRcclxuICogW1wiKV1cclxuICogWyBcXHRdKlxyXG4gKiApPyAgICAgICAgICAgICAgICAgLy8gdGl0bGUgaXMgb3B0aW9uYWxcclxuICogKD86XFxuK3wkKVxyXG4gKiAvZ20sXHJcbiAqIGZ1bmN0aW9uKCl7Li4ufSk7XHJcbiAqXHJcbiAqL1xyXG5zaG93ZG93bi5zdWJQYXJzZXIoJ3N0cmlwTGlua0RlZmluaXRpb25zJywgZnVuY3Rpb24gKHRleHQsIG9wdGlvbnMsIGdsb2JhbHMpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIHZhciByZWdleCA9IC9eIHswLDN9XFxbKC4rKV06WyBcXHRdKlxcbj9bIFxcdF0qPD8oXFxTKz8pPj8oPzogPShbKlxcZF0rW0EtWmEteiVdezAsNH0peChbKlxcZF0rW0EtWmEteiVdezAsNH0pKT9bIFxcdF0qXFxuP1sgXFx0XSooPzooXFxuKilbXCJ8JyhdKC4rPylbXCJ8JyldWyBcXHRdKik/KD86XFxuK3woPz1+MCkpL2dtO1xyXG5cclxuICAvLyBhdHRhY2tsYWI6IHNlbnRpbmVsIHdvcmthcm91bmRzIGZvciBsYWNrIG9mIFxcQSBhbmQgXFxaLCBzYWZhcmlcXGtodG1sIGJ1Z1xyXG4gIHRleHQgKz0gJ34wJztcclxuXHJcbiAgdGV4dCA9IHRleHQucmVwbGFjZShyZWdleCwgZnVuY3Rpb24gKHdob2xlTWF0Y2gsIGxpbmtJZCwgdXJsLCB3aWR0aCwgaGVpZ2h0LCBibGFua0xpbmVzLCB0aXRsZSkge1xyXG4gICAgbGlua0lkID0gbGlua0lkLnRvTG93ZXJDYXNlKCk7XHJcbiAgICBnbG9iYWxzLmdVcmxzW2xpbmtJZF0gPSBzaG93ZG93bi5zdWJQYXJzZXIoJ2VuY29kZUFtcHNBbmRBbmdsZXMnKSh1cmwpOyAgLy8gTGluayBJRHMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcclxuXHJcbiAgICBpZiAoYmxhbmtMaW5lcykge1xyXG4gICAgICAvLyBPb3BzLCBmb3VuZCBibGFuayBsaW5lcywgc28gaXQncyBub3QgYSB0aXRsZS5cclxuICAgICAgLy8gUHV0IGJhY2sgdGhlIHBhcmVudGhldGljYWwgc3RhdGVtZW50IHdlIHN0b2xlLlxyXG4gICAgICByZXR1cm4gYmxhbmtMaW5lcyArIHRpdGxlO1xyXG5cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmICh0aXRsZSkge1xyXG4gICAgICAgIGdsb2JhbHMuZ1RpdGxlc1tsaW5rSWRdID0gdGl0bGUucmVwbGFjZSgvXCJ8Jy9nLCAnJnF1b3Q7Jyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG9wdGlvbnMucGFyc2VJbWdEaW1lbnNpb25zICYmIHdpZHRoICYmIGhlaWdodCkge1xyXG4gICAgICAgIGdsb2JhbHMuZ0RpbWVuc2lvbnNbbGlua0lkXSA9IHtcclxuICAgICAgICAgIHdpZHRoOiAgd2lkdGgsXHJcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIENvbXBsZXRlbHkgcmVtb3ZlIHRoZSBkZWZpbml0aW9uIGZyb20gdGhlIHRleHRcclxuICAgIHJldHVybiAnJztcclxuICB9KTtcclxuXHJcbiAgLy8gYXR0YWNrbGFiOiBzdHJpcCBzZW50aW5lbFxyXG4gIHRleHQgPSB0ZXh0LnJlcGxhY2UoL34wLywgJycpO1xyXG5cclxuICByZXR1cm4gdGV4dDtcclxufSk7XHJcblxyXG5zaG93ZG93bi5zdWJQYXJzZXIoJ3RhYmxlcycsIGZ1bmN0aW9uICh0ZXh0LCBvcHRpb25zLCBnbG9iYWxzKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICB2YXIgdGFibGUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIHRhYmxlcyA9IHt9LFxyXG4gICAgICAgIGZpbHRlcjtcclxuXHJcbiAgICB0YWJsZXMudGggPSBmdW5jdGlvbiAoaGVhZGVyLCBzdHlsZSkge1xyXG4gICAgICB2YXIgaWQgPSAnJztcclxuICAgICAgaGVhZGVyID0gaGVhZGVyLnRyaW0oKTtcclxuICAgICAgaWYgKGhlYWRlciA9PT0gJycpIHtcclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG9wdGlvbnMudGFibGVIZWFkZXJJZCkge1xyXG4gICAgICAgIGlkID0gJyBpZD1cIicgKyBoZWFkZXIucmVwbGFjZSgvIC9nLCAnXycpLnRvTG93ZXJDYXNlKCkgKyAnXCInO1xyXG4gICAgICB9XHJcbiAgICAgIGhlYWRlciA9IHNob3dkb3duLnN1YlBhcnNlcignc3BhbkdhbXV0JykoaGVhZGVyLCBvcHRpb25zLCBnbG9iYWxzKTtcclxuICAgICAgaWYgKCFzdHlsZSB8fCBzdHlsZS50cmltKCkgPT09ICcnKSB7XHJcbiAgICAgICAgc3R5bGUgPSAnJztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzdHlsZSA9ICcgc3R5bGU9XCInICsgc3R5bGUgKyAnXCInO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAnPHRoJyArIGlkICsgc3R5bGUgKyAnPicgKyBoZWFkZXIgKyAnPC90aD4nO1xyXG4gICAgfTtcclxuXHJcbiAgICB0YWJsZXMudGQgPSBmdW5jdGlvbiAoY2VsbCwgc3R5bGUpIHtcclxuICAgICAgdmFyIHN1YlRleHQgPSBzaG93ZG93bi5zdWJQYXJzZXIoJ3NwYW5HYW11dCcpKGNlbGwudHJpbSgpLCBvcHRpb25zLCBnbG9iYWxzKTtcclxuICAgICAgaWYgKCFzdHlsZSB8fCBzdHlsZS50cmltKCkgPT09ICcnKSB7XHJcbiAgICAgICAgc3R5bGUgPSAnJztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzdHlsZSA9ICcgc3R5bGU9XCInICsgc3R5bGUgKyAnXCInO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAnPHRkJyArIHN0eWxlICsgJz4nICsgc3ViVGV4dCArICc8L3RkPic7XHJcbiAgICB9O1xyXG5cclxuICAgIHRhYmxlcy50aHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBvdXQgPSAnJyxcclxuICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgaHMgPSBbXS5zbGljZS5hcHBseShhcmd1bWVudHNbMF0pLFxyXG4gICAgICAgICAgc3R5bGUgPSBbXS5zbGljZS5hcHBseShhcmd1bWVudHNbMV0pO1xyXG5cclxuICAgICAgZm9yIChpOyBpIDwgaHMubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgICBvdXQgKz0gdGFibGVzLnRoKGhzW2ldLCBzdHlsZVtpXSkgKyAnXFxuJztcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG91dDtcclxuICAgIH07XHJcblxyXG4gICAgdGFibGVzLnRkcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIG91dCA9ICcnLFxyXG4gICAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgICBkcyA9IFtdLnNsaWNlLmFwcGx5KGFyZ3VtZW50c1swXSksXHJcbiAgICAgICAgICBzdHlsZSA9IFtdLnNsaWNlLmFwcGx5KGFyZ3VtZW50c1sxXSk7XHJcblxyXG4gICAgICBmb3IgKGk7IGkgPCBkcy5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICAgIG91dCArPSB0YWJsZXMudGQoZHNbaV0sIHN0eWxlW2ldKSArICdcXG4nO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9O1xyXG5cclxuICAgIHRhYmxlcy50aGVhZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIG91dCxcclxuICAgICAgICAgIGhzID0gW10uc2xpY2UuYXBwbHkoYXJndW1lbnRzWzBdKSxcclxuICAgICAgICAgIHN0eWxlID0gW10uc2xpY2UuYXBwbHkoYXJndW1lbnRzWzFdKTtcclxuXHJcbiAgICAgIG91dCA9ICc8dGhlYWQ+XFxuJztcclxuICAgICAgb3V0ICs9ICc8dHI+XFxuJztcclxuICAgICAgb3V0ICs9IHRhYmxlcy50aHMuYXBwbHkodGhpcywgW2hzLCBzdHlsZV0pO1xyXG4gICAgICBvdXQgKz0gJzwvdHI+XFxuJztcclxuICAgICAgb3V0ICs9ICc8L3RoZWFkPlxcbic7XHJcbiAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9O1xyXG5cclxuICAgIHRhYmxlcy50ciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIG91dCxcclxuICAgICAgICBjcyA9IFtdLnNsaWNlLmFwcGx5KGFyZ3VtZW50c1swXSksXHJcbiAgICAgICAgc3R5bGUgPSBbXS5zbGljZS5hcHBseShhcmd1bWVudHNbMV0pO1xyXG5cclxuICAgICAgb3V0ID0gJzx0cj5cXG4nO1xyXG4gICAgICBvdXQgKz0gdGFibGVzLnRkcy5hcHBseSh0aGlzLCBbY3MsIHN0eWxlXSk7XHJcbiAgICAgIG91dCArPSAnPC90cj5cXG4nO1xyXG4gICAgICByZXR1cm4gb3V0O1xyXG4gICAgfTtcclxuXHJcbiAgICBmaWx0ZXIgPSBmdW5jdGlvbiAodGV4dCkge1xyXG4gICAgICB2YXIgaSA9IDAsXHJcbiAgICAgICAgbGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKSxcclxuICAgICAgICBsaW5lLFxyXG4gICAgICAgIGhzLFxyXG4gICAgICAgIG91dCA9IFtdO1xyXG5cclxuICAgICAgZm9yIChpOyBpIDwgbGluZXMubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgICBsaW5lID0gbGluZXNbaV07XHJcbiAgICAgICAgLy8gbG9va3MgbGlrZSBhIHRhYmxlIGhlYWRpbmdcclxuICAgICAgICBpZiAobGluZS50cmltKCkubWF0Y2goL15bfF0uKlt8XSQvKSkge1xyXG4gICAgICAgICAgbGluZSA9IGxpbmUudHJpbSgpO1xyXG5cclxuICAgICAgICAgIHZhciB0YmwgPSBbXSxcclxuICAgICAgICAgICAgICBhbGlnbiA9IGxpbmVzW2kgKyAxXS50cmltKCksXHJcbiAgICAgICAgICAgICAgc3R5bGVzID0gW10sXHJcbiAgICAgICAgICAgICAgaiA9IDA7XHJcblxyXG4gICAgICAgICAgaWYgKGFsaWduLm1hdGNoKC9eW3xdWy09fDogXStbfF0kLykpIHtcclxuICAgICAgICAgICAgc3R5bGVzID0gYWxpZ24uc3Vic3RyaW5nKDEsIGFsaWduLmxlbmd0aCAtIDEpLnNwbGl0KCd8Jyk7XHJcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBzdHlsZXMubGVuZ3RoOyArK2opIHtcclxuICAgICAgICAgICAgICBzdHlsZXNbal0gPSBzdHlsZXNbal0udHJpbSgpO1xyXG4gICAgICAgICAgICAgIGlmIChzdHlsZXNbal0ubWF0Y2goL15bOl1bLT18IF0rWzpdJC8pKSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZXNbal0gPSAndGV4dC1hbGlnbjpjZW50ZXI7JztcclxuXHJcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHlsZXNbal0ubWF0Y2goL15bLT18IF0rWzpdJC8pKSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZXNbal0gPSAndGV4dC1hbGlnbjpyaWdodDsnO1xyXG5cclxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0eWxlc1tqXS5tYXRjaCgvXls6XVstPXwgXSskLykpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlc1tqXSA9ICd0ZXh0LWFsaWduOmxlZnQ7JztcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3R5bGVzW2pdID0gJyc7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0YmwucHVzaCgnPHRhYmxlPicpO1xyXG4gICAgICAgICAgaHMgPSBsaW5lLnN1YnN0cmluZygxLCBsaW5lLmxlbmd0aCAtIDEpLnNwbGl0KCd8Jyk7XHJcblxyXG4gICAgICAgICAgaWYgKHN0eWxlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGhzLmxlbmd0aDsgKytqKSB7XHJcbiAgICAgICAgICAgICAgc3R5bGVzLnB1c2goJ3RleHQtYWxpZ246bGVmdCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0YmwucHVzaCh0YWJsZXMudGhlYWQuYXBwbHkodGhpcywgW2hzLCBzdHlsZXNdKSk7XHJcbiAgICAgICAgICBsaW5lID0gbGluZXNbKytpXTtcclxuICAgICAgICAgIGlmICghbGluZS50cmltKCkubWF0Y2goL15bfF1bLT18OiBdK1t8XSQvKSkge1xyXG4gICAgICAgICAgICAvLyBub3QgYSB0YWJsZSByb2xsaW5nIGJhY2tcclxuICAgICAgICAgICAgbGluZSA9IGxpbmVzWy0taV07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsaW5lID0gbGluZXNbKytpXTtcclxuICAgICAgICAgICAgdGJsLnB1c2goJzx0Ym9keT4nKTtcclxuICAgICAgICAgICAgd2hpbGUgKGxpbmUudHJpbSgpLm1hdGNoKC9eW3xdLipbfF0kLykpIHtcclxuICAgICAgICAgICAgICBsaW5lID0gbGluZS50cmltKCk7XHJcbiAgICAgICAgICAgICAgdGJsLnB1c2godGFibGVzLnRyLmFwcGx5KHRoaXMsIFtsaW5lLnN1YnN0cmluZygxLCBsaW5lLmxlbmd0aCAtIDEpLnNwbGl0KCd8JyksIHN0eWxlc10pKTtcclxuICAgICAgICAgICAgICBsaW5lID0gbGluZXNbKytpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0YmwucHVzaCgnPC90Ym9keT4nKTtcclxuICAgICAgICAgICAgdGJsLnB1c2goJzwvdGFibGU+Jyk7XHJcbiAgICAgICAgICAgIC8vIHdlIGFyZSBkb25lIHdpdGggdGhpcyB0YWJsZSBhbmQgd2UgbW92ZSBhbG9uZ1xyXG4gICAgICAgICAgICBvdXQucHVzaCh0Ymwuam9pbignXFxuJykpO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgb3V0LnB1c2gobGluZSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG91dC5qb2luKCdcXG4nKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4ge3BhcnNlOiBmaWx0ZXJ9O1xyXG4gIH07XHJcblxyXG4gIGlmIChvcHRpb25zLnRhYmxlcykge1xyXG4gICAgdGV4dCA9IGdsb2JhbHMuY29udmVydGVyLl9kaXNwYXRjaCgndGFibGVzLmJlZm9yZScsIHRleHQsIG9wdGlvbnMpO1xyXG4gICAgdmFyIHRhYmxlUGFyc2VyID0gdGFibGUoKTtcclxuICAgIHRleHQgPSB0YWJsZVBhcnNlci5wYXJzZSh0ZXh0KTtcclxuICAgIHRleHQgPSBnbG9iYWxzLmNvbnZlcnRlci5fZGlzcGF0Y2goJ3RhYmxlcy5hZnRlcicsIHRleHQsIG9wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRleHQ7XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIFN3YXAgYmFjayBpbiBhbGwgdGhlIHNwZWNpYWwgY2hhcmFjdGVycyB3ZSd2ZSBoaWRkZW4uXHJcbiAqL1xyXG5zaG93ZG93bi5zdWJQYXJzZXIoJ3VuZXNjYXBlU3BlY2lhbENoYXJzJywgZnVuY3Rpb24gKHRleHQpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIHRleHQgPSB0ZXh0LnJlcGxhY2UoL35FKFxcZCspRS9nLCBmdW5jdGlvbiAod2hvbGVNYXRjaCwgbTEpIHtcclxuICAgIHZhciBjaGFyQ29kZVRvUmVwbGFjZSA9IHBhcnNlSW50KG0xKTtcclxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlVG9SZXBsYWNlKTtcclxuICB9KTtcclxuICByZXR1cm4gdGV4dDtcclxufSk7XHJcblxyXG52YXIgcm9vdCA9IHRoaXM7XHJcblxyXG4vLyBDb21tb25KUy9ub2RlSlMgTG9hZGVyXHJcbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xyXG4gIG1vZHVsZS5leHBvcnRzID0gc2hvd2Rvd247XHJcblxyXG4vLyBBTUQgTG9hZGVyXHJcbn0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgZGVmaW5lKCdzaG93ZG93bicsIGZ1bmN0aW9uICgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiBzaG93ZG93bjtcclxuICB9KTtcclxuXHJcbi8vIFJlZ3VsYXIgQnJvd3NlciBsb2FkZXJcclxufSBlbHNlIHtcclxuICByb290LnNob3dkb3duID0gc2hvd2Rvd247XHJcbn1cclxufSkuY2FsbCh0aGlzKTtcclxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaG93ZG93bi5qcy5tYXBcclxuIiwidmFyIFZ1ZSAvLyBsYXRlIGJpbmRcbnZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpXG52YXIgc2hpbW1lZCA9IGZhbHNlXG52YXIgaXNCcm93c2VyaWZ5ID0gZmFsc2VcblxuLyoqXG4gKiBEZXRlcm1pbmUgY29tcGF0aWJpbGl0eSBhbmQgYXBwbHkgcGF0Y2guXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdnVlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGJyb3dzZXJpZnlcbiAqL1xuXG5leHBvcnRzLmluc3RhbGwgPSBmdW5jdGlvbiAodnVlLCBicm93c2VyaWZ5KSB7XG4gIGlmIChzaGltbWVkKSByZXR1cm5cbiAgc2hpbW1lZCA9IHRydWVcblxuICBWdWUgPSB2dWVcbiAgaXNCcm93c2VyaWZ5ID0gYnJvd3NlcmlmeVxuXG4gIGV4cG9ydHMuY29tcGF0aWJsZSA9ICEhVnVlLmludGVybmFsRGlyZWN0aXZlc1xuICBpZiAoIWV4cG9ydHMuY29tcGF0aWJsZSkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgICdbSE1SXSB2dWUtbG9hZGVyIGhvdCByZWxvYWQgaXMgb25seSBjb21wYXRpYmxlIHdpdGggJyArXG4gICAgICAnVnVlLmpzIDEuMC4wKy4nXG4gICAgKVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gcGF0Y2ggdmlldyBkaXJlY3RpdmVcbiAgcGF0Y2hWaWV3KFZ1ZS5pbnRlcm5hbERpcmVjdGl2ZXMuY29tcG9uZW50KVxuICBjb25zb2xlLmxvZygnW0hNUl0gVnVlIGNvbXBvbmVudCBob3QgcmVsb2FkIHNoaW0gYXBwbGllZC4nKVxuICAvLyBzaGltIHJvdXRlci12aWV3IGlmIHByZXNlbnRcbiAgdmFyIHJvdXRlclZpZXcgPSBWdWUuZWxlbWVudERpcmVjdGl2ZSgncm91dGVyLXZpZXcnKVxuICBpZiAocm91dGVyVmlldykge1xuICAgIHBhdGNoVmlldyhyb3V0ZXJWaWV3KVxuICAgIGNvbnNvbGUubG9nKCdbSE1SXSB2dWUtcm91dGVyIDxyb3V0ZXItdmlldz4gaG90IHJlbG9hZCBzaGltIGFwcGxpZWQuJylcbiAgfVxufVxuXG4vKipcbiAqIFNoaW0gdGhlIHZpZXcgZGlyZWN0aXZlIChjb21wb25lbnQgb3Igcm91dGVyLXZpZXcpLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBWaWV3XG4gKi9cblxuZnVuY3Rpb24gcGF0Y2hWaWV3IChWaWV3KSB7XG4gIHZhciB1bmJ1aWxkID0gVmlldy51bmJ1aWxkXG4gIFZpZXcudW5idWlsZCA9IGZ1bmN0aW9uIChkZWZlcikge1xuICAgIGlmICghdGhpcy5ob3RVcGRhdGluZykge1xuICAgICAgdmFyIHByZXZDb21wb25lbnQgPSB0aGlzLmNoaWxkVk0gJiYgdGhpcy5jaGlsZFZNLmNvbnN0cnVjdG9yXG4gICAgICByZW1vdmVWaWV3KHByZXZDb21wb25lbnQsIHRoaXMpXG4gICAgICAvLyBkZWZlciA9IHRydWUgbWVhbnMgd2UgYXJlIHRyYW5zaXRpb25pbmcgdG8gYSBuZXdcbiAgICAgIC8vIENvbXBvbmVudC4gUmVnaXN0ZXIgdGhpcyBuZXcgY29tcG9uZW50IHRvIHRoZSBsaXN0LlxuICAgICAgaWYgKGRlZmVyKSB7XG4gICAgICAgIGFkZFZpZXcodGhpcy5Db21wb25lbnQsIHRoaXMpXG4gICAgICB9XG4gICAgfVxuICAgIC8vIGNhbGwgb3JpZ2luYWxcbiAgICByZXR1cm4gdW5idWlsZC5jYWxsKHRoaXMsIGRlZmVyKVxuICB9XG59XG5cbi8qKlxuICogQWRkIGEgY29tcG9uZW50IHZpZXcgdG8gYSBDb21wb25lbnQncyBob3QgbGlzdFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IENvbXBvbmVudFxuICogQHBhcmFtIHtEaXJlY3RpdmV9IHZpZXcgLSB2aWV3IGRpcmVjdGl2ZSBpbnN0YW5jZVxuICovXG5cbmZ1bmN0aW9uIGFkZFZpZXcgKENvbXBvbmVudCwgdmlldykge1xuICB2YXIgaWQgPSBDb21wb25lbnQgJiYgQ29tcG9uZW50Lm9wdGlvbnMuaG90SURcbiAgaWYgKGlkKSB7XG4gICAgaWYgKCFtYXBbaWRdKSB7XG4gICAgICBtYXBbaWRdID0ge1xuICAgICAgICBDb21wb25lbnQ6IENvbXBvbmVudCxcbiAgICAgICAgdmlld3M6IFtdLFxuICAgICAgICBpbnN0YW5jZXM6IFtdXG4gICAgICB9XG4gICAgfVxuICAgIG1hcFtpZF0udmlld3MucHVzaCh2aWV3KVxuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGEgY29tcG9uZW50IHZpZXcgZnJvbSBhIENvbXBvbmVudCdzIGhvdCBsaXN0XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gQ29tcG9uZW50XG4gKiBAcGFyYW0ge0RpcmVjdGl2ZX0gdmlldyAtIHZpZXcgZGlyZWN0aXZlIGluc3RhbmNlXG4gKi9cblxuZnVuY3Rpb24gcmVtb3ZlVmlldyAoQ29tcG9uZW50LCB2aWV3KSB7XG4gIHZhciBpZCA9IENvbXBvbmVudCAmJiBDb21wb25lbnQub3B0aW9ucy5ob3RJRFxuICBpZiAoaWQpIHtcbiAgICBtYXBbaWRdLnZpZXdzLiRyZW1vdmUodmlldylcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIHJlY29yZCBmb3IgYSBob3QgbW9kdWxlLCB3aGljaCBrZWVwcyB0cmFjayBvZiBpdHMgY29uc3RydWNvdHIsXG4gKiBpbnN0bmFjZXMgYW5kIHZpZXdzIChjb21wb25lbnQgZGlyZWN0aXZlcyBvciByb3V0ZXItdmlld3MpLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuXG5leHBvcnRzLmNyZWF0ZVJlY29yZCA9IGZ1bmN0aW9uIChpZCwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucy5vcHRpb25zXG4gIH1cbiAgaWYgKHR5cGVvZiBvcHRpb25zLmVsICE9PSAnc3RyaW5nJyAmJiB0eXBlb2Ygb3B0aW9ucy5kYXRhICE9PSAnb2JqZWN0Jykge1xuICAgIG1ha2VPcHRpb25zSG90KGlkLCBvcHRpb25zKVxuICAgIG1hcFtpZF0gPSB7XG4gICAgICBDb21wb25lbnQ6IG51bGwsXG4gICAgICB2aWV3czogW10sXG4gICAgICBpbnN0YW5jZXM6IFtdXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogTWFrZSBhIENvbXBvbmVudCBvcHRpb25zIG9iamVjdCBob3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIG1ha2VPcHRpb25zSG90IChpZCwgb3B0aW9ucykge1xuICBvcHRpb25zLmhvdElEID0gaWRcbiAgaW5qZWN0SG9vayhvcHRpb25zLCAnY3JlYXRlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVjb3JkID0gbWFwW2lkXVxuICAgIGlmICghcmVjb3JkLkNvbXBvbmVudCkge1xuICAgICAgcmVjb3JkLkNvbXBvbmVudCA9IHRoaXMuY29uc3RydWN0b3JcbiAgICB9XG4gICAgcmVjb3JkLmluc3RhbmNlcy5wdXNoKHRoaXMpXG4gIH0pXG4gIGluamVjdEhvb2sob3B0aW9ucywgJ2JlZm9yZURlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG4gICAgbWFwW2lkXS5pbnN0YW5jZXMuJHJlbW92ZSh0aGlzKVxuICB9KVxufVxuXG4vKipcbiAqIEluamVjdCBhIGhvb2sgdG8gYSBob3QgcmVsb2FkYWJsZSBjb21wb25lbnQgc28gdGhhdFxuICogd2UgY2FuIGtlZXAgdHJhY2sgb2YgaXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBob29rXG4gKi9cblxuZnVuY3Rpb24gaW5qZWN0SG9vayAob3B0aW9ucywgbmFtZSwgaG9vaykge1xuICB2YXIgZXhpc3RpbmcgPSBvcHRpb25zW25hbWVdXG4gIG9wdGlvbnNbbmFtZV0gPSBleGlzdGluZ1xuICAgID8gQXJyYXkuaXNBcnJheShleGlzdGluZylcbiAgICAgID8gZXhpc3RpbmcuY29uY2F0KGhvb2spXG4gICAgICA6IFtleGlzdGluZywgaG9va11cbiAgICA6IFtob29rXVxufVxuXG4vKipcbiAqIFVwZGF0ZSBhIGhvdCBjb21wb25lbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKiBAcGFyYW0ge09iamVjdHxudWxsfSBuZXdPcHRpb25zXG4gKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBuZXdUZW1wbGF0ZVxuICovXG5cbmV4cG9ydHMudXBkYXRlID0gZnVuY3Rpb24gKGlkLCBuZXdPcHRpb25zLCBuZXdUZW1wbGF0ZSkge1xuICB2YXIgcmVjb3JkID0gbWFwW2lkXVxuICAvLyBmb3JjZSBmdWxsLXJlbG9hZCBpZiBhbiBpbnN0YW5jZSBvZiB0aGUgY29tcG9uZW50IGlzIGFjdGl2ZSBidXQgaXMgbm90XG4gIC8vIG1hbmFnZWQgYnkgYSB2aWV3XG4gIGlmICghcmVjb3JkIHx8IChyZWNvcmQuaW5zdGFuY2VzLmxlbmd0aCAmJiAhcmVjb3JkLnZpZXdzLmxlbmd0aCkpIHtcbiAgICBjb25zb2xlLmxvZygnW0hNUl0gUm9vdCBvciBtYW51YWxseS1tb3VudGVkIGluc3RhbmNlIG1vZGlmaWVkLiBGdWxsIHJlbG9hZCBtYXkgYmUgcmVxdWlyZWQuJylcbiAgICBpZiAoIWlzQnJvd3NlcmlmeSkge1xuICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGJyb3dzZXJpZnktaG1yIHNvbWVob3cgc2VuZHMgaW5jb21wbGV0ZSBidW5kbGUgaWYgd2UgcmVsb2FkIGhlcmVcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuICBpZiAoIWlzQnJvd3NlcmlmeSkge1xuICAgIC8vIGJyb3dzZXJpZnktaG1yIGFscmVhZHkgbG9ncyB0aGlzXG4gICAgY29uc29sZS5sb2coJ1tITVJdIFVwZGF0aW5nIGNvbXBvbmVudDogJyArIGZvcm1hdChpZCkpXG4gIH1cbiAgdmFyIENvbXBvbmVudCA9IHJlY29yZC5Db21wb25lbnRcbiAgLy8gdXBkYXRlIGNvbnN0cnVjdG9yXG4gIGlmIChuZXdPcHRpb25zKSB7XG4gICAgLy8gaW4gY2FzZSB0aGUgdXNlciBleHBvcnRzIGEgY29uc3RydWN0b3JcbiAgICBDb21wb25lbnQgPSByZWNvcmQuQ29tcG9uZW50ID0gdHlwZW9mIG5ld09wdGlvbnMgPT09ICdmdW5jdGlvbidcbiAgICAgID8gbmV3T3B0aW9uc1xuICAgICAgOiBWdWUuZXh0ZW5kKG5ld09wdGlvbnMpXG4gICAgbWFrZU9wdGlvbnNIb3QoaWQsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG4gIGlmIChuZXdUZW1wbGF0ZSkge1xuICAgIENvbXBvbmVudC5vcHRpb25zLnRlbXBsYXRlID0gbmV3VGVtcGxhdGVcbiAgfVxuICAvLyBoYW5kbGUgcmVjdXJzaXZlIGxvb2t1cFxuICBpZiAoQ29tcG9uZW50Lm9wdGlvbnMubmFtZSkge1xuICAgIENvbXBvbmVudC5vcHRpb25zLmNvbXBvbmVudHNbQ29tcG9uZW50Lm9wdGlvbnMubmFtZV0gPSBDb21wb25lbnRcbiAgfVxuICAvLyByZXNldCBjb25zdHJ1Y3RvciBjYWNoZWQgbGlua2VyXG4gIENvbXBvbmVudC5saW5rZXIgPSBudWxsXG4gIC8vIHJlbG9hZCBhbGwgdmlld3NcbiAgcmVjb3JkLnZpZXdzLmZvckVhY2goZnVuY3Rpb24gKHZpZXcpIHtcbiAgICB1cGRhdGVWaWV3KHZpZXcsIENvbXBvbmVudClcbiAgfSlcbiAgLy8gZmx1c2ggZGV2dG9vbHNcbiAgaWYgKHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fKSB7XG4gICAgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uZW1pdCgnZmx1c2gnKVxuICB9XG59XG5cbi8qKlxuICogVXBkYXRlIGEgY29tcG9uZW50IHZpZXcgaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0ge0RpcmVjdGl2ZX0gdmlld1xuICogQHBhcmFtIHtGdW5jdGlvbn0gQ29tcG9uZW50XG4gKi9cblxuZnVuY3Rpb24gdXBkYXRlVmlldyAodmlldywgQ29tcG9uZW50KSB7XG4gIGlmICghdmlldy5fYm91bmQpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2aWV3LkNvbXBvbmVudCA9IENvbXBvbmVudFxuICB2aWV3LmhvdFVwZGF0aW5nID0gdHJ1ZVxuICAvLyBkaXNhYmxlIHRyYW5zaXRpb25zXG4gIHZpZXcudm0uX2lzQ29tcGlsZWQgPSBmYWxzZVxuICAvLyBzYXZlIHN0YXRlXG4gIHZhciBzdGF0ZSA9IGV4dHJhY3RTdGF0ZSh2aWV3LmNoaWxkVk0pXG4gIC8vIHJlbW91bnQsIG1ha2Ugc3VyZSB0byBkaXNhYmxlIGtlZXAtYWxpdmVcbiAgdmFyIGtlZXBBbGl2ZSA9IHZpZXcua2VlcEFsaXZlXG4gIHZpZXcua2VlcEFsaXZlID0gZmFsc2VcbiAgdmlldy5tb3VudENvbXBvbmVudCgpXG4gIHZpZXcua2VlcEFsaXZlID0ga2VlcEFsaXZlXG4gIC8vIHJlc3RvcmUgc3RhdGVcbiAgcmVzdG9yZVN0YXRlKHZpZXcuY2hpbGRWTSwgc3RhdGUsIHRydWUpXG4gIC8vIHJlLWVhbmJsZSB0cmFuc2l0aW9uc1xuICB2aWV3LnZtLl9pc0NvbXBpbGVkID0gdHJ1ZVxuICB2aWV3LmhvdFVwZGF0aW5nID0gZmFsc2Vcbn1cblxuLyoqXG4gKiBFeHRyYWN0IHN0YXRlIGZyb20gYSBWdWUgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gZXh0cmFjdFN0YXRlICh2bSkge1xuICByZXR1cm4ge1xuICAgIGNpZDogdm0uY29uc3RydWN0b3IuY2lkLFxuICAgIGRhdGE6IHZtLiRkYXRhLFxuICAgIGNoaWxkcmVuOiB2bS4kY2hpbGRyZW4ubWFwKGV4dHJhY3RTdGF0ZSlcbiAgfVxufVxuXG4vKipcbiAqIFJlc3RvcmUgc3RhdGUgdG8gYSByZWxvYWRlZCBWdWUgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcbiAqL1xuXG5mdW5jdGlvbiByZXN0b3JlU3RhdGUgKHZtLCBzdGF0ZSwgaXNSb290KSB7XG4gIHZhciBvbGRBc3luY0NvbmZpZ1xuICBpZiAoaXNSb290KSB7XG4gICAgLy8gc2V0IFZ1ZSBpbnRvIHN5bmMgbW9kZSBkdXJpbmcgc3RhdGUgcmVoeWRyYXRpb25cbiAgICBvbGRBc3luY0NvbmZpZyA9IFZ1ZS5jb25maWcuYXN5bmNcbiAgICBWdWUuY29uZmlnLmFzeW5jID0gZmFsc2VcbiAgfVxuICAvLyBhY3R1YWwgcmVzdG9yZVxuICBpZiAoaXNSb290IHx8ICF2bS5fcHJvcHMpIHtcbiAgICB2bS4kZGF0YSA9IHN0YXRlLmRhdGFcbiAgfSBlbHNlIHtcbiAgICBPYmplY3Qua2V5cyhzdGF0ZS5kYXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmICghdm0uX3Byb3BzW2tleV0pIHtcbiAgICAgICAgLy8gZm9yIG5vbi1yb290LCBvbmx5IHJlc3RvcmUgbm9uLXByb3BzIGZpZWxkc1xuICAgICAgICB2bS4kZGF0YVtrZXldID0gc3RhdGUuZGF0YVtrZXldXG4gICAgICB9XG4gICAgfSlcbiAgfVxuICAvLyB2ZXJpZnkgY2hpbGQgY29uc2lzdGVuY3lcbiAgdmFyIGhhc1NhbWVDaGlsZHJlbiA9IHZtLiRjaGlsZHJlbi5ldmVyeShmdW5jdGlvbiAoYywgaSkge1xuICAgIHJldHVybiBzdGF0ZS5jaGlsZHJlbltpXSAmJiBzdGF0ZS5jaGlsZHJlbltpXS5jaWQgPT09IGMuY29uc3RydWN0b3IuY2lkXG4gIH0pXG4gIGlmIChoYXNTYW1lQ2hpbGRyZW4pIHtcbiAgICAvLyByZWh5ZHJhdGUgY2hpbGRyZW5cbiAgICB2bS4kY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYywgaSkge1xuICAgICAgcmVzdG9yZVN0YXRlKGMsIHN0YXRlLmNoaWxkcmVuW2ldKVxuICAgIH0pXG4gIH1cbiAgaWYgKGlzUm9vdCkge1xuICAgIFZ1ZS5jb25maWcuYXN5bmMgPSBvbGRBc3luY0NvbmZpZ1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdCAoaWQpIHtcbiAgcmV0dXJuIGlkLm1hdGNoKC9bXlxcL10rXFwudnVlJC8pWzBdXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIHRlbXBsYXRlOiAnPG5hdiBjbGFzcz1cIiB7e25hdkNsYXNzfX0gXCI+JyArXHJcbiAgICAgICAgJzx1bCBjbGFzcz1cInBhZ2luYXRpb24ge3tzaXplfX0gXCI+JyArXHJcbiAgICAgICAgICAgICc8bGkgdi1pZj1cInBhZ2luYXRpb24uY3VycmVudF9wYWdlID4gMVwiPicgK1xyXG4gICAgICAgICAgICAgICAgJzxhIGhyZWY9XCIjXCIgYXJpYS1sYWJlbD1cIlByZXZpb3VzXCIgQGNsaWNrLnByZXZlbnQ9XCJjaGFuZ2VQYWdlKDEpXCI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPkZpcnN0PC9zcGFuPicgK1xyXG4gICAgICAgICAgICAgICAgJzwvYT4nICtcclxuICAgICAgICAgICAgJzwvbGk+JyArXHJcbiAgICAgICAgICAgICc8bGkgdi1pZj1cInBhZ2luYXRpb24uY3VycmVudF9wYWdlID4gMVwiPicgK1xyXG4gICAgICAgICAgICAgICAgJzxhIGhyZWY9XCIjXCIgYXJpYS1sYWJlbD1cIlByZXZpb3VzXCIgQGNsaWNrLnByZXZlbnQ9XCJjaGFuZ2VQYWdlKHBhZ2luYXRpb24uY3VycmVudF9wYWdlIC0gMSlcIj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+JmxhcXVvOzwvc3Bhbj4nICtcclxuICAgICAgICAgICAgICAgICc8L2E+JyArXHJcbiAgICAgICAgICAgICc8L2xpPicgK1xyXG4gICAgICAgICAgICAnPGxpIHYtaWY9XCJwYWdpbmF0aW9uLmN1cnJlbnRfcGFnZSA+IDFcIj4nICtcclxuICAgICAgICAgICAgICAgICc8YSBocmVmPVwiI1wiIGFyaWEtbGFiZWw9XCJOZXh0XCIgQGNsaWNrLnByZXZlbnQ9XCJjaGFuZ2VQYWdlKGZyb20pXCI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPi4uLjwvc3Bhbj4nICtcclxuICAgICAgICAgICAgICAgICc8L2E+JyArXHJcbiAgICAgICAgICAgICc8L2xpPicgK1xyXG4gICAgICAgICAgICAnPGxpIHYtZm9yPVwibnVtIGluIGRhdGFcIiA6Y2xhc3M9XCJ7XFwnYWN0aXZlXFwnOiBudW0gPT0gcGFnaW5hdGlvbi5jdXJyZW50X3BhZ2V9XCI+JyArXHJcbiAgICAgICAgICAgICAgICAnPGEgaHJlZj1cIiNcIiBAY2xpY2sucHJldmVudD1cImNoYW5nZVBhZ2UobnVtKVwiPnt7IG51bSB9fTwvYT4nICtcclxuICAgICAgICAgICAgJzwvbGk+JyArXHJcbiAgICAgICAgICAgICc8bGkgdi1pZj1cInBhZ2luYXRpb24uY3VycmVudF9wYWdlIDwgcGFnaW5hdGlvbi50b3RhbF9wYWdlc1wiPicgK1xyXG4gICAgICAgICAgICAgICAgJzxhIGhyZWY9XCIjXCIgYXJpYS1sYWJlbD1cIk5leHRcIiBAY2xpY2sucHJldmVudD1cImNoYW5nZVBhZ2UodG8pXCI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPi4uLjwvc3Bhbj4nICtcclxuICAgICAgICAgICAgICAgICc8L2E+JyArXHJcbiAgICAgICAgICAgICc8L2xpPicgK1xyXG4gICAgICAgICAgICAnPGxpIHYtaWY9XCJwYWdpbmF0aW9uLmN1cnJlbnRfcGFnZSA8IHBhZ2luYXRpb24udG90YWxfcGFnZXNcIj4nICtcclxuICAgICAgICAgICAgICAgICc8YSBocmVmPVwiI1wiIGFyaWEtbGFiZWw9XCJOZXh0XCIgQGNsaWNrLnByZXZlbnQ9XCJjaGFuZ2VQYWdlKHBhZ2luYXRpb24uY3VycmVudF9wYWdlICsgMSlcIj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+JnJhcXVvOzwvc3Bhbj4nICtcclxuICAgICAgICAgICAgICAgICc8L2E+JyArXHJcbiAgICAgICAgICAgICc8L2xpPicgK1xyXG4gICAgICAgICAgICAnPGxpIHYtaWY9XCJwYWdpbmF0aW9uLmN1cnJlbnRfcGFnZSA8IHBhZ2luYXRpb24udG90YWxfcGFnZXNcIj4nICtcclxuICAgICAgICAgICAgICAgICc8YSBocmVmPVwiI1wiIGFyaWEtbGFiZWw9XCJOZXh0XCIgQGNsaWNrLnByZXZlbnQ9XCJjaGFuZ2VQYWdlKHBhZ2luYXRpb24udG90YWxfcGFnZXMpXCI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPkxhc3Q8L3NwYW4+JyArXHJcbiAgICAgICAgICAgICAgICAnPC9hPicgK1xyXG4gICAgICAgICAgICAnPC9saT4nICtcclxuICAgICAgICAnPC91bD4nICtcclxuICAgICc8L25hdj4nLFxyXG5cclxuICAgIGRhdGE6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdG8gOiAwLFxyXG4gICAgICAgICAgICBmcm9tOiAwXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHByb3BzOiB7XHJcbiAgICAgICAgcGFnaW5hdGlvbjoge1xyXG4gICAgICAgICAgICB0eXBlOiBPYmplY3QsXHJcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXHJcbiAgICAgICAgfSxcclxuICAgICAgICBjYWxsYmFjazoge1xyXG4gICAgICAgICAgICB0eXBlOiBGdW5jdGlvbixcclxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNpemU6IHtcclxuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG4gICAgICAgICAgICBkZWZhdWx0OiBcIlwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBuYXZDbGFzczoge1xyXG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IFwiXCJcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9mZnNldDoge1xyXG4gICAgICAgICAgICB0eXBlOiBOdW1iZXIsXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IDRcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgY29tcHV0ZWQ6IHtcclxuICAgICAgICBkYXRhOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBmcm9tID0gdGhpcy5wYWdpbmF0aW9uLmN1cnJlbnRfcGFnZSAtIHRoaXMub2Zmc2V0O1xyXG4gICAgICAgICAgICBpZihmcm9tIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgZnJvbSA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciB0byA9IGZyb20gKyAodGhpcy5vZmZzZXQgKiAyKTtcclxuICAgICAgICAgICAgaWYodG8gPj0gdGhpcy5wYWdpbmF0aW9uLnRvdGFsX3BhZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICB0byA9IHRoaXMucGFnaW5hdGlvbi50b3RhbF9wYWdlcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xyXG4gICAgICAgICAgICB0aGlzLnRvID0gdG87XHJcblxyXG4gICAgICAgICAgICB2YXIgYXJyID0gW107XHJcbiAgICAgICAgICAgIHdoaWxlIChmcm9tIDw9dG8pIHtcclxuICAgICAgICAgICAgICAgIGFyci5wdXNoKGZyb20pO1xyXG4gICAgICAgICAgICAgICAgZnJvbSsrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYXJyO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICB3YXRjaDoge1xyXG4gICAgICAgICdwYWdpbmF0aW9uLnBlcl9wYWdlJzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1ldGhvZHM6IHtcclxuICAgICAgICBjaGFuZ2VQYWdlOiBmdW5jdGlvbiAocGFnZSkge1xyXG4gICAgICAgICAgICB0aGlzLiRzZXQoJ3BhZ2luYXRpb24uY3VycmVudF9wYWdlJywgcGFnZSk7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2soKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbiIsIi8qKlxuICogQmVmb3JlIEludGVyY2VwdG9yLlxuICovXG5cbnZhciBfID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIHJlcXVlc3Q6IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG5cbiAgICAgICAgaWYgKF8uaXNGdW5jdGlvbihyZXF1ZXN0LmJlZm9yZVNlbmQpKSB7XG4gICAgICAgICAgICByZXF1ZXN0LmJlZm9yZVNlbmQuY2FsbCh0aGlzLCByZXF1ZXN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH1cblxufTtcbiIsIi8qKlxuICogQmFzZSBjbGllbnQuXG4gKi9cblxudmFyIF8gPSByZXF1aXJlKCcuLi8uLi91dGlsJyk7XG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJy4uLy4uL3Byb21pc2UnKTtcbnZhciB4aHJDbGllbnQgPSByZXF1aXJlKCcuL3hocicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG5cbiAgICB2YXIgcmVzcG9uc2UgPSAocmVxdWVzdC5jbGllbnQgfHwgeGhyQ2xpZW50KShyZXF1ZXN0KTtcblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzcG9uc2UpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cbiAgICAgICAgaWYgKHJlc3BvbnNlLmhlYWRlcnMpIHtcblxuICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSBwYXJzZUhlYWRlcnMocmVzcG9uc2UuaGVhZGVycyk7XG5cbiAgICAgICAgICAgIHJlc3BvbnNlLmhlYWRlcnMgPSBmdW5jdGlvbiAobmFtZSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhlYWRlcnNbXy50b0xvd2VyKG5hbWUpXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3BvbnNlLm9rID0gcmVzcG9uc2Uuc3RhdHVzID49IDIwMCAmJiByZXNwb25zZS5zdGF0dXMgPCAzMDA7XG5cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0pO1xuXG59O1xuXG5mdW5jdGlvbiBwYXJzZUhlYWRlcnMoc3RyKSB7XG5cbiAgICB2YXIgaGVhZGVycyA9IHt9LCB2YWx1ZSwgbmFtZSwgaTtcblxuICAgIGlmIChfLmlzU3RyaW5nKHN0cikpIHtcbiAgICAgICAgXy5lYWNoKHN0ci5zcGxpdCgnXFxuJyksIGZ1bmN0aW9uIChyb3cpIHtcblxuICAgICAgICAgICAgaSA9IHJvdy5pbmRleE9mKCc6Jyk7XG4gICAgICAgICAgICBuYW1lID0gXy50cmltKF8udG9Mb3dlcihyb3cuc2xpY2UoMCwgaSkpKTtcbiAgICAgICAgICAgIHZhbHVlID0gXy50cmltKHJvdy5zbGljZShpICsgMSkpO1xuXG4gICAgICAgICAgICBpZiAoaGVhZGVyc1tuYW1lXSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKF8uaXNBcnJheShoZWFkZXJzW25hbWVdKSkge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzW25hbWVdLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbbmFtZV0gPSBbaGVhZGVyc1tuYW1lXSwgdmFsdWVdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGhlYWRlcnNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGVhZGVycztcbn1cbiIsIi8qKlxuICogSlNPTlAgY2xpZW50LlxuICovXG5cbnZhciBfID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpO1xudmFyIFByb21pc2UgPSByZXF1aXJlKCcuLi8uLi9wcm9taXNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcblxuICAgICAgICB2YXIgY2FsbGJhY2sgPSAnX2pzb25wJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyKSwgcmVzcG9uc2UgPSB7cmVxdWVzdDogcmVxdWVzdCwgZGF0YTogbnVsbH0sIGhhbmRsZXIsIHNjcmlwdDtcblxuICAgICAgICByZXF1ZXN0LnBhcmFtc1tyZXF1ZXN0Lmpzb25wXSA9IGNhbGxiYWNrO1xuICAgICAgICByZXF1ZXN0LmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGhhbmRsZXIoe3R5cGU6ICdjYW5jZWwnfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgIHNjcmlwdC5zcmMgPSBfLnVybChyZXF1ZXN0KTtcbiAgICAgICAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgICAgICAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcblxuICAgICAgICB3aW5kb3dbY2FsbGJhY2tdID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlLmRhdGEgPSBkYXRhO1xuICAgICAgICB9O1xuXG4gICAgICAgIGhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblxuICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdsb2FkJyAmJiByZXNwb25zZS5kYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzID0gMjAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC50eXBlID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzID0gNDA0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZS5zdGF0dXMgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcblxuICAgICAgICAgICAgZGVsZXRlIHdpbmRvd1tjYWxsYmFja107XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2NyaXB0Lm9ubG9hZCA9IGhhbmRsZXI7XG4gICAgICAgIHNjcmlwdC5vbmVycm9yID0gaGFuZGxlcjtcblxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgfSk7XG59O1xuIiwiLyoqXG4gKiBYRG9tYWluIGNsaWVudCAoSW50ZXJuZXQgRXhwbG9yZXIpLlxuICovXG5cbnZhciBfID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpO1xudmFyIFByb21pc2UgPSByZXF1aXJlKCcuLi8uLi9wcm9taXNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcblxuICAgICAgICB2YXIgeGRyID0gbmV3IFhEb21haW5SZXF1ZXN0KCksIHJlc3BvbnNlID0ge3JlcXVlc3Q6IHJlcXVlc3R9LCBoYW5kbGVyO1xuXG4gICAgICAgIHJlcXVlc3QuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgeGRyLmFib3J0KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgeGRyLm9wZW4ocmVxdWVzdC5tZXRob2QsIF8udXJsKHJlcXVlc3QpLCB0cnVlKTtcblxuICAgICAgICBoYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cbiAgICAgICAgICAgIHJlc3BvbnNlLmRhdGEgPSB4ZHIucmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzID0geGRyLnN0YXR1cztcbiAgICAgICAgICAgIHJlc3BvbnNlLnN0YXR1c1RleHQgPSB4ZHIuc3RhdHVzVGV4dDtcblxuICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgeGRyLnRpbWVvdXQgPSAwO1xuICAgICAgICB4ZHIub25sb2FkID0gaGFuZGxlcjtcbiAgICAgICAgeGRyLm9uYWJvcnQgPSBoYW5kbGVyO1xuICAgICAgICB4ZHIub25lcnJvciA9IGhhbmRsZXI7XG4gICAgICAgIHhkci5vbnRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgeGRyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgICAgICB4ZHIuc2VuZChyZXF1ZXN0LmRhdGEpO1xuICAgIH0pO1xufTtcbiIsIi8qKlxuICogWE1MSHR0cCBjbGllbnQuXG4gKi9cblxudmFyIF8gPSByZXF1aXJlKCcuLi8uLi91dGlsJyk7XG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJy4uLy4uL3Byb21pc2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuXG4gICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKSwgcmVzcG9uc2UgPSB7cmVxdWVzdDogcmVxdWVzdH0sIGhhbmRsZXI7XG5cbiAgICAgICAgcmVxdWVzdC5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB4aHIub3BlbihyZXF1ZXN0Lm1ldGhvZCwgXy51cmwocmVxdWVzdCksIHRydWUpO1xuXG4gICAgICAgIGhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblxuICAgICAgICAgICAgcmVzcG9uc2UuZGF0YSA9IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICByZXNwb25zZS5zdGF0dXMgPSB4aHIuc3RhdHVzO1xuICAgICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzVGV4dCA9IHhoci5zdGF0dXNUZXh0O1xuICAgICAgICAgICAgcmVzcG9uc2UuaGVhZGVycyA9IHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKTtcblxuICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgeGhyLnRpbWVvdXQgPSAwO1xuICAgICAgICB4aHIub25sb2FkID0gaGFuZGxlcjtcbiAgICAgICAgeGhyLm9uYWJvcnQgPSBoYW5kbGVyO1xuICAgICAgICB4aHIub25lcnJvciA9IGhhbmRsZXI7XG4gICAgICAgIHhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgeGhyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgICAgICBpZiAoXy5pc1BsYWluT2JqZWN0KHJlcXVlc3QueGhyKSkge1xuICAgICAgICAgICAgXy5leHRlbmQoeGhyLCByZXF1ZXN0Lnhocik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy5pc1BsYWluT2JqZWN0KHJlcXVlc3QudXBsb2FkKSkge1xuICAgICAgICAgICAgXy5leHRlbmQoeGhyLnVwbG9hZCwgcmVxdWVzdC51cGxvYWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgXy5lYWNoKHJlcXVlc3QuaGVhZGVycyB8fCB7fSwgZnVuY3Rpb24gKHZhbHVlLCBoZWFkZXIpIHtcbiAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlciwgdmFsdWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICB4aHIuc2VuZChyZXF1ZXN0LmRhdGEpO1xuICAgIH0pO1xufTtcbiIsIi8qKlxuICogQ09SUyBJbnRlcmNlcHRvci5cbiAqL1xuXG52YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciB4ZHJDbGllbnQgPSByZXF1aXJlKCcuL2NsaWVudC94ZHInKTtcbnZhciB4aHJDb3JzID0gJ3dpdGhDcmVkZW50aWFscycgaW4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG52YXIgb3JpZ2luVXJsID0gXy51cmwucGFyc2UobG9jYXRpb24uaHJlZik7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgcmVxdWVzdDogZnVuY3Rpb24gKHJlcXVlc3QpIHtcblxuICAgICAgICBpZiAocmVxdWVzdC5jcm9zc09yaWdpbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmVxdWVzdC5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luKHJlcXVlc3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlcXVlc3QuY3Jvc3NPcmlnaW4pIHtcblxuICAgICAgICAgICAgaWYgKCF4aHJDb3JzKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5jbGllbnQgPSB4ZHJDbGllbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlcXVlc3QuZW11bGF0ZUhUVFAgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH1cblxufTtcblxuZnVuY3Rpb24gY3Jvc3NPcmlnaW4ocmVxdWVzdCkge1xuXG4gICAgdmFyIHJlcXVlc3RVcmwgPSBfLnVybC5wYXJzZShfLnVybChyZXF1ZXN0KSk7XG5cbiAgICByZXR1cm4gKHJlcXVlc3RVcmwucHJvdG9jb2wgIT09IG9yaWdpblVybC5wcm90b2NvbCB8fCByZXF1ZXN0VXJsLmhvc3QgIT09IG9yaWdpblVybC5ob3N0KTtcbn1cbiIsIi8qKlxuICogSGVhZGVyIEludGVyY2VwdG9yLlxuICovXG5cbnZhciBfID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIHJlcXVlc3Q6IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG5cbiAgICAgICAgcmVxdWVzdC5tZXRob2QgPSByZXF1ZXN0Lm1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICByZXF1ZXN0LmhlYWRlcnMgPSBfLmV4dGVuZCh7fSwgXy5odHRwLmhlYWRlcnMuY29tbW9uLFxuICAgICAgICAgICAgIXJlcXVlc3QuY3Jvc3NPcmlnaW4gPyBfLmh0dHAuaGVhZGVycy5jdXN0b20gOiB7fSxcbiAgICAgICAgICAgIF8uaHR0cC5oZWFkZXJzW3JlcXVlc3QubWV0aG9kLnRvTG93ZXJDYXNlKCldLFxuICAgICAgICAgICAgcmVxdWVzdC5oZWFkZXJzXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKF8uaXNQbGFpbk9iamVjdChyZXF1ZXN0LmRhdGEpICYmIC9eKEdFVHxKU09OUCkkL2kudGVzdChyZXF1ZXN0Lm1ldGhvZCkpIHtcbiAgICAgICAgICAgIF8uZXh0ZW5kKHJlcXVlc3QucGFyYW1zLCByZXF1ZXN0LmRhdGEpO1xuICAgICAgICAgICAgZGVsZXRlIHJlcXVlc3QuZGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH1cblxufTtcbiIsIi8qKlxuICogU2VydmljZSBmb3Igc2VuZGluZyBuZXR3b3JrIHJlcXVlc3RzLlxuICovXG5cbnZhciBfID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIENsaWVudCA9IHJlcXVpcmUoJy4vY2xpZW50Jyk7XG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJy4uL3Byb21pc2UnKTtcbnZhciBpbnRlcmNlcHRvciA9IHJlcXVpcmUoJy4vaW50ZXJjZXB0b3InKTtcbnZhciBqc29uVHlwZSA9IHsnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nfTtcblxuZnVuY3Rpb24gSHR0cCh1cmwsIG9wdGlvbnMpIHtcblxuICAgIHZhciBjbGllbnQgPSBDbGllbnQsIHJlcXVlc3QsIHByb21pc2U7XG5cbiAgICBIdHRwLmludGVyY2VwdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgIGNsaWVudCA9IGludGVyY2VwdG9yKGhhbmRsZXIsIHRoaXMuJHZtKShjbGllbnQpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgb3B0aW9ucyA9IF8uaXNPYmplY3QodXJsKSA/IHVybCA6IF8uZXh0ZW5kKHt1cmw6IHVybH0sIG9wdGlvbnMpO1xuICAgIHJlcXVlc3QgPSBfLm1lcmdlKHt9LCBIdHRwLm9wdGlvbnMsIHRoaXMuJG9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIHByb21pc2UgPSBjbGllbnQocmVxdWVzdCkuYmluZCh0aGlzLiR2bSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcblxuICAgICAgICByZXR1cm4gcmVzcG9uc2Uub2sgPyByZXNwb25zZSA6IFByb21pc2UucmVqZWN0KHJlc3BvbnNlKTtcblxuICAgIH0sIGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXG4gICAgICAgIGlmIChyZXNwb25zZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICBfLmVycm9yKHJlc3BvbnNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZXNwb25zZSk7XG4gICAgfSk7XG5cbiAgICBpZiAocmVxdWVzdC5zdWNjZXNzKSB7XG4gICAgICAgIHByb21pc2Uuc3VjY2VzcyhyZXF1ZXN0LnN1Y2Nlc3MpO1xuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0LmVycm9yKSB7XG4gICAgICAgIHByb21pc2UuZXJyb3IocmVxdWVzdC5lcnJvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbkh0dHAub3B0aW9ucyA9IHtcbiAgICBtZXRob2Q6ICdnZXQnLFxuICAgIGRhdGE6ICcnLFxuICAgIHBhcmFtczoge30sXG4gICAgaGVhZGVyczoge30sXG4gICAgeGhyOiBudWxsLFxuICAgIHVwbG9hZDogbnVsbCxcbiAgICBqc29ucDogJ2NhbGxiYWNrJyxcbiAgICBiZWZvcmVTZW5kOiBudWxsLFxuICAgIGNyb3NzT3JpZ2luOiBudWxsLFxuICAgIGVtdWxhdGVIVFRQOiBmYWxzZSxcbiAgICBlbXVsYXRlSlNPTjogZmFsc2UsXG4gICAgdGltZW91dDogMFxufTtcblxuSHR0cC5pbnRlcmNlcHRvcnMgPSBbXG4gICAgcmVxdWlyZSgnLi9iZWZvcmUnKSxcbiAgICByZXF1aXJlKCcuL3RpbWVvdXQnKSxcbiAgICByZXF1aXJlKCcuL2pzb25wJyksXG4gICAgcmVxdWlyZSgnLi9tZXRob2QnKSxcbiAgICByZXF1aXJlKCcuL21pbWUnKSxcbiAgICByZXF1aXJlKCcuL2hlYWRlcicpLFxuICAgIHJlcXVpcmUoJy4vY29ycycpXG5dO1xuXG5IdHRwLmhlYWRlcnMgPSB7XG4gICAgcHV0OiBqc29uVHlwZSxcbiAgICBwb3N0OiBqc29uVHlwZSxcbiAgICBwYXRjaDoganNvblR5cGUsXG4gICAgZGVsZXRlOiBqc29uVHlwZSxcbiAgICBjb21tb246IHsnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4sICovKid9LFxuICAgIGN1c3RvbTogeydYLVJlcXVlc3RlZC1XaXRoJzogJ1hNTEh0dHBSZXF1ZXN0J31cbn07XG5cblsnZ2V0JywgJ3B1dCcsICdwb3N0JywgJ3BhdGNoJywgJ2RlbGV0ZScsICdqc29ucCddLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuXG4gICAgSHR0cFttZXRob2RdID0gZnVuY3Rpb24gKHVybCwgZGF0YSwgc3VjY2Vzcywgb3B0aW9ucykge1xuXG4gICAgICAgIGlmIChfLmlzRnVuY3Rpb24oZGF0YSkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBzdWNjZXNzO1xuICAgICAgICAgICAgc3VjY2VzcyA9IGRhdGE7XG4gICAgICAgICAgICBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8uaXNPYmplY3Qoc3VjY2VzcykpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBzdWNjZXNzO1xuICAgICAgICAgICAgc3VjY2VzcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzKHVybCwgXy5leHRlbmQoe21ldGhvZDogbWV0aG9kLCBkYXRhOiBkYXRhLCBzdWNjZXNzOiBzdWNjZXNzfSwgb3B0aW9ucykpO1xuICAgIH07XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfLmh0dHAgPSBIdHRwO1xuIiwiLyoqXG4gKiBJbnRlcmNlcHRvciBmYWN0b3J5LlxuICovXG5cbnZhciBfID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIFByb21pc2UgPSByZXF1aXJlKCcuLi9wcm9taXNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGhhbmRsZXIsIHZtKSB7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKGNsaWVudCkge1xuXG4gICAgICAgIGlmIChfLmlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICAgICAgICAgIGhhbmRsZXIgPSBoYW5kbGVyLmNhbGwodm0sIFByb21pc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG5cbiAgICAgICAgICAgIGlmIChfLmlzRnVuY3Rpb24oaGFuZGxlci5yZXF1ZXN0KSkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSBoYW5kbGVyLnJlcXVlc3QuY2FsbCh2bSwgcmVxdWVzdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB3aGVuKHJlcXVlc3QsIGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdoZW4oY2xpZW50KHJlcXVlc3QpLCBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKGhhbmRsZXIucmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGhhbmRsZXIucmVzcG9uc2UuY2FsbCh2bSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfTtcbn07XG5cbmZ1bmN0aW9uIHdoZW4odmFsdWUsIGZ1bGZpbGxlZCwgcmVqZWN0ZWQpIHtcblxuICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xufVxuIiwiLyoqXG4gKiBKU09OUCBJbnRlcmNlcHRvci5cbiAqL1xuXG52YXIganNvbnBDbGllbnQgPSByZXF1aXJlKCcuL2NsaWVudC9qc29ucCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIHJlcXVlc3Q6IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG5cbiAgICAgICAgaWYgKHJlcXVlc3QubWV0aG9kID09ICdKU09OUCcpIHtcbiAgICAgICAgICAgIHJlcXVlc3QuY2xpZW50ID0ganNvbnBDbGllbnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9XG5cbn07XG4iLCIvKipcbiAqIEhUVFAgbWV0aG9kIG92ZXJyaWRlIEludGVyY2VwdG9yLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgcmVxdWVzdDogZnVuY3Rpb24gKHJlcXVlc3QpIHtcblxuICAgICAgICBpZiAocmVxdWVzdC5lbXVsYXRlSFRUUCAmJiAvXihQVVR8UEFUQ0h8REVMRVRFKSQvaS50ZXN0KHJlcXVlc3QubWV0aG9kKSkge1xuICAgICAgICAgICAgcmVxdWVzdC5oZWFkZXJzWydYLUhUVFAtTWV0aG9kLU92ZXJyaWRlJ10gPSByZXF1ZXN0Lm1ldGhvZDtcbiAgICAgICAgICAgIHJlcXVlc3QubWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfVxuXG59O1xuIiwiLyoqXG4gKiBNaW1lIEludGVyY2VwdG9yLlxuICovXG5cbnZhciBfID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIHJlcXVlc3Q6IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG5cbiAgICAgICAgaWYgKHJlcXVlc3QuZW11bGF0ZUpTT04gJiYgXy5pc1BsYWluT2JqZWN0KHJlcXVlc3QuZGF0YSkpIHtcbiAgICAgICAgICAgIHJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJztcbiAgICAgICAgICAgIHJlcXVlc3QuZGF0YSA9IF8udXJsLnBhcmFtcyhyZXF1ZXN0LmRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8uaXNPYmplY3QocmVxdWVzdC5kYXRhKSAmJiAvRm9ybURhdGEvaS50ZXN0KHJlcXVlc3QuZGF0YS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgZGVsZXRlIHJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1UeXBlJ107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy5pc1BsYWluT2JqZWN0KHJlcXVlc3QuZGF0YSkpIHtcbiAgICAgICAgICAgIHJlcXVlc3QuZGF0YSA9IEpTT04uc3RyaW5naWZ5KHJlcXVlc3QuZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9LFxuXG4gICAgcmVzcG9uc2U6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXNwb25zZS5kYXRhID0gSlNPTi5wYXJzZShyZXNwb25zZS5kYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuXG59O1xuIiwiLyoqXG4gKiBUaW1lb3V0IEludGVyY2VwdG9yLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHRpbWVvdXQ7XG5cbiAgICByZXR1cm4ge1xuXG4gICAgICAgIHJlcXVlc3Q6IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG5cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LnRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgfSwgcmVxdWVzdC50aW1lb3V0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVzcG9uc2U6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfVxuXG4gICAgfTtcbn07XG4iLCIvKipcbiAqIEluc3RhbGwgcGx1Z2luLlxuICovXG5cbmZ1bmN0aW9uIGluc3RhbGwoVnVlKSB7XG5cbiAgICB2YXIgXyA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4gICAgXy5jb25maWcgPSBWdWUuY29uZmlnO1xuICAgIF8ud2FybmluZyA9IFZ1ZS51dGlsLndhcm47XG4gICAgXy5uZXh0VGljayA9IFZ1ZS51dGlsLm5leHRUaWNrO1xuXG4gICAgVnVlLnVybCA9IHJlcXVpcmUoJy4vdXJsJyk7XG4gICAgVnVlLmh0dHAgPSByZXF1aXJlKCcuL2h0dHAnKTtcbiAgICBWdWUucmVzb3VyY2UgPSByZXF1aXJlKCcuL3Jlc291cmNlJyk7XG4gICAgVnVlLlByb21pc2UgPSByZXF1aXJlKCcuL3Byb21pc2UnKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFZ1ZS5wcm90b3R5cGUsIHtcblxuICAgICAgICAkdXJsOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5vcHRpb25zKFZ1ZS51cmwsIHRoaXMsIHRoaXMuJG9wdGlvbnMudXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAkaHR0cDoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF8ub3B0aW9ucyhWdWUuaHR0cCwgdGhpcywgdGhpcy4kb3B0aW9ucy5odHRwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAkcmVzb3VyY2U6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBWdWUucmVzb3VyY2UuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAkcHJvbWlzZToge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChleGVjdXRvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZ1ZS5Qcm9taXNlKGV4ZWN1dG9yLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0pO1xufVxuXG5pZiAod2luZG93LlZ1ZSkge1xuICAgIFZ1ZS51c2UoaW5zdGFsbCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5zdGFsbDtcbiIsIi8qKlxuICogUHJvbWlzZXMvQSsgcG9seWZpbGwgdjEuMS40IChodHRwczovL2dpdGh1Yi5jb20vYnJhbXN0ZWluL3Byb21pcylcbiAqL1xuXG52YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxudmFyIFJFU09MVkVEID0gMDtcbnZhciBSRUpFQ1RFRCA9IDE7XG52YXIgUEVORElORyAgPSAyO1xuXG5mdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG5cbiAgICB0aGlzLnN0YXRlID0gUEVORElORztcbiAgICB0aGlzLnZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZGVmZXJyZWQgPSBbXTtcblxuICAgIHZhciBwcm9taXNlID0gdGhpcztcblxuICAgIHRyeSB7XG4gICAgICAgIGV4ZWN1dG9yKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICBwcm9taXNlLnJlc29sdmUoeCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICBwcm9taXNlLnJlamVjdChyKTtcbiAgICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBwcm9taXNlLnJlamVjdChlKTtcbiAgICB9XG59XG5cblByb21pc2UucmVqZWN0ID0gZnVuY3Rpb24gKHIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICByZWplY3Qocik7XG4gICAgfSk7XG59O1xuXG5Qcm9taXNlLnJlc29sdmUgPSBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHJlc29sdmUoeCk7XG4gICAgfSk7XG59O1xuXG5Qcm9taXNlLmFsbCA9IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBjb3VudCA9IDAsIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGlmIChpdGVyYWJsZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlc29sdmVyKGkpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IHg7XG4gICAgICAgICAgICAgICAgY291bnQgKz0gMTtcblxuICAgICAgICAgICAgICAgIGlmIChjb3VudCA9PT0gaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVyYWJsZS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGl0ZXJhYmxlW2ldKS50aGVuKHJlc29sdmVyKGkpLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG5Qcm9taXNlLnJhY2UgPSBmdW5jdGlvbiByYWNlKGl0ZXJhYmxlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVyYWJsZS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGl0ZXJhYmxlW2ldKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbnZhciBwID0gUHJvbWlzZS5wcm90b3R5cGU7XG5cbnAucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUoeCkge1xuICAgIHZhciBwcm9taXNlID0gdGhpcztcblxuICAgIGlmIChwcm9taXNlLnN0YXRlID09PSBQRU5ESU5HKSB7XG4gICAgICAgIGlmICh4ID09PSBwcm9taXNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcm9taXNlIHNldHRsZWQgd2l0aCBpdHNlbGYuJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2FsbGVkID0gZmFsc2U7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciB0aGVuID0geCAmJiB4Wyd0aGVuJ107XG5cbiAgICAgICAgICAgIGlmICh4ICE9PSBudWxsICYmIHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRoZW4uY2FsbCh4LCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKHgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhbGxlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5yZWplY3Qocik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5yZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBwcm9taXNlLnN0YXRlID0gUkVTT0xWRUQ7XG4gICAgICAgIHByb21pc2UudmFsdWUgPSB4O1xuICAgICAgICBwcm9taXNlLm5vdGlmeSgpO1xuICAgIH1cbn07XG5cbnAucmVqZWN0ID0gZnVuY3Rpb24gcmVqZWN0KHJlYXNvbikge1xuICAgIHZhciBwcm9taXNlID0gdGhpcztcblxuICAgIGlmIChwcm9taXNlLnN0YXRlID09PSBQRU5ESU5HKSB7XG4gICAgICAgIGlmIChyZWFzb24gPT09IHByb21pc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb21pc2Ugc2V0dGxlZCB3aXRoIGl0c2VsZi4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb21pc2Uuc3RhdGUgPSBSRUpFQ1RFRDtcbiAgICAgICAgcHJvbWlzZS52YWx1ZSA9IHJlYXNvbjtcbiAgICAgICAgcHJvbWlzZS5ub3RpZnkoKTtcbiAgICB9XG59O1xuXG5wLm5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeSgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG5cbiAgICBfLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHByb21pc2Uuc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICAgICAgICAgIHdoaWxlIChwcm9taXNlLmRlZmVycmVkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBkZWZlcnJlZCA9IHByb21pc2UuZGVmZXJyZWQuc2hpZnQoKSxcbiAgICAgICAgICAgICAgICAgICAgb25SZXNvbHZlZCA9IGRlZmVycmVkWzBdLFxuICAgICAgICAgICAgICAgICAgICBvblJlamVjdGVkID0gZGVmZXJyZWRbMV0sXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUgPSBkZWZlcnJlZFsyXSxcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0ID0gZGVmZXJyZWRbM107XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvbWlzZS5zdGF0ZSA9PT0gUkVTT0xWRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb25SZXNvbHZlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUob25SZXNvbHZlZC5jYWxsKHVuZGVmaW5lZCwgcHJvbWlzZS52YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHByb21pc2UudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb21pc2Uuc3RhdGUgPT09IFJFSkVDVEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9uUmVqZWN0ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG9uUmVqZWN0ZWQuY2FsbCh1bmRlZmluZWQsIHByb21pc2UudmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHByb21pc2UudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG5wLnRoZW4gPSBmdW5jdGlvbiB0aGVuKG9uUmVzb2x2ZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBwcm9taXNlLmRlZmVycmVkLnB1c2goW29uUmVzb2x2ZWQsIG9uUmVqZWN0ZWQsIHJlc29sdmUsIHJlamVjdF0pO1xuICAgICAgICBwcm9taXNlLm5vdGlmeSgpO1xuICAgIH0pO1xufTtcblxucC5jYXRjaCA9IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuIiwiLyoqXG4gKiBVUkwgVGVtcGxhdGUgdjIuMC42IChodHRwczovL2dpdGh1Yi5jb20vYnJhbXN0ZWluL3VybC10ZW1wbGF0ZSlcbiAqL1xuXG5leHBvcnRzLmV4cGFuZCA9IGZ1bmN0aW9uICh1cmwsIHBhcmFtcywgdmFyaWFibGVzKSB7XG5cbiAgICB2YXIgdG1wbCA9IHRoaXMucGFyc2UodXJsKSwgZXhwYW5kZWQgPSB0bXBsLmV4cGFuZChwYXJhbXMpO1xuXG4gICAgaWYgKHZhcmlhYmxlcykge1xuICAgICAgICB2YXJpYWJsZXMucHVzaC5hcHBseSh2YXJpYWJsZXMsIHRtcGwudmFycyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cGFuZGVkO1xufTtcblxuZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xuXG4gICAgdmFyIG9wZXJhdG9ycyA9IFsnKycsICcjJywgJy4nLCAnLycsICc7JywgJz8nLCAnJiddLCB2YXJpYWJsZXMgPSBbXTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHZhcnM6IHZhcmlhYmxlcyxcbiAgICAgICAgZXhwYW5kOiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIHRlbXBsYXRlLnJlcGxhY2UoL1xceyhbXlxce1xcfV0rKVxcfXwoW15cXHtcXH1dKykvZywgZnVuY3Rpb24gKF8sIGV4cHJlc3Npb24sIGxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvbikge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcGVyYXRvciA9IG51bGwsIHZhbHVlcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGVyYXRvcnMuaW5kZXhPZihleHByZXNzaW9uLmNoYXJBdCgwKSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvciA9IGV4cHJlc3Npb24uY2hhckF0KDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb24uc3Vic3RyKDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbi5zcGxpdCgvLC9nKS5mb3JFYWNoKGZ1bmN0aW9uICh2YXJpYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRtcCA9IC8oW146XFwqXSopKD86OihcXGQrKXwoXFwqKSk/Ly5leGVjKHZhcmlhYmxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoLmFwcGx5KHZhbHVlcywgZXhwb3J0cy5nZXRWYWx1ZXMoY29udGV4dCwgb3BlcmF0b3IsIHRtcFsxXSwgdG1wWzJdIHx8IHRtcFszXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzLnB1c2godG1wWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wZXJhdG9yICYmIG9wZXJhdG9yICE9PSAnKycpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlcGFyYXRvciA9ICcsJztcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wZXJhdG9yID09PSAnPycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXBhcmF0b3IgPSAnJic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wZXJhdG9yICE9PSAnIycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXBhcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh2YWx1ZXMubGVuZ3RoICE9PSAwID8gb3BlcmF0b3IgOiAnJykgKyB2YWx1ZXMuam9pbihzZXBhcmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlcy5qb2luKCcsJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBleHBvcnRzLmVuY29kZVJlc2VydmVkKGxpdGVyYWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbmV4cG9ydHMuZ2V0VmFsdWVzID0gZnVuY3Rpb24gKGNvbnRleHQsIG9wZXJhdG9yLCBrZXksIG1vZGlmaWVyKSB7XG5cbiAgICB2YXIgdmFsdWUgPSBjb250ZXh0W2tleV0sIHJlc3VsdCA9IFtdO1xuXG4gICAgaWYgKHRoaXMuaXNEZWZpbmVkKHZhbHVlKSAmJiB2YWx1ZSAhPT0gJycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuXG4gICAgICAgICAgICBpZiAobW9kaWZpZXIgJiYgbW9kaWZpZXIgIT09ICcqJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDAsIHBhcnNlSW50KG1vZGlmaWVyLCAxMCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmVuY29kZVZhbHVlKG9wZXJhdG9yLCB2YWx1ZSwgdGhpcy5pc0tleU9wZXJhdG9yKG9wZXJhdG9yKSA/IGtleSA6IG51bGwpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChtb2RpZmllciA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLmZpbHRlcih0aGlzLmlzRGVmaW5lZCkuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZW5jb2RlVmFsdWUob3BlcmF0b3IsIHZhbHVlLCB0aGlzLmlzS2V5T3BlcmF0b3Iob3BlcmF0b3IpID8ga2V5IDogbnVsbCkpO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNEZWZpbmVkKHZhbHVlW2tdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZW5jb2RlVmFsdWUob3BlcmF0b3IsIHZhbHVlW2tdLCBrKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHRtcCA9IFtdO1xuXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLmZpbHRlcih0aGlzLmlzRGVmaW5lZCkuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcC5wdXNoKHRoaXMuZW5jb2RlVmFsdWUob3BlcmF0b3IsIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHZhbHVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0RlZmluZWQodmFsdWVba10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGspKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAucHVzaCh0aGlzLmVuY29kZVZhbHVlKG9wZXJhdG9yLCB2YWx1ZVtrXS50b1N0cmluZygpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzS2V5T3BlcmF0b3Iob3BlcmF0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nICsgdG1wLmpvaW4oJywnKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0bXAubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRtcC5qb2luKCcsJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvcGVyYXRvciA9PT0gJzsnKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09ICcnICYmIChvcGVyYXRvciA9PT0gJyYnIHx8IG9wZXJhdG9yID09PSAnPycpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICc9Jyk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuZXhwb3J0cy5pc0RlZmluZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbDtcbn07XG5cbmV4cG9ydHMuaXNLZXlPcGVyYXRvciA9IGZ1bmN0aW9uIChvcGVyYXRvcikge1xuICAgIHJldHVybiBvcGVyYXRvciA9PT0gJzsnIHx8IG9wZXJhdG9yID09PSAnJicgfHwgb3BlcmF0b3IgPT09ICc/Jztcbn07XG5cbmV4cG9ydHMuZW5jb2RlVmFsdWUgPSBmdW5jdGlvbiAob3BlcmF0b3IsIHZhbHVlLCBrZXkpIHtcblxuICAgIHZhbHVlID0gKG9wZXJhdG9yID09PSAnKycgfHwgb3BlcmF0b3IgPT09ICcjJykgPyB0aGlzLmVuY29kZVJlc2VydmVkKHZhbHVlKSA6IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICc9JyArIHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59O1xuXG5leHBvcnRzLmVuY29kZVJlc2VydmVkID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBzdHIuc3BsaXQoLyglWzAtOUEtRmEtZl17Mn0pL2cpLm1hcChmdW5jdGlvbiAocGFydCkge1xuICAgICAgICBpZiAoIS8lWzAtOUEtRmEtZl0vLnRlc3QocGFydCkpIHtcbiAgICAgICAgICAgIHBhcnQgPSBlbmNvZGVVUkkocGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgfSkuam9pbignJyk7XG59O1xuIiwiLyoqXG4gKiBQcm9taXNlIGFkYXB0ZXIuXG4gKi9cblxudmFyIF8gPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBQcm9taXNlT2JqID0gd2luZG93LlByb21pc2UgfHwgcmVxdWlyZSgnLi9saWIvcHJvbWlzZScpO1xuXG5mdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yLCBjb250ZXh0KSB7XG5cbiAgICBpZiAoZXhlY3V0b3IgaW5zdGFuY2VvZiBQcm9taXNlT2JqKSB7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IGV4ZWN1dG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlT2JqKGV4ZWN1dG9yLmJpbmQoY29udGV4dCkpO1xuICAgIH1cblxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG59XG5cblByb21pc2UuYWxsID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKFByb21pc2VPYmouYWxsKGl0ZXJhYmxlKSwgY29udGV4dCk7XG59O1xuXG5Qcm9taXNlLnJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoUHJvbWlzZU9iai5yZXNvbHZlKHZhbHVlKSwgY29udGV4dCk7XG59O1xuXG5Qcm9taXNlLnJlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24sIGNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoUHJvbWlzZU9iai5yZWplY3QocmVhc29uKSwgY29udGV4dCk7XG59O1xuXG5Qcm9taXNlLnJhY2UgPSBmdW5jdGlvbiAoaXRlcmFibGUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoUHJvbWlzZU9iai5yYWNlKGl0ZXJhYmxlKSwgY29udGV4dCk7XG59O1xuXG52YXIgcCA9IFByb21pc2UucHJvdG90eXBlO1xuXG5wLmJpbmQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5wLnRoZW4gPSBmdW5jdGlvbiAoZnVsZmlsbGVkLCByZWplY3RlZCkge1xuXG4gICAgaWYgKGZ1bGZpbGxlZCAmJiBmdWxmaWxsZWQuYmluZCAmJiB0aGlzLmNvbnRleHQpIHtcbiAgICAgICAgZnVsZmlsbGVkID0gZnVsZmlsbGVkLmJpbmQodGhpcy5jb250ZXh0KTtcbiAgICB9XG5cbiAgICBpZiAocmVqZWN0ZWQgJiYgcmVqZWN0ZWQuYmluZCAmJiB0aGlzLmNvbnRleHQpIHtcbiAgICAgICAgcmVqZWN0ZWQgPSByZWplY3RlZC5iaW5kKHRoaXMuY29udGV4dCk7XG4gICAgfVxuXG4gICAgdGhpcy5wcm9taXNlID0gdGhpcy5wcm9taXNlLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbnAuY2F0Y2ggPSBmdW5jdGlvbiAocmVqZWN0ZWQpIHtcblxuICAgIGlmIChyZWplY3RlZCAmJiByZWplY3RlZC5iaW5kICYmIHRoaXMuY29udGV4dCkge1xuICAgICAgICByZWplY3RlZCA9IHJlamVjdGVkLmJpbmQodGhpcy5jb250ZXh0KTtcbiAgICB9XG5cbiAgICB0aGlzLnByb21pc2UgPSB0aGlzLnByb21pc2UuY2F0Y2gocmVqZWN0ZWQpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5wLmZpbmFsbHkgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblxuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2VPYmoucmVqZWN0KHJlYXNvbik7XG4gICAgICAgIH1cbiAgICApO1xufTtcblxucC5zdWNjZXNzID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cbiAgICBfLndhcm4oJ1RoZSBgc3VjY2Vzc2AgbWV0aG9kIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSB0aGUgYHRoZW5gIG1ldGhvZCBpbnN0ZWFkLicpO1xuXG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpcywgcmVzcG9uc2UuZGF0YSwgcmVzcG9uc2Uuc3RhdHVzLCByZXNwb25zZSkgfHwgcmVzcG9uc2U7XG4gICAgfSk7XG59O1xuXG5wLmVycm9yID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cbiAgICBfLndhcm4oJ1RoZSBgZXJyb3JgIG1ldGhvZCBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgdGhlIGBjYXRjaGAgbWV0aG9kIGluc3RlYWQuJyk7XG5cbiAgICByZXR1cm4gdGhpcy5jYXRjaChmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpcywgcmVzcG9uc2UuZGF0YSwgcmVzcG9uc2Uuc3RhdHVzLCByZXNwb25zZSkgfHwgcmVzcG9uc2U7XG4gICAgfSk7XG59O1xuXG5wLmFsd2F5cyA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXG4gICAgXy53YXJuKCdUaGUgYGFsd2F5c2AgbWV0aG9kIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSB0aGUgYGZpbmFsbHlgIG1ldGhvZCBpbnN0ZWFkLicpO1xuXG4gICAgdmFyIGNiID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXMsIHJlc3BvbnNlLmRhdGEsIHJlc3BvbnNlLnN0YXR1cywgcmVzcG9uc2UpIHx8IHJlc3BvbnNlO1xuICAgIH07XG5cbiAgICByZXR1cm4gdGhpcy50aGVuKGNiLCBjYik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG4iLCIvKipcbiAqIFNlcnZpY2UgZm9yIGludGVyYWN0aW5nIHdpdGggUkVTVGZ1bCBzZXJ2aWNlcy5cbiAqL1xuXG52YXIgXyA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5mdW5jdGlvbiBSZXNvdXJjZSh1cmwsIHBhcmFtcywgYWN0aW9ucywgb3B0aW9ucykge1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzLCByZXNvdXJjZSA9IHt9O1xuXG4gICAgYWN0aW9ucyA9IF8uZXh0ZW5kKHt9LFxuICAgICAgICBSZXNvdXJjZS5hY3Rpb25zLFxuICAgICAgICBhY3Rpb25zXG4gICAgKTtcblxuICAgIF8uZWFjaChhY3Rpb25zLCBmdW5jdGlvbiAoYWN0aW9uLCBuYW1lKSB7XG5cbiAgICAgICAgYWN0aW9uID0gXy5tZXJnZSh7dXJsOiB1cmwsIHBhcmFtczogcGFyYW1zIHx8IHt9fSwgb3B0aW9ucywgYWN0aW9uKTtcblxuICAgICAgICByZXNvdXJjZVtuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAoc2VsZi4kaHR0cCB8fCBfLmh0dHApKG9wdHMoYWN0aW9uLCBhcmd1bWVudHMpKTtcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXNvdXJjZTtcbn1cblxuZnVuY3Rpb24gb3B0cyhhY3Rpb24sIGFyZ3MpIHtcblxuICAgIHZhciBvcHRpb25zID0gXy5leHRlbmQoe30sIGFjdGlvbiksIHBhcmFtcyA9IHt9LCBkYXRhLCBzdWNjZXNzLCBlcnJvcjtcblxuICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcblxuICAgICAgICBjYXNlIDQ6XG5cbiAgICAgICAgICAgIGVycm9yID0gYXJnc1szXTtcbiAgICAgICAgICAgIHN1Y2Nlc3MgPSBhcmdzWzJdO1xuXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgY2FzZSAyOlxuXG4gICAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKGFyZ3NbMV0pKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKGFyZ3NbMF0pKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gYXJnc1sxXTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzdWNjZXNzID0gYXJnc1sxXTtcbiAgICAgICAgICAgICAgICBlcnJvciA9IGFyZ3NbMl07XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBwYXJhbXMgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIGRhdGEgPSBhcmdzWzFdO1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3MgPSBhcmdzWzJdO1xuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAxOlxuXG4gICAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKGFyZ3NbMF0pKSB7XG4gICAgICAgICAgICAgICAgc3VjY2VzcyA9IGFyZ3NbMF07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKC9eKFBPU1R8UFVUfFBBVENIKSQvaS50ZXN0KG9wdGlvbnMubWV0aG9kKSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBhcmdzWzBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSBhcmdzWzBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDA6XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG5cbiAgICAgICAgICAgIHRocm93ICdFeHBlY3RlZCB1cCB0byA0IGFyZ3VtZW50cyBbcGFyYW1zLCBkYXRhLCBzdWNjZXNzLCBlcnJvcl0sIGdvdCAnICsgYXJncy5sZW5ndGggKyAnIGFyZ3VtZW50cyc7XG4gICAgfVxuXG4gICAgb3B0aW9ucy5kYXRhID0gZGF0YTtcbiAgICBvcHRpb25zLnBhcmFtcyA9IF8uZXh0ZW5kKHt9LCBvcHRpb25zLnBhcmFtcywgcGFyYW1zKTtcblxuICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgIG9wdGlvbnMuc3VjY2VzcyA9IHN1Y2Nlc3M7XG4gICAgfVxuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICAgIG9wdGlvbnMuZXJyb3IgPSBlcnJvcjtcbiAgICB9XG5cbiAgICByZXR1cm4gb3B0aW9ucztcbn1cblxuUmVzb3VyY2UuYWN0aW9ucyA9IHtcblxuICAgIGdldDoge21ldGhvZDogJ0dFVCd9LFxuICAgIHNhdmU6IHttZXRob2Q6ICdQT1NUJ30sXG4gICAgcXVlcnk6IHttZXRob2Q6ICdHRVQnfSxcbiAgICB1cGRhdGU6IHttZXRob2Q6ICdQVVQnfSxcbiAgICByZW1vdmU6IHttZXRob2Q6ICdERUxFVEUnfSxcbiAgICBkZWxldGU6IHttZXRob2Q6ICdERUxFVEUnfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IF8ucmVzb3VyY2UgPSBSZXNvdXJjZTtcbiIsIi8qKlxuICogU2VydmljZSBmb3IgVVJMIHRlbXBsYXRpbmcuXG4gKi9cblxudmFyIF8gPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgaWUgPSBkb2N1bWVudC5kb2N1bWVudE1vZGU7XG52YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG5cbmZ1bmN0aW9uIFVybCh1cmwsIHBhcmFtcykge1xuXG4gICAgdmFyIG9wdGlvbnMgPSB1cmwsIHRyYW5zZm9ybTtcblxuICAgIGlmIChfLmlzU3RyaW5nKHVybCkpIHtcbiAgICAgICAgb3B0aW9ucyA9IHt1cmw6IHVybCwgcGFyYW1zOiBwYXJhbXN9O1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBfLm1lcmdlKHt9LCBVcmwub3B0aW9ucywgdGhpcy4kb3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICBVcmwudHJhbnNmb3Jtcy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgIHRyYW5zZm9ybSA9IGZhY3RvcnkoaGFuZGxlciwgdHJhbnNmb3JtLCB0aGlzLiR2bSk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICByZXR1cm4gdHJhbnNmb3JtKG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBVcmwgb3B0aW9ucy5cbiAqL1xuXG5Vcmwub3B0aW9ucyA9IHtcbiAgICB1cmw6ICcnLFxuICAgIHJvb3Q6IG51bGwsXG4gICAgcGFyYW1zOiB7fVxufTtcblxuLyoqXG4gKiBVcmwgdHJhbnNmb3Jtcy5cbiAqL1xuXG5VcmwudHJhbnNmb3JtcyA9IFtcbiAgICByZXF1aXJlKCcuL3RlbXBsYXRlJyksXG4gICAgcmVxdWlyZSgnLi9sZWdhY3knKSxcbiAgICByZXF1aXJlKCcuL3F1ZXJ5JyksXG4gICAgcmVxdWlyZSgnLi9yb290Jylcbl07XG5cbi8qKlxuICogRW5jb2RlcyBhIFVybCBwYXJhbWV0ZXIgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqL1xuXG5VcmwucGFyYW1zID0gZnVuY3Rpb24gKG9iaikge1xuXG4gICAgdmFyIHBhcmFtcyA9IFtdLCBlc2NhcGUgPSBlbmNvZGVVUklDb21wb25lbnQ7XG5cbiAgICBwYXJhbXMuYWRkID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcblxuICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wdXNoKGVzY2FwZShrZXkpICsgJz0nICsgZXNjYXBlKHZhbHVlKSk7XG4gICAgfTtcblxuICAgIHNlcmlhbGl6ZShwYXJhbXMsIG9iaik7XG5cbiAgICByZXR1cm4gcGFyYW1zLmpvaW4oJyYnKS5yZXBsYWNlKC8lMjAvZywgJysnKTtcbn07XG5cbi8qKlxuICogUGFyc2UgYSBVUkwgYW5kIHJldHVybiBpdHMgY29tcG9uZW50cy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKi9cblxuVXJsLnBhcnNlID0gZnVuY3Rpb24gKHVybCkge1xuXG4gICAgaWYgKGllKSB7XG4gICAgICAgIGVsLmhyZWYgPSB1cmw7XG4gICAgICAgIHVybCA9IGVsLmhyZWY7XG4gICAgfVxuXG4gICAgZWwuaHJlZiA9IHVybDtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGhyZWY6IGVsLmhyZWYsXG4gICAgICAgIHByb3RvY29sOiBlbC5wcm90b2NvbCA/IGVsLnByb3RvY29sLnJlcGxhY2UoLzokLywgJycpIDogJycsXG4gICAgICAgIHBvcnQ6IGVsLnBvcnQsXG4gICAgICAgIGhvc3Q6IGVsLmhvc3QsXG4gICAgICAgIGhvc3RuYW1lOiBlbC5ob3N0bmFtZSxcbiAgICAgICAgcGF0aG5hbWU6IGVsLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nID8gZWwucGF0aG5hbWUgOiAnLycgKyBlbC5wYXRobmFtZSxcbiAgICAgICAgc2VhcmNoOiBlbC5zZWFyY2ggPyBlbC5zZWFyY2gucmVwbGFjZSgvXlxcPy8sICcnKSA6ICcnLFxuICAgICAgICBoYXNoOiBlbC5oYXNoID8gZWwuaGFzaC5yZXBsYWNlKC9eIy8sICcnKSA6ICcnXG4gICAgfTtcbn07XG5cbmZ1bmN0aW9uIGZhY3RvcnkoaGFuZGxlciwgbmV4dCwgdm0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXIuY2FsbCh2bSwgb3B0aW9ucywgbmV4dCk7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplKHBhcmFtcywgb2JqLCBzY29wZSkge1xuXG4gICAgdmFyIGFycmF5ID0gXy5pc0FycmF5KG9iaiksIHBsYWluID0gXy5pc1BsYWluT2JqZWN0KG9iaiksIGhhc2g7XG5cbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuXG4gICAgICAgIGhhc2ggPSBfLmlzT2JqZWN0KHZhbHVlKSB8fCBfLmlzQXJyYXkodmFsdWUpO1xuXG4gICAgICAgIGlmIChzY29wZSkge1xuICAgICAgICAgICAga2V5ID0gc2NvcGUgKyAnWycgKyAocGxhaW4gfHwgaGFzaCA/IGtleSA6ICcnKSArICddJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2NvcGUgJiYgYXJyYXkpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hZGQodmFsdWUubmFtZSwgdmFsdWUudmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGhhc2gpIHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZShwYXJhbXMsIHZhbHVlLCBrZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zLmFkZChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF8udXJsID0gVXJsO1xuIiwiLyoqXG4gKiBMZWdhY3kgVHJhbnNmb3JtLlxuICovXG5cbnZhciBfID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRpb25zLCBuZXh0KSB7XG5cbiAgICB2YXIgdmFyaWFibGVzID0gW10sIHVybCA9IG5leHQob3B0aW9ucyk7XG5cbiAgICB1cmwgPSB1cmwucmVwbGFjZSgvKFxcLz8pOihbYS16XVxcdyopL2dpLCBmdW5jdGlvbiAobWF0Y2gsIHNsYXNoLCBuYW1lKSB7XG5cbiAgICAgICAgXy53YXJuKCdUaGUgYDonICsgbmFtZSArICdgIHBhcmFtZXRlciBzeW50YXggaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIHRoZSBgeycgKyBuYW1lICsgJ31gIHN5bnRheCBpbnN0ZWFkLicpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnBhcmFtc1tuYW1lXSkge1xuICAgICAgICAgICAgdmFyaWFibGVzLnB1c2gobmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gc2xhc2ggKyBlbmNvZGVVcmlTZWdtZW50KG9wdGlvbnMucGFyYW1zW25hbWVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnJztcbiAgICB9KTtcblxuICAgIHZhcmlhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMucGFyYW1zW2tleV07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdXJsO1xufTtcblxuZnVuY3Rpb24gZW5jb2RlVXJpU2VnbWVudCh2YWx1ZSkge1xuXG4gICAgcmV0dXJuIGVuY29kZVVyaVF1ZXJ5KHZhbHVlLCB0cnVlKS5cbiAgICAgICAgcmVwbGFjZSgvJTI2L2dpLCAnJicpLlxuICAgICAgICByZXBsYWNlKC8lM0QvZ2ksICc9JykuXG4gICAgICAgIHJlcGxhY2UoLyUyQi9naSwgJysnKTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlVXJpUXVlcnkodmFsdWUsIHNwYWNlcykge1xuXG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkuXG4gICAgICAgIHJlcGxhY2UoLyU0MC9naSwgJ0AnKS5cbiAgICAgICAgcmVwbGFjZSgvJTNBL2dpLCAnOicpLlxuICAgICAgICByZXBsYWNlKC8lMjQvZywgJyQnKS5cbiAgICAgICAgcmVwbGFjZSgvJTJDL2dpLCAnLCcpLlxuICAgICAgICByZXBsYWNlKC8lMjAvZywgKHNwYWNlcyA/ICclMjAnIDogJysnKSk7XG59XG4iLCIvKipcbiAqIFF1ZXJ5IFBhcmFtZXRlciBUcmFuc2Zvcm0uXG4gKi9cblxudmFyIF8gPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdGlvbnMsIG5leHQpIHtcblxuICAgIHZhciB1cmxQYXJhbXMgPSBPYmplY3Qua2V5cyhfLnVybC5vcHRpb25zLnBhcmFtcyksIHF1ZXJ5ID0ge30sIHVybCA9IG5leHQob3B0aW9ucyk7XG5cbiAgIF8uZWFjaChvcHRpb25zLnBhcmFtcywgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgaWYgKHVybFBhcmFtcy5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICAgICAgICBxdWVyeVtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHF1ZXJ5ID0gXy51cmwucGFyYW1zKHF1ZXJ5KTtcblxuICAgIGlmIChxdWVyeSkge1xuICAgICAgICB1cmwgKz0gKHVybC5pbmRleE9mKCc/JykgPT0gLTEgPyAnPycgOiAnJicpICsgcXVlcnk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVybDtcbn07XG4iLCIvKipcbiAqIFJvb3QgUHJlZml4IFRyYW5zZm9ybS5cbiAqL1xuXG52YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0aW9ucywgbmV4dCkge1xuXG4gICAgdmFyIHVybCA9IG5leHQob3B0aW9ucyk7XG5cbiAgICBpZiAoXy5pc1N0cmluZyhvcHRpb25zLnJvb3QpICYmICF1cmwubWF0Y2goL14oaHR0cHM/Oik/XFwvLykpIHtcbiAgICAgICAgdXJsID0gb3B0aW9ucy5yb290ICsgJy8nICsgdXJsO1xuICAgIH1cblxuICAgIHJldHVybiB1cmw7XG59O1xuIiwiLyoqXG4gKiBVUkwgVGVtcGxhdGUgKFJGQyA2NTcwKSBUcmFuc2Zvcm0uXG4gKi9cblxudmFyIFVybFRlbXBsYXRlID0gcmVxdWlyZSgnLi4vbGliL3VybC10ZW1wbGF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cbiAgICB2YXIgdmFyaWFibGVzID0gW10sIHVybCA9IFVybFRlbXBsYXRlLmV4cGFuZChvcHRpb25zLnVybCwgb3B0aW9ucy5wYXJhbXMsIHZhcmlhYmxlcyk7XG5cbiAgICB2YXJpYWJsZXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLnBhcmFtc1trZXldO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHVybDtcbn07XG4iLCIvKipcbiAqIFV0aWxpdHkgZnVuY3Rpb25zLlxuICovXG5cbnZhciBfID0gZXhwb3J0cywgYXJyYXkgPSBbXSwgY29uc29sZSA9IHdpbmRvdy5jb25zb2xlO1xuXG5fLndhcm4gPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgaWYgKGNvbnNvbGUgJiYgXy53YXJuaW5nICYmICghXy5jb25maWcuc2lsZW50IHx8IF8uY29uZmlnLmRlYnVnKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1tWdWVSZXNvdXJjZSB3YXJuXTogJyArIG1zZyk7XG4gICAgfVxufTtcblxuXy5lcnJvciA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICBpZiAoY29uc29sZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgfVxufTtcblxuXy50cmltID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyp8XFxzKiQvZywgJycpO1xufTtcblxuXy50b0xvd2VyID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBzdHIgPyBzdHIudG9Mb3dlckNhc2UoKSA6ICcnO1xufTtcblxuXy5pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuXy5pc1N0cmluZyA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZyc7XG59O1xuXG5fLmlzRnVuY3Rpb24gPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbic7XG59O1xuXG5fLmlzT2JqZWN0ID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCc7XG59O1xuXG5fLmlzUGxhaW5PYmplY3QgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIF8uaXNPYmplY3Qob2JqKSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSA9PSBPYmplY3QucHJvdG90eXBlO1xufTtcblxuXy5vcHRpb25zID0gZnVuY3Rpb24gKGZuLCBvYmosIG9wdGlvbnMpIHtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYgKF8uaXNGdW5jdGlvbihvcHRpb25zKSkge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucy5jYWxsKG9iaik7XG4gICAgfVxuXG4gICAgcmV0dXJuIF8ubWVyZ2UoZm4uYmluZCh7JHZtOiBvYmosICRvcHRpb25zOiBvcHRpb25zfSksIGZuLCB7JG9wdGlvbnM6IG9wdGlvbnN9KTtcbn07XG5cbl8uZWFjaCA9IGZ1bmN0aW9uIChvYmosIGl0ZXJhdG9yKSB7XG5cbiAgICB2YXIgaSwga2V5O1xuXG4gICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwob2JqW2ldLCBvYmpbaV0sIGkpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChfLmlzT2JqZWN0KG9iaikpIHtcbiAgICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5jYWxsKG9ialtrZXldLCBvYmpba2V5XSwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG59O1xuXG5fLmRlZmF1bHRzID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmICh0YXJnZXRba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG5cbl8uZXh0ZW5kID0gZnVuY3Rpb24gKHRhcmdldCkge1xuXG4gICAgdmFyIGFyZ3MgPSBhcnJheS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICBhcmdzLmZvckVhY2goZnVuY3Rpb24gKGFyZykge1xuICAgICAgICBtZXJnZSh0YXJnZXQsIGFyZyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcblxuXy5tZXJnZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcblxuICAgIHZhciBhcmdzID0gYXJyYXkuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgbWVyZ2UodGFyZ2V0LCBhcmcsIHRydWUpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG5cbmZ1bmN0aW9uIG1lcmdlKHRhcmdldCwgc291cmNlLCBkZWVwKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoZGVlcCAmJiAoXy5pc1BsYWluT2JqZWN0KHNvdXJjZVtrZXldKSB8fCBfLmlzQXJyYXkoc291cmNlW2tleV0pKSkge1xuICAgICAgICAgICAgaWYgKF8uaXNQbGFpbk9iamVjdChzb3VyY2Vba2V5XSkgJiYgIV8uaXNQbGFpbk9iamVjdCh0YXJnZXRba2V5XSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF8uaXNBcnJheShzb3VyY2Vba2V5XSkgJiYgIV8uaXNBcnJheSh0YXJnZXRba2V5XSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVyZ2UodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldLCBkZWVwKTtcbiAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Vba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiLyohXG4gKiB2dWUtcm91dGVyIHYwLjcuMTNcbiAqIChjKSAyMDE2IEV2YW4gWW91XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgZ2xvYmFsLlZ1ZVJvdXRlciA9IGZhY3RvcnkoKTtcbn0odGhpcywgZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGJhYmVsSGVscGVycyA9IHt9O1xuXG4gIGJhYmVsSGVscGVycy5jbGFzc0NhbGxDaGVjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIFRhcmdldChwYXRoLCBtYXRjaGVyLCBkZWxlZ2F0ZSkge1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy5tYXRjaGVyID0gbWF0Y2hlcjtcbiAgICB0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XG4gIH1cblxuICBUYXJnZXQucHJvdG90eXBlID0ge1xuICAgIHRvOiBmdW5jdGlvbiB0byh0YXJnZXQsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgZGVsZWdhdGUgPSB0aGlzLmRlbGVnYXRlO1xuXG4gICAgICBpZiAoZGVsZWdhdGUgJiYgZGVsZWdhdGUud2lsbEFkZFJvdXRlKSB7XG4gICAgICAgIHRhcmdldCA9IGRlbGVnYXRlLndpbGxBZGRSb3V0ZSh0aGlzLm1hdGNoZXIudGFyZ2V0LCB0YXJnZXQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm1hdGNoZXIuYWRkKHRoaXMucGF0aCwgdGFyZ2V0KTtcblxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbXVzdCBoYXZlIGFuIGFyZ3VtZW50IGluIHRoZSBmdW5jdGlvbiBwYXNzZWQgdG8gYHRvYFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hdGNoZXIuYWRkQ2hpbGQodGhpcy5wYXRoLCB0YXJnZXQsIGNhbGxiYWNrLCB0aGlzLmRlbGVnYXRlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBNYXRjaGVyKHRhcmdldCkge1xuICAgIHRoaXMucm91dGVzID0ge307XG4gICAgdGhpcy5jaGlsZHJlbiA9IHt9O1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICB9XG5cbiAgTWF0Y2hlci5wcm90b3R5cGUgPSB7XG4gICAgYWRkOiBmdW5jdGlvbiBhZGQocGF0aCwgaGFuZGxlcikge1xuICAgICAgdGhpcy5yb3V0ZXNbcGF0aF0gPSBoYW5kbGVyO1xuICAgIH0sXG5cbiAgICBhZGRDaGlsZDogZnVuY3Rpb24gYWRkQ2hpbGQocGF0aCwgdGFyZ2V0LCBjYWxsYmFjaywgZGVsZWdhdGUpIHtcbiAgICAgIHZhciBtYXRjaGVyID0gbmV3IE1hdGNoZXIodGFyZ2V0KTtcbiAgICAgIHRoaXMuY2hpbGRyZW5bcGF0aF0gPSBtYXRjaGVyO1xuXG4gICAgICB2YXIgbWF0Y2ggPSBnZW5lcmF0ZU1hdGNoKHBhdGgsIG1hdGNoZXIsIGRlbGVnYXRlKTtcblxuICAgICAgaWYgKGRlbGVnYXRlICYmIGRlbGVnYXRlLmNvbnRleHRFbnRlcmVkKSB7XG4gICAgICAgIGRlbGVnYXRlLmNvbnRleHRFbnRlcmVkKHRhcmdldCwgbWF0Y2gpO1xuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhtYXRjaCk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlTWF0Y2goc3RhcnRpbmdQYXRoLCBtYXRjaGVyLCBkZWxlZ2F0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAocGF0aCwgbmVzdGVkQ2FsbGJhY2spIHtcbiAgICAgIHZhciBmdWxsUGF0aCA9IHN0YXJ0aW5nUGF0aCArIHBhdGg7XG5cbiAgICAgIGlmIChuZXN0ZWRDYWxsYmFjaykge1xuICAgICAgICBuZXN0ZWRDYWxsYmFjayhnZW5lcmF0ZU1hdGNoKGZ1bGxQYXRoLCBtYXRjaGVyLCBkZWxlZ2F0ZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUYXJnZXQoc3RhcnRpbmdQYXRoICsgcGF0aCwgbWF0Y2hlciwgZGVsZWdhdGUpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBhZGRSb3V0ZShyb3V0ZUFycmF5LCBwYXRoLCBoYW5kbGVyKSB7XG4gICAgdmFyIGxlbiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSByb3V0ZUFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgbGVuICs9IHJvdXRlQXJyYXlbaV0ucGF0aC5sZW5ndGg7XG4gICAgfVxuXG4gICAgcGF0aCA9IHBhdGguc3Vic3RyKGxlbik7XG4gICAgdmFyIHJvdXRlID0geyBwYXRoOiBwYXRoLCBoYW5kbGVyOiBoYW5kbGVyIH07XG4gICAgcm91dGVBcnJheS5wdXNoKHJvdXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVhY2hSb3V0ZShiYXNlUm91dGUsIG1hdGNoZXIsIGNhbGxiYWNrLCBiaW5kaW5nKSB7XG4gICAgdmFyIHJvdXRlcyA9IG1hdGNoZXIucm91dGVzO1xuXG4gICAgZm9yICh2YXIgcGF0aCBpbiByb3V0ZXMpIHtcbiAgICAgIGlmIChyb3V0ZXMuaGFzT3duUHJvcGVydHkocGF0aCkpIHtcbiAgICAgICAgdmFyIHJvdXRlQXJyYXkgPSBiYXNlUm91dGUuc2xpY2UoKTtcbiAgICAgICAgYWRkUm91dGUocm91dGVBcnJheSwgcGF0aCwgcm91dGVzW3BhdGhdKTtcblxuICAgICAgICBpZiAobWF0Y2hlci5jaGlsZHJlbltwYXRoXSkge1xuICAgICAgICAgIGVhY2hSb3V0ZShyb3V0ZUFycmF5LCBtYXRjaGVyLmNoaWxkcmVuW3BhdGhdLCBjYWxsYmFjaywgYmluZGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2suY2FsbChiaW5kaW5nLCByb3V0ZUFycmF5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcCAoY2FsbGJhY2ssIGFkZFJvdXRlQ2FsbGJhY2spIHtcbiAgICB2YXIgbWF0Y2hlciA9IG5ldyBNYXRjaGVyKCk7XG5cbiAgICBjYWxsYmFjayhnZW5lcmF0ZU1hdGNoKFwiXCIsIG1hdGNoZXIsIHRoaXMuZGVsZWdhdGUpKTtcblxuICAgIGVhY2hSb3V0ZShbXSwgbWF0Y2hlciwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICBpZiAoYWRkUm91dGVDYWxsYmFjaykge1xuICAgICAgICBhZGRSb3V0ZUNhbGxiYWNrKHRoaXMsIHJvdXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWRkKHJvdXRlKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgfVxuXG4gIHZhciBzcGVjaWFscyA9IFsnLycsICcuJywgJyonLCAnKycsICc/JywgJ3wnLCAnKCcsICcpJywgJ1snLCAnXScsICd7JywgJ30nLCAnXFxcXCddO1xuXG4gIHZhciBlc2NhcGVSZWdleCA9IG5ldyBSZWdFeHAoJyhcXFxcJyArIHNwZWNpYWxzLmpvaW4oJ3xcXFxcJykgKyAnKScsICdnJyk7XG5cbiAgdmFyIG5vV2FybmluZyA9IGZhbHNlO1xuICBmdW5jdGlvbiB3YXJuKG1zZykge1xuICAgIGlmICghbm9XYXJuaW5nICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcignW3Z1ZS1yb3V0ZXJdICcgKyBtc2cpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRyeURlY29kZSh1cmksIGFzQ29tcG9uZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhc0NvbXBvbmVudCA/IGRlY29kZVVSSUNvbXBvbmVudCh1cmkpIDogZGVjb2RlVVJJKHVyaSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgd2FybignbWFsZm9ybWVkIFVSSScgKyAoYXNDb21wb25lbnQgPyAnIGNvbXBvbmVudDogJyA6ICc6ICcpICsgdXJpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc0FycmF5KHRlc3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRlc3QpID09PSBcIltvYmplY3QgQXJyYXldXCI7XG4gIH1cblxuICAvLyBBIFNlZ21lbnQgcmVwcmVzZW50cyBhIHNlZ21lbnQgaW4gdGhlIG9yaWdpbmFsIHJvdXRlIGRlc2NyaXB0aW9uLlxuICAvLyBFYWNoIFNlZ21lbnQgdHlwZSBwcm92aWRlcyBhbiBgZWFjaENoYXJgIGFuZCBgcmVnZXhgIG1ldGhvZC5cbiAgLy9cbiAgLy8gVGhlIGBlYWNoQ2hhcmAgbWV0aG9kIGludm9rZXMgdGhlIGNhbGxiYWNrIHdpdGggb25lIG9yIG1vcmUgY2hhcmFjdGVyXG4gIC8vIHNwZWNpZmljYXRpb25zLiBBIGNoYXJhY3RlciBzcGVjaWZpY2F0aW9uIGNvbnN1bWVzIG9uZSBvciBtb3JlIGlucHV0XG4gIC8vIGNoYXJhY3RlcnMuXG4gIC8vXG4gIC8vIFRoZSBgcmVnZXhgIG1ldGhvZCByZXR1cm5zIGEgcmVnZXggZnJhZ21lbnQgZm9yIHRoZSBzZWdtZW50LiBJZiB0aGVcbiAgLy8gc2VnbWVudCBpcyBhIGR5bmFtaWMgb2Ygc3RhciBzZWdtZW50LCB0aGUgcmVnZXggZnJhZ21lbnQgYWxzbyBpbmNsdWRlc1xuICAvLyBhIGNhcHR1cmUuXG4gIC8vXG4gIC8vIEEgY2hhcmFjdGVyIHNwZWNpZmljYXRpb24gY29udGFpbnM6XG4gIC8vXG4gIC8vICogYHZhbGlkQ2hhcnNgOiBhIFN0cmluZyB3aXRoIGEgbGlzdCBvZiBhbGwgdmFsaWQgY2hhcmFjdGVycywgb3JcbiAgLy8gKiBgaW52YWxpZENoYXJzYDogYSBTdHJpbmcgd2l0aCBhIGxpc3Qgb2YgYWxsIGludmFsaWQgY2hhcmFjdGVyc1xuICAvLyAqIGByZXBlYXRgOiB0cnVlIGlmIHRoZSBjaGFyYWN0ZXIgc3BlY2lmaWNhdGlvbiBjYW4gcmVwZWF0XG5cbiAgZnVuY3Rpb24gU3RhdGljU2VnbWVudChzdHJpbmcpIHtcbiAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgfVxuICBTdGF0aWNTZWdtZW50LnByb3RvdHlwZSA9IHtcbiAgICBlYWNoQ2hhcjogZnVuY3Rpb24gZWFjaENoYXIoY2FsbGJhY2spIHtcbiAgICAgIHZhciBzdHJpbmcgPSB0aGlzLnN0cmluZyxcbiAgICAgICAgICBjaDtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdHJpbmcubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNoID0gc3RyaW5nLmNoYXJBdChpKTtcbiAgICAgICAgY2FsbGJhY2soeyB2YWxpZENoYXJzOiBjaCB9KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVnZXg6IGZ1bmN0aW9uIHJlZ2V4KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nLnJlcGxhY2UoZXNjYXBlUmVnZXgsICdcXFxcJDEnKTtcbiAgICB9LFxuXG4gICAgZ2VuZXJhdGU6IGZ1bmN0aW9uIGdlbmVyYXRlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBEeW5hbWljU2VnbWVudChuYW1lKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgfVxuICBEeW5hbWljU2VnbWVudC5wcm90b3R5cGUgPSB7XG4gICAgZWFjaENoYXI6IGZ1bmN0aW9uIGVhY2hDaGFyKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayh7IGludmFsaWRDaGFyczogXCIvXCIsIHJlcGVhdDogdHJ1ZSB9KTtcbiAgICB9LFxuXG4gICAgcmVnZXg6IGZ1bmN0aW9uIHJlZ2V4KCkge1xuICAgICAgcmV0dXJuIFwiKFteL10rKVwiO1xuICAgIH0sXG5cbiAgICBnZW5lcmF0ZTogZnVuY3Rpb24gZ2VuZXJhdGUocGFyYW1zKSB7XG4gICAgICB2YXIgdmFsID0gcGFyYW1zW3RoaXMubmFtZV07XG4gICAgICByZXR1cm4gdmFsID09IG51bGwgPyBcIjpcIiArIHRoaXMubmFtZSA6IHZhbDtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gU3RhclNlZ21lbnQobmFtZSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gIH1cbiAgU3RhclNlZ21lbnQucHJvdG90eXBlID0ge1xuICAgIGVhY2hDaGFyOiBmdW5jdGlvbiBlYWNoQ2hhcihjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soeyBpbnZhbGlkQ2hhcnM6IFwiXCIsIHJlcGVhdDogdHJ1ZSB9KTtcbiAgICB9LFxuXG4gICAgcmVnZXg6IGZ1bmN0aW9uIHJlZ2V4KCkge1xuICAgICAgcmV0dXJuIFwiKC4rKVwiO1xuICAgIH0sXG5cbiAgICBnZW5lcmF0ZTogZnVuY3Rpb24gZ2VuZXJhdGUocGFyYW1zKSB7XG4gICAgICB2YXIgdmFsID0gcGFyYW1zW3RoaXMubmFtZV07XG4gICAgICByZXR1cm4gdmFsID09IG51bGwgPyBcIjpcIiArIHRoaXMubmFtZSA6IHZhbDtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gRXBzaWxvblNlZ21lbnQoKSB7fVxuICBFcHNpbG9uU2VnbWVudC5wcm90b3R5cGUgPSB7XG4gICAgZWFjaENoYXI6IGZ1bmN0aW9uIGVhY2hDaGFyKCkge30sXG4gICAgcmVnZXg6IGZ1bmN0aW9uIHJlZ2V4KCkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfSxcbiAgICBnZW5lcmF0ZTogZnVuY3Rpb24gZ2VuZXJhdGUoKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gcGFyc2Uocm91dGUsIG5hbWVzLCBzcGVjaWZpY2l0eSkge1xuICAgIC8vIG5vcm1hbGl6ZSByb3V0ZSBhcyBub3Qgc3RhcnRpbmcgd2l0aCBhIFwiL1wiLiBSZWNvZ25pdGlvbiB3aWxsXG4gICAgLy8gYWxzbyBub3JtYWxpemUuXG4gICAgaWYgKHJvdXRlLmNoYXJBdCgwKSA9PT0gXCIvXCIpIHtcbiAgICAgIHJvdXRlID0gcm91dGUuc3Vic3RyKDEpO1xuICAgIH1cblxuICAgIHZhciBzZWdtZW50cyA9IHJvdXRlLnNwbGl0KFwiL1wiKSxcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuXG4gICAgLy8gQSByb3V0ZXMgaGFzIHNwZWNpZmljaXR5IGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoYXQgaXRzIGRpZmZlcmVudCBzZWdtZW50c1xuICAgIC8vIGFwcGVhciBpbi4gVGhpcyBzeXN0ZW0gbWlycm9ycyBob3cgdGhlIG1hZ25pdHVkZSBvZiBudW1iZXJzIHdyaXR0ZW4gYXMgc3RyaW5nc1xuICAgIC8vIHdvcmtzLlxuICAgIC8vIENvbnNpZGVyIGEgbnVtYmVyIHdyaXR0ZW4gYXM6IFwiYWJjXCIuIEFuIGV4YW1wbGUgd291bGQgYmUgXCIyMDBcIi4gQW55IG90aGVyIG51bWJlciB3cml0dGVuXG4gICAgLy8gXCJ4eXpcIiB3aWxsIGJlIHNtYWxsZXIgdGhhbiBcImFiY1wiIHNvIGxvbmcgYXMgYGEgPiB6YC4gRm9yIGluc3RhbmNlLCBcIjE5OVwiIGlzIHNtYWxsZXJcbiAgICAvLyB0aGVuIFwiMjAwXCIsIGV2ZW4gdGhvdWdoIFwieVwiIGFuZCBcInpcIiAod2hpY2ggYXJlIGJvdGggOSkgYXJlIGxhcmdlciB0aGFuIFwiMFwiICh0aGUgdmFsdWVcbiAgICAvLyBvZiAoYGJgIGFuZCBgY2ApLiBUaGlzIGlzIGJlY2F1c2UgdGhlIGxlYWRpbmcgc3ltYm9sLCBcIjJcIiwgaXMgbGFyZ2VyIHRoYW4gdGhlIG90aGVyXG4gICAgLy8gbGVhZGluZyBzeW1ib2wsIFwiMVwiLlxuICAgIC8vIFRoZSBydWxlIGlzIHRoYXQgc3ltYm9scyB0byB0aGUgbGVmdCBjYXJyeSBtb3JlIHdlaWdodCB0aGFuIHN5bWJvbHMgdG8gdGhlIHJpZ2h0XG4gICAgLy8gd2hlbiBhIG51bWJlciBpcyB3cml0dGVuIG91dCBhcyBhIHN0cmluZy4gSW4gdGhlIGFib3ZlIHN0cmluZ3MsIHRoZSBsZWFkaW5nIGRpZ2l0XG4gICAgLy8gcmVwcmVzZW50cyBob3cgbWFueSAxMDAncyBhcmUgaW4gdGhlIG51bWJlciwgYW5kIGl0IGNhcnJpZXMgbW9yZSB3ZWlnaHQgdGhhbiB0aGUgbWlkZGxlXG4gICAgLy8gbnVtYmVyIHdoaWNoIHJlcHJlc2VudHMgaG93IG1hbnkgMTAncyBhcmUgaW4gdGhlIG51bWJlci5cbiAgICAvLyBUaGlzIHN5c3RlbSBvZiBudW1iZXIgbWFnbml0dWRlIHdvcmtzIHdlbGwgZm9yIHJvdXRlIHNwZWNpZmljaXR5LCB0b28uIEEgcm91dGUgd3JpdHRlbiBhc1xuICAgIC8vIGBhL2IvY2Agd2lsbCBiZSBtb3JlIHNwZWNpZmljIHRoYW4gYHgveS96YCBhcyBsb25nIGFzIGBhYCBpcyBtb3JlIHNwZWNpZmljIHRoYW5cbiAgICAvLyBgeGAsIGlycmVzcGVjdGl2ZSBvZiB0aGUgb3RoZXIgcGFydHMuXG4gICAgLy8gQmVjYXVzZSBvZiB0aGlzIHNpbWlsYXJpdHksIHdlIGFzc2lnbiBlYWNoIHR5cGUgb2Ygc2VnbWVudCBhIG51bWJlciB2YWx1ZSB3cml0dGVuIGFzIGFcbiAgICAvLyBzdHJpbmcuIFdlIGNhbiBmaW5kIHRoZSBzcGVjaWZpY2l0eSBvZiBjb21wb3VuZCByb3V0ZXMgYnkgY29uY2F0ZW5hdGluZyB0aGVzZSBzdHJpbmdzXG4gICAgLy8gdG9nZXRoZXIsIGZyb20gbGVmdCB0byByaWdodC4gQWZ0ZXIgd2UgaGF2ZSBsb29wZWQgdGhyb3VnaCBhbGwgb2YgdGhlIHNlZ21lbnRzLFxuICAgIC8vIHdlIGNvbnZlcnQgdGhlIHN0cmluZyB0byBhIG51bWJlci5cbiAgICBzcGVjaWZpY2l0eS52YWwgPSAnJztcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldLFxuICAgICAgICAgIG1hdGNoO1xuXG4gICAgICBpZiAobWF0Y2ggPSBzZWdtZW50Lm1hdGNoKC9eOihbXlxcL10rKSQvKSkge1xuICAgICAgICByZXN1bHRzLnB1c2gobmV3IER5bmFtaWNTZWdtZW50KG1hdGNoWzFdKSk7XG4gICAgICAgIG5hbWVzLnB1c2gobWF0Y2hbMV0pO1xuICAgICAgICBzcGVjaWZpY2l0eS52YWwgKz0gJzMnO1xuICAgICAgfSBlbHNlIGlmIChtYXRjaCA9IHNlZ21lbnQubWF0Y2goL15cXCooW15cXC9dKykkLykpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKG5ldyBTdGFyU2VnbWVudChtYXRjaFsxXSkpO1xuICAgICAgICBzcGVjaWZpY2l0eS52YWwgKz0gJzInO1xuICAgICAgICBuYW1lcy5wdXNoKG1hdGNoWzFdKTtcbiAgICAgIH0gZWxzZSBpZiAoc2VnbWVudCA9PT0gXCJcIikge1xuICAgICAgICByZXN1bHRzLnB1c2gobmV3IEVwc2lsb25TZWdtZW50KCkpO1xuICAgICAgICBzcGVjaWZpY2l0eS52YWwgKz0gJzEnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKG5ldyBTdGF0aWNTZWdtZW50KHNlZ21lbnQpKTtcbiAgICAgICAgc3BlY2lmaWNpdHkudmFsICs9ICc0JztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzcGVjaWZpY2l0eS52YWwgPSArc3BlY2lmaWNpdHkudmFsO1xuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICAvLyBBIFN0YXRlIGhhcyBhIGNoYXJhY3RlciBzcGVjaWZpY2F0aW9uIGFuZCAoYGNoYXJTcGVjYCkgYW5kIGEgbGlzdCBvZiBwb3NzaWJsZVxuICAvLyBzdWJzZXF1ZW50IHN0YXRlcyAoYG5leHRTdGF0ZXNgKS5cbiAgLy9cbiAgLy8gSWYgYSBTdGF0ZSBpcyBhbiBhY2NlcHRpbmcgc3RhdGUsIGl0IHdpbGwgYWxzbyBoYXZlIHNldmVyYWwgYWRkaXRpb25hbFxuICAvLyBwcm9wZXJ0aWVzOlxuICAvL1xuICAvLyAqIGByZWdleGA6IEEgcmVndWxhciBleHByZXNzaW9uIHRoYXQgaXMgdXNlZCB0byBleHRyYWN0IHBhcmFtZXRlcnMgZnJvbSBwYXRoc1xuICAvLyAgIHRoYXQgcmVhY2hlZCB0aGlzIGFjY2VwdGluZyBzdGF0ZS5cbiAgLy8gKiBgaGFuZGxlcnNgOiBJbmZvcm1hdGlvbiBvbiBob3cgdG8gY29udmVydCB0aGUgbGlzdCBvZiBjYXB0dXJlcyBpbnRvIGNhbGxzXG4gIC8vICAgdG8gcmVnaXN0ZXJlZCBoYW5kbGVycyB3aXRoIHRoZSBzcGVjaWZpZWQgcGFyYW1ldGVyc1xuICAvLyAqIGB0eXBlc2A6IEhvdyBtYW55IHN0YXRpYywgZHluYW1pYyBvciBzdGFyIHNlZ21lbnRzIGluIHRoaXMgcm91dGUuIFVzZWQgdG9cbiAgLy8gICBkZWNpZGUgd2hpY2ggcm91dGUgdG8gdXNlIGlmIG11bHRpcGxlIHJlZ2lzdGVyZWQgcm91dGVzIG1hdGNoIGEgcGF0aC5cbiAgLy9cbiAgLy8gQ3VycmVudGx5LCBTdGF0ZSBpcyBpbXBsZW1lbnRlZCBuYWl2ZWx5IGJ5IGxvb3Bpbmcgb3ZlciBgbmV4dFN0YXRlc2AgYW5kXG4gIC8vIGNvbXBhcmluZyBhIGNoYXJhY3RlciBzcGVjaWZpY2F0aW9uIGFnYWluc3QgYSBjaGFyYWN0ZXIuIEEgbW9yZSBlZmZpY2llbnRcbiAgLy8gaW1wbGVtZW50YXRpb24gd291bGQgdXNlIGEgaGFzaCBvZiBrZXlzIHBvaW50aW5nIGF0IG9uZSBvciBtb3JlIG5leHQgc3RhdGVzLlxuXG4gIGZ1bmN0aW9uIFN0YXRlKGNoYXJTcGVjKSB7XG4gICAgdGhpcy5jaGFyU3BlYyA9IGNoYXJTcGVjO1xuICAgIHRoaXMubmV4dFN0YXRlcyA9IFtdO1xuICB9XG5cbiAgU3RhdGUucHJvdG90eXBlID0ge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KGNoYXJTcGVjKSB7XG4gICAgICB2YXIgbmV4dFN0YXRlcyA9IHRoaXMubmV4dFN0YXRlcztcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBuZXh0U3RhdGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBuZXh0U3RhdGVzW2ldO1xuXG4gICAgICAgIHZhciBpc0VxdWFsID0gY2hpbGQuY2hhclNwZWMudmFsaWRDaGFycyA9PT0gY2hhclNwZWMudmFsaWRDaGFycztcbiAgICAgICAgaXNFcXVhbCA9IGlzRXF1YWwgJiYgY2hpbGQuY2hhclNwZWMuaW52YWxpZENoYXJzID09PSBjaGFyU3BlYy5pbnZhbGlkQ2hhcnM7XG5cbiAgICAgICAgaWYgKGlzRXF1YWwpIHtcbiAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcHV0OiBmdW5jdGlvbiBwdXQoY2hhclNwZWMpIHtcbiAgICAgIHZhciBzdGF0ZTtcblxuICAgICAgLy8gSWYgdGhlIGNoYXJhY3RlciBzcGVjaWZpY2F0aW9uIGFscmVhZHkgZXhpc3RzIGluIGEgY2hpbGQgb2YgdGhlIGN1cnJlbnRcbiAgICAgIC8vIHN0YXRlLCBqdXN0IHJldHVybiB0aGF0IHN0YXRlLlxuICAgICAgaWYgKHN0YXRlID0gdGhpcy5nZXQoY2hhclNwZWMpKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgIH1cblxuICAgICAgLy8gTWFrZSBhIG5ldyBzdGF0ZSBmb3IgdGhlIGNoYXJhY3RlciBzcGVjXG4gICAgICBzdGF0ZSA9IG5ldyBTdGF0ZShjaGFyU3BlYyk7XG5cbiAgICAgIC8vIEluc2VydCB0aGUgbmV3IHN0YXRlIGFzIGEgY2hpbGQgb2YgdGhlIGN1cnJlbnQgc3RhdGVcbiAgICAgIHRoaXMubmV4dFN0YXRlcy5wdXNoKHN0YXRlKTtcblxuICAgICAgLy8gSWYgdGhpcyBjaGFyYWN0ZXIgc3BlY2lmaWNhdGlvbiByZXBlYXRzLCBpbnNlcnQgdGhlIG5ldyBzdGF0ZSBhcyBhIGNoaWxkXG4gICAgICAvLyBvZiBpdHNlbGYuIE5vdGUgdGhhdCB0aGlzIHdpbGwgbm90IHRyaWdnZXIgYW4gaW5maW5pdGUgbG9vcCBiZWNhdXNlIGVhY2hcbiAgICAgIC8vIHRyYW5zaXRpb24gZHVyaW5nIHJlY29nbml0aW9uIGNvbnN1bWVzIGEgY2hhcmFjdGVyLlxuICAgICAgaWYgKGNoYXJTcGVjLnJlcGVhdCkge1xuICAgICAgICBzdGF0ZS5uZXh0U3RhdGVzLnB1c2goc3RhdGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm4gdGhlIG5ldyBzdGF0ZVxuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG5cbiAgICAvLyBGaW5kIGEgbGlzdCBvZiBjaGlsZCBzdGF0ZXMgbWF0Y2hpbmcgdGhlIG5leHQgY2hhcmFjdGVyXG4gICAgbWF0Y2g6IGZ1bmN0aW9uIG1hdGNoKGNoKSB7XG4gICAgICAvLyBERUJVRyBcIlByb2Nlc3NpbmcgYFwiICsgY2ggKyBcImA6XCJcbiAgICAgIHZhciBuZXh0U3RhdGVzID0gdGhpcy5uZXh0U3RhdGVzLFxuICAgICAgICAgIGNoaWxkLFxuICAgICAgICAgIGNoYXJTcGVjLFxuICAgICAgICAgIGNoYXJzO1xuXG4gICAgICAvLyBERUJVRyBcIiAgXCIgKyBkZWJ1Z1N0YXRlKHRoaXMpXG4gICAgICB2YXIgcmV0dXJuZWQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBuZXh0U3RhdGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjaGlsZCA9IG5leHRTdGF0ZXNbaV07XG5cbiAgICAgICAgY2hhclNwZWMgPSBjaGlsZC5jaGFyU3BlYztcblxuICAgICAgICBpZiAodHlwZW9mIChjaGFycyA9IGNoYXJTcGVjLnZhbGlkQ2hhcnMpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGlmIChjaGFycy5pbmRleE9mKGNoKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybmVkLnB1c2goY2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgKGNoYXJzID0gY2hhclNwZWMuaW52YWxpZENoYXJzKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBpZiAoY2hhcnMuaW5kZXhPZihjaCkgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm5lZC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldHVybmVkO1xuICAgIH1cblxuICAgIC8qKiBJRiBERUJVR1xuICAgICwgZGVidWc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNoYXJTcGVjID0gdGhpcy5jaGFyU3BlYyxcbiAgICAgICAgICBkZWJ1ZyA9IFwiW1wiLFxuICAgICAgICAgIGNoYXJzID0gY2hhclNwZWMudmFsaWRDaGFycyB8fCBjaGFyU3BlYy5pbnZhbGlkQ2hhcnM7XG4gICAgICAgaWYgKGNoYXJTcGVjLmludmFsaWRDaGFycykgeyBkZWJ1ZyArPSBcIl5cIjsgfVxuICAgICAgZGVidWcgKz0gY2hhcnM7XG4gICAgICBkZWJ1ZyArPSBcIl1cIjtcbiAgICAgICBpZiAoY2hhclNwZWMucmVwZWF0KSB7IGRlYnVnICs9IFwiK1wiOyB9XG4gICAgICAgcmV0dXJuIGRlYnVnO1xuICAgIH1cbiAgICBFTkQgSUYgKiovXG4gIH07XG5cbiAgLyoqIElGIERFQlVHXG4gIGZ1bmN0aW9uIGRlYnVnKGxvZykge1xuICAgIGNvbnNvbGUubG9nKGxvZyk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWJ1Z1N0YXRlKHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlLm5leHRTdGF0ZXMubWFwKGZ1bmN0aW9uKG4pIHtcbiAgICAgIGlmIChuLm5leHRTdGF0ZXMubGVuZ3RoID09PSAwKSB7IHJldHVybiBcIiggXCIgKyBuLmRlYnVnKCkgKyBcIiBbYWNjZXB0aW5nXSApXCI7IH1cbiAgICAgIHJldHVybiBcIiggXCIgKyBuLmRlYnVnKCkgKyBcIiA8dGhlbj4gXCIgKyBuLm5leHRTdGF0ZXMubWFwKGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHMuZGVidWcoKSB9KS5qb2luKFwiIG9yIFwiKSArIFwiIClcIjtcbiAgICB9KS5qb2luKFwiLCBcIilcbiAgfVxuICBFTkQgSUYgKiovXG5cbiAgLy8gU29ydCB0aGUgcm91dGVzIGJ5IHNwZWNpZmljaXR5XG4gIGZ1bmN0aW9uIHNvcnRTb2x1dGlvbnMoc3RhdGVzKSB7XG4gICAgcmV0dXJuIHN0YXRlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYi5zcGVjaWZpY2l0eS52YWwgLSBhLnNwZWNpZmljaXR5LnZhbDtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29nbml6ZUNoYXIoc3RhdGVzLCBjaCkge1xuICAgIHZhciBuZXh0U3RhdGVzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHN0YXRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBzdGF0ZSA9IHN0YXRlc1tpXTtcblxuICAgICAgbmV4dFN0YXRlcyA9IG5leHRTdGF0ZXMuY29uY2F0KHN0YXRlLm1hdGNoKGNoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5leHRTdGF0ZXM7XG4gIH1cblxuICB2YXIgb0NyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gKHByb3RvKSB7XG4gICAgZnVuY3Rpb24gRigpIHt9XG4gICAgRi5wcm90b3R5cGUgPSBwcm90bztcbiAgICByZXR1cm4gbmV3IEYoKTtcbiAgfTtcblxuICBmdW5jdGlvbiBSZWNvZ25pemVSZXN1bHRzKHF1ZXJ5UGFyYW1zKSB7XG4gICAgdGhpcy5xdWVyeVBhcmFtcyA9IHF1ZXJ5UGFyYW1zIHx8IHt9O1xuICB9XG4gIFJlY29nbml6ZVJlc3VsdHMucHJvdG90eXBlID0gb0NyZWF0ZSh7XG4gICAgc3BsaWNlOiBBcnJheS5wcm90b3R5cGUuc3BsaWNlLFxuICAgIHNsaWNlOiBBcnJheS5wcm90b3R5cGUuc2xpY2UsXG4gICAgcHVzaDogQXJyYXkucHJvdG90eXBlLnB1c2gsXG4gICAgbGVuZ3RoOiAwLFxuICAgIHF1ZXJ5UGFyYW1zOiBudWxsXG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGZpbmRIYW5kbGVyKHN0YXRlLCBwYXRoLCBxdWVyeVBhcmFtcykge1xuICAgIHZhciBoYW5kbGVycyA9IHN0YXRlLmhhbmRsZXJzLFxuICAgICAgICByZWdleCA9IHN0YXRlLnJlZ2V4O1xuICAgIHZhciBjYXB0dXJlcyA9IHBhdGgubWF0Y2gocmVnZXgpLFxuICAgICAgICBjdXJyZW50Q2FwdHVyZSA9IDE7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBSZWNvZ25pemVSZXN1bHRzKHF1ZXJ5UGFyYW1zKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgaGFuZGxlciA9IGhhbmRsZXJzW2ldLFxuICAgICAgICAgIG5hbWVzID0gaGFuZGxlci5uYW1lcyxcbiAgICAgICAgICBwYXJhbXMgPSB7fTtcblxuICAgICAgZm9yICh2YXIgaiA9IDAsIG0gPSBuYW1lcy5sZW5ndGg7IGogPCBtOyBqKyspIHtcbiAgICAgICAgcGFyYW1zW25hbWVzW2pdXSA9IGNhcHR1cmVzW2N1cnJlbnRDYXB0dXJlKytdO1xuICAgICAgfVxuXG4gICAgICByZXN1bHQucHVzaCh7IGhhbmRsZXI6IGhhbmRsZXIuaGFuZGxlciwgcGFyYW1zOiBwYXJhbXMsIGlzRHluYW1pYzogISFuYW1lcy5sZW5ndGggfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFNlZ21lbnQoY3VycmVudFN0YXRlLCBzZWdtZW50KSB7XG4gICAgc2VnbWVudC5lYWNoQ2hhcihmdW5jdGlvbiAoY2gpIHtcbiAgICAgIHZhciBzdGF0ZTtcblxuICAgICAgY3VycmVudFN0YXRlID0gY3VycmVudFN0YXRlLnB1dChjaCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY3VycmVudFN0YXRlO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVjb2RlUXVlcnlQYXJhbVBhcnQocGFydCkge1xuICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw0MDEvaW50ZXJhY3QvZm9ybXMuaHRtbCNoLTE3LjEzLjQuMVxuICAgIHBhcnQgPSBwYXJ0LnJlcGxhY2UoL1xcKy9nbSwgJyUyMCcpO1xuICAgIHJldHVybiB0cnlEZWNvZGUocGFydCwgdHJ1ZSk7XG4gIH1cblxuICAvLyBUaGUgbWFpbiBpbnRlcmZhY2VcblxuICB2YXIgUm91dGVSZWNvZ25pemVyID0gZnVuY3Rpb24gUm91dGVSZWNvZ25pemVyKCkge1xuICAgIHRoaXMucm9vdFN0YXRlID0gbmV3IFN0YXRlKCk7XG4gICAgdGhpcy5uYW1lcyA9IHt9O1xuICB9O1xuXG4gIFJvdXRlUmVjb2duaXplci5wcm90b3R5cGUgPSB7XG4gICAgYWRkOiBmdW5jdGlvbiBhZGQocm91dGVzLCBvcHRpb25zKSB7XG4gICAgICB2YXIgY3VycmVudFN0YXRlID0gdGhpcy5yb290U3RhdGUsXG4gICAgICAgICAgcmVnZXggPSBcIl5cIixcbiAgICAgICAgICBzcGVjaWZpY2l0eSA9IHt9LFxuICAgICAgICAgIGhhbmRsZXJzID0gW10sXG4gICAgICAgICAgYWxsU2VnbWVudHMgPSBbXSxcbiAgICAgICAgICBuYW1lO1xuXG4gICAgICB2YXIgaXNFbXB0eSA9IHRydWU7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcm91dGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcm91dGUgPSByb3V0ZXNbaV0sXG4gICAgICAgICAgICBuYW1lcyA9IFtdO1xuXG4gICAgICAgIHZhciBzZWdtZW50cyA9IHBhcnNlKHJvdXRlLnBhdGgsIG5hbWVzLCBzcGVjaWZpY2l0eSk7XG5cbiAgICAgICAgYWxsU2VnbWVudHMgPSBhbGxTZWdtZW50cy5jb25jYXQoc2VnbWVudHMpO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwLCBtID0gc2VnbWVudHMubGVuZ3RoOyBqIDwgbTsgaisrKSB7XG4gICAgICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tqXTtcblxuICAgICAgICAgIGlmIChzZWdtZW50IGluc3RhbmNlb2YgRXBzaWxvblNlZ21lbnQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlzRW1wdHkgPSBmYWxzZTtcblxuICAgICAgICAgIC8vIEFkZCBhIFwiL1wiIGZvciB0aGUgbmV3IHNlZ21lbnRcbiAgICAgICAgICBjdXJyZW50U3RhdGUgPSBjdXJyZW50U3RhdGUucHV0KHsgdmFsaWRDaGFyczogXCIvXCIgfSk7XG4gICAgICAgICAgcmVnZXggKz0gXCIvXCI7XG5cbiAgICAgICAgICAvLyBBZGQgYSByZXByZXNlbnRhdGlvbiBvZiB0aGUgc2VnbWVudCB0byB0aGUgTkZBIGFuZCByZWdleFxuICAgICAgICAgIGN1cnJlbnRTdGF0ZSA9IGFkZFNlZ21lbnQoY3VycmVudFN0YXRlLCBzZWdtZW50KTtcbiAgICAgICAgICByZWdleCArPSBzZWdtZW50LnJlZ2V4KCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGFuZGxlciA9IHsgaGFuZGxlcjogcm91dGUuaGFuZGxlciwgbmFtZXM6IG5hbWVzIH07XG4gICAgICAgIGhhbmRsZXJzLnB1c2goaGFuZGxlcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0VtcHR5KSB7XG4gICAgICAgIGN1cnJlbnRTdGF0ZSA9IGN1cnJlbnRTdGF0ZS5wdXQoeyB2YWxpZENoYXJzOiBcIi9cIiB9KTtcbiAgICAgICAgcmVnZXggKz0gXCIvXCI7XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRTdGF0ZS5oYW5kbGVycyA9IGhhbmRsZXJzO1xuICAgICAgY3VycmVudFN0YXRlLnJlZ2V4ID0gbmV3IFJlZ0V4cChyZWdleCArIFwiJFwiKTtcbiAgICAgIGN1cnJlbnRTdGF0ZS5zcGVjaWZpY2l0eSA9IHNwZWNpZmljaXR5O1xuXG4gICAgICBpZiAobmFtZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5hcykge1xuICAgICAgICB0aGlzLm5hbWVzW25hbWVdID0ge1xuICAgICAgICAgIHNlZ21lbnRzOiBhbGxTZWdtZW50cyxcbiAgICAgICAgICBoYW5kbGVyczogaGFuZGxlcnNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaGFuZGxlcnNGb3I6IGZ1bmN0aW9uIGhhbmRsZXJzRm9yKG5hbWUpIHtcbiAgICAgIHZhciByb3V0ZSA9IHRoaXMubmFtZXNbbmFtZV0sXG4gICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICBpZiAoIXJvdXRlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZXJlIGlzIG5vIHJvdXRlIG5hbWVkIFwiICsgbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcm91dGUuaGFuZGxlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHJvdXRlLmhhbmRsZXJzW2ldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgaGFzUm91dGU6IGZ1bmN0aW9uIGhhc1JvdXRlKG5hbWUpIHtcbiAgICAgIHJldHVybiAhIXRoaXMubmFtZXNbbmFtZV07XG4gICAgfSxcblxuICAgIGdlbmVyYXRlOiBmdW5jdGlvbiBnZW5lcmF0ZShuYW1lLCBwYXJhbXMpIHtcbiAgICAgIHZhciByb3V0ZSA9IHRoaXMubmFtZXNbbmFtZV0sXG4gICAgICAgICAgb3V0cHV0ID0gXCJcIjtcbiAgICAgIGlmICghcm91dGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlcmUgaXMgbm8gcm91dGUgbmFtZWQgXCIgKyBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNlZ21lbnRzID0gcm91dGUuc2VnbWVudHM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG5cbiAgICAgICAgaWYgKHNlZ21lbnQgaW5zdGFuY2VvZiBFcHNpbG9uU2VnbWVudCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0cHV0ICs9IFwiL1wiO1xuICAgICAgICBvdXRwdXQgKz0gc2VnbWVudC5nZW5lcmF0ZShwYXJhbXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3V0cHV0LmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgICAgIG91dHB1dCA9ICcvJyArIG91dHB1dDtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcyAmJiBwYXJhbXMucXVlcnlQYXJhbXMpIHtcbiAgICAgICAgb3V0cHV0ICs9IHRoaXMuZ2VuZXJhdGVRdWVyeVN0cmluZyhwYXJhbXMucXVlcnlQYXJhbXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0sXG5cbiAgICBnZW5lcmF0ZVF1ZXJ5U3RyaW5nOiBmdW5jdGlvbiBnZW5lcmF0ZVF1ZXJ5U3RyaW5nKHBhcmFtcykge1xuICAgICAgdmFyIHBhaXJzID0gW107XG4gICAgICB2YXIga2V5cyA9IFtdO1xuICAgICAgZm9yICh2YXIga2V5IGluIHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAga2V5cy5zb3J0KCk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICB2YXIgdmFsdWUgPSBwYXJhbXNba2V5XTtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFpciA9IGVuY29kZVVSSUNvbXBvbmVudChrZXkpO1xuICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaiA8IGw7IGorKykge1xuICAgICAgICAgICAgdmFyIGFycmF5UGFpciA9IGtleSArICdbXScgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWVbal0pO1xuICAgICAgICAgICAgcGFpcnMucHVzaChhcnJheVBhaXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYWlyICs9IFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgICAgICAgICBwYWlycy5wdXNoKHBhaXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwYWlycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gXCI/XCIgKyBwYWlycy5qb2luKFwiJlwiKTtcbiAgICB9LFxuXG4gICAgcGFyc2VRdWVyeVN0cmluZzogZnVuY3Rpb24gcGFyc2VRdWVyeVN0cmluZyhxdWVyeVN0cmluZykge1xuICAgICAgdmFyIHBhaXJzID0gcXVlcnlTdHJpbmcuc3BsaXQoXCImXCIpLFxuICAgICAgICAgIHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwYWlyID0gcGFpcnNbaV0uc3BsaXQoJz0nKSxcbiAgICAgICAgICAgIGtleSA9IGRlY29kZVF1ZXJ5UGFyYW1QYXJ0KHBhaXJbMF0pLFxuICAgICAgICAgICAga2V5TGVuZ3RoID0ga2V5Lmxlbmd0aCxcbiAgICAgICAgICAgIGlzQXJyYXkgPSBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlO1xuICAgICAgICBpZiAocGFpci5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICB2YWx1ZSA9ICd0cnVlJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvL0hhbmRsZSBhcnJheXNcbiAgICAgICAgICBpZiAoa2V5TGVuZ3RoID4gMiAmJiBrZXkuc2xpY2Uoa2V5TGVuZ3RoIC0gMikgPT09ICdbXScpIHtcbiAgICAgICAgICAgIGlzQXJyYXkgPSB0cnVlO1xuICAgICAgICAgICAga2V5ID0ga2V5LnNsaWNlKDAsIGtleUxlbmd0aCAtIDIpO1xuICAgICAgICAgICAgaWYgKCFxdWVyeVBhcmFtc1trZXldKSB7XG4gICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zW2tleV0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWUgPSBwYWlyWzFdID8gZGVjb2RlUXVlcnlQYXJhbVBhcnQocGFpclsxXSkgOiAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBcnJheSkge1xuICAgICAgICAgIHF1ZXJ5UGFyYW1zW2tleV0ucHVzaCh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcXVlcnlQYXJhbXNba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcXVlcnlQYXJhbXM7XG4gICAgfSxcblxuICAgIHJlY29nbml6ZTogZnVuY3Rpb24gcmVjb2duaXplKHBhdGgsIHNpbGVudCkge1xuICAgICAgbm9XYXJuaW5nID0gc2lsZW50O1xuICAgICAgdmFyIHN0YXRlcyA9IFt0aGlzLnJvb3RTdGF0ZV0sXG4gICAgICAgICAgcGF0aExlbixcbiAgICAgICAgICBpLFxuICAgICAgICAgIGwsXG4gICAgICAgICAgcXVlcnlTdGFydCxcbiAgICAgICAgICBxdWVyeVBhcmFtcyA9IHt9LFxuICAgICAgICAgIGlzU2xhc2hEcm9wcGVkID0gZmFsc2U7XG5cbiAgICAgIHF1ZXJ5U3RhcnQgPSBwYXRoLmluZGV4T2YoJz8nKTtcbiAgICAgIGlmIChxdWVyeVN0YXJ0ICE9PSAtMSkge1xuICAgICAgICB2YXIgcXVlcnlTdHJpbmcgPSBwYXRoLnN1YnN0cihxdWVyeVN0YXJ0ICsgMSwgcGF0aC5sZW5ndGgpO1xuICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHIoMCwgcXVlcnlTdGFydCk7XG4gICAgICAgIGlmIChxdWVyeVN0cmluZykge1xuICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gdGhpcy5wYXJzZVF1ZXJ5U3RyaW5nKHF1ZXJ5U3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwYXRoID0gdHJ5RGVjb2RlKHBhdGgpO1xuICAgICAgaWYgKCFwYXRoKSByZXR1cm47XG5cbiAgICAgIC8vIERFQlVHIEdST1VQIHBhdGhcblxuICAgICAgaWYgKHBhdGguY2hhckF0KDApICE9PSBcIi9cIikge1xuICAgICAgICBwYXRoID0gXCIvXCIgKyBwYXRoO1xuICAgICAgfVxuXG4gICAgICBwYXRoTGVuID0gcGF0aC5sZW5ndGg7XG4gICAgICBpZiAocGF0aExlbiA+IDEgJiYgcGF0aC5jaGFyQXQocGF0aExlbiAtIDEpID09PSBcIi9cIikge1xuICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHIoMCwgcGF0aExlbiAtIDEpO1xuICAgICAgICBpc1NsYXNoRHJvcHBlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIGwgPSBwYXRoLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBzdGF0ZXMgPSByZWNvZ25pemVDaGFyKHN0YXRlcywgcGF0aC5jaGFyQXQoaSkpO1xuICAgICAgICBpZiAoIXN0YXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBFTkQgREVCVUcgR1JPVVBcblxuICAgICAgdmFyIHNvbHV0aW9ucyA9IFtdO1xuICAgICAgZm9yIChpID0gMCwgbCA9IHN0YXRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKHN0YXRlc1tpXS5oYW5kbGVycykge1xuICAgICAgICAgIHNvbHV0aW9ucy5wdXNoKHN0YXRlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RhdGVzID0gc29ydFNvbHV0aW9ucyhzb2x1dGlvbnMpO1xuXG4gICAgICB2YXIgc3RhdGUgPSBzb2x1dGlvbnNbMF07XG5cbiAgICAgIGlmIChzdGF0ZSAmJiBzdGF0ZS5oYW5kbGVycykge1xuICAgICAgICAvLyBpZiBhIHRyYWlsaW5nIHNsYXNoIHdhcyBkcm9wcGVkIGFuZCBhIHN0YXIgc2VnbWVudCBpcyB0aGUgbGFzdCBzZWdtZW50XG4gICAgICAgIC8vIHNwZWNpZmllZCwgcHV0IHRoZSB0cmFpbGluZyBzbGFzaCBiYWNrXG4gICAgICAgIGlmIChpc1NsYXNoRHJvcHBlZCAmJiBzdGF0ZS5yZWdleC5zb3VyY2Uuc2xpY2UoLTUpID09PSBcIiguKykkXCIpIHtcbiAgICAgICAgICBwYXRoID0gcGF0aCArIFwiL1wiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaW5kSGFuZGxlcihzdGF0ZSwgcGF0aCwgcXVlcnlQYXJhbXMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBSb3V0ZVJlY29nbml6ZXIucHJvdG90eXBlLm1hcCA9IG1hcDtcblxuICB2YXIgZ2VuUXVlcnkgPSBSb3V0ZVJlY29nbml6ZXIucHJvdG90eXBlLmdlbmVyYXRlUXVlcnlTdHJpbmc7XG5cbiAgLy8gZXhwb3J0IGRlZmF1bHQgZm9yIGhvbGRpbmcgdGhlIFZ1ZSByZWZlcmVuY2VcbiAgdmFyIGV4cG9ydHMkMSA9IHt9O1xuICAvKipcbiAgICogV2FybiBzdHVmZi5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZ1xuICAgKi9cblxuICBmdW5jdGlvbiB3YXJuJDEobXNnKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbdnVlLXJvdXRlcl0gJyArIG1zZyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlc29sdmUgYSByZWxhdGl2ZSBwYXRoLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYmFzZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcmVsYXRpdmVcbiAgICogQHBhcmFtIHtCb29sZWFufSBhcHBlbmRcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cblxuICBmdW5jdGlvbiByZXNvbHZlUGF0aChiYXNlLCByZWxhdGl2ZSwgYXBwZW5kKSB7XG4gICAgdmFyIHF1ZXJ5ID0gYmFzZS5tYXRjaCgvKFxcPy4qKSQvKTtcbiAgICBpZiAocXVlcnkpIHtcbiAgICAgIHF1ZXJ5ID0gcXVlcnlbMV07XG4gICAgICBiYXNlID0gYmFzZS5zbGljZSgwLCAtcXVlcnkubGVuZ3RoKTtcbiAgICB9XG4gICAgLy8gYSBxdWVyeSFcbiAgICBpZiAocmVsYXRpdmUuY2hhckF0KDApID09PSAnPycpIHtcbiAgICAgIHJldHVybiBiYXNlICsgcmVsYXRpdmU7XG4gICAgfVxuICAgIHZhciBzdGFjayA9IGJhc2Uuc3BsaXQoJy8nKTtcbiAgICAvLyByZW1vdmUgdHJhaWxpbmcgc2VnbWVudCBpZjpcbiAgICAvLyAtIG5vdCBhcHBlbmRpbmdcbiAgICAvLyAtIGFwcGVuZGluZyB0byB0cmFpbGluZyBzbGFzaCAobGFzdCBzZWdtZW50IGlzIGVtcHR5KVxuICAgIGlmICghYXBwZW5kIHx8ICFzdGFja1tzdGFjay5sZW5ndGggLSAxXSkge1xuICAgICAgc3RhY2sucG9wKCk7XG4gICAgfVxuICAgIC8vIHJlc29sdmUgcmVsYXRpdmUgcGF0aFxuICAgIHZhciBzZWdtZW50cyA9IHJlbGF0aXZlLnJlcGxhY2UoL15cXC8vLCAnJykuc3BsaXQoJy8nKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgICAgaWYgKHNlZ21lbnQgPT09ICcuJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAoc2VnbWVudCA9PT0gJy4uJykge1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YWNrLnB1c2goc2VnbWVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGVuc3VyZSBsZWFkaW5nIHNsYXNoXG4gICAgaWYgKHN0YWNrWzBdICE9PSAnJykge1xuICAgICAgc3RhY2sudW5zaGlmdCgnJyk7XG4gICAgfVxuICAgIHJldHVybiBzdGFjay5qb2luKCcvJyk7XG4gIH1cblxuICAvKipcbiAgICogRm9yZ2l2aW5nIGNoZWNrIGZvciBhIHByb21pc2VcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG5cbiAgZnVuY3Rpb24gaXNQcm9taXNlKHApIHtcbiAgICByZXR1cm4gcCAmJiB0eXBlb2YgcC50aGVuID09PSAnZnVuY3Rpb24nO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpdmUgYSByb3V0ZSBjb25maWcgZmllbGQgZnJvbSBhIGNvbXBvbmVudCBpbnN0YW5jZVxuICAgKiBPUiBhIGNvbXBvbmVudCBjb250cnVjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufFZ1ZX0gY29tcG9uZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGdldFJvdXRlQ29uZmlnKGNvbXBvbmVudCwgbmFtZSkge1xuICAgIHZhciBvcHRpb25zID0gY29tcG9uZW50ICYmIChjb21wb25lbnQuJG9wdGlvbnMgfHwgY29tcG9uZW50Lm9wdGlvbnMpO1xuICAgIHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMucm91dGUgJiYgb3B0aW9ucy5yb3V0ZVtuYW1lXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlIGFuIGFzeW5jIGNvbXBvbmVudCBmYWN0b3J5LiBIYXZlIHRvIGRvIGEgZGlydHlcbiAgICogbW9jayBoZXJlIGJlY2F1c2Ugb2YgVnVlIGNvcmUncyBpbnRlcm5hbCBBUEkgZGVwZW5kcyBvblxuICAgKiBhbiBJRCBjaGVjay5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGhhbmRsZXJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICovXG5cbiAgdmFyIHJlc29sdmVyID0gdW5kZWZpbmVkO1xuXG4gIGZ1bmN0aW9uIHJlc29sdmVBc3luY0NvbXBvbmVudChoYW5kbGVyLCBjYikge1xuICAgIGlmICghcmVzb2x2ZXIpIHtcbiAgICAgIHJlc29sdmVyID0ge1xuICAgICAgICByZXNvbHZlOiBleHBvcnRzJDEuVnVlLnByb3RvdHlwZS5fcmVzb2x2ZUNvbXBvbmVudCxcbiAgICAgICAgJG9wdGlvbnM6IHtcbiAgICAgICAgICBjb21wb25lbnRzOiB7XG4gICAgICAgICAgICBfOiBoYW5kbGVyLmNvbXBvbmVudFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZXIuJG9wdGlvbnMuY29tcG9uZW50cy5fID0gaGFuZGxlci5jb21wb25lbnQ7XG4gICAgfVxuICAgIHJlc29sdmVyLnJlc29sdmUoJ18nLCBmdW5jdGlvbiAoQ29tcG9uZW50KSB7XG4gICAgICBoYW5kbGVyLmNvbXBvbmVudCA9IENvbXBvbmVudDtcbiAgICAgIGNiKENvbXBvbmVudCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTWFwIHRoZSBkeW5hbWljIHNlZ21lbnRzIGluIGEgcGF0aCB0byBwYXJhbXMuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICogQHBhcmFtIHtPYmplY3R9IHF1ZXJ5XG4gICAqL1xuXG4gIGZ1bmN0aW9uIG1hcFBhcmFtcyhwYXRoLCBwYXJhbXMsIHF1ZXJ5KSB7XG4gICAgaWYgKHBhcmFtcyA9PT0gdW5kZWZpbmVkKSBwYXJhbXMgPSB7fTtcblxuICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoLzooW15cXC9dKykvZywgZnVuY3Rpb24gKF8sIGtleSkge1xuICAgICAgdmFyIHZhbCA9IHBhcmFtc1trZXldO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIXZhbCkge1xuICAgICAgICB3YXJuJDEoJ3BhcmFtIFwiJyArIGtleSArICdcIiBub3QgZm91bmQgd2hlbiBnZW5lcmF0aW5nICcgKyAncGF0aCBmb3IgXCInICsgcGF0aCArICdcIiB3aXRoIHBhcmFtcyAnICsgSlNPTi5zdHJpbmdpZnkocGFyYW1zKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsIHx8ICcnO1xuICAgIH0pO1xuICAgIGlmIChxdWVyeSkge1xuICAgICAgcGF0aCArPSBnZW5RdWVyeShxdWVyeSk7XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xuICB9XG5cbiAgdmFyIGhhc2hSRSA9IC8jLiokLztcblxuICB2YXIgSFRNTDVIaXN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIVE1MNUhpc3RvcnkoX3JlZikge1xuICAgICAgdmFyIHJvb3QgPSBfcmVmLnJvb3Q7XG4gICAgICB2YXIgb25DaGFuZ2UgPSBfcmVmLm9uQ2hhbmdlO1xuICAgICAgYmFiZWxIZWxwZXJzLmNsYXNzQ2FsbENoZWNrKHRoaXMsIEhUTUw1SGlzdG9yeSk7XG5cbiAgICAgIGlmIChyb290ICYmIHJvb3QgIT09ICcvJykge1xuICAgICAgICAvLyBtYWtlIHN1cmUgdGhlcmUncyB0aGUgc3RhcnRpbmcgc2xhc2hcbiAgICAgICAgaWYgKHJvb3QuY2hhckF0KDApICE9PSAnLycpIHtcbiAgICAgICAgICByb290ID0gJy8nICsgcm9vdDtcbiAgICAgICAgfVxuICAgICAgICAvLyByZW1vdmUgdHJhaWxpbmcgc2xhc2hcbiAgICAgICAgdGhpcy5yb290ID0gcm9vdC5yZXBsYWNlKC9cXC8kLywgJycpO1xuICAgICAgICB0aGlzLnJvb3RSRSA9IG5ldyBSZWdFeHAoJ15cXFxcJyArIHRoaXMucm9vdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJvb3QgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5vbkNoYW5nZSA9IG9uQ2hhbmdlO1xuICAgICAgLy8gY2hlY2sgYmFzZSB0YWdcbiAgICAgIHZhciBiYXNlRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdiYXNlJyk7XG4gICAgICB0aGlzLmJhc2UgPSBiYXNlRWwgJiYgYmFzZUVsLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuICAgIH1cblxuICAgIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMubGlzdGVuZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgdXJsID0gbG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2g7XG4gICAgICAgIGlmIChfdGhpcy5yb290KSB7XG4gICAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoX3RoaXMucm9vdFJFLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMub25DaGFuZ2UodXJsLCBlICYmIGUuc3RhdGUsIGxvY2F0aW9uLmhhc2gpO1xuICAgICAgfTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHRoaXMubGlzdGVuZXIpO1xuICAgICAgdGhpcy5saXN0ZW5lcigpO1xuICAgIH07XG5cbiAgICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgdGhpcy5saXN0ZW5lcik7XG4gICAgfTtcblxuICAgIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiBnbyhwYXRoLCByZXBsYWNlLCBhcHBlbmQpIHtcbiAgICAgIHZhciB1cmwgPSB0aGlzLmZvcm1hdFBhdGgocGF0aCwgYXBwZW5kKTtcbiAgICAgIGlmIChyZXBsYWNlKSB7XG4gICAgICAgIGhpc3RvcnkucmVwbGFjZVN0YXRlKHt9LCAnJywgdXJsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlY29yZCBzY3JvbGwgcG9zaXRpb24gYnkgcmVwbGFjaW5nIGN1cnJlbnQgc3RhdGVcbiAgICAgICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUoe1xuICAgICAgICAgIHBvczoge1xuICAgICAgICAgICAgeDogd2luZG93LnBhZ2VYT2Zmc2V0LFxuICAgICAgICAgICAgeTogd2luZG93LnBhZ2VZT2Zmc2V0XG4gICAgICAgICAgfVxuICAgICAgICB9LCAnJywgbG9jYXRpb24uaHJlZik7XG4gICAgICAgIC8vIHRoZW4gcHVzaCBuZXcgc3RhdGVcbiAgICAgICAgaGlzdG9yeS5wdXNoU3RhdGUoe30sICcnLCB1cmwpO1xuICAgICAgfVxuICAgICAgdmFyIGhhc2hNYXRjaCA9IHBhdGgubWF0Y2goaGFzaFJFKTtcbiAgICAgIHZhciBoYXNoID0gaGFzaE1hdGNoICYmIGhhc2hNYXRjaFswXTtcbiAgICAgIHBhdGggPSB1cmxcbiAgICAgIC8vIHN0cmlwIGhhc2ggc28gaXQgZG9lc24ndCBtZXNzIHVwIHBhcmFtc1xuICAgICAgLnJlcGxhY2UoaGFzaFJFLCAnJylcbiAgICAgIC8vIHJlbW92ZSByb290IGJlZm9yZSBtYXRjaGluZ1xuICAgICAgLnJlcGxhY2UodGhpcy5yb290UkUsICcnKTtcbiAgICAgIHRoaXMub25DaGFuZ2UocGF0aCwgbnVsbCwgaGFzaCk7XG4gICAgfTtcblxuICAgIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUuZm9ybWF0UGF0aCA9IGZ1bmN0aW9uIGZvcm1hdFBhdGgocGF0aCwgYXBwZW5kKSB7XG4gICAgICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJ1xuICAgICAgLy8gYWJzb2x1dGUgcGF0aFxuICAgICAgPyB0aGlzLnJvb3QgPyB0aGlzLnJvb3QgKyAnLycgKyBwYXRoLnJlcGxhY2UoL15cXC8vLCAnJykgOiBwYXRoIDogcmVzb2x2ZVBhdGgodGhpcy5iYXNlIHx8IGxvY2F0aW9uLnBhdGhuYW1lLCBwYXRoLCBhcHBlbmQpO1xuICAgIH07XG5cbiAgICByZXR1cm4gSFRNTDVIaXN0b3J5O1xuICB9KSgpO1xuXG4gIHZhciBIYXNoSGlzdG9yeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSGFzaEhpc3RvcnkoX3JlZikge1xuICAgICAgdmFyIGhhc2hiYW5nID0gX3JlZi5oYXNoYmFuZztcbiAgICAgIHZhciBvbkNoYW5nZSA9IF9yZWYub25DaGFuZ2U7XG4gICAgICBiYWJlbEhlbHBlcnMuY2xhc3NDYWxsQ2hlY2sodGhpcywgSGFzaEhpc3RvcnkpO1xuXG4gICAgICB0aGlzLmhhc2hiYW5nID0gaGFzaGJhbmc7XG4gICAgICB0aGlzLm9uQ2hhbmdlID0gb25DaGFuZ2U7XG4gICAgfVxuXG4gICAgSGFzaEhpc3RvcnkucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB0aGlzLmxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGF0aCA9IGxvY2F0aW9uLmhhc2g7XG4gICAgICAgIHZhciByYXcgPSBwYXRoLnJlcGxhY2UoL14jIT8vLCAnJyk7XG4gICAgICAgIC8vIGFsd2F5c1xuICAgICAgICBpZiAocmF3LmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgICAgICAgcmF3ID0gJy8nICsgcmF3O1xuICAgICAgICB9XG4gICAgICAgIHZhciBmb3JtYXR0ZWRQYXRoID0gc2VsZi5mb3JtYXRQYXRoKHJhdyk7XG4gICAgICAgIGlmIChmb3JtYXR0ZWRQYXRoICE9PSBwYXRoKSB7XG4gICAgICAgICAgbG9jYXRpb24ucmVwbGFjZShmb3JtYXR0ZWRQYXRoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGV0ZXJtaW5lIHF1ZXJ5XG4gICAgICAgIC8vIG5vdGUgaXQncyBwb3NzaWJsZSB0byBoYXZlIHF1ZXJpZXMgaW4gYm90aCB0aGUgYWN0dWFsIFVSTFxuICAgICAgICAvLyBhbmQgdGhlIGhhc2ggZnJhZ21lbnQgaXRzZWxmLlxuICAgICAgICB2YXIgcXVlcnkgPSBsb2NhdGlvbi5zZWFyY2ggJiYgcGF0aC5pbmRleE9mKCc/JykgPiAtMSA/ICcmJyArIGxvY2F0aW9uLnNlYXJjaC5zbGljZSgxKSA6IGxvY2F0aW9uLnNlYXJjaDtcbiAgICAgICAgc2VsZi5vbkNoYW5nZShwYXRoLnJlcGxhY2UoL14jIT8vLCAnJykgKyBxdWVyeSk7XG4gICAgICB9O1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCB0aGlzLmxpc3RlbmVyKTtcbiAgICAgIHRoaXMubGlzdGVuZXIoKTtcbiAgICB9O1xuXG4gICAgSGFzaEhpc3RvcnkucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCB0aGlzLmxpc3RlbmVyKTtcbiAgICB9O1xuXG4gICAgSGFzaEhpc3RvcnkucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gZ28ocGF0aCwgcmVwbGFjZSwgYXBwZW5kKSB7XG4gICAgICBwYXRoID0gdGhpcy5mb3JtYXRQYXRoKHBhdGgsIGFwcGVuZCk7XG4gICAgICBpZiAocmVwbGFjZSkge1xuICAgICAgICBsb2NhdGlvbi5yZXBsYWNlKHBhdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9jYXRpb24uaGFzaCA9IHBhdGg7XG4gICAgICB9XG4gICAgfTtcblxuICAgIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5mb3JtYXRQYXRoID0gZnVuY3Rpb24gZm9ybWF0UGF0aChwYXRoLCBhcHBlbmQpIHtcbiAgICAgIHZhciBpc0Fic29sb3V0ZSA9IHBhdGguY2hhckF0KDApID09PSAnLyc7XG4gICAgICB2YXIgcHJlZml4ID0gJyMnICsgKHRoaXMuaGFzaGJhbmcgPyAnIScgOiAnJyk7XG4gICAgICByZXR1cm4gaXNBYnNvbG91dGUgPyBwcmVmaXggKyBwYXRoIDogcHJlZml4ICsgcmVzb2x2ZVBhdGgobG9jYXRpb24uaGFzaC5yZXBsYWNlKC9eIyE/LywgJycpLCBwYXRoLCBhcHBlbmQpO1xuICAgIH07XG5cbiAgICByZXR1cm4gSGFzaEhpc3Rvcnk7XG4gIH0pKCk7XG5cbiAgdmFyIEFic3RyYWN0SGlzdG9yeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQWJzdHJhY3RIaXN0b3J5KF9yZWYpIHtcbiAgICAgIHZhciBvbkNoYW5nZSA9IF9yZWYub25DaGFuZ2U7XG4gICAgICBiYWJlbEhlbHBlcnMuY2xhc3NDYWxsQ2hlY2sodGhpcywgQWJzdHJhY3RIaXN0b3J5KTtcblxuICAgICAgdGhpcy5vbkNoYW5nZSA9IG9uQ2hhbmdlO1xuICAgICAgdGhpcy5jdXJyZW50UGF0aCA9ICcvJztcbiAgICB9XG5cbiAgICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICB0aGlzLm9uQ2hhbmdlKCcvJyk7XG4gICAgfTtcblxuICAgIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICAvLyBub29wXG4gICAgfTtcblxuICAgIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiBnbyhwYXRoLCByZXBsYWNlLCBhcHBlbmQpIHtcbiAgICAgIHBhdGggPSB0aGlzLmN1cnJlbnRQYXRoID0gdGhpcy5mb3JtYXRQYXRoKHBhdGgsIGFwcGVuZCk7XG4gICAgICB0aGlzLm9uQ2hhbmdlKHBhdGgpO1xuICAgIH07XG5cbiAgICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLmZvcm1hdFBhdGggPSBmdW5jdGlvbiBmb3JtYXRQYXRoKHBhdGgsIGFwcGVuZCkge1xuICAgICAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLycgPyBwYXRoIDogcmVzb2x2ZVBhdGgodGhpcy5jdXJyZW50UGF0aCwgcGF0aCwgYXBwZW5kKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEFic3RyYWN0SGlzdG9yeTtcbiAgfSkoKTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHRoZSByZXVzYWJpbGl0eSBvZiBhbiBleGlzdGluZyByb3V0ZXIgdmlldy5cbiAgICpcbiAgICogQHBhcmFtIHtEaXJlY3RpdmV9IHZpZXdcbiAgICogQHBhcmFtIHtPYmplY3R9IGhhbmRsZXJcbiAgICogQHBhcmFtIHtUcmFuc2l0aW9ufSB0cmFuc2l0aW9uXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNhblJldXNlKHZpZXcsIGhhbmRsZXIsIHRyYW5zaXRpb24pIHtcbiAgICB2YXIgY29tcG9uZW50ID0gdmlldy5jaGlsZFZNO1xuICAgIGlmICghY29tcG9uZW50IHx8ICFoYW5kbGVyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGltcG9ydGFudDogY2hlY2sgdmlldy5Db21wb25lbnQgaGVyZSBiZWNhdXNlIGl0IG1heVxuICAgIC8vIGhhdmUgYmVlbiBjaGFuZ2VkIGluIGFjdGl2YXRlIGhvb2tcbiAgICBpZiAodmlldy5Db21wb25lbnQgIT09IGhhbmRsZXIuY29tcG9uZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBjYW5SZXVzZUZuID0gZ2V0Um91dGVDb25maWcoY29tcG9uZW50LCAnY2FuUmV1c2UnKTtcbiAgICByZXR1cm4gdHlwZW9mIGNhblJldXNlRm4gPT09ICdib29sZWFuJyA/IGNhblJldXNlRm4gOiBjYW5SZXVzZUZuID8gY2FuUmV1c2VGbi5jYWxsKGNvbXBvbmVudCwge1xuICAgICAgdG86IHRyYW5zaXRpb24udG8sXG4gICAgICBmcm9tOiB0cmFuc2l0aW9uLmZyb21cbiAgICB9KSA6IHRydWU7IC8vIGRlZmF1bHRzIHRvIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIGNvbXBvbmVudCBjYW4gZGVhY3RpdmF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtEaXJlY3RpdmV9IHZpZXdcbiAgICogQHBhcmFtIHtUcmFuc2l0aW9ufSB0cmFuc2l0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHRcbiAgICovXG5cbiAgZnVuY3Rpb24gY2FuRGVhY3RpdmF0ZSh2aWV3LCB0cmFuc2l0aW9uLCBuZXh0KSB7XG4gICAgdmFyIGZyb21Db21wb25lbnQgPSB2aWV3LmNoaWxkVk07XG4gICAgdmFyIGhvb2sgPSBnZXRSb3V0ZUNvbmZpZyhmcm9tQ29tcG9uZW50LCAnY2FuRGVhY3RpdmF0ZScpO1xuICAgIGlmICghaG9vaykge1xuICAgICAgbmV4dCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2l0aW9uLmNhbGxIb29rKGhvb2ssIGZyb21Db21wb25lbnQsIG5leHQsIHtcbiAgICAgICAgZXhwZWN0Qm9vbGVhbjogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgY29tcG9uZW50IGNhbiBhY3RpdmF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGhhbmRsZXJcbiAgICogQHBhcmFtIHtUcmFuc2l0aW9ufSB0cmFuc2l0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHRcbiAgICovXG5cbiAgZnVuY3Rpb24gY2FuQWN0aXZhdGUoaGFuZGxlciwgdHJhbnNpdGlvbiwgbmV4dCkge1xuICAgIHJlc29sdmVBc3luY0NvbXBvbmVudChoYW5kbGVyLCBmdW5jdGlvbiAoQ29tcG9uZW50KSB7XG4gICAgICAvLyBoYXZlIHRvIGNoZWNrIGR1ZSB0byBhc3luYy1uZXNzXG4gICAgICBpZiAodHJhbnNpdGlvbi5hYm9ydGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIGRldGVybWluZSBpZiB0aGlzIGNvbXBvbmVudCBjYW4gYmUgYWN0aXZhdGVkXG4gICAgICB2YXIgaG9vayA9IGdldFJvdXRlQ29uZmlnKENvbXBvbmVudCwgJ2NhbkFjdGl2YXRlJyk7XG4gICAgICBpZiAoIWhvb2spIHtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhbnNpdGlvbi5jYWxsSG9vayhob29rLCBudWxsLCBuZXh0LCB7XG4gICAgICAgICAgZXhwZWN0Qm9vbGVhbjogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsIGRlYWN0aXZhdGUgaG9va3MgZm9yIGV4aXN0aW5nIHJvdXRlci12aWV3cy5cbiAgICpcbiAgICogQHBhcmFtIHtEaXJlY3RpdmV9IHZpZXdcbiAgICogQHBhcmFtIHtUcmFuc2l0aW9ufSB0cmFuc2l0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHRcbiAgICovXG5cbiAgZnVuY3Rpb24gZGVhY3RpdmF0ZSh2aWV3LCB0cmFuc2l0aW9uLCBuZXh0KSB7XG4gICAgdmFyIGNvbXBvbmVudCA9IHZpZXcuY2hpbGRWTTtcbiAgICB2YXIgaG9vayA9IGdldFJvdXRlQ29uZmlnKGNvbXBvbmVudCwgJ2RlYWN0aXZhdGUnKTtcbiAgICBpZiAoIWhvb2spIHtcbiAgICAgIG5leHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNpdGlvbi5jYWxsSG9va3MoaG9vaywgY29tcG9uZW50LCBuZXh0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWN0aXZhdGUgLyBzd2l0Y2ggY29tcG9uZW50IGZvciBhIHJvdXRlci12aWV3LlxuICAgKlxuICAgKiBAcGFyYW0ge0RpcmVjdGl2ZX0gdmlld1xuICAgKiBAcGFyYW0ge1RyYW5zaXRpb259IHRyYW5zaXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlcHRoXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICovXG5cbiAgZnVuY3Rpb24gYWN0aXZhdGUodmlldywgdHJhbnNpdGlvbiwgZGVwdGgsIGNiLCByZXVzZSkge1xuICAgIHZhciBoYW5kbGVyID0gdHJhbnNpdGlvbi5hY3RpdmF0ZVF1ZXVlW2RlcHRoXTtcbiAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgIHNhdmVDaGlsZFZpZXcodmlldyk7XG4gICAgICBpZiAodmlldy5fYm91bmQpIHtcbiAgICAgICAgdmlldy5zZXRDb21wb25lbnQobnVsbCk7XG4gICAgICB9XG4gICAgICBjYiAmJiBjYigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBDb21wb25lbnQgPSB2aWV3LkNvbXBvbmVudCA9IGhhbmRsZXIuY29tcG9uZW50O1xuICAgIHZhciBhY3RpdmF0ZUhvb2sgPSBnZXRSb3V0ZUNvbmZpZyhDb21wb25lbnQsICdhY3RpdmF0ZScpO1xuICAgIHZhciBkYXRhSG9vayA9IGdldFJvdXRlQ29uZmlnKENvbXBvbmVudCwgJ2RhdGEnKTtcbiAgICB2YXIgd2FpdEZvckRhdGEgPSBnZXRSb3V0ZUNvbmZpZyhDb21wb25lbnQsICd3YWl0Rm9yRGF0YScpO1xuXG4gICAgdmlldy5kZXB0aCA9IGRlcHRoO1xuICAgIHZpZXcuYWN0aXZhdGVkID0gZmFsc2U7XG5cbiAgICB2YXIgY29tcG9uZW50ID0gdW5kZWZpbmVkO1xuICAgIHZhciBsb2FkaW5nID0gISEoZGF0YUhvb2sgJiYgIXdhaXRGb3JEYXRhKTtcblxuICAgIC8vIFwicmV1c2VcIiBpcyBhIGZsYWcgcGFzc2VkIGRvd24gd2hlbiB0aGUgcGFyZW50IHZpZXcgaXNcbiAgICAvLyBlaXRoZXIgcmV1c2VkIHZpYSBrZWVwLWFsaXZlIG9yIGFzIGEgY2hpbGQgb2YgYSBrZXB0LWFsaXZlIHZpZXcuXG4gICAgLy8gb2YgY291cnNlIHdlIGNhbiBvbmx5IHJldXNlIGlmIHRoZSBjdXJyZW50IGtlcHQtYWxpdmUgaW5zdGFuY2VcbiAgICAvLyBpcyBvZiB0aGUgY29ycmVjdCB0eXBlLlxuICAgIHJldXNlID0gcmV1c2UgJiYgdmlldy5jaGlsZFZNICYmIHZpZXcuY2hpbGRWTS5jb25zdHJ1Y3RvciA9PT0gQ29tcG9uZW50O1xuXG4gICAgaWYgKHJldXNlKSB7XG4gICAgICAvLyBqdXN0IHJldXNlXG4gICAgICBjb21wb25lbnQgPSB2aWV3LmNoaWxkVk07XG4gICAgICBjb21wb25lbnQuJGxvYWRpbmdSb3V0ZURhdGEgPSBsb2FkaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICBzYXZlQ2hpbGRWaWV3KHZpZXcpO1xuXG4gICAgICAvLyB1bmJ1aWxkIGN1cnJlbnQgY29tcG9uZW50LiB0aGlzIHN0ZXAgYWxzbyBkZXN0cm95c1xuICAgICAgLy8gYW5kIHJlbW92ZXMgYWxsIG5lc3RlZCBjaGlsZCB2aWV3cy5cbiAgICAgIHZpZXcudW5idWlsZCh0cnVlKTtcblxuICAgICAgLy8gYnVpbGQgdGhlIG5ldyBjb21wb25lbnQuIHRoaXMgd2lsbCBhbHNvIGNyZWF0ZSB0aGVcbiAgICAgIC8vIGRpcmVjdCBjaGlsZCB2aWV3IG9mIHRoZSBjdXJyZW50IG9uZS4gaXQgd2lsbCByZWdpc3RlclxuICAgICAgLy8gaXRzZWxmIGFzIHZpZXcuY2hpbGRWaWV3LlxuICAgICAgY29tcG9uZW50ID0gdmlldy5idWlsZCh7XG4gICAgICAgIF9tZXRhOiB7XG4gICAgICAgICAgJGxvYWRpbmdSb3V0ZURhdGE6IGxvYWRpbmdcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcbiAgICAgICAgICB0aGlzLl9yb3V0ZXJWaWV3ID0gdmlldztcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIGhhbmRsZSBrZWVwLWFsaXZlLlxuICAgICAgLy8gd2hlbiBhIGtlcHQtYWxpdmUgY2hpbGQgdm0gaXMgcmVzdG9yZWQsIHdlIG5lZWQgdG9cbiAgICAgIC8vIGFkZCBpdHMgY2FjaGVkIGNoaWxkIHZpZXdzIGludG8gdGhlIHJvdXRlcidzIHZpZXcgbGlzdCxcbiAgICAgIC8vIGFuZCBhbHNvIHByb3Blcmx5IHVwZGF0ZSBjdXJyZW50IHZpZXcncyBjaGlsZCB2aWV3LlxuICAgICAgaWYgKHZpZXcua2VlcEFsaXZlKSB7XG4gICAgICAgIGNvbXBvbmVudC4kbG9hZGluZ1JvdXRlRGF0YSA9IGxvYWRpbmc7XG4gICAgICAgIHZhciBjYWNoZWRDaGlsZFZpZXcgPSBjb21wb25lbnQuX2tlZXBBbGl2ZVJvdXRlclZpZXc7XG4gICAgICAgIGlmIChjYWNoZWRDaGlsZFZpZXcpIHtcbiAgICAgICAgICB2aWV3LmNoaWxkVmlldyA9IGNhY2hlZENoaWxkVmlldztcbiAgICAgICAgICBjb21wb25lbnQuX2tlZXBBbGl2ZVJvdXRlclZpZXcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2xlYW51cCB0aGUgY29tcG9uZW50IGluIGNhc2UgdGhlIHRyYW5zaXRpb24gaXMgYWJvcnRlZFxuICAgIC8vIGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIGV2ZXIgaW5zZXJ0ZWQuXG4gICAgdmFyIGNsZWFudXAgPSBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgY29tcG9uZW50LiRkZXN0cm95KCk7XG4gICAgfTtcblxuICAgIC8vIGFjdHVhbGx5IGluc2VydCB0aGUgY29tcG9uZW50IGFuZCB0cmlnZ2VyIHRyYW5zaXRpb25cbiAgICB2YXIgaW5zZXJ0ID0gZnVuY3Rpb24gaW5zZXJ0KCkge1xuICAgICAgaWYgKHJldXNlKSB7XG4gICAgICAgIGNiICYmIGNiKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciByb3V0ZXIgPSB0cmFuc2l0aW9uLnJvdXRlcjtcbiAgICAgIGlmIChyb3V0ZXIuX3JlbmRlcmVkIHx8IHJvdXRlci5fdHJhbnNpdGlvbk9uTG9hZCkge1xuICAgICAgICB2aWV3LnRyYW5zaXRpb24oY29tcG9uZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vIHRyYW5zaXRpb24gb24gZmlyc3QgcmVuZGVyLCBtYW51YWwgdHJhbnNpdGlvblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHZpZXcuc2V0Q3VycmVudCkge1xuICAgICAgICAgIC8vIDAuMTIgY29tcGF0XG4gICAgICAgICAgdmlldy5zZXRDdXJyZW50KGNvbXBvbmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gMS4wXG4gICAgICAgICAgdmlldy5jaGlsZFZNID0gY29tcG9uZW50O1xuICAgICAgICB9XG4gICAgICAgIGNvbXBvbmVudC4kYmVmb3JlKHZpZXcuYW5jaG9yLCBudWxsLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICBjYiAmJiBjYigpO1xuICAgIH07XG5cbiAgICB2YXIgYWZ0ZXJEYXRhID0gZnVuY3Rpb24gYWZ0ZXJEYXRhKCkge1xuICAgICAgLy8gYWN0aXZhdGUgdGhlIGNoaWxkIHZpZXdcbiAgICAgIGlmICh2aWV3LmNoaWxkVmlldykge1xuICAgICAgICBhY3RpdmF0ZSh2aWV3LmNoaWxkVmlldywgdHJhbnNpdGlvbiwgZGVwdGggKyAxLCBudWxsLCByZXVzZSB8fCB2aWV3LmtlZXBBbGl2ZSk7XG4gICAgICB9XG4gICAgICBpbnNlcnQoKTtcbiAgICB9O1xuXG4gICAgLy8gY2FsbGVkIGFmdGVyIGFjdGl2YXRpb24gaG9vayBpcyByZXNvbHZlZFxuICAgIHZhciBhZnRlckFjdGl2YXRlID0gZnVuY3Rpb24gYWZ0ZXJBY3RpdmF0ZSgpIHtcbiAgICAgIHZpZXcuYWN0aXZhdGVkID0gdHJ1ZTtcbiAgICAgIGlmIChkYXRhSG9vayAmJiB3YWl0Rm9yRGF0YSkge1xuICAgICAgICAvLyB3YWl0IHVudGlsIGRhdGEgbG9hZGVkIHRvIGluc2VydFxuICAgICAgICBsb2FkRGF0YShjb21wb25lbnQsIHRyYW5zaXRpb24sIGRhdGFIb29rLCBhZnRlckRhdGEsIGNsZWFudXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbG9hZCBkYXRhIGFuZCBpbnNlcnQgYXQgdGhlIHNhbWUgdGltZVxuICAgICAgICBpZiAoZGF0YUhvb2spIHtcbiAgICAgICAgICBsb2FkRGF0YShjb21wb25lbnQsIHRyYW5zaXRpb24sIGRhdGFIb29rKTtcbiAgICAgICAgfVxuICAgICAgICBhZnRlckRhdGEoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKGFjdGl2YXRlSG9vaykge1xuICAgICAgdHJhbnNpdGlvbi5jYWxsSG9va3MoYWN0aXZhdGVIb29rLCBjb21wb25lbnQsIGFmdGVyQWN0aXZhdGUsIHtcbiAgICAgICAgY2xlYW51cDogY2xlYW51cCxcbiAgICAgICAgcG9zdEFjdGl2YXRlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJBY3RpdmF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXVzZSBhIHZpZXcsIGp1c3QgcmVsb2FkIGRhdGEgaWYgbmVjZXNzYXJ5LlxuICAgKlxuICAgKiBAcGFyYW0ge0RpcmVjdGl2ZX0gdmlld1xuICAgKiBAcGFyYW0ge1RyYW5zaXRpb259IHRyYW5zaXRpb25cbiAgICovXG5cbiAgZnVuY3Rpb24gcmV1c2UodmlldywgdHJhbnNpdGlvbikge1xuICAgIHZhciBjb21wb25lbnQgPSB2aWV3LmNoaWxkVk07XG4gICAgdmFyIGRhdGFIb29rID0gZ2V0Um91dGVDb25maWcoY29tcG9uZW50LCAnZGF0YScpO1xuICAgIGlmIChkYXRhSG9vaykge1xuICAgICAgbG9hZERhdGEoY29tcG9uZW50LCB0cmFuc2l0aW9uLCBkYXRhSG9vayk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFzeW5jaHJvbm91c2x5IGxvYWQgYW5kIGFwcGx5IGRhdGEgdG8gY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1Z1ZX0gY29tcG9uZW50XG4gICAqIEBwYXJhbSB7VHJhbnNpdGlvbn0gdHJhbnNpdGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBob29rXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNsZWFudXBcbiAgICovXG5cbiAgZnVuY3Rpb24gbG9hZERhdGEoY29tcG9uZW50LCB0cmFuc2l0aW9uLCBob29rLCBjYiwgY2xlYW51cCkge1xuICAgIGNvbXBvbmVudC4kbG9hZGluZ1JvdXRlRGF0YSA9IHRydWU7XG4gICAgdHJhbnNpdGlvbi5jYWxsSG9va3MoaG9vaywgY29tcG9uZW50LCBmdW5jdGlvbiAoKSB7XG4gICAgICBjb21wb25lbnQuJGxvYWRpbmdSb3V0ZURhdGEgPSBmYWxzZTtcbiAgICAgIGNvbXBvbmVudC4kZW1pdCgncm91dGUtZGF0YS1sb2FkZWQnLCBjb21wb25lbnQpO1xuICAgICAgY2IgJiYgY2IoKTtcbiAgICB9LCB7XG4gICAgICBjbGVhbnVwOiBjbGVhbnVwLFxuICAgICAgcG9zdEFjdGl2YXRlOiB0cnVlLFxuICAgICAgcHJvY2Vzc0RhdGE6IGZ1bmN0aW9uIHByb2Nlc3NEYXRhKGRhdGEpIHtcbiAgICAgICAgLy8gaGFuZGxlIHByb21pc2Ugc3VnYXIgc3ludGF4XG4gICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgICAgICBpZiAoaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgICAgICAgIE9iamVjdC5rZXlzKGRhdGEpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIHZhbCA9IGRhdGFba2V5XTtcbiAgICAgICAgICAgIGlmIChpc1Byb21pc2UodmFsKSkge1xuICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHZhbC50aGVuKGZ1bmN0aW9uIChyZXNvbHZlZFZhbCkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC4kc2V0KGtleSwgcmVzb2x2ZWRWYWwpO1xuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb21wb25lbnQuJHNldChrZXksIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb21pc2VzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBwcm9taXNlc1swXS5jb25zdHJ1Y3Rvci5hbGwocHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2F2ZSB0aGUgY2hpbGQgdmlldyBmb3IgYSBrZXB0LWFsaXZlIHZpZXcgc28gdGhhdFxuICAgKiB3ZSBjYW4gcmVzdG9yZSBpdCB3aGVuIGl0IGlzIHN3aXRjaGVkIGJhY2sgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7RGlyZWN0aXZlfSB2aWV3XG4gICAqL1xuXG4gIGZ1bmN0aW9uIHNhdmVDaGlsZFZpZXcodmlldykge1xuICAgIGlmICh2aWV3LmtlZXBBbGl2ZSAmJiB2aWV3LmNoaWxkVk0gJiYgdmlldy5jaGlsZFZpZXcpIHtcbiAgICAgIHZpZXcuY2hpbGRWTS5fa2VlcEFsaXZlUm91dGVyVmlldyA9IHZpZXcuY2hpbGRWaWV3O1xuICAgIH1cbiAgICB2aWV3LmNoaWxkVmlldyA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgcGxhaW4gb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbFxuICAgKi9cblxuICBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG4gIH1cblxuICAvKipcbiAgICogQSBSb3V0ZVRyYW5zaXRpb24gb2JqZWN0IG1hbmFnZXMgdGhlIHBpcGVsaW5lIG9mIGFcbiAgICogcm91dGVyLXZpZXcgc3dpdGNoaW5nIHByb2Nlc3MuIFRoaXMgaXMgYWxzbyB0aGUgb2JqZWN0XG4gICAqIHBhc3NlZCBpbnRvIHVzZXIgcm91dGUgaG9va3MuXG4gICAqXG4gICAqIEBwYXJhbSB7Um91dGVyfSByb3V0ZXJcbiAgICogQHBhcmFtIHtSb3V0ZX0gdG9cbiAgICogQHBhcmFtIHtSb3V0ZX0gZnJvbVxuICAgKi9cblxuICB2YXIgUm91dGVUcmFuc2l0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSb3V0ZVRyYW5zaXRpb24ocm91dGVyLCB0bywgZnJvbSkge1xuICAgICAgYmFiZWxIZWxwZXJzLmNsYXNzQ2FsbENoZWNrKHRoaXMsIFJvdXRlVHJhbnNpdGlvbik7XG5cbiAgICAgIHRoaXMucm91dGVyID0gcm91dGVyO1xuICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgIHRoaXMubmV4dCA9IG51bGw7XG4gICAgICB0aGlzLmFib3J0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFib3J0IGN1cnJlbnQgdHJhbnNpdGlvbiBhbmQgcmV0dXJuIHRvIHByZXZpb3VzIGxvY2F0aW9uLlxuICAgICAqL1xuXG4gICAgUm91dGVUcmFuc2l0aW9uLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgICAgaWYgKCF0aGlzLmFib3J0ZWQpIHtcbiAgICAgICAgdGhpcy5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gaWYgdGhlIHJvb3QgcGF0aCB0aHJvd3MgYW4gZXJyb3IgZHVyaW5nIHZhbGlkYXRpb25cbiAgICAgICAgLy8gb24gaW5pdGlhbCBsb2FkLCBpdCBnZXRzIGNhdWdodCBpbiBhbiBpbmZpbml0ZSBsb29wLlxuICAgICAgICB2YXIgYWJvcnRpbmdPbkxvYWQgPSAhdGhpcy5mcm9tLnBhdGggJiYgdGhpcy50by5wYXRoID09PSAnLyc7XG4gICAgICAgIGlmICghYWJvcnRpbmdPbkxvYWQpIHtcbiAgICAgICAgICB0aGlzLnJvdXRlci5yZXBsYWNlKHRoaXMuZnJvbS5wYXRoIHx8ICcvJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWJvcnQgY3VycmVudCB0cmFuc2l0aW9uIGFuZCByZWRpcmVjdCB0byBhIG5ldyBsb2NhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAgICovXG5cbiAgICBSb3V0ZVRyYW5zaXRpb24ucHJvdG90eXBlLnJlZGlyZWN0ID0gZnVuY3Rpb24gcmVkaXJlY3QocGF0aCkge1xuICAgICAgaWYgKCF0aGlzLmFib3J0ZWQpIHtcbiAgICAgICAgdGhpcy5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHBhdGggPSBtYXBQYXJhbXMocGF0aCwgdGhpcy50by5wYXJhbXMsIHRoaXMudG8ucXVlcnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGgucGFyYW1zID0gcGF0aC5wYXJhbXMgfHwgdGhpcy50by5wYXJhbXM7XG4gICAgICAgICAgcGF0aC5xdWVyeSA9IHBhdGgucXVlcnkgfHwgdGhpcy50by5xdWVyeTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJvdXRlci5yZXBsYWNlKHBhdGgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBIHJvdXRlciB2aWV3IHRyYW5zaXRpb24ncyBwaXBlbGluZSBjYW4gYmUgZGVzY3JpYmVkIGFzXG4gICAgICogZm9sbG93cywgYXNzdW1pbmcgd2UgYXJlIHRyYW5zaXRpb25pbmcgZnJvbSBhbiBleGlzdGluZ1xuICAgICAqIDxyb3V0ZXItdmlldz4gY2hhaW4gW0NvbXBvbmVudCBBLCBDb21wb25lbnQgQl0gdG8gYSBuZXdcbiAgICAgKiBjaGFpbiBbQ29tcG9uZW50IEEsIENvbXBvbmVudCBDXTpcbiAgICAgKlxuICAgICAqICBBICAgIEFcbiAgICAgKiAgfCA9PiB8XG4gICAgICogIEIgICAgQ1xuICAgICAqXG4gICAgICogMS4gUmV1c2FibGl0eSBwaGFzZTpcbiAgICAgKiAgIC0+IGNhblJldXNlKEEsIEEpXG4gICAgICogICAtPiBjYW5SZXVzZShCLCBDKVxuICAgICAqICAgLT4gZGV0ZXJtaW5lIG5ldyBxdWV1ZXM6XG4gICAgICogICAgICAtIGRlYWN0aXZhdGlvbjogW0JdXG4gICAgICogICAgICAtIGFjdGl2YXRpb246IFtDXVxuICAgICAqXG4gICAgICogMi4gVmFsaWRhdGlvbiBwaGFzZTpcbiAgICAgKiAgIC0+IGNhbkRlYWN0aXZhdGUoQilcbiAgICAgKiAgIC0+IGNhbkFjdGl2YXRlKEMpXG4gICAgICpcbiAgICAgKiAzLiBBY3RpdmF0aW9uIHBoYXNlOlxuICAgICAqICAgLT4gZGVhY3RpdmF0ZShCKVxuICAgICAqICAgLT4gYWN0aXZhdGUoQylcbiAgICAgKlxuICAgICAqIEVhY2ggb2YgdGhlc2Ugc3RlcHMgY2FuIGJlIGFzeW5jaHJvbm91cywgYW5kIGFueVxuICAgICAqIHN0ZXAgY2FuIHBvdGVudGlhbGx5IGFib3J0IHRoZSB0cmFuc2l0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICAgKi9cblxuICAgIFJvdXRlVHJhbnNpdGlvbi5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiBzdGFydChjYikge1xuICAgICAgdmFyIHRyYW5zaXRpb24gPSB0aGlzO1xuXG4gICAgICAvLyBkZXRlcm1pbmUgdGhlIHF1ZXVlIG9mIHZpZXdzIHRvIGRlYWN0aXZhdGVcbiAgICAgIHZhciBkZWFjdGl2YXRlUXVldWUgPSBbXTtcbiAgICAgIHZhciB2aWV3ID0gdGhpcy5yb3V0ZXIuX3Jvb3RWaWV3O1xuICAgICAgd2hpbGUgKHZpZXcpIHtcbiAgICAgICAgZGVhY3RpdmF0ZVF1ZXVlLnVuc2hpZnQodmlldyk7XG4gICAgICAgIHZpZXcgPSB2aWV3LmNoaWxkVmlldztcbiAgICAgIH1cbiAgICAgIHZhciByZXZlcnNlRGVhY3RpdmF0ZVF1ZXVlID0gZGVhY3RpdmF0ZVF1ZXVlLnNsaWNlKCkucmV2ZXJzZSgpO1xuXG4gICAgICAvLyBkZXRlcm1pbmUgdGhlIHF1ZXVlIG9mIHJvdXRlIGhhbmRsZXJzIHRvIGFjdGl2YXRlXG4gICAgICB2YXIgYWN0aXZhdGVRdWV1ZSA9IHRoaXMuYWN0aXZhdGVRdWV1ZSA9IHRvQXJyYXkodGhpcy50by5tYXRjaGVkKS5tYXAoZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgIHJldHVybiBtYXRjaC5oYW5kbGVyO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIDEuIFJldXNhYmlsaXR5IHBoYXNlXG4gICAgICB2YXIgaSA9IHVuZGVmaW5lZCxcbiAgICAgICAgICByZXVzZVF1ZXVlID0gdW5kZWZpbmVkO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHJldmVyc2VEZWFjdGl2YXRlUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFjYW5SZXVzZShyZXZlcnNlRGVhY3RpdmF0ZVF1ZXVlW2ldLCBhY3RpdmF0ZVF1ZXVlW2ldLCB0cmFuc2l0aW9uKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgcmV1c2VRdWV1ZSA9IHJldmVyc2VEZWFjdGl2YXRlUXVldWUuc2xpY2UoMCwgaSk7XG4gICAgICAgIGRlYWN0aXZhdGVRdWV1ZSA9IHJldmVyc2VEZWFjdGl2YXRlUXVldWUuc2xpY2UoaSkucmV2ZXJzZSgpO1xuICAgICAgICBhY3RpdmF0ZVF1ZXVlID0gYWN0aXZhdGVRdWV1ZS5zbGljZShpKTtcbiAgICAgIH1cblxuICAgICAgLy8gMi4gVmFsaWRhdGlvbiBwaGFzZVxuICAgICAgdHJhbnNpdGlvbi5ydW5RdWV1ZShkZWFjdGl2YXRlUXVldWUsIGNhbkRlYWN0aXZhdGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJhbnNpdGlvbi5ydW5RdWV1ZShhY3RpdmF0ZVF1ZXVlLCBjYW5BY3RpdmF0ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRyYW5zaXRpb24ucnVuUXVldWUoZGVhY3RpdmF0ZVF1ZXVlLCBkZWFjdGl2YXRlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyAzLiBBY3RpdmF0aW9uIHBoYXNlXG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSByb3V0ZXIgY3VycmVudCByb3V0ZVxuICAgICAgICAgICAgdHJhbnNpdGlvbi5yb3V0ZXIuX29uVHJhbnNpdGlvblZhbGlkYXRlZCh0cmFuc2l0aW9uKTtcblxuICAgICAgICAgICAgLy8gdHJpZ2dlciByZXVzZSBmb3IgYWxsIHJldXNlZCB2aWV3c1xuICAgICAgICAgICAgcmV1c2VRdWV1ZSAmJiByZXVzZVF1ZXVlLmZvckVhY2goZnVuY3Rpb24gKHZpZXcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJldXNlKHZpZXcsIHRyYW5zaXRpb24pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHRoZSByb290IG9mIHRoZSBjaGFpbiB0aGF0IG5lZWRzIHRvIGJlIHJlcGxhY2VkXG4gICAgICAgICAgICAvLyBpcyB0aGUgdG9wLW1vc3Qgbm9uLXJldXNhYmxlIHZpZXcuXG4gICAgICAgICAgICBpZiAoZGVhY3RpdmF0ZVF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICB2YXIgX3ZpZXcgPSBkZWFjdGl2YXRlUXVldWVbZGVhY3RpdmF0ZVF1ZXVlLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICB2YXIgZGVwdGggPSByZXVzZVF1ZXVlID8gcmV1c2VRdWV1ZS5sZW5ndGggOiAwO1xuICAgICAgICAgICAgICBhY3RpdmF0ZShfdmlldywgdHJhbnNpdGlvbiwgZGVwdGgsIGNiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFzeW5jaHJvbm91c2x5IGFuZCBzZXF1ZW50aWFsbHkgYXBwbHkgYSBmdW5jdGlvbiB0byBhXG4gICAgICogcXVldWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBxdWV1ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICAgKi9cblxuICAgIFJvdXRlVHJhbnNpdGlvbi5wcm90b3R5cGUucnVuUXVldWUgPSBmdW5jdGlvbiBydW5RdWV1ZShxdWV1ZSwgZm4sIGNiKSB7XG4gICAgICB2YXIgdHJhbnNpdGlvbiA9IHRoaXM7XG4gICAgICBzdGVwKDApO1xuICAgICAgZnVuY3Rpb24gc3RlcChpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPj0gcXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgY2IoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmbihxdWV1ZVtpbmRleF0sIHRyYW5zaXRpb24sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHN0ZXAoaW5kZXggKyAxKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDYWxsIGEgdXNlciBwcm92aWRlZCByb3V0ZSB0cmFuc2l0aW9uIGhvb2sgYW5kIGhhbmRsZVxuICAgICAqIHRoZSByZXNwb25zZSAoZS5nLiBpZiB0aGUgdXNlciByZXR1cm5zIGEgcHJvbWlzZSkuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgdXNlciBuZWl0aGVyIGV4cGVjdHMgYW4gYXJndW1lbnQgbm9yIHJldHVybnMgYVxuICAgICAqIHByb21pc2UsIHRoZSBob29rIGlzIGFzc3VtZWQgdG8gYmUgc3luY2hyb25vdXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBob29rXG4gICAgICogQHBhcmFtIHsqfSBbY29udGV4dF1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSBleHBlY3RCb29sZWFuXG4gICAgICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IHBvc3RBY3RpdmVcbiAgICAgKiAgICAgICAgICAgICAgICAgLSB7RnVuY3Rpb259IHByb2Nlc3NEYXRhXG4gICAgICogICAgICAgICAgICAgICAgIC0ge0Z1bmN0aW9ufSBjbGVhbnVwXG4gICAgICovXG5cbiAgICBSb3V0ZVRyYW5zaXRpb24ucHJvdG90eXBlLmNhbGxIb29rID0gZnVuY3Rpb24gY2FsbEhvb2soaG9vaywgY29udGV4dCwgY2IpIHtcbiAgICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA8PSAzIHx8IGFyZ3VtZW50c1szXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbM107XG5cbiAgICAgIHZhciBfcmVmJGV4cGVjdEJvb2xlYW4gPSBfcmVmLmV4cGVjdEJvb2xlYW47XG4gICAgICB2YXIgZXhwZWN0Qm9vbGVhbiA9IF9yZWYkZXhwZWN0Qm9vbGVhbiA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJGV4cGVjdEJvb2xlYW47XG4gICAgICB2YXIgX3JlZiRwb3N0QWN0aXZhdGUgPSBfcmVmLnBvc3RBY3RpdmF0ZTtcbiAgICAgIHZhciBwb3N0QWN0aXZhdGUgPSBfcmVmJHBvc3RBY3RpdmF0ZSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJHBvc3RBY3RpdmF0ZTtcbiAgICAgIHZhciBwcm9jZXNzRGF0YSA9IF9yZWYucHJvY2Vzc0RhdGE7XG4gICAgICB2YXIgY2xlYW51cCA9IF9yZWYuY2xlYW51cDtcblxuICAgICAgdmFyIHRyYW5zaXRpb24gPSB0aGlzO1xuICAgICAgdmFyIG5leHRDYWxsZWQgPSBmYWxzZTtcblxuICAgICAgLy8gYWJvcnQgdGhlIHRyYW5zaXRpb25cbiAgICAgIHZhciBhYm9ydCA9IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgICAgICBjbGVhbnVwICYmIGNsZWFudXAoKTtcbiAgICAgICAgdHJhbnNpdGlvbi5hYm9ydCgpO1xuICAgICAgfTtcblxuICAgICAgLy8gaGFuZGxlIGVycm9yc1xuICAgICAgdmFyIG9uRXJyb3IgPSBmdW5jdGlvbiBvbkVycm9yKGVycikge1xuICAgICAgICBwb3N0QWN0aXZhdGUgPyBuZXh0KCkgOiBhYm9ydCgpO1xuICAgICAgICBpZiAoZXJyICYmICF0cmFuc2l0aW9uLnJvdXRlci5fc3VwcHJlc3MpIHtcbiAgICAgICAgICB3YXJuJDEoJ1VuY2F1Z2h0IGVycm9yIGR1cmluZyB0cmFuc2l0aW9uOiAnKTtcbiAgICAgICAgICB0aHJvdyBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyciA6IG5ldyBFcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBzaW5jZSBwcm9taXNlIHN3YWxsb3dzIGVycm9ycywgd2UgaGF2ZSB0b1xuICAgICAgLy8gdGhyb3cgaXQgaW4gdGhlIG5leHQgdGljay4uLlxuICAgICAgdmFyIG9uUHJvbWlzZUVycm9yID0gZnVuY3Rpb24gb25Qcm9taXNlRXJyb3IoZXJyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBhZHZhbmNlIHRoZSB0cmFuc2l0aW9uIHRvIHRoZSBuZXh0IHN0ZXBcbiAgICAgIHZhciBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgaWYgKG5leHRDYWxsZWQpIHtcbiAgICAgICAgICB3YXJuJDEoJ3RyYW5zaXRpb24ubmV4dCgpIHNob3VsZCBiZSBjYWxsZWQgb25seSBvbmNlLicpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBuZXh0Q2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRyYW5zaXRpb24uYWJvcnRlZCkge1xuICAgICAgICAgIGNsZWFudXAgJiYgY2xlYW51cCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYiAmJiBjYigpO1xuICAgICAgfTtcblxuICAgICAgdmFyIG5leHRXaXRoQm9vbGVhbiA9IGZ1bmN0aW9uIG5leHRXaXRoQm9vbGVhbihyZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXMgPT09ICdib29sZWFuJykge1xuICAgICAgICAgIHJlcyA/IG5leHQoKSA6IGFib3J0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNQcm9taXNlKHJlcykpIHtcbiAgICAgICAgICByZXMudGhlbihmdW5jdGlvbiAob2spIHtcbiAgICAgICAgICAgIG9rID8gbmV4dCgpIDogYWJvcnQoKTtcbiAgICAgICAgICB9LCBvblByb21pc2VFcnJvcik7XG4gICAgICAgIH0gZWxzZSBpZiAoIWhvb2subGVuZ3RoKSB7XG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgbmV4dFdpdGhEYXRhID0gZnVuY3Rpb24gbmV4dFdpdGhEYXRhKGRhdGEpIHtcbiAgICAgICAgdmFyIHJlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXMgPSBwcm9jZXNzRGF0YShkYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIG9uRXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQcm9taXNlKHJlcykpIHtcbiAgICAgICAgICByZXMudGhlbihuZXh0LCBvblByb21pc2VFcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBleHBvc2UgYSBjbG9uZSBvZiB0aGUgdHJhbnNpdGlvbiBvYmplY3QsIHNvIHRoYXQgZWFjaFxuICAgICAgLy8gaG9vayBnZXRzIGEgY2xlYW4gY29weSBhbmQgcHJldmVudCB0aGUgdXNlciBmcm9tXG4gICAgICAvLyBtZXNzaW5nIHdpdGggdGhlIGludGVybmFscy5cbiAgICAgIHZhciBleHBvc2VkID0ge1xuICAgICAgICB0bzogdHJhbnNpdGlvbi50byxcbiAgICAgICAgZnJvbTogdHJhbnNpdGlvbi5mcm9tLFxuICAgICAgICBhYm9ydDogYWJvcnQsXG4gICAgICAgIG5leHQ6IHByb2Nlc3NEYXRhID8gbmV4dFdpdGhEYXRhIDogbmV4dCxcbiAgICAgICAgcmVkaXJlY3Q6IGZ1bmN0aW9uIHJlZGlyZWN0KCkge1xuICAgICAgICAgIHRyYW5zaXRpb24ucmVkaXJlY3QuYXBwbHkodHJhbnNpdGlvbiwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gYWN0dWFsbHkgY2FsbCB0aGUgaG9va1xuICAgICAgdmFyIHJlcyA9IHVuZGVmaW5lZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlcyA9IGhvb2suY2FsbChjb250ZXh0LCBleHBvc2VkKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gb25FcnJvcihlcnIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXhwZWN0Qm9vbGVhbikge1xuICAgICAgICAvLyBib29sZWFuIGhvb2tzXG4gICAgICAgIG5leHRXaXRoQm9vbGVhbihyZXMpO1xuICAgICAgfSBlbHNlIGlmIChpc1Byb21pc2UocmVzKSkge1xuICAgICAgICAvLyBwcm9taXNlXG4gICAgICAgIGlmIChwcm9jZXNzRGF0YSkge1xuICAgICAgICAgIHJlcy50aGVuKG5leHRXaXRoRGF0YSwgb25Qcm9taXNlRXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcy50aGVuKG5leHQsIG9uUHJvbWlzZUVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzRGF0YSAmJiBpc1BsYWluT2piZWN0KHJlcykpIHtcbiAgICAgICAgLy8gZGF0YSBwcm9taXNlIHN1Z2FyXG4gICAgICAgIG5leHRXaXRoRGF0YShyZXMpO1xuICAgICAgfSBlbHNlIGlmICghaG9vay5sZW5ndGgpIHtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDYWxsIGEgc2luZ2xlIGhvb2sgb3IgYW4gYXJyYXkgb2YgYXN5bmMgaG9va3MgaW4gc2VyaWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gaG9va3NcbiAgICAgKiBAcGFyYW0geyp9IGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKi9cblxuICAgIFJvdXRlVHJhbnNpdGlvbi5wcm90b3R5cGUuY2FsbEhvb2tzID0gZnVuY3Rpb24gY2FsbEhvb2tzKGhvb2tzLCBjb250ZXh0LCBjYiwgb3B0aW9ucykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaG9va3MpKSB7XG4gICAgICAgIHRoaXMucnVuUXVldWUoaG9va3MsIGZ1bmN0aW9uIChob29rLCBfLCBuZXh0KSB7XG4gICAgICAgICAgaWYgKCFfdGhpcy5hYm9ydGVkKSB7XG4gICAgICAgICAgICBfdGhpcy5jYWxsSG9vayhob29rLCBjb250ZXh0LCBuZXh0LCBvcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGNiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2FsbEhvb2soaG9va3MsIGNvbnRleHQsIGNiLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIFJvdXRlVHJhbnNpdGlvbjtcbiAgfSkoKTtcblxuICBmdW5jdGlvbiBpc1BsYWluT2piZWN0KHZhbCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG4gIH1cblxuICBmdW5jdGlvbiB0b0FycmF5KHZhbCkge1xuICAgIHJldHVybiB2YWwgPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh2YWwpIDogW107XG4gIH1cblxuICB2YXIgaW50ZXJuYWxLZXlzUkUgPSAvXihjb21wb25lbnR8c3ViUm91dGVzfGZ1bGxQYXRoKSQvO1xuXG4gIC8qKlxuICAgKiBSb3V0ZSBDb250ZXh0IE9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICAgKiBAcGFyYW0ge1JvdXRlcn0gcm91dGVyXG4gICAqL1xuXG4gIHZhciBSb3V0ZSA9IGZ1bmN0aW9uIFJvdXRlKHBhdGgsIHJvdXRlcikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBiYWJlbEhlbHBlcnMuY2xhc3NDYWxsQ2hlY2sodGhpcywgUm91dGUpO1xuXG4gICAgdmFyIG1hdGNoZWQgPSByb3V0ZXIuX3JlY29nbml6ZXIucmVjb2duaXplKHBhdGgpO1xuICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAvLyBjb3B5IGFsbCBjdXN0b20gZmllbGRzIGZyb20gcm91dGUgY29uZmlnc1xuICAgICAgW10uZm9yRWFjaC5jYWxsKG1hdGNoZWQsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gbWF0Y2guaGFuZGxlcikge1xuICAgICAgICAgIGlmICghaW50ZXJuYWxLZXlzUkUudGVzdChrZXkpKSB7XG4gICAgICAgICAgICBfdGhpc1trZXldID0gbWF0Y2guaGFuZGxlcltrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyBzZXQgcXVlcnkgYW5kIHBhcmFtc1xuICAgICAgdGhpcy5xdWVyeSA9IG1hdGNoZWQucXVlcnlQYXJhbXM7XG4gICAgICB0aGlzLnBhcmFtcyA9IFtdLnJlZHVjZS5jYWxsKG1hdGNoZWQsIGZ1bmN0aW9uIChwcmV2LCBjdXIpIHtcbiAgICAgICAgaWYgKGN1ci5wYXJhbXMpIHtcbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gY3VyLnBhcmFtcykge1xuICAgICAgICAgICAgcHJldltrZXldID0gY3VyLnBhcmFtc1trZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgIH0sIHt9KTtcbiAgICB9XG4gICAgLy8gZXhwb3NlIHBhdGggYW5kIHJvdXRlclxuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgLy8gZm9yIGludGVybmFsIHVzZVxuICAgIHRoaXMubWF0Y2hlZCA9IG1hdGNoZWQgfHwgcm91dGVyLl9ub3RGb3VuZEhhbmRsZXI7XG4gICAgLy8gaW50ZXJuYWwgcmVmZXJlbmNlIHRvIHJvdXRlclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncm91dGVyJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogcm91dGVyXG4gICAgfSk7XG4gICAgLy8gSW1wb3J0YW50OiBmcmVlemUgc2VsZiB0byBwcmV2ZW50IG9ic2VydmF0aW9uXG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgfTtcblxuICBmdW5jdGlvbiBhcHBseU92ZXJyaWRlIChWdWUpIHtcbiAgICB2YXIgX1Z1ZSR1dGlsID0gVnVlLnV0aWw7XG4gICAgdmFyIGV4dGVuZCA9IF9WdWUkdXRpbC5leHRlbmQ7XG4gICAgdmFyIGlzQXJyYXkgPSBfVnVlJHV0aWwuaXNBcnJheTtcbiAgICB2YXIgZGVmaW5lUmVhY3RpdmUgPSBfVnVlJHV0aWwuZGVmaW5lUmVhY3RpdmU7XG5cbiAgICAvLyBvdmVycmlkZSBWdWUncyBpbml0IGFuZCBkZXN0cm95IHByb2Nlc3MgdG8ga2VlcCB0cmFjayBvZiByb3V0ZXIgaW5zdGFuY2VzXG4gICAgdmFyIGluaXQgPSBWdWUucHJvdG90eXBlLl9pbml0O1xuICAgIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICB2YXIgcm9vdCA9IG9wdGlvbnMuX3BhcmVudCB8fCBvcHRpb25zLnBhcmVudCB8fCB0aGlzO1xuICAgICAgdmFyIHJvdXRlciA9IHJvb3QuJHJvdXRlcjtcbiAgICAgIHZhciByb3V0ZSA9IHJvb3QuJHJvdXRlO1xuICAgICAgaWYgKHJvdXRlcikge1xuICAgICAgICAvLyBleHBvc2Ugcm91dGVyXG4gICAgICAgIHRoaXMuJHJvdXRlciA9IHJvdXRlcjtcbiAgICAgICAgcm91dGVyLl9jaGlsZHJlbi5wdXNoKHRoaXMpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHRoaXMuX2RlZmluZU1ldGEpIHtcbiAgICAgICAgICAvLyAwLjEyXG4gICAgICAgICAgdGhpcy5fZGVmaW5lTWV0YSgnJHJvdXRlJywgcm91dGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIDEuMFxuICAgICAgICAgIGRlZmluZVJlYWN0aXZlKHRoaXMsICckcm91dGUnLCByb3V0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGluaXQuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB9O1xuXG4gICAgdmFyIGRlc3Ryb3kgPSBWdWUucHJvdG90eXBlLl9kZXN0cm95O1xuICAgIFZ1ZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuX2lzQmVpbmdEZXN0cm95ZWQgJiYgdGhpcy4kcm91dGVyKSB7XG4gICAgICAgIHRoaXMuJHJvdXRlci5fY2hpbGRyZW4uJHJlbW92ZSh0aGlzKTtcbiAgICAgIH1cbiAgICAgIGRlc3Ryb3kuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgLy8gMS4wIG9ubHk6IGVuYWJsZSByb3V0ZSBtaXhpbnNcbiAgICB2YXIgc3RyYXRzID0gVnVlLmNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG4gICAgdmFyIGhvb2tzVG9NZXJnZVJFID0gL14oZGF0YXxhY3RpdmF0ZXxkZWFjdGl2YXRlKSQvO1xuXG4gICAgaWYgKHN0cmF0cykge1xuICAgICAgc3RyYXRzLnJvdXRlID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgICAgICAgaWYgKCFjaGlsZFZhbCkgcmV0dXJuIHBhcmVudFZhbDtcbiAgICAgICAgaWYgKCFwYXJlbnRWYWwpIHJldHVybiBjaGlsZFZhbDtcbiAgICAgICAgdmFyIHJldCA9IHt9O1xuICAgICAgICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gY2hpbGRWYWwpIHtcbiAgICAgICAgICB2YXIgYSA9IHJldFtrZXldO1xuICAgICAgICAgIHZhciBiID0gY2hpbGRWYWxba2V5XTtcbiAgICAgICAgICAvLyBmb3IgZGF0YSwgYWN0aXZhdGUgYW5kIGRlYWN0aXZhdGUsIHdlIG5lZWQgdG8gbWVyZ2UgdGhlbSBpbnRvXG4gICAgICAgICAgLy8gYXJyYXlzIHNpbWlsYXIgdG8gbGlmZWN5Y2xlIGhvb2tzLlxuICAgICAgICAgIGlmIChhICYmIGhvb2tzVG9NZXJnZVJFLnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgcmV0W2tleV0gPSAoaXNBcnJheShhKSA/IGEgOiBbYV0pLmNvbmNhdChiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0W2tleV0gPSBiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBWaWV3IChWdWUpIHtcblxuICAgIHZhciBfID0gVnVlLnV0aWw7XG4gICAgdmFyIGNvbXBvbmVudERlZiA9XG4gICAgLy8gMC4xMlxuICAgIFZ1ZS5kaXJlY3RpdmUoJ19jb21wb25lbnQnKSB8fFxuICAgIC8vIDEuMFxuICAgIFZ1ZS5pbnRlcm5hbERpcmVjdGl2ZXMuY29tcG9uZW50O1xuICAgIC8vIDxyb3V0ZXItdmlldz4gZXh0ZW5kcyB0aGUgaW50ZXJuYWwgY29tcG9uZW50IGRpcmVjdGl2ZVxuICAgIHZhciB2aWV3RGVmID0gXy5leHRlbmQoe30sIGNvbXBvbmVudERlZik7XG5cbiAgICAvLyB3aXRoIHNvbWUgb3ZlcnJpZGVzXG4gICAgXy5leHRlbmQodmlld0RlZiwge1xuXG4gICAgICBfaXNSb3V0ZXJWaWV3OiB0cnVlLFxuXG4gICAgICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgICAgICB2YXIgcm91dGUgPSB0aGlzLnZtLiRyb3V0ZTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghcm91dGUpIHtcbiAgICAgICAgICB3YXJuJDEoJzxyb3V0ZXItdmlldz4gY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgYSAnICsgJ3JvdXRlci1lbmFibGVkIGFwcC4nKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gZm9yY2UgZHluYW1pYyBkaXJlY3RpdmUgc28gdi1jb21wb25lbnQgZG9lc24ndFxuICAgICAgICAvLyBhdHRlbXB0IHRvIGJ1aWxkIHJpZ2h0IG5vd1xuICAgICAgICB0aGlzLl9pc0R5bmFtaWNMaXRlcmFsID0gdHJ1ZTtcbiAgICAgICAgLy8gZmluYWxseSwgaW5pdCBieSBkZWxlZ2F0aW5nIHRvIHYtY29tcG9uZW50XG4gICAgICAgIGNvbXBvbmVudERlZi5iaW5kLmNhbGwodGhpcyk7XG5cbiAgICAgICAgLy8gbG9jYXRlIHRoZSBwYXJlbnQgdmlld1xuICAgICAgICB2YXIgcGFyZW50VmlldyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMudm07XG4gICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICBpZiAocGFyZW50Ll9yb3V0ZXJWaWV3KSB7XG4gICAgICAgICAgICBwYXJlbnRWaWV3ID0gcGFyZW50Ll9yb3V0ZXJWaWV3O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJlbnRWaWV3KSB7XG4gICAgICAgICAgLy8gcmVnaXN0ZXIgc2VsZiBhcyBhIGNoaWxkIG9mIHRoZSBwYXJlbnQgdmlldyxcbiAgICAgICAgICAvLyBpbnN0ZWFkIG9mIGFjdGl2YXRpbmcgbm93LiBUaGlzIGlzIHNvIHRoYXQgdGhlXG4gICAgICAgICAgLy8gY2hpbGQncyBhY3RpdmF0ZSBob29rIGlzIGNhbGxlZCBhZnRlciB0aGVcbiAgICAgICAgICAvLyBwYXJlbnQncyBoYXMgcmVzb2x2ZWQuXG4gICAgICAgICAgdGhpcy5wYXJlbnRWaWV3ID0gcGFyZW50VmlldztcbiAgICAgICAgICBwYXJlbnRWaWV3LmNoaWxkVmlldyA9IHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdGhpcyBpcyB0aGUgcm9vdCB2aWV3IVxuICAgICAgICAgIHZhciByb3V0ZXIgPSByb3V0ZS5yb3V0ZXI7XG4gICAgICAgICAgcm91dGVyLl9yb290VmlldyA9IHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoYW5kbGUgbGF0ZS1yZW5kZXJlZCB2aWV3XG4gICAgICAgIC8vIHR3byBwb3NzaWJpbGl0aWVzOlxuICAgICAgICAvLyAxLiByb290IHZpZXcgcmVuZGVyZWQgYWZ0ZXIgdHJhbnNpdGlvbiBoYXMgYmVlblxuICAgICAgICAvLyAgICB2YWxpZGF0ZWQ7XG4gICAgICAgIC8vIDIuIGNoaWxkIHZpZXcgcmVuZGVyZWQgYWZ0ZXIgcGFyZW50IHZpZXcgaGFzIGJlZW5cbiAgICAgICAgLy8gICAgYWN0aXZhdGVkLlxuICAgICAgICB2YXIgdHJhbnNpdGlvbiA9IHJvdXRlLnJvdXRlci5fY3VycmVudFRyYW5zaXRpb247XG4gICAgICAgIGlmICghcGFyZW50VmlldyAmJiB0cmFuc2l0aW9uLmRvbmUgfHwgcGFyZW50VmlldyAmJiBwYXJlbnRWaWV3LmFjdGl2YXRlZCkge1xuICAgICAgICAgIHZhciBkZXB0aCA9IHBhcmVudFZpZXcgPyBwYXJlbnRWaWV3LmRlcHRoICsgMSA6IDA7XG4gICAgICAgICAgYWN0aXZhdGUodGhpcywgdHJhbnNpdGlvbiwgZGVwdGgpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50Vmlldykge1xuICAgICAgICAgIHRoaXMucGFyZW50Vmlldy5jaGlsZFZpZXcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbXBvbmVudERlZi51bmJpbmQuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIFZ1ZS5lbGVtZW50RGlyZWN0aXZlKCdyb3V0ZXItdmlldycsIHZpZXdEZWYpO1xuICB9XG5cbiAgdmFyIHRyYWlsaW5nU2xhc2hSRSA9IC9cXC8kLztcbiAgdmFyIHJlZ2V4RXNjYXBlUkUgPSAvWy0uKis/XiR7fSgpfFtcXF1cXC9cXFxcXS9nO1xuICB2YXIgcXVlcnlTdHJpbmdSRSA9IC9cXD8uKiQvO1xuXG4gIC8vIGluc3RhbGwgdi1saW5rLCB3aGljaCBwcm92aWRlcyBuYXZpZ2F0aW9uIHN1cHBvcnQgZm9yXG4gIC8vIEhUTUw1IGhpc3RvcnkgbW9kZVxuICBmdW5jdGlvbiBMaW5rIChWdWUpIHtcbiAgICB2YXIgX1Z1ZSR1dGlsID0gVnVlLnV0aWw7XG4gICAgdmFyIF9iaW5kID0gX1Z1ZSR1dGlsLmJpbmQ7XG4gICAgdmFyIGlzT2JqZWN0ID0gX1Z1ZSR1dGlsLmlzT2JqZWN0O1xuICAgIHZhciBhZGRDbGFzcyA9IF9WdWUkdXRpbC5hZGRDbGFzcztcbiAgICB2YXIgcmVtb3ZlQ2xhc3MgPSBfVnVlJHV0aWwucmVtb3ZlQ2xhc3M7XG5cbiAgICB2YXIgb25Qcmlvcml0eSA9IFZ1ZS5kaXJlY3RpdmUoJ29uJykucHJpb3JpdHk7XG4gICAgdmFyIExJTktfVVBEQVRFID0gJ19fdnVlLXJvdXRlci1saW5rLXVwZGF0ZV9fJztcblxuICAgIHZhciBhY3RpdmVJZCA9IDA7XG5cbiAgICBWdWUuZGlyZWN0aXZlKCdsaW5rLWFjdGl2ZScsIHtcbiAgICAgIHByaW9yaXR5OiA5OTk5LFxuICAgICAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB2YXIgaWQgPSBTdHJpbmcoYWN0aXZlSWQrKyk7XG4gICAgICAgIC8vIGNvbGxlY3Qgdi1saW5rcyBjb250YWluZWQgd2l0aGluIHRoaXMgZWxlbWVudC5cbiAgICAgICAgLy8gd2UgbmVlZCBkbyB0aGlzIGhlcmUgYmVmb3JlIHRoZSBwYXJlbnQtY2hpbGQgcmVsYXRpb25zaGlwXG4gICAgICAgIC8vIGdldHMgbWVzc2VkIHVwIGJ5IHRlcm1pbmFsIGRpcmVjdGl2ZXMgKGlmLCBmb3IsIGNvbXBvbmVudHMpXG4gICAgICAgIHZhciBjaGlsZExpbmtzID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yQWxsKCdbdi1saW5rXScpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkTGlua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGxpbmsgPSBjaGlsZExpbmtzW2ldO1xuICAgICAgICAgIHZhciBleGlzdGluZ0lkID0gbGluay5nZXRBdHRyaWJ1dGUoTElOS19VUERBVEUpO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGV4aXN0aW5nSWQgPyBleGlzdGluZ0lkICsgJywnICsgaWQgOiBpZDtcbiAgICAgICAgICAvLyBsZWF2ZSBhIG1hcmsgb24gdGhlIGxpbmsgZWxlbWVudCB3aGljaCBjYW4gYmUgcGVyc2lzdGVkXG4gICAgICAgICAgLy8gdGhyb3VnaCBmcmFnbWVudCBjbG9uZXMuXG4gICAgICAgICAgbGluay5zZXRBdHRyaWJ1dGUoTElOS19VUERBVEUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZtLiRvbihMSU5LX1VQREFURSwgdGhpcy5jYiA9IGZ1bmN0aW9uIChsaW5rLCBwYXRoKSB7XG4gICAgICAgICAgaWYgKGxpbmsuYWN0aXZlSWRzLmluZGV4T2YoaWQpID4gLTEpIHtcbiAgICAgICAgICAgIGxpbmsudXBkYXRlQ2xhc3NlcyhwYXRoLCBfdGhpcy5lbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICAgICAgdGhpcy52bS4kb2ZmKExJTktfVVBEQVRFLCB0aGlzLmNiKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIFZ1ZS5kaXJlY3RpdmUoJ2xpbmsnLCB7XG4gICAgICBwcmlvcml0eTogb25Qcmlvcml0eSAtIDIsXG5cbiAgICAgIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgICAgIHZhciB2bSA9IHRoaXMudm07XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIXZtLiRyb3V0ZSkge1xuICAgICAgICAgIHdhcm4kMSgndi1saW5rIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIGEgcm91dGVyLWVuYWJsZWQgYXBwLicpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJvdXRlciA9IHZtLiRyb3V0ZS5yb3V0ZXI7XG4gICAgICAgIC8vIHVwZGF0ZSB0aGluZ3Mgd2hlbiB0aGUgcm91dGUgY2hhbmdlc1xuICAgICAgICB0aGlzLnVud2F0Y2ggPSB2bS4kd2F0Y2goJyRyb3V0ZScsIF9iaW5kKHRoaXMub25Sb3V0ZVVwZGF0ZSwgdGhpcykpO1xuICAgICAgICAvLyBjaGVjayB2LWxpbmstYWN0aXZlIGlkc1xuICAgICAgICB2YXIgYWN0aXZlSWRzID0gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoTElOS19VUERBVEUpO1xuICAgICAgICBpZiAoYWN0aXZlSWRzKSB7XG4gICAgICAgICAgdGhpcy5lbC5yZW1vdmVBdHRyaWJ1dGUoTElOS19VUERBVEUpO1xuICAgICAgICAgIHRoaXMuYWN0aXZlSWRzID0gYWN0aXZlSWRzLnNwbGl0KCcsJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm8gbmVlZCB0byBoYW5kbGUgY2xpY2sgaWYgbGluayBleHBlY3RzIHRvIGJlIG9wZW5lZFxuICAgICAgICAvLyBpbiBhIG5ldyB3aW5kb3cvdGFiLlxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHRoaXMuZWwudGFnTmFtZSA9PT0gJ0EnICYmIHRoaXMuZWwuZ2V0QXR0cmlidXRlKCd0YXJnZXQnKSA9PT0gJ19ibGFuaycpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gaGFuZGxlIGNsaWNrXG4gICAgICAgIHRoaXMuaGFuZGxlciA9IF9iaW5kKHRoaXMub25DbGljaywgdGhpcyk7XG4gICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmhhbmRsZXIpO1xuICAgICAgfSxcblxuICAgICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodGFyZ2V0KSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICBpZiAoaXNPYmplY3QodGFyZ2V0KSkge1xuICAgICAgICAgIHRoaXMuYXBwZW5kID0gdGFyZ2V0LmFwcGVuZDtcbiAgICAgICAgICB0aGlzLmV4YWN0ID0gdGFyZ2V0LmV4YWN0O1xuICAgICAgICAgIHRoaXMucHJldkFjdGl2ZUNsYXNzID0gdGhpcy5hY3RpdmVDbGFzcztcbiAgICAgICAgICB0aGlzLmFjdGl2ZUNsYXNzID0gdGFyZ2V0LmFjdGl2ZUNsYXNzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25Sb3V0ZVVwZGF0ZSh0aGlzLnZtLiRyb3V0ZSk7XG4gICAgICB9LFxuXG4gICAgICBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKGUpIHtcbiAgICAgICAgLy8gZG9uJ3QgcmVkaXJlY3Qgd2l0aCBjb250cm9sIGtleXNcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChlLm1ldGFLZXkgfHwgZS5jdHJsS2V5IHx8IGUuc2hpZnRLZXkpIHJldHVybjtcbiAgICAgICAgLy8gZG9uJ3QgcmVkaXJlY3Qgd2hlbiBwcmV2ZW50RGVmYXVsdCBjYWxsZWRcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChlLmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcbiAgICAgICAgLy8gZG9uJ3QgcmVkaXJlY3Qgb24gcmlnaHQgY2xpY2tcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChlLmJ1dHRvbiAhPT0gMCkgcmV0dXJuO1xuXG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLnRhcmdldDtcbiAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgIC8vIHYtbGluayB3aXRoIGV4cHJlc3Npb24sIGp1c3QgZ29cbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy5yb3V0ZXIuZ28odGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBubyBleHByZXNzaW9uLCBkZWxlZ2F0ZSBmb3IgYW4gPGE+IGluc2lkZVxuICAgICAgICAgIHZhciBlbCA9IGUudGFyZ2V0O1xuICAgICAgICAgIHdoaWxlIChlbC50YWdOYW1lICE9PSAnQScgJiYgZWwgIT09IHRoaXMuZWwpIHtcbiAgICAgICAgICAgIGVsID0gZWwucGFyZW50Tm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsLnRhZ05hbWUgPT09ICdBJyAmJiBzYW1lT3JpZ2luKGVsKSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdmFyIHBhdGggPSBlbC5wYXRobmFtZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJvdXRlci5oaXN0b3J5LnJvb3QpIHtcbiAgICAgICAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZSh0aGlzLnJvdXRlci5oaXN0b3J5LnJvb3RSRSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yb3V0ZXIuZ28oe1xuICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICByZXBsYWNlOiB0YXJnZXQgJiYgdGFyZ2V0LnJlcGxhY2UsXG4gICAgICAgICAgICAgIGFwcGVuZDogdGFyZ2V0ICYmIHRhcmdldC5hcHBlbmRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgb25Sb3V0ZVVwZGF0ZTogZnVuY3Rpb24gb25Sb3V0ZVVwZGF0ZShyb3V0ZSkge1xuICAgICAgICAvLyByb3V0ZXIuc3RyaW5naWZ5UGF0aCBpcyBkZXBlbmRlbnQgb24gY3VycmVudCByb3V0ZVxuICAgICAgICAvLyBhbmQgbmVlZHMgdG8gYmUgY2FsbGVkIGFnYWluIHdoZW52ZXIgcm91dGUgY2hhbmdlcy5cbiAgICAgICAgdmFyIG5ld1BhdGggPSB0aGlzLnJvdXRlci5zdHJpbmdpZnlQYXRoKHRoaXMudGFyZ2V0KTtcbiAgICAgICAgaWYgKHRoaXMucGF0aCAhPT0gbmV3UGF0aCkge1xuICAgICAgICAgIHRoaXMucGF0aCA9IG5ld1BhdGg7XG4gICAgICAgICAgdGhpcy51cGRhdGVBY3RpdmVNYXRjaCgpO1xuICAgICAgICAgIHRoaXMudXBkYXRlSHJlZigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZUlkcykge1xuICAgICAgICAgIHRoaXMudm0uJGVtaXQoTElOS19VUERBVEUsIHRoaXMsIHJvdXRlLnBhdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudXBkYXRlQ2xhc3Nlcyhyb3V0ZS5wYXRoLCB0aGlzLmVsKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgdXBkYXRlQWN0aXZlTWF0Y2g6IGZ1bmN0aW9uIHVwZGF0ZUFjdGl2ZU1hdGNoKCkge1xuICAgICAgICB0aGlzLmFjdGl2ZVJFID0gdGhpcy5wYXRoICYmICF0aGlzLmV4YWN0ID8gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLnBhdGgucmVwbGFjZSgvXFwvJC8sICcnKS5yZXBsYWNlKHF1ZXJ5U3RyaW5nUkUsICcnKS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKSArICcoXFxcXC98JCknKSA6IG51bGw7XG4gICAgICB9LFxuXG4gICAgICB1cGRhdGVIcmVmOiBmdW5jdGlvbiB1cGRhdGVIcmVmKCkge1xuICAgICAgICBpZiAodGhpcy5lbC50YWdOYW1lICE9PSAnQScpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLnBhdGg7XG4gICAgICAgIHZhciByb3V0ZXIgPSB0aGlzLnJvdXRlcjtcbiAgICAgICAgdmFyIGlzQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICAgICAgICAvLyBkbyBub3QgZm9ybWF0IG5vbi1oYXNoIHJlbGF0aXZlIHBhdGhzXG4gICAgICAgIHZhciBocmVmID0gcGF0aCAmJiAocm91dGVyLm1vZGUgPT09ICdoYXNoJyB8fCBpc0Fic29sdXRlKSA/IHJvdXRlci5oaXN0b3J5LmZvcm1hdFBhdGgocGF0aCwgdGhpcy5hcHBlbmQpIDogcGF0aDtcbiAgICAgICAgaWYgKGhyZWYpIHtcbiAgICAgICAgICB0aGlzLmVsLmhyZWYgPSBocmVmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKCdocmVmJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHVwZGF0ZUNsYXNzZXM6IGZ1bmN0aW9uIHVwZGF0ZUNsYXNzZXMocGF0aCwgZWwpIHtcbiAgICAgICAgdmFyIGFjdGl2ZUNsYXNzID0gdGhpcy5hY3RpdmVDbGFzcyB8fCB0aGlzLnJvdXRlci5fbGlua0FjdGl2ZUNsYXNzO1xuICAgICAgICAvLyBjbGVhciBvbGQgY2xhc3NcbiAgICAgICAgaWYgKHRoaXMucHJldkFjdGl2ZUNsYXNzICYmIHRoaXMucHJldkFjdGl2ZUNsYXNzICE9PSBhY3RpdmVDbGFzcykge1xuICAgICAgICAgIHRvZ2dsZUNsYXNzZXMoZWwsIHRoaXMucHJldkFjdGl2ZUNsYXNzLCByZW1vdmVDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVtb3ZlIHF1ZXJ5IHN0cmluZyBiZWZvcmUgbWF0Y2hpbmdcbiAgICAgICAgdmFyIGRlc3QgPSB0aGlzLnBhdGgucmVwbGFjZShxdWVyeVN0cmluZ1JFLCAnJyk7XG4gICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UocXVlcnlTdHJpbmdSRSwgJycpO1xuICAgICAgICAvLyBhZGQgbmV3IGNsYXNzXG4gICAgICAgIGlmICh0aGlzLmV4YWN0KSB7XG4gICAgICAgICAgaWYgKGRlc3QgPT09IHBhdGggfHxcbiAgICAgICAgICAvLyBhbHNvIGFsbG93IGFkZGl0aW9uYWwgdHJhaWxpbmcgc2xhc2hcbiAgICAgICAgICBkZXN0LmNoYXJBdChkZXN0Lmxlbmd0aCAtIDEpICE9PSAnLycgJiYgZGVzdCA9PT0gcGF0aC5yZXBsYWNlKHRyYWlsaW5nU2xhc2hSRSwgJycpKSB7XG4gICAgICAgICAgICB0b2dnbGVDbGFzc2VzKGVsLCBhY3RpdmVDbGFzcywgYWRkQ2xhc3MpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b2dnbGVDbGFzc2VzKGVsLCBhY3RpdmVDbGFzcywgcmVtb3ZlQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5hY3RpdmVSRSAmJiB0aGlzLmFjdGl2ZVJFLnRlc3QocGF0aCkpIHtcbiAgICAgICAgICAgIHRvZ2dsZUNsYXNzZXMoZWwsIGFjdGl2ZUNsYXNzLCBhZGRDbGFzcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvZ2dsZUNsYXNzZXMoZWwsIGFjdGl2ZUNsYXNzLCByZW1vdmVDbGFzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlcik7XG4gICAgICAgIHRoaXMudW53YXRjaCAmJiB0aGlzLnVud2F0Y2goKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIHNhbWVPcmlnaW4obGluaykge1xuICAgICAgcmV0dXJuIGxpbmsucHJvdG9jb2wgPT09IGxvY2F0aW9uLnByb3RvY29sICYmIGxpbmsuaG9zdG5hbWUgPT09IGxvY2F0aW9uLmhvc3RuYW1lICYmIGxpbmsucG9ydCA9PT0gbG9jYXRpb24ucG9ydDtcbiAgICB9XG5cbiAgICAvLyB0aGlzIGZ1bmN0aW9uIGlzIGNvcGllZCBmcm9tIHYtYmluZDpjbGFzcyBpbXBsZW1lbnRhdGlvbiB1bnRpbFxuICAgIC8vIHdlIHByb3Blcmx5IGV4cG9zZSBpdC4uLlxuICAgIGZ1bmN0aW9uIHRvZ2dsZUNsYXNzZXMoZWwsIGtleSwgZm4pIHtcbiAgICAgIGtleSA9IGtleS50cmltKCk7XG4gICAgICBpZiAoa2V5LmluZGV4T2YoJyAnKSA9PT0gLTEpIHtcbiAgICAgICAgZm4oZWwsIGtleSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBrZXlzID0ga2V5LnNwbGl0KC9cXHMrLyk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGZuKGVsLCBrZXlzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgaGlzdG9yeUJhY2tlbmRzID0ge1xuICAgIGFic3RyYWN0OiBBYnN0cmFjdEhpc3RvcnksXG4gICAgaGFzaDogSGFzaEhpc3RvcnksXG4gICAgaHRtbDU6IEhUTUw1SGlzdG9yeVxuICB9O1xuXG4gIC8vIGxhdGUgYmluZCBkdXJpbmcgaW5zdGFsbFxuICB2YXIgVnVlID0gdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBSb3V0ZXIgY29uc3RydWN0b3JcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKi9cblxuICB2YXIgUm91dGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSb3V0ZXIoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICAgICB2YXIgX3JlZiRoYXNoYmFuZyA9IF9yZWYuaGFzaGJhbmc7XG4gICAgICB2YXIgaGFzaGJhbmcgPSBfcmVmJGhhc2hiYW5nID09PSB1bmRlZmluZWQgPyB0cnVlIDogX3JlZiRoYXNoYmFuZztcbiAgICAgIHZhciBfcmVmJGFic3RyYWN0ID0gX3JlZi5hYnN0cmFjdDtcbiAgICAgIHZhciBhYnN0cmFjdCA9IF9yZWYkYWJzdHJhY3QgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRhYnN0cmFjdDtcbiAgICAgIHZhciBfcmVmJGhpc3RvcnkgPSBfcmVmLmhpc3Rvcnk7XG4gICAgICB2YXIgaGlzdG9yeSA9IF9yZWYkaGlzdG9yeSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJGhpc3Rvcnk7XG4gICAgICB2YXIgX3JlZiRzYXZlU2Nyb2xsUG9zaXRpb24gPSBfcmVmLnNhdmVTY3JvbGxQb3NpdGlvbjtcbiAgICAgIHZhciBzYXZlU2Nyb2xsUG9zaXRpb24gPSBfcmVmJHNhdmVTY3JvbGxQb3NpdGlvbiA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJHNhdmVTY3JvbGxQb3NpdGlvbjtcbiAgICAgIHZhciBfcmVmJHRyYW5zaXRpb25PbkxvYWQgPSBfcmVmLnRyYW5zaXRpb25PbkxvYWQ7XG4gICAgICB2YXIgdHJhbnNpdGlvbk9uTG9hZCA9IF9yZWYkdHJhbnNpdGlvbk9uTG9hZCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJHRyYW5zaXRpb25PbkxvYWQ7XG4gICAgICB2YXIgX3JlZiRzdXBwcmVzc1RyYW5zaXRpb25FcnJvciA9IF9yZWYuc3VwcHJlc3NUcmFuc2l0aW9uRXJyb3I7XG4gICAgICB2YXIgc3VwcHJlc3NUcmFuc2l0aW9uRXJyb3IgPSBfcmVmJHN1cHByZXNzVHJhbnNpdGlvbkVycm9yID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkc3VwcHJlc3NUcmFuc2l0aW9uRXJyb3I7XG4gICAgICB2YXIgX3JlZiRyb290ID0gX3JlZi5yb290O1xuICAgICAgdmFyIHJvb3QgPSBfcmVmJHJvb3QgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBfcmVmJHJvb3Q7XG4gICAgICB2YXIgX3JlZiRsaW5rQWN0aXZlQ2xhc3MgPSBfcmVmLmxpbmtBY3RpdmVDbGFzcztcbiAgICAgIHZhciBsaW5rQWN0aXZlQ2xhc3MgPSBfcmVmJGxpbmtBY3RpdmVDbGFzcyA9PT0gdW5kZWZpbmVkID8gJ3YtbGluay1hY3RpdmUnIDogX3JlZiRsaW5rQWN0aXZlQ2xhc3M7XG4gICAgICBiYWJlbEhlbHBlcnMuY2xhc3NDYWxsQ2hlY2sodGhpcywgUm91dGVyKTtcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIVJvdXRlci5pbnN0YWxsZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgaW5zdGFsbCB0aGUgUm91dGVyIHdpdGggVnVlLnVzZSgpIGJlZm9yZSAnICsgJ2NyZWF0aW5nIGFuIGluc3RhbmNlLicpO1xuICAgICAgfVxuXG4gICAgICAvLyBWdWUgaW5zdGFuY2VzXG4gICAgICB0aGlzLmFwcCA9IG51bGw7XG4gICAgICB0aGlzLl9jaGlsZHJlbiA9IFtdO1xuXG4gICAgICAvLyByb3V0ZSByZWNvZ25pemVyXG4gICAgICB0aGlzLl9yZWNvZ25pemVyID0gbmV3IFJvdXRlUmVjb2duaXplcigpO1xuICAgICAgdGhpcy5fZ3VhcmRSZWNvZ25pemVyID0gbmV3IFJvdXRlUmVjb2duaXplcigpO1xuXG4gICAgICAvLyBzdGF0ZVxuICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fc3RhcnRDYiA9IG51bGw7XG4gICAgICB0aGlzLl9jdXJyZW50Um91dGUgPSB7fTtcbiAgICAgIHRoaXMuX2N1cnJlbnRUcmFuc2l0aW9uID0gbnVsbDtcbiAgICAgIHRoaXMuX3ByZXZpb3VzVHJhbnNpdGlvbiA9IG51bGw7XG4gICAgICB0aGlzLl9ub3RGb3VuZEhhbmRsZXIgPSBudWxsO1xuICAgICAgdGhpcy5fbm90Rm91bmRSZWRpcmVjdCA9IG51bGw7XG4gICAgICB0aGlzLl9iZWZvcmVFYWNoSG9va3MgPSBbXTtcbiAgICAgIHRoaXMuX2FmdGVyRWFjaEhvb2tzID0gW107XG5cbiAgICAgIC8vIHRyaWdnZXIgdHJhbnNpdGlvbiBvbiBpbml0aWFsIHJlbmRlcj9cbiAgICAgIHRoaXMuX3JlbmRlcmVkID0gZmFsc2U7XG4gICAgICB0aGlzLl90cmFuc2l0aW9uT25Mb2FkID0gdHJhbnNpdGlvbk9uTG9hZDtcblxuICAgICAgLy8gaGlzdG9yeSBtb2RlXG4gICAgICB0aGlzLl9yb290ID0gcm9vdDtcbiAgICAgIHRoaXMuX2Fic3RyYWN0ID0gYWJzdHJhY3Q7XG4gICAgICB0aGlzLl9oYXNoYmFuZyA9IGhhc2hiYW5nO1xuXG4gICAgICAvLyBjaGVjayBpZiBIVE1MNSBoaXN0b3J5IGlzIGF2YWlsYWJsZVxuICAgICAgdmFyIGhhc1B1c2hTdGF0ZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5oaXN0b3J5ICYmIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZTtcbiAgICAgIHRoaXMuX2hpc3RvcnkgPSBoaXN0b3J5ICYmIGhhc1B1c2hTdGF0ZTtcbiAgICAgIHRoaXMuX2hpc3RvcnlGYWxsYmFjayA9IGhpc3RvcnkgJiYgIWhhc1B1c2hTdGF0ZTtcblxuICAgICAgLy8gY3JlYXRlIGhpc3Rvcnkgb2JqZWN0XG4gICAgICB2YXIgaW5Ccm93c2VyID0gVnVlLnV0aWwuaW5Ccm93c2VyO1xuICAgICAgdGhpcy5tb2RlID0gIWluQnJvd3NlciB8fCB0aGlzLl9hYnN0cmFjdCA/ICdhYnN0cmFjdCcgOiB0aGlzLl9oaXN0b3J5ID8gJ2h0bWw1JyA6ICdoYXNoJztcblxuICAgICAgdmFyIEhpc3RvcnkgPSBoaXN0b3J5QmFja2VuZHNbdGhpcy5tb2RlXTtcbiAgICAgIHRoaXMuaGlzdG9yeSA9IG5ldyBIaXN0b3J5KHtcbiAgICAgICAgcm9vdDogcm9vdCxcbiAgICAgICAgaGFzaGJhbmc6IHRoaXMuX2hhc2hiYW5nLFxuICAgICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UocGF0aCwgc3RhdGUsIGFuY2hvcikge1xuICAgICAgICAgIF90aGlzLl9tYXRjaChwYXRoLCBzdGF0ZSwgYW5jaG9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIG90aGVyIG9wdGlvbnNcbiAgICAgIHRoaXMuX3NhdmVTY3JvbGxQb3NpdGlvbiA9IHNhdmVTY3JvbGxQb3NpdGlvbjtcbiAgICAgIHRoaXMuX2xpbmtBY3RpdmVDbGFzcyA9IGxpbmtBY3RpdmVDbGFzcztcbiAgICAgIHRoaXMuX3N1cHByZXNzID0gc3VwcHJlc3NUcmFuc2l0aW9uRXJyb3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWxsb3cgZGlyZWN0bHkgcGFzc2luZyBjb21wb25lbnRzIHRvIGEgcm91dGVcbiAgICAgKiBkZWZpbml0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaGFuZGxlclxuICAgICAqL1xuXG4gICAgLy8gQVBJID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgLyoqXG4gICAgKiBSZWdpc3RlciBhIG1hcCBvZiB0b3AtbGV2ZWwgcGF0aHMuXG4gICAgKlxuICAgICogQHBhcmFtIHtPYmplY3R9IG1hcFxuICAgICovXG5cbiAgICBSb3V0ZXIucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIG1hcChfbWFwKSB7XG4gICAgICBmb3IgKHZhciByb3V0ZSBpbiBfbWFwKSB7XG4gICAgICAgIHRoaXMub24ocm91dGUsIF9tYXBbcm91dGVdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIHNpbmdsZSByb290LWxldmVsIHBhdGhcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSByb290UGF0aFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBoYW5kbGVyXG4gICAgICogICAgICAgICAgICAgICAgIC0ge1N0cmluZ30gY29tcG9uZW50XG4gICAgICogICAgICAgICAgICAgICAgIC0ge09iamVjdH0gW3N1YlJvdXRlc11cbiAgICAgKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gW2ZvcmNlUmVmcmVzaF1cbiAgICAgKiAgICAgICAgICAgICAgICAgLSB7RnVuY3Rpb259IFtiZWZvcmVdXG4gICAgICogICAgICAgICAgICAgICAgIC0ge0Z1bmN0aW9ufSBbYWZ0ZXJdXG4gICAgICovXG5cbiAgICBSb3V0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24ocm9vdFBhdGgsIGhhbmRsZXIpIHtcbiAgICAgIGlmIChyb290UGF0aCA9PT0gJyonKSB7XG4gICAgICAgIHRoaXMuX25vdEZvdW5kKGhhbmRsZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYWRkUm91dGUocm9vdFBhdGgsIGhhbmRsZXIsIFtdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXQgcmVkaXJlY3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1hcFxuICAgICAqL1xuXG4gICAgUm91dGVyLnByb3RvdHlwZS5yZWRpcmVjdCA9IGZ1bmN0aW9uIHJlZGlyZWN0KG1hcCkge1xuICAgICAgZm9yICh2YXIgcGF0aCBpbiBtYXApIHtcbiAgICAgICAgdGhpcy5fYWRkUmVkaXJlY3QocGF0aCwgbWFwW3BhdGhdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYWxpYXNlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYXBcbiAgICAgKi9cblxuICAgIFJvdXRlci5wcm90b3R5cGUuYWxpYXMgPSBmdW5jdGlvbiBhbGlhcyhtYXApIHtcbiAgICAgIGZvciAodmFyIHBhdGggaW4gbWFwKSB7XG4gICAgICAgIHRoaXMuX2FkZEFsaWFzKHBhdGgsIG1hcFtwYXRoXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IGdsb2JhbCBiZWZvcmUgaG9vay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAgICovXG5cbiAgICBSb3V0ZXIucHJvdG90eXBlLmJlZm9yZUVhY2ggPSBmdW5jdGlvbiBiZWZvcmVFYWNoKGZuKSB7XG4gICAgICB0aGlzLl9iZWZvcmVFYWNoSG9va3MucHVzaChmbik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IGdsb2JhbCBhZnRlciBob29rLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICAgKi9cblxuICAgIFJvdXRlci5wcm90b3R5cGUuYWZ0ZXJFYWNoID0gZnVuY3Rpb24gYWZ0ZXJFYWNoKGZuKSB7XG4gICAgICB0aGlzLl9hZnRlckVhY2hIb29rcy5wdXNoKGZuKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBOYXZpZ2F0ZSB0byBhIGdpdmVuIHBhdGguXG4gICAgICogVGhlIHBhdGggY2FuIGJlIGFuIG9iamVjdCBkZXNjcmliaW5nIGEgbmFtZWQgcGF0aCBpblxuICAgICAqIHRoZSBmb3JtYXQgb2YgeyBuYW1lOiAnLi4uJywgcGFyYW1zOiB7fSwgcXVlcnk6IHt9fVxuICAgICAqIFRoZSBwYXRoIGlzIGFzc3VtZWQgdG8gYmUgYWxyZWFkeSBkZWNvZGVkLCBhbmQgd2lsbFxuICAgICAqIGJlIHJlc29sdmVkIGFnYWluc3Qgcm9vdCAoaWYgcHJvdmlkZWQpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHBhdGhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtyZXBsYWNlXVxuICAgICAqL1xuXG4gICAgUm91dGVyLnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIGdvKHBhdGgpIHtcbiAgICAgIHZhciByZXBsYWNlID0gZmFsc2U7XG4gICAgICB2YXIgYXBwZW5kID0gZmFsc2U7XG4gICAgICBpZiAoVnVlLnV0aWwuaXNPYmplY3QocGF0aCkpIHtcbiAgICAgICAgcmVwbGFjZSA9IHBhdGgucmVwbGFjZTtcbiAgICAgICAgYXBwZW5kID0gcGF0aC5hcHBlbmQ7XG4gICAgICB9XG4gICAgICBwYXRoID0gdGhpcy5zdHJpbmdpZnlQYXRoKHBhdGgpO1xuICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgdGhpcy5oaXN0b3J5LmdvKHBhdGgsIHJlcGxhY2UsIGFwcGVuZCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNob3J0IGhhbmQgZm9yIHJlcGxhY2luZyBjdXJyZW50IHBhdGhcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAgICovXG5cbiAgICBSb3V0ZXIucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHBhdGgpIHtcbiAgICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcGF0aCA9IHsgcGF0aDogcGF0aCB9O1xuICAgICAgfVxuICAgICAgcGF0aC5yZXBsYWNlID0gdHJ1ZTtcbiAgICAgIHRoaXMuZ28ocGF0aCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IHRoZSByb3V0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1Z1ZUNvbnN0cnVjdG9yfSBBcHBcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fSBjb250YWluZXJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAgICovXG5cbiAgICBSb3V0ZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gc3RhcnQoQXBwLCBjb250YWluZXIsIGNiKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICh0aGlzLl9zdGFydGVkKSB7XG4gICAgICAgIHdhcm4kMSgnYWxyZWFkeSBzdGFydGVkLicpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3N0YXJ0Q2IgPSBjYjtcbiAgICAgIGlmICghdGhpcy5hcHApIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghQXBwIHx8ICFjb250YWluZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3Qgc3RhcnQgdnVlLXJvdXRlciB3aXRoIGEgY29tcG9uZW50IGFuZCBhICcgKyAncm9vdCBjb250YWluZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChBcHAgaW5zdGFuY2VvZiBWdWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3Qgc3RhcnQgdnVlLXJvdXRlciB3aXRoIGEgY29tcG9uZW50LCBub3QgYSAnICsgJ1Z1ZSBpbnN0YW5jZS4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hcHBDb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIHZhciBDdG9yID0gdGhpcy5fYXBwQ29uc3RydWN0b3IgPSB0eXBlb2YgQXBwID09PSAnZnVuY3Rpb24nID8gQXBwIDogVnVlLmV4dGVuZChBcHApO1xuICAgICAgICAvLyBnaXZlIGl0IGEgbmFtZSBmb3IgYmV0dGVyIGRlYnVnZ2luZ1xuICAgICAgICBDdG9yLm9wdGlvbnMubmFtZSA9IEN0b3Iub3B0aW9ucy5uYW1lIHx8ICdSb3V0ZXJBcHAnO1xuICAgICAgfVxuXG4gICAgICAvLyBoYW5kbGUgaGlzdG9yeSBmYWxsYmFjayBpbiBicm93c2VycyB0aGF0IGRvIG5vdFxuICAgICAgLy8gc3VwcG9ydCBIVE1MNSBoaXN0b3J5IEFQSVxuICAgICAgaWYgKHRoaXMuX2hpc3RvcnlGYWxsYmFjaykge1xuICAgICAgICB2YXIgX2xvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuICAgICAgICB2YXIgX2hpc3RvcnkgPSBuZXcgSFRNTDVIaXN0b3J5KHsgcm9vdDogdGhpcy5fcm9vdCB9KTtcbiAgICAgICAgdmFyIHBhdGggPSBfaGlzdG9yeS5yb290ID8gX2xvY2F0aW9uLnBhdGhuYW1lLnJlcGxhY2UoX2hpc3Rvcnkucm9vdFJFLCAnJykgOiBfbG9jYXRpb24ucGF0aG5hbWU7XG4gICAgICAgIGlmIChwYXRoICYmIHBhdGggIT09ICcvJykge1xuICAgICAgICAgIF9sb2NhdGlvbi5hc3NpZ24oKF9oaXN0b3J5LnJvb3QgfHwgJycpICsgJy8nICsgdGhpcy5oaXN0b3J5LmZvcm1hdFBhdGgocGF0aCkgKyBfbG9jYXRpb24uc2VhcmNoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5oaXN0b3J5LnN0YXJ0KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN0b3AgbGlzdGVuaW5nIHRvIHJvdXRlIGNoYW5nZXMuXG4gICAgICovXG5cbiAgICBSb3V0ZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgdGhpcy5oaXN0b3J5LnN0b3AoKTtcbiAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplIG5hbWVkIHJvdXRlIG9iamVjdCAvIHN0cmluZyBwYXRocyBpbnRvXG4gICAgICogYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd8TnVtYmVyfSBwYXRoXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuXG4gICAgUm91dGVyLnByb3RvdHlwZS5zdHJpbmdpZnlQYXRoID0gZnVuY3Rpb24gc3RyaW5naWZ5UGF0aChwYXRoKSB7XG4gICAgICB2YXIgZ2VuZXJhdGVkUGF0aCA9ICcnO1xuICAgICAgaWYgKHBhdGggJiYgdHlwZW9mIHBhdGggPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChwYXRoLm5hbWUpIHtcbiAgICAgICAgICB2YXIgZXh0ZW5kID0gVnVlLnV0aWwuZXh0ZW5kO1xuICAgICAgICAgIHZhciBjdXJyZW50UGFyYW1zID0gdGhpcy5fY3VycmVudFRyYW5zaXRpb24gJiYgdGhpcy5fY3VycmVudFRyYW5zaXRpb24udG8ucGFyYW1zO1xuICAgICAgICAgIHZhciB0YXJnZXRQYXJhbXMgPSBwYXRoLnBhcmFtcyB8fCB7fTtcbiAgICAgICAgICB2YXIgcGFyYW1zID0gY3VycmVudFBhcmFtcyA/IGV4dGVuZChleHRlbmQoe30sIGN1cnJlbnRQYXJhbXMpLCB0YXJnZXRQYXJhbXMpIDogdGFyZ2V0UGFyYW1zO1xuICAgICAgICAgIGdlbmVyYXRlZFBhdGggPSBlbmNvZGVVUkkodGhpcy5fcmVjb2duaXplci5nZW5lcmF0ZShwYXRoLm5hbWUsIHBhcmFtcykpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhdGgucGF0aCkge1xuICAgICAgICAgIGdlbmVyYXRlZFBhdGggPSBlbmNvZGVVUkkocGF0aC5wYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aC5xdWVyeSkge1xuICAgICAgICAgIC8vIG5vdGU6IHRoZSBnZW5lcmF0ZWQgcXVlcnkgc3RyaW5nIGlzIHByZS1VUkwtZW5jb2RlZCBieSB0aGUgcmVjb2duaXplclxuICAgICAgICAgIHZhciBxdWVyeSA9IHRoaXMuX3JlY29nbml6ZXIuZ2VuZXJhdGVRdWVyeVN0cmluZyhwYXRoLnF1ZXJ5KTtcbiAgICAgICAgICBpZiAoZ2VuZXJhdGVkUGF0aC5pbmRleE9mKCc/JykgPiAtMSkge1xuICAgICAgICAgICAgZ2VuZXJhdGVkUGF0aCArPSAnJicgKyBxdWVyeS5zbGljZSgxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2VuZXJhdGVkUGF0aCArPSBxdWVyeTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdlbmVyYXRlZFBhdGggPSBlbmNvZGVVUkkocGF0aCA/IHBhdGggKyAnJyA6ICcnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZW5lcmF0ZWRQYXRoO1xuICAgIH07XG5cbiAgICAvLyBJbnRlcm5hbCBtZXRob2RzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvKipcbiAgICAqIEFkZCBhIHJvdXRlIGNvbnRhaW5pbmcgYSBsaXN0IG9mIHNlZ21lbnRzIHRvIHRoZSBpbnRlcm5hbFxuICAgICogcm91dGUgcmVjb2duaXplci4gV2lsbCBiZSBjYWxsZWQgcmVjdXJzaXZlbHkgdG8gYWRkIGFsbFxuICAgICogcG9zc2libGUgc3ViLXJvdXRlcy5cbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICAgICogQHBhcmFtIHtPYmplY3R9IGhhbmRsZXJcbiAgICAqIEBwYXJhbSB7QXJyYXl9IHNlZ21lbnRzXG4gICAgKi9cblxuICAgIFJvdXRlci5wcm90b3R5cGUuX2FkZFJvdXRlID0gZnVuY3Rpb24gX2FkZFJvdXRlKHBhdGgsIGhhbmRsZXIsIHNlZ21lbnRzKSB7XG4gICAgICBndWFyZENvbXBvbmVudChwYXRoLCBoYW5kbGVyKTtcbiAgICAgIGhhbmRsZXIucGF0aCA9IHBhdGg7XG4gICAgICBoYW5kbGVyLmZ1bGxQYXRoID0gKHNlZ21lbnRzLnJlZHVjZShmdW5jdGlvbiAocGF0aCwgc2VnbWVudCkge1xuICAgICAgICByZXR1cm4gcGF0aCArIHNlZ21lbnQucGF0aDtcbiAgICAgIH0sICcnKSArIHBhdGgpLnJlcGxhY2UoJy8vJywgJy8nKTtcbiAgICAgIHNlZ21lbnRzLnB1c2goe1xuICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICBoYW5kbGVyOiBoYW5kbGVyXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3JlY29nbml6ZXIuYWRkKHNlZ21lbnRzLCB7XG4gICAgICAgIGFzOiBoYW5kbGVyLm5hbWVcbiAgICAgIH0pO1xuICAgICAgLy8gYWRkIHN1YiByb3V0ZXNcbiAgICAgIGlmIChoYW5kbGVyLnN1YlJvdXRlcykge1xuICAgICAgICBmb3IgKHZhciBzdWJQYXRoIGluIGhhbmRsZXIuc3ViUm91dGVzKSB7XG4gICAgICAgICAgLy8gcmVjdXJzaXZlbHkgd2FsayBhbGwgc3ViIHJvdXRlc1xuICAgICAgICAgIHRoaXMuX2FkZFJvdXRlKHN1YlBhdGgsIGhhbmRsZXIuc3ViUm91dGVzW3N1YlBhdGhdLFxuICAgICAgICAgIC8vIHBhc3MgYSBjb3B5IGluIHJlY3Vyc2lvbiB0byBhdm9pZCBtdXRhdGluZ1xuICAgICAgICAgIC8vIGFjcm9zcyBicmFuY2hlc1xuICAgICAgICAgIHNlZ21lbnRzLnNsaWNlKCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbm90Rm91bmQgcm91dGUgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBoYW5kbGVyXG4gICAgICovXG5cbiAgICBSb3V0ZXIucHJvdG90eXBlLl9ub3RGb3VuZCA9IGZ1bmN0aW9uIF9ub3RGb3VuZChoYW5kbGVyKSB7XG4gICAgICBndWFyZENvbXBvbmVudCgnKicsIGhhbmRsZXIpO1xuICAgICAgdGhpcy5fbm90Rm91bmRIYW5kbGVyID0gW3sgaGFuZGxlcjogaGFuZGxlciB9XTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkIGEgcmVkaXJlY3QgcmVjb3JkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcmVkaXJlY3RQYXRoXG4gICAgICovXG5cbiAgICBSb3V0ZXIucHJvdG90eXBlLl9hZGRSZWRpcmVjdCA9IGZ1bmN0aW9uIF9hZGRSZWRpcmVjdChwYXRoLCByZWRpcmVjdFBhdGgpIHtcbiAgICAgIGlmIChwYXRoID09PSAnKicpIHtcbiAgICAgICAgdGhpcy5fbm90Rm91bmRSZWRpcmVjdCA9IHJlZGlyZWN0UGF0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2FkZEd1YXJkKHBhdGgsIHJlZGlyZWN0UGF0aCwgdGhpcy5yZXBsYWNlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkIGFuIGFsaWFzIHJlY29yZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFsaWFzUGF0aFxuICAgICAqL1xuXG4gICAgUm91dGVyLnByb3RvdHlwZS5fYWRkQWxpYXMgPSBmdW5jdGlvbiBfYWRkQWxpYXMocGF0aCwgYWxpYXNQYXRoKSB7XG4gICAgICB0aGlzLl9hZGRHdWFyZChwYXRoLCBhbGlhc1BhdGgsIHRoaXMuX21hdGNoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkIGEgcGF0aCBndWFyZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1hcHBlZFBhdGhcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAgICovXG5cbiAgICBSb3V0ZXIucHJvdG90eXBlLl9hZGRHdWFyZCA9IGZ1bmN0aW9uIF9hZGRHdWFyZChwYXRoLCBtYXBwZWRQYXRoLCBfaGFuZGxlcikge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMuX2d1YXJkUmVjb2duaXplci5hZGQoW3tcbiAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihtYXRjaCwgcXVlcnkpIHtcbiAgICAgICAgICB2YXIgcmVhbFBhdGggPSBtYXBQYXJhbXMobWFwcGVkUGF0aCwgbWF0Y2gucGFyYW1zLCBxdWVyeSk7XG4gICAgICAgICAgX2hhbmRsZXIuY2FsbChfdGhpczIsIHJlYWxQYXRoKTtcbiAgICAgICAgfVxuICAgICAgfV0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHBhdGggbWF0Y2hlcyBhbnkgcmVkaXJlY3QgcmVjb3Jkcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gLSBpZiB0cnVlLCB3aWxsIHNraXAgbm9ybWFsIG1hdGNoLlxuICAgICAqL1xuXG4gICAgUm91dGVyLnByb3RvdHlwZS5fY2hlY2tHdWFyZCA9IGZ1bmN0aW9uIF9jaGVja0d1YXJkKHBhdGgpIHtcbiAgICAgIHZhciBtYXRjaGVkID0gdGhpcy5fZ3VhcmRSZWNvZ25pemVyLnJlY29nbml6ZShwYXRoLCB0cnVlKTtcbiAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgIG1hdGNoZWRbMF0uaGFuZGxlcihtYXRjaGVkWzBdLCBtYXRjaGVkLnF1ZXJ5UGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX25vdEZvdW5kUmVkaXJlY3QpIHtcbiAgICAgICAgbWF0Y2hlZCA9IHRoaXMuX3JlY29nbml6ZXIucmVjb2duaXplKHBhdGgpO1xuICAgICAgICBpZiAoIW1hdGNoZWQpIHtcbiAgICAgICAgICB0aGlzLnJlcGxhY2UodGhpcy5fbm90Rm91bmRSZWRpcmVjdCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTWF0Y2ggYSBVUkwgcGF0aCBhbmQgc2V0IHRoZSByb3V0ZSBjb250ZXh0IG9uIHZtLFxuICAgICAqIHRyaWdnZXJpbmcgdmlldyB1cGRhdGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YXRlXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbYW5jaG9yXVxuICAgICAqL1xuXG4gICAgUm91dGVyLnByb3RvdHlwZS5fbWF0Y2ggPSBmdW5jdGlvbiBfbWF0Y2gocGF0aCwgc3RhdGUsIGFuY2hvcikge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLl9jaGVja0d1YXJkKHBhdGgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGN1cnJlbnRSb3V0ZSA9IHRoaXMuX2N1cnJlbnRSb3V0ZTtcbiAgICAgIHZhciBjdXJyZW50VHJhbnNpdGlvbiA9IHRoaXMuX2N1cnJlbnRUcmFuc2l0aW9uO1xuXG4gICAgICBpZiAoY3VycmVudFRyYW5zaXRpb24pIHtcbiAgICAgICAgaWYgKGN1cnJlbnRUcmFuc2l0aW9uLnRvLnBhdGggPT09IHBhdGgpIHtcbiAgICAgICAgICAvLyBkbyBub3RoaW5nIGlmIHdlIGhhdmUgYW4gYWN0aXZlIHRyYW5zaXRpb24gZ29pbmcgdG8gdGhlIHNhbWUgcGF0aFxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50Um91dGUucGF0aCA9PT0gcGF0aCkge1xuICAgICAgICAgIC8vIFdlIGFyZSBnb2luZyB0byB0aGUgc2FtZSBwYXRoLCBidXQgd2UgYWxzbyBoYXZlIGFuIG9uZ29pbmcgYnV0XG4gICAgICAgICAgLy8gbm90LXlldC12YWxpZGF0ZWQgdHJhbnNpdGlvbi4gQWJvcnQgdGhhdCB0cmFuc2l0aW9uIGFuZCByZXNldCB0b1xuICAgICAgICAgIC8vIHByZXYgdHJhbnNpdGlvbi5cbiAgICAgICAgICBjdXJyZW50VHJhbnNpdGlvbi5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLl9jdXJyZW50VHJhbnNpdGlvbiA9IHRoaXMuX3ByZXZUcmFuc2l0aW9uO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBnb2luZyB0byBhIHRvdGFsbHkgZGlmZmVyZW50IHBhdGguIGFib3J0IG9uZ29pbmcgdHJhbnNpdGlvbi5cbiAgICAgICAgICBjdXJyZW50VHJhbnNpdGlvbi5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBjb25zdHJ1Y3QgbmV3IHJvdXRlIGFuZCB0cmFuc2l0aW9uIGNvbnRleHRcbiAgICAgIHZhciByb3V0ZSA9IG5ldyBSb3V0ZShwYXRoLCB0aGlzKTtcbiAgICAgIHZhciB0cmFuc2l0aW9uID0gbmV3IFJvdXRlVHJhbnNpdGlvbih0aGlzLCByb3V0ZSwgY3VycmVudFJvdXRlKTtcblxuICAgICAgLy8gY3VycmVudCB0cmFuc2l0aW9uIGlzIHVwZGF0ZWQgcmlnaHQgbm93LlxuICAgICAgLy8gaG93ZXZlciwgY3VycmVudCByb3V0ZSB3aWxsIG9ubHkgYmUgdXBkYXRlZCBhZnRlciB0aGUgdHJhbnNpdGlvbiBoYXNcbiAgICAgIC8vIGJlZW4gdmFsaWRhdGVkLlxuICAgICAgdGhpcy5fcHJldlRyYW5zaXRpb24gPSBjdXJyZW50VHJhbnNpdGlvbjtcbiAgICAgIHRoaXMuX2N1cnJlbnRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcblxuICAgICAgaWYgKCF0aGlzLmFwcCkge1xuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIGluaXRpYWwgcmVuZGVyXG4gICAgICAgICAgdmFyIHJvdXRlciA9IF90aGlzMztcbiAgICAgICAgICBfdGhpczMuYXBwID0gbmV3IF90aGlzMy5fYXBwQ29uc3RydWN0b3Ioe1xuICAgICAgICAgICAgZWw6IF90aGlzMy5fYXBwQ29udGFpbmVyLFxuICAgICAgICAgICAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcbiAgICAgICAgICAgICAgdGhpcy4kcm91dGVyID0gcm91dGVyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9tZXRhOiB7XG4gICAgICAgICAgICAgICRyb3V0ZTogcm91dGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkoKTtcbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgZ2xvYmFsIGJlZm9yZSBob29rXG4gICAgICB2YXIgYmVmb3JlSG9va3MgPSB0aGlzLl9iZWZvcmVFYWNoSG9va3M7XG4gICAgICB2YXIgc3RhcnRUcmFuc2l0aW9uID0gZnVuY3Rpb24gc3RhcnRUcmFuc2l0aW9uKCkge1xuICAgICAgICB0cmFuc2l0aW9uLnN0YXJ0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczMuX3Bvc3RUcmFuc2l0aW9uKHJvdXRlLCBzdGF0ZSwgYW5jaG9yKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBpZiAoYmVmb3JlSG9va3MubGVuZ3RoKSB7XG4gICAgICAgIHRyYW5zaXRpb24ucnVuUXVldWUoYmVmb3JlSG9va3MsIGZ1bmN0aW9uIChob29rLCBfLCBuZXh0KSB7XG4gICAgICAgICAgaWYgKHRyYW5zaXRpb24gPT09IF90aGlzMy5fY3VycmVudFRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb24uY2FsbEhvb2soaG9vaywgbnVsbCwgbmV4dCwge1xuICAgICAgICAgICAgICBleHBlY3RCb29sZWFuOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHN0YXJ0VHJhbnNpdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydFRyYW5zaXRpb24oKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9yZW5kZXJlZCAmJiB0aGlzLl9zdGFydENiKSB7XG4gICAgICAgIHRoaXMuX3N0YXJ0Q2IuY2FsbChudWxsKTtcbiAgICAgIH1cblxuICAgICAgLy8gSEFDSzpcbiAgICAgIC8vIHNldCByZW5kZXJlZCB0byB0cnVlIGFmdGVyIHRoZSB0cmFuc2l0aW9uIHN0YXJ0LCBzb1xuICAgICAgLy8gdGhhdCBjb21wb25lbnRzIHRoYXQgYXJlIGFjaXR2YXRlZCBzeW5jaHJvbm91c2x5IGtub3dcbiAgICAgIC8vIHdoZXRoZXIgaXQgaXMgdGhlIGluaXRpYWwgcmVuZGVyLlxuICAgICAgdGhpcy5fcmVuZGVyZWQgPSB0cnVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXQgY3VycmVudCB0byB0aGUgbmV3IHRyYW5zaXRpb24uXG4gICAgICogVGhpcyBpcyBjYWxsZWQgYnkgdGhlIHRyYW5zaXRpb24gb2JqZWN0IHdoZW4gdGhlXG4gICAgICogdmFsaWRhdGlvbiBvZiBhIHJvdXRlIGhhcyBzdWNjZWVkZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1RyYW5zaXRpb259IHRyYW5zaXRpb25cbiAgICAgKi9cblxuICAgIFJvdXRlci5wcm90b3R5cGUuX29uVHJhbnNpdGlvblZhbGlkYXRlZCA9IGZ1bmN0aW9uIF9vblRyYW5zaXRpb25WYWxpZGF0ZWQodHJhbnNpdGlvbikge1xuICAgICAgLy8gc2V0IGN1cnJlbnQgcm91dGVcbiAgICAgIHZhciByb3V0ZSA9IHRoaXMuX2N1cnJlbnRSb3V0ZSA9IHRyYW5zaXRpb24udG87XG4gICAgICAvLyB1cGRhdGUgcm91dGUgY29udGV4dCBmb3IgYWxsIGNoaWxkcmVuXG4gICAgICBpZiAodGhpcy5hcHAuJHJvdXRlICE9PSByb3V0ZSkge1xuICAgICAgICB0aGlzLmFwcC4kcm91dGUgPSByb3V0ZTtcbiAgICAgICAgdGhpcy5fY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICBjaGlsZC4kcm91dGUgPSByb3V0ZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvLyBjYWxsIGdsb2JhbCBhZnRlciBob29rXG4gICAgICBpZiAodGhpcy5fYWZ0ZXJFYWNoSG9va3MubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX2FmdGVyRWFjaEhvb2tzLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgICAgICAgICByZXR1cm4gaG9vay5jYWxsKG51bGwsIHtcbiAgICAgICAgICAgIHRvOiB0cmFuc2l0aW9uLnRvLFxuICAgICAgICAgICAgZnJvbTogdHJhbnNpdGlvbi5mcm9tXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5fY3VycmVudFRyYW5zaXRpb24uZG9uZSA9IHRydWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBzdHVmZiBhZnRlciB0aGUgdHJhbnNpdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Um91dGV9IHJvdXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGF0ZV1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2FuY2hvcl1cbiAgICAgKi9cblxuICAgIFJvdXRlci5wcm90b3R5cGUuX3Bvc3RUcmFuc2l0aW9uID0gZnVuY3Rpb24gX3Bvc3RUcmFuc2l0aW9uKHJvdXRlLCBzdGF0ZSwgYW5jaG9yKSB7XG4gICAgICAvLyBoYW5kbGUgc2Nyb2xsIHBvc2l0aW9uc1xuICAgICAgLy8gc2F2ZWQgc2Nyb2xsIHBvc2l0aW9ucyB0YWtlIHByaW9yaXR5XG4gICAgICAvLyB0aGVuIHdlIGNoZWNrIGlmIHRoZSBwYXRoIGhhcyBhbiBhbmNob3JcbiAgICAgIHZhciBwb3MgPSBzdGF0ZSAmJiBzdGF0ZS5wb3M7XG4gICAgICBpZiAocG9zICYmIHRoaXMuX3NhdmVTY3JvbGxQb3NpdGlvbikge1xuICAgICAgICBWdWUubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbyhwb3MueCwgcG9zLnkpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoYW5jaG9yKSB7XG4gICAgICAgIFZ1ZS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYW5jaG9yLnNsaWNlKDEpKTtcbiAgICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbyh3aW5kb3cuc2Nyb2xsWCwgZWwub2Zmc2V0VG9wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gUm91dGVyO1xuICB9KSgpO1xuXG4gIGZ1bmN0aW9uIGd1YXJkQ29tcG9uZW50KHBhdGgsIGhhbmRsZXIpIHtcbiAgICB2YXIgY29tcCA9IGhhbmRsZXIuY29tcG9uZW50O1xuICAgIGlmIChWdWUudXRpbC5pc1BsYWluT2JqZWN0KGNvbXApKSB7XG4gICAgICBjb21wID0gaGFuZGxlci5jb21wb25lbnQgPSBWdWUuZXh0ZW5kKGNvbXApO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodHlwZW9mIGNvbXAgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGhhbmRsZXIuY29tcG9uZW50ID0gbnVsbDtcbiAgICAgIHdhcm4kMSgnaW52YWxpZCBjb21wb25lbnQgZm9yIHJvdXRlIFwiJyArIHBhdGggKyAnXCIuJyk7XG4gICAgfVxuICB9XG5cbiAgLyogSW5zdGFsbGF0aW9uICovXG5cbiAgUm91dGVyLmluc3RhbGxlZCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBJbnN0YWxsYXRpb24gaW50ZXJmYWNlLlxuICAgKiBJbnN0YWxsIHRoZSBuZWNlc3NhcnkgZGlyZWN0aXZlcy5cbiAgICovXG5cbiAgUm91dGVyLmluc3RhbGwgPSBmdW5jdGlvbiAoZXh0ZXJuYWxWdWUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoUm91dGVyLmluc3RhbGxlZCkge1xuICAgICAgd2FybiQxKCdhbHJlYWR5IGluc3RhbGxlZC4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgVnVlID0gZXh0ZXJuYWxWdWU7XG4gICAgYXBwbHlPdmVycmlkZShWdWUpO1xuICAgIFZpZXcoVnVlKTtcbiAgICBMaW5rKFZ1ZSk7XG4gICAgZXhwb3J0cyQxLlZ1ZSA9IFZ1ZTtcbiAgICBSb3V0ZXIuaW5zdGFsbGVkID0gdHJ1ZTtcbiAgfTtcblxuICAvLyBhdXRvIGluc3RhbGxcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuVnVlKSB7XG4gICAgd2luZG93LlZ1ZS51c2UoUm91dGVyKTtcbiAgfVxuXG4gIHJldHVybiBSb3V0ZXI7XG5cbn0pKTsiLCJ2YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWwnKVxudmFyIFdhdGNoZXIgPSByZXF1aXJlKCcuLi93YXRjaGVyJylcbnZhciBQYXRoID0gcmVxdWlyZSgnLi4vcGFyc2Vycy9wYXRoJylcbnZhciB0ZXh0UGFyc2VyID0gcmVxdWlyZSgnLi4vcGFyc2Vycy90ZXh0JylcbnZhciBkaXJQYXJzZXIgPSByZXF1aXJlKCcuLi9wYXJzZXJzL2RpcmVjdGl2ZScpXG52YXIgZXhwUGFyc2VyID0gcmVxdWlyZSgnLi4vcGFyc2Vycy9leHByZXNzaW9uJylcbnZhciBmaWx0ZXJSRSA9IC9bXnxdXFx8W158XS9cblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIGZyb20gYW4gZXhwcmVzc2lvbiBvbiB0aGlzIHZtLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHBcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2FzU3RhdGVtZW50XVxuICogQHJldHVybiB7Kn1cbiAqL1xuXG5leHBvcnRzLiRnZXQgPSBmdW5jdGlvbiAoZXhwLCBhc1N0YXRlbWVudCkge1xuICB2YXIgcmVzID0gZXhwUGFyc2VyLnBhcnNlKGV4cClcbiAgaWYgKHJlcykge1xuICAgIGlmIChhc1N0YXRlbWVudCAmJiAhZXhwUGFyc2VyLmlzU2ltcGxlUGF0aChleHApKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICAgIHJldHVybiBmdW5jdGlvbiBzdGF0ZW1lbnRIYW5kbGVyICgpIHtcbiAgICAgICAgcmVzLmdldC5jYWxsKHNlbGYsIHNlbGYpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiByZXMuZ2V0LmNhbGwodGhpcywgdGhpcylcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogU2V0IHRoZSB2YWx1ZSBmcm9tIGFuIGV4cHJlc3Npb24gb24gdGhpcyB2bS5cbiAqIFRoZSBleHByZXNzaW9uIG11c3QgYmUgYSB2YWxpZCBsZWZ0LWhhbmRcbiAqIGV4cHJlc3Npb24gaW4gYW4gYXNzaWdubWVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwXG4gKiBAcGFyYW0geyp9IHZhbFxuICovXG5cbmV4cG9ydHMuJHNldCA9IGZ1bmN0aW9uIChleHAsIHZhbCkge1xuICB2YXIgcmVzID0gZXhwUGFyc2VyLnBhcnNlKGV4cCwgdHJ1ZSlcbiAgaWYgKHJlcyAmJiByZXMuc2V0KSB7XG4gICAgcmVzLnNldC5jYWxsKHRoaXMsIHRoaXMsIHZhbClcbiAgfVxufVxuXG4vKipcbiAqIERlbGV0ZSBhIHByb3BlcnR5IG9uIHRoZSBWTVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqL1xuXG5leHBvcnRzLiRkZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIF8uZGVsZXRlKHRoaXMuX2RhdGEsIGtleSlcbn1cblxuLyoqXG4gKiBXYXRjaCBhbiBleHByZXNzaW9uLCB0cmlnZ2VyIGNhbGxiYWNrIHdoZW4gaXRzXG4gKiB2YWx1ZSBjaGFuZ2VzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBleHBPckZuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IGRlZXBcbiAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSBpbW1lZGlhdGVcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSAtIHVud2F0Y2hGblxuICovXG5cbmV4cG9ydHMuJHdhdGNoID0gZnVuY3Rpb24gKGV4cE9yRm4sIGNiLCBvcHRpb25zKSB7XG4gIHZhciB2bSA9IHRoaXNcbiAgdmFyIHBhcnNlZFxuICBpZiAodHlwZW9mIGV4cE9yRm4gPT09ICdzdHJpbmcnKSB7XG4gICAgcGFyc2VkID0gZGlyUGFyc2VyLnBhcnNlKGV4cE9yRm4pXG4gICAgZXhwT3JGbiA9IHBhcnNlZC5leHByZXNzaW9uXG4gIH1cbiAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIHtcbiAgICBkZWVwOiBvcHRpb25zICYmIG9wdGlvbnMuZGVlcCxcbiAgICBmaWx0ZXJzOiBwYXJzZWQgJiYgcGFyc2VkLmZpbHRlcnNcbiAgfSlcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5pbW1lZGlhdGUpIHtcbiAgICBjYi5jYWxsKHZtLCB3YXRjaGVyLnZhbHVlKVxuICB9XG4gIHJldHVybiBmdW5jdGlvbiB1bndhdGNoRm4gKCkge1xuICAgIHdhdGNoZXIudGVhcmRvd24oKVxuICB9XG59XG5cbi8qKlxuICogRXZhbHVhdGUgYSB0ZXh0IGRpcmVjdGl2ZSwgaW5jbHVkaW5nIGZpbHRlcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2FzU3RhdGVtZW50XVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmV4cG9ydHMuJGV2YWwgPSBmdW5jdGlvbiAodGV4dCwgYXNTdGF0ZW1lbnQpIHtcbiAgLy8gY2hlY2sgZm9yIGZpbHRlcnMuXG4gIGlmIChmaWx0ZXJSRS50ZXN0KHRleHQpKSB7XG4gICAgdmFyIGRpciA9IGRpclBhcnNlci5wYXJzZSh0ZXh0KVxuICAgIC8vIHRoZSBmaWx0ZXIgcmVnZXggY2hlY2sgbWlnaHQgZ2l2ZSBmYWxzZSBwb3NpdGl2ZVxuICAgIC8vIGZvciBwaXBlcyBpbnNpZGUgc3RyaW5ncywgc28gaXQncyBwb3NzaWJsZSB0aGF0XG4gICAgLy8gd2UgZG9uJ3QgZ2V0IGFueSBmaWx0ZXJzIGhlcmVcbiAgICB2YXIgdmFsID0gdGhpcy4kZ2V0KGRpci5leHByZXNzaW9uLCBhc1N0YXRlbWVudClcbiAgICByZXR1cm4gZGlyLmZpbHRlcnNcbiAgICAgID8gdGhpcy5fYXBwbHlGaWx0ZXJzKHZhbCwgbnVsbCwgZGlyLmZpbHRlcnMpXG4gICAgICA6IHZhbFxuICB9IGVsc2Uge1xuICAgIC8vIG5vIGZpbHRlclxuICAgIHJldHVybiB0aGlzLiRnZXQodGV4dCwgYXNTdGF0ZW1lbnQpXG4gIH1cbn1cblxuLyoqXG4gKiBJbnRlcnBvbGF0ZSBhIHBpZWNlIG9mIHRlbXBsYXRlIHRleHQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRleHRcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5leHBvcnRzLiRpbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gIHZhciB0b2tlbnMgPSB0ZXh0UGFyc2VyLnBhcnNlKHRleHQpXG4gIHZhciB2bSA9IHRoaXNcbiAgaWYgKHRva2Vucykge1xuICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gdm0uJGV2YWwodG9rZW5zWzBdLnZhbHVlKSArICcnXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0b2tlbnMubWFwKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICByZXR1cm4gdG9rZW4udGFnXG4gICAgICAgICAgPyB2bS4kZXZhbCh0b2tlbi52YWx1ZSlcbiAgICAgICAgICA6IHRva2VuLnZhbHVlXG4gICAgICB9KS5qb2luKCcnKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGV4dFxuICB9XG59XG5cbi8qKlxuICogTG9nIGluc3RhbmNlIGRhdGEgYXMgYSBwbGFpbiBKUyBvYmplY3RcbiAqIHNvIHRoYXQgaXQgaXMgZWFzaWVyIHRvIGluc3BlY3QgaW4gY29uc29sZS5cbiAqIFRoaXMgbWV0aG9kIGFzc3VtZXMgY29uc29sZSBpcyBhdmFpbGFibGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICovXG5cbmV4cG9ydHMuJGxvZyA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gIHZhciBkYXRhID0gcGF0aFxuICAgID8gUGF0aC5nZXQodGhpcy5fZGF0YSwgcGF0aClcbiAgICA6IHRoaXMuX2RhdGFcbiAgaWYgKGRhdGEpIHtcbiAgICBkYXRhID0gY2xlYW4oZGF0YSlcbiAgfVxuICAvLyBpbmNsdWRlIGNvbXB1dGVkIGZpZWxkc1xuICBpZiAoIXBhdGgpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy4kb3B0aW9ucy5jb21wdXRlZCkge1xuICAgICAgZGF0YVtrZXldID0gY2xlYW4odGhpc1trZXldKVxuICAgIH1cbiAgfVxuICBjb25zb2xlLmxvZyhkYXRhKVxufVxuXG4vKipcbiAqIFwiY2xlYW5cIiBhIGdldHRlci9zZXR0ZXIgY29udmVydGVkIG9iamVjdCBpbnRvIGEgcGxhaW5cbiAqIG9iamVjdCBjb3B5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSAtIG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIGNsZWFuIChvYmopIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSlcbn1cbiIsInZhciBfID0gcmVxdWlyZSgnLi4vdXRpbCcpXG52YXIgdHJhbnNpdGlvbiA9IHJlcXVpcmUoJy4uL3RyYW5zaXRpb24nKVxuXG4vKipcbiAqIENvbnZlbmllbmNlIG9uLWluc3RhbmNlIG5leHRUaWNrLiBUaGUgY2FsbGJhY2sgaXNcbiAqIGF1dG8tYm91bmQgdG8gdGhlIGluc3RhbmNlLCBhbmQgdGhpcyBhdm9pZHMgY29tcG9uZW50XG4gKiBtb2R1bGVzIGhhdmluZyB0byByZWx5IG9uIHRoZSBnbG9iYWwgVnVlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cblxuZXhwb3J0cy4kbmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgXy5uZXh0VGljayhmbiwgdGhpcylcbn1cblxuLyoqXG4gKiBBcHBlbmQgaW5zdGFuY2UgdG8gdGFyZ2V0XG4gKlxuICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3dpdGhUcmFuc2l0aW9uXSAtIGRlZmF1bHRzIHRvIHRydWVcbiAqL1xuXG5leHBvcnRzLiRhcHBlbmRUbyA9IGZ1bmN0aW9uICh0YXJnZXQsIGNiLCB3aXRoVHJhbnNpdGlvbikge1xuICByZXR1cm4gaW5zZXJ0KFxuICAgIHRoaXMsIHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uLFxuICAgIGFwcGVuZCwgdHJhbnNpdGlvbi5hcHBlbmRcbiAgKVxufVxuXG4vKipcbiAqIFByZXBlbmQgaW5zdGFuY2UgdG8gdGFyZ2V0XG4gKlxuICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3dpdGhUcmFuc2l0aW9uXSAtIGRlZmF1bHRzIHRvIHRydWVcbiAqL1xuXG5leHBvcnRzLiRwcmVwZW5kVG8gPSBmdW5jdGlvbiAodGFyZ2V0LCBjYiwgd2l0aFRyYW5zaXRpb24pIHtcbiAgdGFyZ2V0ID0gcXVlcnkodGFyZ2V0KVxuICBpZiAodGFyZ2V0Lmhhc0NoaWxkTm9kZXMoKSkge1xuICAgIHRoaXMuJGJlZm9yZSh0YXJnZXQuZmlyc3RDaGlsZCwgY2IsIHdpdGhUcmFuc2l0aW9uKVxuICB9IGVsc2Uge1xuICAgIHRoaXMuJGFwcGVuZFRvKHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogSW5zZXJ0IGluc3RhbmNlIGJlZm9yZSB0YXJnZXRcbiAqXG4gKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICogQHBhcmFtIHtCb29sZWFufSBbd2l0aFRyYW5zaXRpb25dIC0gZGVmYXVsdHMgdG8gdHJ1ZVxuICovXG5cbmV4cG9ydHMuJGJlZm9yZSA9IGZ1bmN0aW9uICh0YXJnZXQsIGNiLCB3aXRoVHJhbnNpdGlvbikge1xuICByZXR1cm4gaW5zZXJ0KFxuICAgIHRoaXMsIHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uLFxuICAgIGJlZm9yZSwgdHJhbnNpdGlvbi5iZWZvcmVcbiAgKVxufVxuXG4vKipcbiAqIEluc2VydCBpbnN0YW5jZSBhZnRlciB0YXJnZXRcbiAqXG4gKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICogQHBhcmFtIHtCb29sZWFufSBbd2l0aFRyYW5zaXRpb25dIC0gZGVmYXVsdHMgdG8gdHJ1ZVxuICovXG5cbmV4cG9ydHMuJGFmdGVyID0gZnVuY3Rpb24gKHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uKSB7XG4gIHRhcmdldCA9IHF1ZXJ5KHRhcmdldClcbiAgaWYgKHRhcmdldC5uZXh0U2libGluZykge1xuICAgIHRoaXMuJGJlZm9yZSh0YXJnZXQubmV4dFNpYmxpbmcsIGNiLCB3aXRoVHJhbnNpdGlvbilcbiAgfSBlbHNlIHtcbiAgICB0aGlzLiRhcHBlbmRUbyh0YXJnZXQucGFyZW50Tm9kZSwgY2IsIHdpdGhUcmFuc2l0aW9uKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogUmVtb3ZlIGluc3RhbmNlIGZyb20gRE9NXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICogQHBhcmFtIHtCb29sZWFufSBbd2l0aFRyYW5zaXRpb25dIC0gZGVmYXVsdHMgdG8gdHJ1ZVxuICovXG5cbmV4cG9ydHMuJHJlbW92ZSA9IGZ1bmN0aW9uIChjYiwgd2l0aFRyYW5zaXRpb24pIHtcbiAgaWYgKCF0aGlzLiRlbC5wYXJlbnROb2RlKSB7XG4gICAgcmV0dXJuIGNiICYmIGNiKClcbiAgfVxuICB2YXIgaW5Eb2MgPSB0aGlzLl9pc0F0dGFjaGVkICYmIF8uaW5Eb2ModGhpcy4kZWwpXG4gIC8vIGlmIHdlIGFyZSBub3QgaW4gZG9jdW1lbnQsIG5vIG5lZWQgdG8gY2hlY2tcbiAgLy8gZm9yIHRyYW5zaXRpb25zXG4gIGlmICghaW5Eb2MpIHdpdGhUcmFuc2l0aW9uID0gZmFsc2VcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciByZWFsQ2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGluRG9jKSBzZWxmLl9jYWxsSG9vaygnZGV0YWNoZWQnKVxuICAgIGlmIChjYikgY2IoKVxuICB9XG4gIGlmICh0aGlzLl9pc0ZyYWdtZW50KSB7XG4gICAgXy5yZW1vdmVOb2RlUmFuZ2UoXG4gICAgICB0aGlzLl9mcmFnbWVudFN0YXJ0LFxuICAgICAgdGhpcy5fZnJhZ21lbnRFbmQsXG4gICAgICB0aGlzLCB0aGlzLl9mcmFnbWVudCwgcmVhbENiXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHZhciBvcCA9IHdpdGhUcmFuc2l0aW9uID09PSBmYWxzZVxuICAgICAgPyByZW1vdmVcbiAgICAgIDogdHJhbnNpdGlvbi5yZW1vdmVcbiAgICBvcCh0aGlzLiRlbCwgdGhpcywgcmVhbENiKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogU2hhcmVkIERPTSBpbnNlcnRpb24gZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICogQHBhcmFtIHtCb29sZWFufSBbd2l0aFRyYW5zaXRpb25dXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcDEgLSBvcCBmb3Igbm9uLXRyYW5zaXRpb24gaW5zZXJ0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcDIgLSBvcCBmb3IgdHJhbnNpdGlvbiBpbnNlcnRcbiAqIEByZXR1cm4gdm1cbiAqL1xuXG5mdW5jdGlvbiBpbnNlcnQgKHZtLCB0YXJnZXQsIGNiLCB3aXRoVHJhbnNpdGlvbiwgb3AxLCBvcDIpIHtcbiAgdGFyZ2V0ID0gcXVlcnkodGFyZ2V0KVxuICB2YXIgdGFyZ2V0SXNEZXRhY2hlZCA9ICFfLmluRG9jKHRhcmdldClcbiAgdmFyIG9wID0gd2l0aFRyYW5zaXRpb24gPT09IGZhbHNlIHx8IHRhcmdldElzRGV0YWNoZWRcbiAgICAgID8gb3AxXG4gICAgICA6IG9wMlxuICB2YXIgc2hvdWxkQ2FsbEhvb2sgPVxuICAgICF0YXJnZXRJc0RldGFjaGVkICYmXG4gICAgIXZtLl9pc0F0dGFjaGVkICYmXG4gICAgIV8uaW5Eb2Modm0uJGVsKVxuICBpZiAodm0uX2lzRnJhZ21lbnQpIHtcbiAgICBfLm1hcE5vZGVSYW5nZSh2bS5fZnJhZ21lbnRTdGFydCwgdm0uX2ZyYWdtZW50RW5kLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgb3Aobm9kZSwgdGFyZ2V0LCB2bSlcbiAgICB9KVxuICAgIGNiICYmIGNiKClcbiAgfSBlbHNlIHtcbiAgICBvcCh2bS4kZWwsIHRhcmdldCwgdm0sIGNiKVxuICB9XG4gIGlmIChzaG91bGRDYWxsSG9vaykge1xuICAgIHZtLl9jYWxsSG9vaygnYXR0YWNoZWQnKVxuICB9XG4gIHJldHVybiB2bVxufVxuXG4vKipcbiAqIENoZWNrIGZvciBzZWxlY3RvcnNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fSBlbFxuICovXG5cbmZ1bmN0aW9uIHF1ZXJ5IChlbCkge1xuICByZXR1cm4gdHlwZW9mIGVsID09PSAnc3RyaW5nJ1xuICAgID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbClcbiAgICA6IGVsXG59XG5cbi8qKlxuICogQXBwZW5kIG9wZXJhdGlvbiB0aGF0IHRha2VzIGEgY2FsbGJhY2suXG4gKlxuICogQHBhcmFtIHtOb2RlfSBlbFxuICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAqIEBwYXJhbSB7VnVlfSB2bSAtIHVudXNlZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICovXG5cbmZ1bmN0aW9uIGFwcGVuZCAoZWwsIHRhcmdldCwgdm0sIGNiKSB7XG4gIHRhcmdldC5hcHBlbmRDaGlsZChlbClcbiAgaWYgKGNiKSBjYigpXG59XG5cbi8qKlxuICogSW5zZXJ0QmVmb3JlIG9wZXJhdGlvbiB0aGF0IHRha2VzIGEgY2FsbGJhY2suXG4gKlxuICogQHBhcmFtIHtOb2RlfSBlbFxuICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAqIEBwYXJhbSB7VnVlfSB2bSAtIHVudXNlZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICovXG5cbmZ1bmN0aW9uIGJlZm9yZSAoZWwsIHRhcmdldCwgdm0sIGNiKSB7XG4gIF8uYmVmb3JlKGVsLCB0YXJnZXQpXG4gIGlmIChjYikgY2IoKVxufVxuXG4vKipcbiAqIFJlbW92ZSBvcGVyYXRpb24gdGhhdCB0YWtlcyBhIGNhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gZWxcbiAqIEBwYXJhbSB7VnVlfSB2bSAtIHVudXNlZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICovXG5cbmZ1bmN0aW9uIHJlbW92ZSAoZWwsIHZtLCBjYikge1xuICBfLnJlbW92ZShlbClcbiAgaWYgKGNiKSBjYigpXG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWwnKVxuXG4vKipcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5cbmV4cG9ydHMuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAodGhpcy5fZXZlbnRzW2V2ZW50XSB8fCAodGhpcy5fZXZlbnRzW2V2ZW50XSA9IFtdKSlcbiAgICAucHVzaChmbilcbiAgbW9kaWZ5TGlzdGVuZXJDb3VudCh0aGlzLCBldmVudCwgMSlcbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcbiAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5cbmV4cG9ydHMuJG9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBmdW5jdGlvbiBvbiAoKSB7XG4gICAgc2VsZi4kb2ZmKGV2ZW50LCBvbilcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gIH1cbiAgb24uZm4gPSBmblxuICB0aGlzLiRvbihldmVudCwgb24pXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuXG5leHBvcnRzLiRvZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gIHZhciBjYnNcbiAgLy8gYWxsXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGlmICh0aGlzLiRwYXJlbnQpIHtcbiAgICAgIGZvciAoZXZlbnQgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICAgIGNicyA9IHRoaXMuX2V2ZW50c1tldmVudF1cbiAgICAgICAgaWYgKGNicykge1xuICAgICAgICAgIG1vZGlmeUxpc3RlbmVyQ291bnQodGhpcywgZXZlbnQsIC1jYnMubGVuZ3RoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuICAvLyBzcGVjaWZpYyBldmVudFxuICBjYnMgPSB0aGlzLl9ldmVudHNbZXZlbnRdXG4gIGlmICghY2JzKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIG1vZGlmeUxpc3RlbmVyQ291bnQodGhpcywgZXZlbnQsIC1jYnMubGVuZ3RoKVxuICAgIHRoaXMuX2V2ZW50c1tldmVudF0gPSBudWxsXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuICAvLyBzcGVjaWZpYyBoYW5kbGVyXG4gIHZhciBjYlxuICB2YXIgaSA9IGNicy5sZW5ndGhcbiAgd2hpbGUgKGktLSkge1xuICAgIGNiID0gY2JzW2ldXG4gICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgIG1vZGlmeUxpc3RlbmVyQ291bnQodGhpcywgZXZlbnQsIC0xKVxuICAgICAgY2JzLnNwbGljZShpLCAxKVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBUcmlnZ2VyIGFuIGV2ZW50IG9uIHNlbGYuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKi9cblxuZXhwb3J0cy4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICB2YXIgY2JzID0gdGhpcy5fZXZlbnRzW2V2ZW50XVxuICB0aGlzLl9zaG91bGRQcm9wYWdhdGUgPSAhY2JzXG4gIGlmIChjYnMpIHtcbiAgICBjYnMgPSBjYnMubGVuZ3RoID4gMVxuICAgICAgPyBfLnRvQXJyYXkoY2JzKVxuICAgICAgOiBjYnNcbiAgICB2YXIgYXJncyA9IF8udG9BcnJheShhcmd1bWVudHMsIDEpXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgcmVzID0gY2JzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICBpZiAocmVzID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX3Nob3VsZFByb3BhZ2F0ZSA9IHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBSZWN1cnNpdmVseSBicm9hZGNhc3QgYW4gZXZlbnQgdG8gYWxsIGNoaWxkcmVuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7Li4uKn0gYWRkaXRpb25hbCBhcmd1bWVudHNcbiAqL1xuXG5leHBvcnRzLiRicm9hZGNhc3QgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgLy8gaWYgbm8gY2hpbGQgaGFzIHJlZ2lzdGVyZWQgZm9yIHRoaXMgZXZlbnQsXG4gIC8vIHRoZW4gdGhlcmUncyBubyBuZWVkIHRvIGJyb2FkY2FzdC5cbiAgaWYgKCF0aGlzLl9ldmVudHNDb3VudFtldmVudF0pIHJldHVyblxuICB2YXIgY2hpbGRyZW4gPSB0aGlzLiRjaGlsZHJlblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldXG4gICAgY2hpbGQuJGVtaXQuYXBwbHkoY2hpbGQsIGFyZ3VtZW50cylcbiAgICBpZiAoY2hpbGQuX3Nob3VsZFByb3BhZ2F0ZSkge1xuICAgICAgY2hpbGQuJGJyb2FkY2FzdC5hcHBseShjaGlsZCwgYXJndW1lbnRzKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHByb3BhZ2F0ZSBhbiBldmVudCB1cCB0aGUgcGFyZW50IGNoYWluLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHsuLi4qfSBhZGRpdGlvbmFsIGFyZ3VtZW50c1xuICovXG5cbmV4cG9ydHMuJGRpc3BhdGNoID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLiRlbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgdmFyIHBhcmVudCA9IHRoaXMuJHBhcmVudFxuICB3aGlsZSAocGFyZW50KSB7XG4gICAgcGFyZW50LiRlbWl0LmFwcGx5KHBhcmVudCwgYXJndW1lbnRzKVxuICAgIHBhcmVudCA9IHBhcmVudC5fc2hvdWxkUHJvcGFnYXRlXG4gICAgICA/IHBhcmVudC4kcGFyZW50XG4gICAgICA6IG51bGxcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIE1vZGlmeSB0aGUgbGlzdGVuZXIgY291bnRzIG9uIGFsbCBwYXJlbnRzLlxuICogVGhpcyBib29ra2VlcGluZyBhbGxvd3MgJGJyb2FkY2FzdCB0byByZXR1cm4gZWFybHkgd2hlblxuICogbm8gY2hpbGQgaGFzIGxpc3RlbmVkIHRvIGEgY2VydGFpbiBldmVudC5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50XG4gKi9cblxudmFyIGhvb2tSRSA9IC9eaG9vazovXG5mdW5jdGlvbiBtb2RpZnlMaXN0ZW5lckNvdW50ICh2bSwgZXZlbnQsIGNvdW50KSB7XG4gIHZhciBwYXJlbnQgPSB2bS4kcGFyZW50XG4gIC8vIGhvb2tzIGRvIG5vdCBnZXQgYnJvYWRjYXN0ZWQgc28gbm8gbmVlZFxuICAvLyB0byBkbyBib29ra2VlcGluZyBmb3IgdGhlbVxuICBpZiAoIXBhcmVudCB8fCAhY291bnQgfHwgaG9va1JFLnRlc3QoZXZlbnQpKSByZXR1cm5cbiAgd2hpbGUgKHBhcmVudCkge1xuICAgIHBhcmVudC5fZXZlbnRzQ291bnRbZXZlbnRdID1cbiAgICAgIChwYXJlbnQuX2V2ZW50c0NvdW50W2V2ZW50XSB8fCAwKSArIGNvdW50XG4gICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnRcbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi91dGlsJylcbnZhciBjb25maWcgPSByZXF1aXJlKCcuLi9jb25maWcnKVxuXG4vKipcbiAqIEV4cG9zZSB1c2VmdWwgaW50ZXJuYWxzXG4gKi9cblxuZXhwb3J0cy51dGlsID0gX1xuZXhwb3J0cy5jb25maWcgPSBjb25maWdcbmV4cG9ydHMuc2V0ID0gXy5zZXRcbmV4cG9ydHMuZGVsZXRlID0gXy5kZWxldGVcbmV4cG9ydHMubmV4dFRpY2sgPSBfLm5leHRUaWNrXG5cbi8qKlxuICogVGhlIGZvbGxvd2luZyBhcmUgZXhwb3NlZCBmb3IgYWR2YW5jZWQgdXNhZ2UgLyBwbHVnaW5zXG4gKi9cblxuZXhwb3J0cy5jb21waWxlciA9IHJlcXVpcmUoJy4uL2NvbXBpbGVyJylcbmV4cG9ydHMuRnJhZ21lbnRGYWN0b3J5ID0gcmVxdWlyZSgnLi4vZnJhZ21lbnQvZmFjdG9yeScpXG5leHBvcnRzLmludGVybmFsRGlyZWN0aXZlcyA9IHJlcXVpcmUoJy4uL2RpcmVjdGl2ZXMvaW50ZXJuYWwnKVxuZXhwb3J0cy5wYXJzZXJzID0ge1xuICBwYXRoOiByZXF1aXJlKCcuLi9wYXJzZXJzL3BhdGgnKSxcbiAgdGV4dDogcmVxdWlyZSgnLi4vcGFyc2Vycy90ZXh0JyksXG4gIHRlbXBsYXRlOiByZXF1aXJlKCcuLi9wYXJzZXJzL3RlbXBsYXRlJyksXG4gIGRpcmVjdGl2ZTogcmVxdWlyZSgnLi4vcGFyc2Vycy9kaXJlY3RpdmUnKSxcbiAgZXhwcmVzc2lvbjogcmVxdWlyZSgnLi4vcGFyc2Vycy9leHByZXNzaW9uJylcbn1cblxuLyoqXG4gKiBFYWNoIGluc3RhbmNlIGNvbnN0cnVjdG9yLCBpbmNsdWRpbmcgVnVlLCBoYXMgYSB1bmlxdWVcbiAqIGNpZC4gVGhpcyBlbmFibGVzIHVzIHRvIGNyZWF0ZSB3cmFwcGVkIFwiY2hpbGRcbiAqIGNvbnN0cnVjdG9yc1wiIGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlIGFuZCBjYWNoZSB0aGVtLlxuICovXG5cbmV4cG9ydHMuY2lkID0gMFxudmFyIGNpZCA9IDFcblxuLyoqXG4gKiBDbGFzcyBpbmhlcml0YW5jZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbmRPcHRpb25zXG4gKi9cblxuZXhwb3J0cy5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xuICBleHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucyB8fCB7fVxuICB2YXIgU3VwZXIgPSB0aGlzXG4gIHZhciBpc0ZpcnN0RXh0ZW5kID0gU3VwZXIuY2lkID09PSAwXG4gIGlmIChpc0ZpcnN0RXh0ZW5kICYmIGV4dGVuZE9wdGlvbnMuX0N0b3IpIHtcbiAgICByZXR1cm4gZXh0ZW5kT3B0aW9ucy5fQ3RvclxuICB9XG4gIHZhciBuYW1lID0gZXh0ZW5kT3B0aW9ucy5uYW1lIHx8IFN1cGVyLm9wdGlvbnMubmFtZVxuICB2YXIgU3ViID0gY3JlYXRlQ2xhc3MobmFtZSB8fCAnVnVlQ29tcG9uZW50JylcbiAgU3ViLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKVxuICBTdWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViXG4gIFN1Yi5jaWQgPSBjaWQrK1xuICBTdWIub3B0aW9ucyA9IF8ubWVyZ2VPcHRpb25zKFxuICAgIFN1cGVyLm9wdGlvbnMsXG4gICAgZXh0ZW5kT3B0aW9uc1xuICApXG4gIFN1Ylsnc3VwZXInXSA9IFN1cGVyXG4gIC8vIGFsbG93IGZ1cnRoZXIgZXh0ZW5zaW9uXG4gIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmRcbiAgLy8gY3JlYXRlIGFzc2V0IHJlZ2lzdGVycywgc28gZXh0ZW5kZWQgY2xhc3Nlc1xuICAvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXG4gIGNvbmZpZy5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgU3ViW3R5cGVdID0gU3VwZXJbdHlwZV1cbiAgfSlcbiAgLy8gZW5hYmxlIHJlY3Vyc2l2ZSBzZWxmLWxvb2t1cFxuICBpZiAobmFtZSkge1xuICAgIFN1Yi5vcHRpb25zLmNvbXBvbmVudHNbbmFtZV0gPSBTdWJcbiAgfVxuICAvLyBjYWNoZSBjb25zdHJ1Y3RvclxuICBpZiAoaXNGaXJzdEV4dGVuZCkge1xuICAgIGV4dGVuZE9wdGlvbnMuX0N0b3IgPSBTdWJcbiAgfVxuICByZXR1cm4gU3ViXG59XG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBzdWItY2xhc3MgY29uc3RydWN0b3Igd2l0aCB0aGVcbiAqIGdpdmVuIG5hbWUuIFRoaXMgZ2l2ZXMgdXMgbXVjaCBuaWNlciBvdXRwdXQgd2hlblxuICogbG9nZ2luZyBpbnN0YW5jZXMgaW4gdGhlIGNvbnNvbGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUNsYXNzIChuYW1lKSB7XG4gIHJldHVybiBuZXcgRnVuY3Rpb24oXG4gICAgJ3JldHVybiBmdW5jdGlvbiAnICsgXy5jbGFzc2lmeShuYW1lKSArXG4gICAgJyAob3B0aW9ucykgeyB0aGlzLl9pbml0KG9wdGlvbnMpIH0nXG4gICkoKVxufVxuXG4vKipcbiAqIFBsdWdpbiBzeXN0ZW1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGx1Z2luXG4gKi9cblxuZXhwb3J0cy51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAocGx1Z2luLmluc3RhbGxlZCkge1xuICAgIHJldHVyblxuICB9XG4gIC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVyc1xuICB2YXIgYXJncyA9IF8udG9BcnJheShhcmd1bWVudHMsIDEpXG4gIGFyZ3MudW5zaGlmdCh0aGlzKVxuICBpZiAodHlwZW9mIHBsdWdpbi5pbnN0YWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKVxuICB9IGVsc2Uge1xuICAgIHBsdWdpbi5hcHBseShudWxsLCBhcmdzKVxuICB9XG4gIHBsdWdpbi5pbnN0YWxsZWQgPSB0cnVlXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogQXBwbHkgYSBnbG9iYWwgbWl4aW4gYnkgbWVyZ2luZyBpdCBpbnRvIHRoZSBkZWZhdWx0XG4gKiBvcHRpb25zLlxuICovXG5cbmV4cG9ydHMubWl4aW4gPSBmdW5jdGlvbiAobWl4aW4pIHtcbiAgdmFyIFZ1ZSA9IF8uVnVlXG4gIFZ1ZS5vcHRpb25zID0gXy5tZXJnZU9wdGlvbnMoVnVlLm9wdGlvbnMsIG1peGluKVxufVxuXG4vKipcbiAqIENyZWF0ZSBhc3NldCByZWdpc3RyYXRpb24gbWV0aG9kcyB3aXRoIHRoZSBmb2xsb3dpbmdcbiAqIHNpZ25hdHVyZTpcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAqIEBwYXJhbSB7Kn0gZGVmaW5pdGlvblxuICovXG5cbmNvbmZpZy5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gIGV4cG9ydHNbdHlwZV0gPSBmdW5jdGlvbiAoaWQsIGRlZmluaXRpb24pIHtcbiAgICBpZiAoIWRlZmluaXRpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChcbiAgICAgICAgdHlwZSA9PT0gJ2NvbXBvbmVudCcgJiZcbiAgICAgICAgXy5pc1BsYWluT2JqZWN0KGRlZmluaXRpb24pXG4gICAgICApIHtcbiAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gaWRcbiAgICAgICAgZGVmaW5pdGlvbiA9IF8uVnVlLmV4dGVuZChkZWZpbml0aW9uKVxuICAgICAgfVxuICAgICAgdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXSA9IGRlZmluaXRpb25cbiAgICAgIHJldHVybiBkZWZpbml0aW9uXG4gICAgfVxuICB9XG59KVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi91dGlsJylcbnZhciBjb21waWxlciA9IHJlcXVpcmUoJy4uL2NvbXBpbGVyJylcblxuLyoqXG4gKiBTZXQgaW5zdGFuY2UgdGFyZ2V0IGVsZW1lbnQgYW5kIGtpY2sgb2ZmIHRoZSBjb21waWxhdGlvblxuICogcHJvY2Vzcy4gVGhlIHBhc3NlZCBpbiBgZWxgIGNhbiBiZSBhIHNlbGVjdG9yIHN0cmluZywgYW5cbiAqIGV4aXN0aW5nIEVsZW1lbnQsIG9yIGEgRG9jdW1lbnRGcmFnbWVudCAoZm9yIGJsb2NrXG4gKiBpbnN0YW5jZXMpLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fHN0cmluZ30gZWxcbiAqIEBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLiRtb3VudCA9IGZ1bmN0aW9uIChlbCkge1xuICBpZiAodGhpcy5faXNDb21waWxlZCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgXy53YXJuKFxuICAgICAgJyRtb3VudCgpIHNob3VsZCBiZSBjYWxsZWQgb25seSBvbmNlLidcbiAgICApXG4gICAgcmV0dXJuXG4gIH1cbiAgZWwgPSBfLnF1ZXJ5KGVsKVxuICBpZiAoIWVsKSB7XG4gICAgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICB9XG4gIHRoaXMuX2NvbXBpbGUoZWwpXG4gIHRoaXMuX2luaXRET01Ib29rcygpXG4gIGlmIChfLmluRG9jKHRoaXMuJGVsKSkge1xuICAgIHRoaXMuX2NhbGxIb29rKCdhdHRhY2hlZCcpXG4gICAgcmVhZHkuY2FsbCh0aGlzKVxuICB9IGVsc2Uge1xuICAgIHRoaXMuJG9uY2UoJ2hvb2s6YXR0YWNoZWQnLCByZWFkeSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIE1hcmsgYW4gaW5zdGFuY2UgYXMgcmVhZHkuXG4gKi9cblxuZnVuY3Rpb24gcmVhZHkgKCkge1xuICB0aGlzLl9pc0F0dGFjaGVkID0gdHJ1ZVxuICB0aGlzLl9pc1JlYWR5ID0gdHJ1ZVxuICB0aGlzLl9jYWxsSG9vaygncmVhZHknKVxufVxuXG4vKipcbiAqIFRlYXJkb3duIHRoZSBpbnN0YW5jZSwgc2ltcGx5IGRlbGVnYXRlIHRvIHRoZSBpbnRlcm5hbFxuICogX2Rlc3Ryb3kuXG4gKi9cblxuZXhwb3J0cy4kZGVzdHJveSA9IGZ1bmN0aW9uIChyZW1vdmUsIGRlZmVyQ2xlYW51cCkge1xuICB0aGlzLl9kZXN0cm95KHJlbW92ZSwgZGVmZXJDbGVhbnVwKVxufVxuXG4vKipcbiAqIFBhcnRpYWxseSBjb21waWxlIGEgcGllY2Ugb2YgRE9NIGFuZCByZXR1cm4gYVxuICogZGVjb21waWxlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fSBlbFxuICogQHBhcmFtIHtWdWV9IFtob3N0XVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZXhwb3J0cy4kY29tcGlsZSA9IGZ1bmN0aW9uIChlbCwgaG9zdCwgc2NvcGUsIGZyYWcpIHtcbiAgcmV0dXJuIGNvbXBpbGVyLmNvbXBpbGUoZWwsIHRoaXMuJG9wdGlvbnMsIHRydWUpKFxuICAgIHRoaXMsIGVsLCBob3N0LCBzY29wZSwgZnJhZ1xuICApXG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4vdXRpbCcpXG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKVxuXG4vLyB3ZSBoYXZlIHR3byBzZXBhcmF0ZSBxdWV1ZXM6IG9uZSBmb3IgZGlyZWN0aXZlIHVwZGF0ZXNcbi8vIGFuZCBvbmUgZm9yIHVzZXIgd2F0Y2hlciByZWdpc3RlcmVkIHZpYSAkd2F0Y2goKS5cbi8vIHdlIHdhbnQgdG8gZ3VhcmFudGVlIGRpcmVjdGl2ZSB1cGRhdGVzIHRvIGJlIGNhbGxlZFxuLy8gYmVmb3JlIHVzZXIgd2F0Y2hlcnMgc28gdGhhdCB3aGVuIHVzZXIgd2F0Y2hlcnMgYXJlXG4vLyB0cmlnZ2VyZWQsIHRoZSBET00gd291bGQgaGF2ZSBhbHJlYWR5IGJlZW4gaW4gdXBkYXRlZFxuLy8gc3RhdGUuXG52YXIgcXVldWUgPSBbXVxudmFyIHVzZXJRdWV1ZSA9IFtdXG52YXIgaGFzID0ge31cbnZhciBjaXJjdWxhciA9IHt9XG52YXIgd2FpdGluZyA9IGZhbHNlXG52YXIgaW50ZXJuYWxRdWV1ZURlcGxldGVkID0gZmFsc2VcblxuLyoqXG4gKiBSZXNldCB0aGUgYmF0Y2hlcidzIHN0YXRlLlxuICovXG5cbmZ1bmN0aW9uIHJlc2V0QmF0Y2hlclN0YXRlICgpIHtcbiAgcXVldWUgPSBbXVxuICB1c2VyUXVldWUgPSBbXVxuICBoYXMgPSB7fVxuICBjaXJjdWxhciA9IHt9XG4gIHdhaXRpbmcgPSBpbnRlcm5hbFF1ZXVlRGVwbGV0ZWQgPSBmYWxzZVxufVxuXG4vKipcbiAqIEZsdXNoIGJvdGggcXVldWVzIGFuZCBydW4gdGhlIHdhdGNoZXJzLlxuICovXG5cbmZ1bmN0aW9uIGZsdXNoQmF0Y2hlclF1ZXVlICgpIHtcbiAgcnVuQmF0Y2hlclF1ZXVlKHF1ZXVlKVxuICBpbnRlcm5hbFF1ZXVlRGVwbGV0ZWQgPSB0cnVlXG4gIHJ1bkJhdGNoZXJRdWV1ZSh1c2VyUXVldWUpXG4gIC8vIGRldiB0b29sIGhvb2tcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKF8uaW5Ccm93c2VyICYmIHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fKSB7XG4gICAgICB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5lbWl0KCdmbHVzaCcpXG4gICAgfVxuICB9XG4gIHJlc2V0QmF0Y2hlclN0YXRlKClcbn1cblxuLyoqXG4gKiBSdW4gdGhlIHdhdGNoZXJzIGluIGEgc2luZ2xlIHF1ZXVlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHF1ZXVlXG4gKi9cblxuZnVuY3Rpb24gcnVuQmF0Y2hlclF1ZXVlIChxdWV1ZSkge1xuICAvLyBkbyBub3QgY2FjaGUgbGVuZ3RoIGJlY2F1c2UgbW9yZSB3YXRjaGVycyBtaWdodCBiZSBwdXNoZWRcbiAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgd2F0Y2hlciA9IHF1ZXVlW2ldXG4gICAgdmFyIGlkID0gd2F0Y2hlci5pZFxuICAgIGhhc1tpZF0gPSBudWxsXG4gICAgd2F0Y2hlci5ydW4oKVxuICAgIC8vIGluIGRldiBidWlsZCwgY2hlY2sgYW5kIHN0b3AgY2lyY3VsYXIgdXBkYXRlcy5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBoYXNbaWRdICE9IG51bGwpIHtcbiAgICAgIGNpcmN1bGFyW2lkXSA9IChjaXJjdWxhcltpZF0gfHwgMCkgKyAxXG4gICAgICBpZiAoY2lyY3VsYXJbaWRdID4gY29uZmlnLl9tYXhVcGRhdGVDb3VudCkge1xuICAgICAgICBxdWV1ZS5zcGxpY2UoaGFzW2lkXSwgMSlcbiAgICAgICAgXy53YXJuKFxuICAgICAgICAgICdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgZm9yIHdhdGNoZXIgJyArXG4gICAgICAgICAgJ3dpdGggZXhwcmVzc2lvbjogJyArIHdhdGNoZXIuZXhwcmVzc2lvblxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUHVzaCBhIHdhdGNoZXIgaW50byB0aGUgd2F0Y2hlciBxdWV1ZS5cbiAqIEpvYnMgd2l0aCBkdXBsaWNhdGUgSURzIHdpbGwgYmUgc2tpcHBlZCB1bmxlc3MgaXQnc1xuICogcHVzaGVkIHdoZW4gdGhlIHF1ZXVlIGlzIGJlaW5nIGZsdXNoZWQuXG4gKlxuICogQHBhcmFtIHtXYXRjaGVyfSB3YXRjaGVyXG4gKiAgIHByb3BlcnRpZXM6XG4gKiAgIC0ge051bWJlcn0gaWRcbiAqICAgLSB7RnVuY3Rpb259IHJ1blxuICovXG5cbmV4cG9ydHMucHVzaCA9IGZ1bmN0aW9uICh3YXRjaGVyKSB7XG4gIHZhciBpZCA9IHdhdGNoZXIuaWRcbiAgaWYgKGhhc1tpZF0gPT0gbnVsbCkge1xuICAgIC8vIGlmIGFuIGludGVybmFsIHdhdGNoZXIgaXMgcHVzaGVkLCBidXQgdGhlIGludGVybmFsXG4gICAgLy8gcXVldWUgaXMgYWxyZWFkeSBkZXBsZXRlZCwgd2UgcnVuIGl0IGltbWVkaWF0ZWx5LlxuICAgIGlmIChpbnRlcm5hbFF1ZXVlRGVwbGV0ZWQgJiYgIXdhdGNoZXIudXNlcikge1xuICAgICAgd2F0Y2hlci5ydW4oKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIHB1c2ggd2F0Y2hlciBpbnRvIGFwcHJvcHJpYXRlIHF1ZXVlXG4gICAgdmFyIHEgPSB3YXRjaGVyLnVzZXIgPyB1c2VyUXVldWUgOiBxdWV1ZVxuICAgIGhhc1tpZF0gPSBxLmxlbmd0aFxuICAgIHEucHVzaCh3YXRjaGVyKVxuICAgIC8vIHF1ZXVlIHRoZSBmbHVzaFxuICAgIGlmICghd2FpdGluZykge1xuICAgICAgd2FpdGluZyA9IHRydWVcbiAgICAgIF8ubmV4dFRpY2soZmx1c2hCYXRjaGVyUXVldWUpXG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIEEgZG91Ymx5IGxpbmtlZCBsaXN0LWJhc2VkIExlYXN0IFJlY2VudGx5IFVzZWQgKExSVSlcbiAqIGNhY2hlLiBXaWxsIGtlZXAgbW9zdCByZWNlbnRseSB1c2VkIGl0ZW1zIHdoaWxlXG4gKiBkaXNjYXJkaW5nIGxlYXN0IHJlY2VudGx5IHVzZWQgaXRlbXMgd2hlbiBpdHMgbGltaXQgaXNcbiAqIHJlYWNoZWQuIFRoaXMgaXMgYSBiYXJlLWJvbmUgdmVyc2lvbiBvZlxuICogUmFzbXVzIEFuZGVyc3NvbidzIGpzLWxydTpcbiAqXG4gKiAgIGh0dHBzOi8vZ2l0aHViLmNvbS9yc21zL2pzLWxydVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBsaW1pdFxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuZnVuY3Rpb24gQ2FjaGUgKGxpbWl0KSB7XG4gIHRoaXMuc2l6ZSA9IDBcbiAgdGhpcy5saW1pdCA9IGxpbWl0XG4gIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IHVuZGVmaW5lZFxuICB0aGlzLl9rZXltYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpXG59XG5cbnZhciBwID0gQ2FjaGUucHJvdG90eXBlXG5cbi8qKlxuICogUHV0IDx2YWx1ZT4gaW50byB0aGUgY2FjaGUgYXNzb2NpYXRlZCB3aXRoIDxrZXk+LlxuICogUmV0dXJucyB0aGUgZW50cnkgd2hpY2ggd2FzIHJlbW92ZWQgdG8gbWFrZSByb29tIGZvclxuICogdGhlIG5ldyBlbnRyeS4gT3RoZXJ3aXNlIHVuZGVmaW5lZCBpcyByZXR1cm5lZC5cbiAqIChpLmUuIGlmIHRoZXJlIHdhcyBlbm91Z2ggcm9vbSBhbHJlYWR5KS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtFbnRyeXx1bmRlZmluZWR9XG4gKi9cblxucC5wdXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICB2YXIgZW50cnkgPSB7XG4gICAga2V5OiBrZXksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH1cbiAgdGhpcy5fa2V5bWFwW2tleV0gPSBlbnRyeVxuICBpZiAodGhpcy50YWlsKSB7XG4gICAgdGhpcy50YWlsLm5ld2VyID0gZW50cnlcbiAgICBlbnRyeS5vbGRlciA9IHRoaXMudGFpbFxuICB9IGVsc2Uge1xuICAgIHRoaXMuaGVhZCA9IGVudHJ5XG4gIH1cbiAgdGhpcy50YWlsID0gZW50cnlcbiAgaWYgKHRoaXMuc2l6ZSA9PT0gdGhpcy5saW1pdCkge1xuICAgIHJldHVybiB0aGlzLnNoaWZ0KClcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnNpemUrK1xuICB9XG59XG5cbi8qKlxuICogUHVyZ2UgdGhlIGxlYXN0IHJlY2VudGx5IHVzZWQgKG9sZGVzdCkgZW50cnkgZnJvbSB0aGVcbiAqIGNhY2hlLiBSZXR1cm5zIHRoZSByZW1vdmVkIGVudHJ5IG9yIHVuZGVmaW5lZCBpZiB0aGVcbiAqIGNhY2hlIHdhcyBlbXB0eS5cbiAqL1xuXG5wLnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZW50cnkgPSB0aGlzLmhlYWRcbiAgaWYgKGVudHJ5KSB7XG4gICAgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5ld2VyXG4gICAgdGhpcy5oZWFkLm9sZGVyID0gdW5kZWZpbmVkXG4gICAgZW50cnkubmV3ZXIgPSBlbnRyeS5vbGRlciA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX2tleW1hcFtlbnRyeS5rZXldID0gdW5kZWZpbmVkXG4gIH1cbiAgcmV0dXJuIGVudHJ5XG59XG5cbi8qKlxuICogR2V0IGFuZCByZWdpc3RlciByZWNlbnQgdXNlIG9mIDxrZXk+LiBSZXR1cm5zIHRoZSB2YWx1ZVxuICogYXNzb2NpYXRlZCB3aXRoIDxrZXk+IG9yIHVuZGVmaW5lZCBpZiBub3QgaW4gY2FjaGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtCb29sZWFufSByZXR1cm5FbnRyeVxuICogQHJldHVybiB7RW50cnl8Kn1cbiAqL1xuXG5wLmdldCA9IGZ1bmN0aW9uIChrZXksIHJldHVybkVudHJ5KSB7XG4gIHZhciBlbnRyeSA9IHRoaXMuX2tleW1hcFtrZXldXG4gIGlmIChlbnRyeSA9PT0gdW5kZWZpbmVkKSByZXR1cm5cbiAgaWYgKGVudHJ5ID09PSB0aGlzLnRhaWwpIHtcbiAgICByZXR1cm4gcmV0dXJuRW50cnlcbiAgICAgID8gZW50cnlcbiAgICAgIDogZW50cnkudmFsdWVcbiAgfVxuICAvLyBIRUFELS0tLS0tLS0tLS0tLS1UQUlMXG4gIC8vICAgPC5vbGRlciAgIC5uZXdlcj5cbiAgLy8gIDwtLS0gYWRkIGRpcmVjdGlvbiAtLVxuICAvLyAgIEEgIEIgIEMgIDxEPiAgRVxuICBpZiAoZW50cnkubmV3ZXIpIHtcbiAgICBpZiAoZW50cnkgPT09IHRoaXMuaGVhZCkge1xuICAgICAgdGhpcy5oZWFkID0gZW50cnkubmV3ZXJcbiAgICB9XG4gICAgZW50cnkubmV3ZXIub2xkZXIgPSBlbnRyeS5vbGRlciAvLyBDIDwtLSBFLlxuICB9XG4gIGlmIChlbnRyeS5vbGRlcikge1xuICAgIGVudHJ5Lm9sZGVyLm5ld2VyID0gZW50cnkubmV3ZXIgLy8gQy4gLS0+IEVcbiAgfVxuICBlbnRyeS5uZXdlciA9IHVuZGVmaW5lZCAvLyBEIC0teFxuICBlbnRyeS5vbGRlciA9IHRoaXMudGFpbCAvLyBELiAtLT4gRVxuICBpZiAodGhpcy50YWlsKSB7XG4gICAgdGhpcy50YWlsLm5ld2VyID0gZW50cnkgLy8gRS4gPC0tIERcbiAgfVxuICB0aGlzLnRhaWwgPSBlbnRyeVxuICByZXR1cm4gcmV0dXJuRW50cnlcbiAgICA/IGVudHJ5XG4gICAgOiBlbnRyeS52YWx1ZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENhY2hlXG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWwnKVxudmFyIGRpclBhcnNlciA9IHJlcXVpcmUoJy4uL3BhcnNlcnMvZGlyZWN0aXZlJylcbnZhciBwcm9wRGVmID0gcmVxdWlyZSgnLi4vZGlyZWN0aXZlcy9pbnRlcm5hbC9wcm9wJylcbnZhciBwcm9wQmluZGluZ01vZGVzID0gcmVxdWlyZSgnLi4vY29uZmlnJykuX3Byb3BCaW5kaW5nTW9kZXNcbnZhciBlbXB0eSA9IHt9XG5cbi8vIHJlZ2V4ZXNcbnZhciBpZGVudFJFID0gcmVxdWlyZSgnLi4vcGFyc2Vycy9wYXRoJykuaWRlbnRSRVxudmFyIHNldHRhYmxlUGF0aFJFID0gL15bQS1aYS16XyRdW1xcdyRdKihcXC5bQS1aYS16XyRdW1xcdyRdKnxcXFtbXlxcW1xcXV0rXFxdKSokL1xuXG4vKipcbiAqIENvbXBpbGUgcHJvcHMgb24gYSByb290IGVsZW1lbnQgYW5kIHJldHVyblxuICogYSBwcm9wcyBsaW5rIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fSBlbFxuICogQHBhcmFtIHtBcnJheX0gcHJvcE9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBwcm9wc0xpbmtGblxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29tcGlsZVByb3BzIChlbCwgcHJvcE9wdGlvbnMpIHtcbiAgdmFyIHByb3BzID0gW11cbiAgdmFyIG5hbWVzID0gT2JqZWN0LmtleXMocHJvcE9wdGlvbnMpXG4gIHZhciBpID0gbmFtZXMubGVuZ3RoXG4gIHZhciBvcHRpb25zLCBuYW1lLCBhdHRyLCB2YWx1ZSwgcGF0aCwgcGFyc2VkLCBwcm9wLCBpc1RpdGxlQmluZGluZ1xuICB3aGlsZSAoaS0tKSB7XG4gICAgbmFtZSA9IG5hbWVzW2ldXG4gICAgb3B0aW9ucyA9IHByb3BPcHRpb25zW25hbWVdIHx8IGVtcHR5XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBuYW1lID09PSAnJGRhdGEnKSB7XG4gICAgICBfLndhcm4oJ0RvIG5vdCB1c2UgJGRhdGEgYXMgcHJvcC4nKVxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICAvLyBwcm9wcyBjb3VsZCBjb250YWluIGRhc2hlcywgd2hpY2ggd2lsbCBiZVxuICAgIC8vIGludGVycHJldGVkIGFzIG1pbnVzIGNhbGN1bGF0aW9ucyBieSB0aGUgcGFyc2VyXG4gICAgLy8gc28gd2UgbmVlZCB0byBjYW1lbGl6ZSB0aGUgcGF0aCBoZXJlXG4gICAgcGF0aCA9IF8uY2FtZWxpemUobmFtZSlcbiAgICBpZiAoIWlkZW50UkUudGVzdChwYXRoKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBfLndhcm4oXG4gICAgICAgICdJbnZhbGlkIHByb3Aga2V5OiBcIicgKyBuYW1lICsgJ1wiLiBQcm9wIGtleXMgJyArXG4gICAgICAgICdtdXN0IGJlIHZhbGlkIGlkZW50aWZpZXJzLidcbiAgICAgIClcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgcHJvcCA9IHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBwYXRoOiBwYXRoLFxuICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgIG1vZGU6IHByb3BCaW5kaW5nTW9kZXMuT05FX1dBWVxuICAgIH1cblxuICAgIC8vIElFIHRpdGxlIGlzc3Vlc1xuICAgIGlzVGl0bGVCaW5kaW5nID0gZmFsc2VcbiAgICBpZiAobmFtZSA9PT0gJ3RpdGxlJyAmJiAoZWwuZ2V0QXR0cmlidXRlKCc6dGl0bGUnKSB8fCBlbC5nZXRBdHRyaWJ1dGUoJ3YtYmluZDp0aXRsZScpKSkge1xuICAgICAgaXNUaXRsZUJpbmRpbmcgPSB0cnVlXG4gICAgfVxuXG4gICAgLy8gZmlyc3QgY2hlY2sgbGl0ZXJhbCB2ZXJzaW9uXG4gICAgYXR0ciA9IF8uaHlwaGVuYXRlKG5hbWUpXG4gICAgdmFsdWUgPSBwcm9wLnJhdyA9IF8uYXR0cihlbCwgYXR0cilcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgaXNUaXRsZUJpbmRpbmcpIHtcbiAgICAgIC8vIHRoZW4gY2hlY2sgZHluYW1pYyB2ZXJzaW9uXG4gICAgICBpZiAoKHZhbHVlID0gXy5nZXRCaW5kQXR0cihlbCwgYXR0cikpID09PSBudWxsKSB7XG4gICAgICAgIGlmICgodmFsdWUgPSBfLmdldEJpbmRBdHRyKGVsLCBhdHRyICsgJy5zeW5jJykpICE9PSBudWxsKSB7XG4gICAgICAgICAgcHJvcC5tb2RlID0gcHJvcEJpbmRpbmdNb2Rlcy5UV09fV0FZXG4gICAgICAgIH0gZWxzZSBpZiAoKHZhbHVlID0gXy5nZXRCaW5kQXR0cihlbCwgYXR0ciArICcub25jZScpKSAhPT0gbnVsbCkge1xuICAgICAgICAgIHByb3AubW9kZSA9IHByb3BCaW5kaW5nTW9kZXMuT05FX1RJTUVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJvcC5yYXcgPSB2YWx1ZVxuICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIHBhcnNlZCA9IGRpclBhcnNlci5wYXJzZSh2YWx1ZSlcbiAgICAgICAgdmFsdWUgPSBwYXJzZWQuZXhwcmVzc2lvblxuICAgICAgICBwcm9wLmZpbHRlcnMgPSBwYXJzZWQuZmlsdGVyc1xuICAgICAgICAvLyBjaGVjayBiaW5kaW5nIHR5cGVcbiAgICAgICAgaWYgKF8uaXNMaXRlcmFsKHZhbHVlKSkge1xuICAgICAgICAgIC8vIGZvciBleHByZXNzaW9ucyBjb250YWluaW5nIGxpdGVyYWwgbnVtYmVycyBhbmRcbiAgICAgICAgICAvLyBib29sZWFucywgdGhlcmUncyBubyBuZWVkIHRvIHNldHVwIGEgcHJvcCBiaW5kaW5nLFxuICAgICAgICAgIC8vIHNvIHdlIGNhbiBvcHRpbWl6ZSB0aGVtIGFzIGEgb25lLXRpbWUgc2V0LlxuICAgICAgICAgIHByb3Aub3B0aW1pemVkTGl0ZXJhbCA9IHRydWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wLmR5bmFtaWMgPSB0cnVlXG4gICAgICAgICAgLy8gY2hlY2sgbm9uLXNldHRhYmxlIHBhdGggZm9yIHR3by13YXkgYmluZGluZ3NcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICBwcm9wLm1vZGUgPT09IHByb3BCaW5kaW5nTW9kZXMuVFdPX1dBWSAmJlxuICAgICAgICAgICAgICAhc2V0dGFibGVQYXRoUkUudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHByb3AubW9kZSA9IHByb3BCaW5kaW5nTW9kZXMuT05FX1dBWVxuICAgICAgICAgICAgXy53YXJuKFxuICAgICAgICAgICAgICAnQ2Fubm90IGJpbmQgdHdvLXdheSBwcm9wIHdpdGggbm9uLXNldHRhYmxlICcgK1xuICAgICAgICAgICAgICAncGFyZW50IHBhdGg6ICcgKyB2YWx1ZVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcm9wLnBhcmVudFBhdGggPSB2YWx1ZVxuXG4gICAgICAgIC8vIHdhcm4gcmVxdWlyZWQgdHdvLXdheVxuICAgICAgICBpZiAoXG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgIG9wdGlvbnMudHdvV2F5ICYmXG4gICAgICAgICAgcHJvcC5tb2RlICE9PSBwcm9wQmluZGluZ01vZGVzLlRXT19XQVlcbiAgICAgICAgKSB7XG4gICAgICAgICAgXy53YXJuKFxuICAgICAgICAgICAgJ1Byb3AgXCInICsgbmFtZSArICdcIiBleHBlY3RzIGEgdHdvLXdheSBiaW5kaW5nIHR5cGUuJ1xuICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMucmVxdWlyZWQpIHtcbiAgICAgICAgLy8gd2FybiBtaXNzaW5nIHJlcXVpcmVkXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgXy53YXJuKFxuICAgICAgICAgICdNaXNzaW5nIHJlcXVpcmVkIHByb3A6ICcgKyBuYW1lXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwdXNoIHByb3BcbiAgICBwcm9wcy5wdXNoKHByb3ApXG4gIH1cbiAgcmV0dXJuIG1ha2VQcm9wc0xpbmtGbihwcm9wcylcbn1cblxuLyoqXG4gKiBCdWlsZCBhIGZ1bmN0aW9uIHRoYXQgYXBwbGllcyBwcm9wcyB0byBhIHZtLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gcHJvcHNMaW5rRm5cbiAqL1xuXG5mdW5jdGlvbiBtYWtlUHJvcHNMaW5rRm4gKHByb3BzKSB7XG4gIHJldHVybiBmdW5jdGlvbiBwcm9wc0xpbmtGbiAodm0sIHNjb3BlKSB7XG4gICAgLy8gc3RvcmUgcmVzb2x2ZWQgcHJvcHMgaW5mb1xuICAgIHZtLl9wcm9wcyA9IHt9XG4gICAgdmFyIGkgPSBwcm9wcy5sZW5ndGhcbiAgICB2YXIgcHJvcCwgcGF0aCwgb3B0aW9ucywgdmFsdWUsIHJhd1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHByb3AgPSBwcm9wc1tpXVxuICAgICAgcmF3ID0gcHJvcC5yYXdcbiAgICAgIHBhdGggPSBwcm9wLnBhdGhcbiAgICAgIG9wdGlvbnMgPSBwcm9wLm9wdGlvbnNcbiAgICAgIHZtLl9wcm9wc1twYXRoXSA9IHByb3BcbiAgICAgIGlmIChyYXcgPT09IG51bGwpIHtcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBhYnNlbnQgcHJvcFxuICAgICAgICBfLmluaXRQcm9wKHZtLCBwcm9wLCBnZXREZWZhdWx0KHZtLCBvcHRpb25zKSlcbiAgICAgIH0gZWxzZSBpZiAocHJvcC5keW5hbWljKSB7XG4gICAgICAgIC8vIGR5bmFtaWMgcHJvcFxuICAgICAgICBpZiAodm0uX2NvbnRleHQpIHtcbiAgICAgICAgICBpZiAocHJvcC5tb2RlID09PSBwcm9wQmluZGluZ01vZGVzLk9ORV9USU1FKSB7XG4gICAgICAgICAgICAvLyBvbmUgdGltZSBiaW5kaW5nXG4gICAgICAgICAgICB2YWx1ZSA9IChzY29wZSB8fCB2bS5fY29udGV4dCkuJGdldChwcm9wLnBhcmVudFBhdGgpXG4gICAgICAgICAgICBfLmluaXRQcm9wKHZtLCBwcm9wLCB2YWx1ZSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZHluYW1pYyBiaW5kaW5nXG4gICAgICAgICAgICB2bS5fYmluZERpcih7XG4gICAgICAgICAgICAgIG5hbWU6ICdwcm9wJyxcbiAgICAgICAgICAgICAgZGVmOiBwcm9wRGVmLFxuICAgICAgICAgICAgICBwcm9wOiBwcm9wXG4gICAgICAgICAgICB9LCBudWxsLCBudWxsLCBzY29wZSkgLy8gZWwsIGhvc3QsIHNjb3BlXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgXy53YXJuKFxuICAgICAgICAgICAgJ0Nhbm5vdCBiaW5kIGR5bmFtaWMgcHJvcCBvbiBhIHJvb3QgaW5zdGFuY2UnICtcbiAgICAgICAgICAgICcgd2l0aCBubyBwYXJlbnQ6ICcgKyBwcm9wLm5hbWUgKyAnPVwiJyArXG4gICAgICAgICAgICByYXcgKyAnXCInXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHByb3Aub3B0aW1pemVkTGl0ZXJhbCkge1xuICAgICAgICAvLyBvcHRpbWl6ZWQgbGl0ZXJhbCwgY2FzdCBpdCBhbmQganVzdCBzZXQgb25jZVxuICAgICAgICByYXcgPSBfLnN0cmlwUXVvdGVzKHJhdylcbiAgICAgICAgdmFsdWUgPSBfLnRvQm9vbGVhbihfLnRvTnVtYmVyKHJhdykpXG4gICAgICAgIF8uaW5pdFByb3Aodm0sIHByb3AsIHZhbHVlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc3RyaW5nIGxpdGVyYWwsIGJ1dCB3ZSBuZWVkIHRvIGNhdGVyIGZvclxuICAgICAgICAvLyBCb29sZWFuIHByb3BzIHdpdGggbm8gdmFsdWVcbiAgICAgICAgdmFsdWUgPSBvcHRpb25zLnR5cGUgPT09IEJvb2xlYW4gJiYgcmF3ID09PSAnJ1xuICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgIDogcmF3XG4gICAgICAgIF8uaW5pdFByb3Aodm0sIHByb3AsIHZhbHVlKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHByb3AuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7Kn1cbiAqL1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0ICh2bSwgb3B0aW9ucykge1xuICAvLyBubyBkZWZhdWx0LCByZXR1cm4gdW5kZWZpbmVkXG4gIGlmICghb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnZGVmYXVsdCcpKSB7XG4gICAgLy8gYWJzZW50IGJvb2xlYW4gdmFsdWUgZGVmYXVsdHMgdG8gZmFsc2VcbiAgICByZXR1cm4gb3B0aW9ucy50eXBlID09PSBCb29sZWFuXG4gICAgICA/IGZhbHNlXG4gICAgICA6IHVuZGVmaW5lZFxuICB9XG4gIHZhciBkZWYgPSBvcHRpb25zLmRlZmF1bHRcbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1mYWN0b3J5IGRlZmF1bHRzIGZvciBPYmplY3QgJiBBcnJheVxuICBpZiAoXy5pc09iamVjdChkZWYpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBfLndhcm4oXG4gICAgICAnT2JqZWN0L0FycmF5IGFzIGRlZmF1bHQgcHJvcCB2YWx1ZXMgd2lsbCBiZSBzaGFyZWQgJyArXG4gICAgICAnYWNyb3NzIG11bHRpcGxlIGluc3RhbmNlcy4gVXNlIGEgZmFjdG9yeSBmdW5jdGlvbiAnICtcbiAgICAgICd0byByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUgaW5zdGVhZC4nXG4gICAgKVxuICB9XG4gIC8vIGNhbGwgZmFjdG9yeSBmdW5jdGlvbiBmb3Igbm9uLUZ1bmN0aW9uIHR5cGVzXG4gIHJldHVybiB0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nICYmIG9wdGlvbnMudHlwZSAhPT0gRnVuY3Rpb25cbiAgICA/IGRlZi5jYWxsKHZtKVxuICAgIDogZGVmXG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWwnKVxudmFyIHB1YmxpY0RpcmVjdGl2ZXMgPSByZXF1aXJlKCcuLi9kaXJlY3RpdmVzL3B1YmxpYycpXG52YXIgaW50ZXJuYWxEaXJlY3RpdmVzID0gcmVxdWlyZSgnLi4vZGlyZWN0aXZlcy9pbnRlcm5hbCcpXG52YXIgY29tcGlsZVByb3BzID0gcmVxdWlyZSgnLi9jb21waWxlLXByb3BzJylcbnZhciB0ZXh0UGFyc2VyID0gcmVxdWlyZSgnLi4vcGFyc2Vycy90ZXh0JylcbnZhciBkaXJQYXJzZXIgPSByZXF1aXJlKCcuLi9wYXJzZXJzL2RpcmVjdGl2ZScpXG52YXIgdGVtcGxhdGVQYXJzZXIgPSByZXF1aXJlKCcuLi9wYXJzZXJzL3RlbXBsYXRlJylcbnZhciByZXNvbHZlQXNzZXQgPSBfLnJlc29sdmVBc3NldFxuXG4vLyBzcGVjaWFsIGJpbmRpbmcgcHJlZml4ZXNcbnZhciBiaW5kUkUgPSAvXnYtYmluZDp8XjovXG52YXIgb25SRSA9IC9edi1vbjp8XkAvXG52YXIgYXJnUkUgPSAvOiguKikkL1xudmFyIG1vZGlmaWVyUkUgPSAvXFwuW15cXC5dKy9nXG52YXIgdHJhbnNpdGlvblJFID0gL14odi1iaW5kOnw6KT90cmFuc2l0aW9uJC9cblxuLy8gdGVybWluYWwgZGlyZWN0aXZlc1xudmFyIHRlcm1pbmFsRGlyZWN0aXZlcyA9IFtcbiAgJ2ZvcicsXG4gICdpZidcbl1cblxuLy8gZGVmYXVsdCBkaXJlY3RpdmUgcHJpb3JpdHlcbnZhciBERUZBVUxUX1BSSU9SSVRZID0gMTAwMFxuXG4vKipcbiAqIENvbXBpbGUgYSB0ZW1wbGF0ZSBhbmQgcmV0dXJuIGEgcmV1c2FibGUgY29tcG9zaXRlIGxpbmtcbiAqIGZ1bmN0aW9uLCB3aGljaCByZWN1cnNpdmVseSBjb250YWlucyBtb3JlIGxpbmsgZnVuY3Rpb25zXG4gKiBpbnNpZGUuIFRoaXMgdG9wIGxldmVsIGNvbXBpbGUgZnVuY3Rpb24gd291bGQgbm9ybWFsbHlcbiAqIGJlIGNhbGxlZCBvbiBpbnN0YW5jZSByb290IG5vZGVzLCBidXQgY2FuIGFsc28gYmUgdXNlZFxuICogZm9yIHBhcnRpYWwgY29tcGlsYXRpb24gaWYgdGhlIHBhcnRpYWwgYXJndW1lbnQgaXMgdHJ1ZS5cbiAqXG4gKiBUaGUgcmV0dXJuZWQgY29tcG9zaXRlIGxpbmsgZnVuY3Rpb24sIHdoZW4gY2FsbGVkLCB3aWxsXG4gKiByZXR1cm4gYW4gdW5saW5rIGZ1bmN0aW9uIHRoYXQgdGVhcnNkb3duIGFsbCBkaXJlY3RpdmVzXG4gKiBjcmVhdGVkIGR1cmluZyB0aGUgbGlua2luZyBwaGFzZS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHBhcnRpYWxcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmV4cG9ydHMuY29tcGlsZSA9IGZ1bmN0aW9uIChlbCwgb3B0aW9ucywgcGFydGlhbCkge1xuICAvLyBsaW5rIGZ1bmN0aW9uIGZvciB0aGUgbm9kZSBpdHNlbGYuXG4gIHZhciBub2RlTGlua0ZuID0gcGFydGlhbCB8fCAhb3B0aW9ucy5fYXNDb21wb25lbnRcbiAgICA/IGNvbXBpbGVOb2RlKGVsLCBvcHRpb25zKVxuICAgIDogbnVsbFxuICAvLyBsaW5rIGZ1bmN0aW9uIGZvciB0aGUgY2hpbGROb2Rlc1xuICB2YXIgY2hpbGRMaW5rRm4gPVxuICAgICEobm9kZUxpbmtGbiAmJiBub2RlTGlua0ZuLnRlcm1pbmFsKSAmJlxuICAgIGVsLnRhZ05hbWUgIT09ICdTQ1JJUFQnICYmXG4gICAgZWwuaGFzQ2hpbGROb2RlcygpXG4gICAgICA/IGNvbXBpbGVOb2RlTGlzdChlbC5jaGlsZE5vZGVzLCBvcHRpb25zKVxuICAgICAgOiBudWxsXG5cbiAgLyoqXG4gICAqIEEgY29tcG9zaXRlIGxpbmtlciBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gYSBhbHJlYWR5XG4gICAqIGNvbXBpbGVkIHBpZWNlIG9mIERPTSwgd2hpY2ggaW5zdGFudGlhdGVzIGFsbCBkaXJlY3RpdmVcbiAgICogaW5zdGFuY2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge1Z1ZX0gdm1cbiAgICogQHBhcmFtIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9IGVsXG4gICAqIEBwYXJhbSB7VnVlfSBbaG9zdF0gLSBob3N0IHZtIG9mIHRyYW5zY2x1ZGVkIGNvbnRlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV0gLSB2LWZvciBzY29wZVxuICAgKiBAcGFyYW0ge0ZyYWdtZW50fSBbZnJhZ10gLSBsaW5rIGNvbnRleHQgZnJhZ21lbnRcbiAgICogQHJldHVybiB7RnVuY3Rpb258dW5kZWZpbmVkfVxuICAgKi9cblxuICByZXR1cm4gZnVuY3Rpb24gY29tcG9zaXRlTGlua0ZuICh2bSwgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKSB7XG4gICAgLy8gY2FjaGUgY2hpbGROb2RlcyBiZWZvcmUgbGlua2luZyBwYXJlbnQsIGZpeCAjNjU3XG4gICAgdmFyIGNoaWxkTm9kZXMgPSBfLnRvQXJyYXkoZWwuY2hpbGROb2RlcylcbiAgICAvLyBsaW5rXG4gICAgdmFyIGRpcnMgPSBsaW5rQW5kQ2FwdHVyZShmdW5jdGlvbiBjb21wb3NpdGVMaW5rQ2FwdHVyZXIgKCkge1xuICAgICAgaWYgKG5vZGVMaW5rRm4pIG5vZGVMaW5rRm4odm0sIGVsLCBob3N0LCBzY29wZSwgZnJhZylcbiAgICAgIGlmIChjaGlsZExpbmtGbikgY2hpbGRMaW5rRm4odm0sIGNoaWxkTm9kZXMsIGhvc3QsIHNjb3BlLCBmcmFnKVxuICAgIH0sIHZtKVxuICAgIHJldHVybiBtYWtlVW5saW5rRm4odm0sIGRpcnMpXG4gIH1cbn1cblxuLyoqXG4gKiBBcHBseSBhIGxpbmtlciB0byBhIHZtL2VsZW1lbnQgcGFpciBhbmQgY2FwdHVyZSB0aGVcbiAqIGRpcmVjdGl2ZXMgY3JlYXRlZCBkdXJpbmcgdGhlIHByb2Nlc3MuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbGlua2VyXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqL1xuXG5mdW5jdGlvbiBsaW5rQW5kQ2FwdHVyZSAobGlua2VyLCB2bSkge1xuICB2YXIgb3JpZ2luYWxEaXJDb3VudCA9IHZtLl9kaXJlY3RpdmVzLmxlbmd0aFxuICBsaW5rZXIoKVxuICB2YXIgZGlycyA9IHZtLl9kaXJlY3RpdmVzLnNsaWNlKG9yaWdpbmFsRGlyQ291bnQpXG4gIGRpcnMuc29ydChkaXJlY3RpdmVDb21wYXJhdG9yKVxuICBmb3IgKHZhciBpID0gMCwgbCA9IGRpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZGlyc1tpXS5fYmluZCgpXG4gIH1cbiAgcmV0dXJuIGRpcnNcbn1cblxuLyoqXG4gKiBEaXJlY3RpdmUgcHJpb3JpdHkgc29ydCBjb21wYXJhdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBiXG4gKi9cblxuZnVuY3Rpb24gZGlyZWN0aXZlQ29tcGFyYXRvciAoYSwgYikge1xuICBhID0gYS5kZXNjcmlwdG9yLmRlZi5wcmlvcml0eSB8fCBERUZBVUxUX1BSSU9SSVRZXG4gIGIgPSBiLmRlc2NyaXB0b3IuZGVmLnByaW9yaXR5IHx8IERFRkFVTFRfUFJJT1JJVFlcbiAgcmV0dXJuIGEgPiBiID8gLTEgOiBhID09PSBiID8gMCA6IDFcbn1cblxuLyoqXG4gKiBMaW5rZXIgZnVuY3Rpb25zIHJldHVybiBhbiB1bmxpbmsgZnVuY3Rpb24gdGhhdFxuICogdGVhcnNkb3duIGFsbCBkaXJlY3RpdmVzIGluc3RhbmNlcyBnZW5lcmF0ZWQgZHVyaW5nXG4gKiB0aGUgcHJvY2Vzcy5cbiAqXG4gKiBXZSBjcmVhdGUgdW5saW5rIGZ1bmN0aW9ucyB3aXRoIG9ubHkgdGhlIG5lY2Vzc2FyeVxuICogaW5mb3JtYXRpb24gdG8gYXZvaWQgcmV0YWluaW5nIGFkZGl0aW9uYWwgY2xvc3VyZXMuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0FycmF5fSBkaXJzXG4gKiBAcGFyYW0ge1Z1ZX0gW2NvbnRleHRdXG4gKiBAcGFyYW0ge0FycmF5fSBbY29udGV4dERpcnNdXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5mdW5jdGlvbiBtYWtlVW5saW5rRm4gKHZtLCBkaXJzLCBjb250ZXh0LCBjb250ZXh0RGlycykge1xuICByZXR1cm4gZnVuY3Rpb24gdW5saW5rIChkZXN0cm95aW5nKSB7XG4gICAgdGVhcmRvd25EaXJzKHZtLCBkaXJzLCBkZXN0cm95aW5nKVxuICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHREaXJzKSB7XG4gICAgICB0ZWFyZG93bkRpcnMoY29udGV4dCwgY29udGV4dERpcnMpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVGVhcmRvd24gcGFydGlhbCBsaW5rZWQgZGlyZWN0aXZlcy5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7QXJyYXl9IGRpcnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGVzdHJveWluZ1xuICovXG5cbmZ1bmN0aW9uIHRlYXJkb3duRGlycyAodm0sIGRpcnMsIGRlc3Ryb3lpbmcpIHtcbiAgdmFyIGkgPSBkaXJzLmxlbmd0aFxuICB3aGlsZSAoaS0tKSB7XG4gICAgZGlyc1tpXS5fdGVhcmRvd24oKVxuICAgIGlmICghZGVzdHJveWluZykge1xuICAgICAgdm0uX2RpcmVjdGl2ZXMuJHJlbW92ZShkaXJzW2ldKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENvbXBpbGUgbGluayBwcm9wcyBvbiBhbiBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV1cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmV4cG9ydHMuY29tcGlsZUFuZExpbmtQcm9wcyA9IGZ1bmN0aW9uICh2bSwgZWwsIHByb3BzLCBzY29wZSkge1xuICB2YXIgcHJvcHNMaW5rRm4gPSBjb21waWxlUHJvcHMoZWwsIHByb3BzKVxuICB2YXIgcHJvcERpcnMgPSBsaW5rQW5kQ2FwdHVyZShmdW5jdGlvbiAoKSB7XG4gICAgcHJvcHNMaW5rRm4odm0sIHNjb3BlKVxuICB9LCB2bSlcbiAgcmV0dXJuIG1ha2VVbmxpbmtGbih2bSwgcHJvcERpcnMpXG59XG5cbi8qKlxuICogQ29tcGlsZSB0aGUgcm9vdCBlbGVtZW50IG9mIGFuIGluc3RhbmNlLlxuICpcbiAqIDEuIGF0dHJzIG9uIGNvbnRleHQgY29udGFpbmVyIChjb250ZXh0IHNjb3BlKVxuICogMi4gYXR0cnMgb24gdGhlIGNvbXBvbmVudCB0ZW1wbGF0ZSByb290IG5vZGUsIGlmXG4gKiAgICByZXBsYWNlOnRydWUgKGNoaWxkIHNjb3BlKVxuICpcbiAqIElmIHRoaXMgaXMgYSBmcmFnbWVudCBpbnN0YW5jZSwgd2Ugb25seSBuZWVkIHRvIGNvbXBpbGUgMS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dE9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmV4cG9ydHMuY29tcGlsZVJvb3QgPSBmdW5jdGlvbiAoZWwsIG9wdGlvbnMsIGNvbnRleHRPcHRpb25zKSB7XG4gIHZhciBjb250YWluZXJBdHRycyA9IG9wdGlvbnMuX2NvbnRhaW5lckF0dHJzXG4gIHZhciByZXBsYWNlckF0dHJzID0gb3B0aW9ucy5fcmVwbGFjZXJBdHRyc1xuICB2YXIgY29udGV4dExpbmtGbiwgcmVwbGFjZXJMaW5rRm5cblxuICAvLyBvbmx5IG5lZWQgdG8gY29tcGlsZSBvdGhlciBhdHRyaWJ1dGVzIGZvclxuICAvLyBub24tZnJhZ21lbnQgaW5zdGFuY2VzXG4gIGlmIChlbC5ub2RlVHlwZSAhPT0gMTEpIHtcbiAgICAvLyBmb3IgY29tcG9uZW50cywgY29udGFpbmVyIGFuZCByZXBsYWNlciBuZWVkIHRvIGJlXG4gICAgLy8gY29tcGlsZWQgc2VwYXJhdGVseSBhbmQgbGlua2VkIGluIGRpZmZlcmVudCBzY29wZXMuXG4gICAgaWYgKG9wdGlvbnMuX2FzQ29tcG9uZW50KSB7XG4gICAgICAvLyAyLiBjb250YWluZXIgYXR0cmlidXRlc1xuICAgICAgaWYgKGNvbnRhaW5lckF0dHJzICYmIGNvbnRleHRPcHRpb25zKSB7XG4gICAgICAgIGNvbnRleHRMaW5rRm4gPSBjb21waWxlRGlyZWN0aXZlcyhjb250YWluZXJBdHRycywgY29udGV4dE9wdGlvbnMpXG4gICAgICB9XG4gICAgICBpZiAocmVwbGFjZXJBdHRycykge1xuICAgICAgICAvLyAzLiByZXBsYWNlciBhdHRyaWJ1dGVzXG4gICAgICAgIHJlcGxhY2VyTGlua0ZuID0gY29tcGlsZURpcmVjdGl2ZXMocmVwbGFjZXJBdHRycywgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm9uLWNvbXBvbmVudCwganVzdCBjb21waWxlIGFzIGEgbm9ybWFsIGVsZW1lbnQuXG4gICAgICByZXBsYWNlckxpbmtGbiA9IGNvbXBpbGVEaXJlY3RpdmVzKGVsLmF0dHJpYnV0ZXMsIG9wdGlvbnMpXG4gICAgfVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29udGFpbmVyQXR0cnMpIHtcbiAgICAvLyB3YXJuIGNvbnRhaW5lciBkaXJlY3RpdmVzIGZvciBmcmFnbWVudCBpbnN0YW5jZXNcbiAgICB2YXIgbmFtZXMgPSBjb250YWluZXJBdHRycy5tYXAoZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgIHJldHVybiAnXCInICsgYXR0ci5uYW1lICsgJ1wiJ1xuICAgIH0pLmpvaW4oJywgJylcbiAgICB2YXIgcGx1cmFsID0gY29udGFpbmVyQXR0cnMubGVuZ3RoID4gMVxuICAgIF8ud2FybihcbiAgICAgICdBdHRyaWJ1dGUnICsgKHBsdXJhbCA/ICdzICcgOiAnICcpICsgbmFtZXMgK1xuICAgICAgKHBsdXJhbCA/ICcgYXJlJyA6ICcgaXMnKSArICcgaWdub3JlZCBvbiBjb21wb25lbnQgJyArXG4gICAgICAnPCcgKyBvcHRpb25zLmVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSArICc+IGJlY2F1c2UgJyArXG4gICAgICAndGhlIGNvbXBvbmVudCBpcyBhIGZyYWdtZW50IGluc3RhbmNlOiAnICtcbiAgICAgICdodHRwOi8vdnVlanMub3JnL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNGcmFnbWVudF9JbnN0YW5jZSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcm9vdExpbmtGbiAodm0sIGVsLCBzY29wZSkge1xuICAgIC8vIGxpbmsgY29udGV4dCBzY29wZSBkaXJzXG4gICAgdmFyIGNvbnRleHQgPSB2bS5fY29udGV4dFxuICAgIHZhciBjb250ZXh0RGlyc1xuICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHRMaW5rRm4pIHtcbiAgICAgIGNvbnRleHREaXJzID0gbGlua0FuZENhcHR1cmUoZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZXh0TGlua0ZuKGNvbnRleHQsIGVsLCBudWxsLCBzY29wZSlcbiAgICAgIH0sIGNvbnRleHQpXG4gICAgfVxuXG4gICAgLy8gbGluayBzZWxmXG4gICAgdmFyIHNlbGZEaXJzID0gbGlua0FuZENhcHR1cmUoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHJlcGxhY2VyTGlua0ZuKSByZXBsYWNlckxpbmtGbih2bSwgZWwpXG4gICAgfSwgdm0pXG5cbiAgICAvLyByZXR1cm4gdGhlIHVubGluayBmdW5jdGlvbiB0aGF0IHRlYXJzZG93biBjb250ZXh0XG4gICAgLy8gY29udGFpbmVyIGRpcmVjdGl2ZXMuXG4gICAgcmV0dXJuIG1ha2VVbmxpbmtGbih2bSwgc2VsZkRpcnMsIGNvbnRleHQsIGNvbnRleHREaXJzKVxuICB9XG59XG5cbi8qKlxuICogQ29tcGlsZSBhIG5vZGUgYW5kIHJldHVybiBhIG5vZGVMaW5rRm4gYmFzZWQgb24gdGhlXG4gKiBub2RlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb258bnVsbH1cbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlTm9kZSAobm9kZSwgb3B0aW9ucykge1xuICB2YXIgdHlwZSA9IG5vZGUubm9kZVR5cGVcbiAgaWYgKHR5cGUgPT09IDEgJiYgbm9kZS50YWdOYW1lICE9PSAnU0NSSVBUJykge1xuICAgIHJldHVybiBjb21waWxlRWxlbWVudChub2RlLCBvcHRpb25zKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09IDMgJiYgbm9kZS5kYXRhLnRyaW0oKSkge1xuICAgIHJldHVybiBjb21waWxlVGV4dE5vZGUobm9kZSwgb3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbi8qKlxuICogQ29tcGlsZSBhbiBlbGVtZW50IGFuZCByZXR1cm4gYSBub2RlTGlua0ZuLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtGdW5jdGlvbnxudWxsfVxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVFbGVtZW50IChlbCwgb3B0aW9ucykge1xuICAvLyBwcmVwcm9jZXNzIHRleHRhcmVhcy5cbiAgLy8gdGV4dGFyZWEgdHJlYXRzIGl0cyB0ZXh0IGNvbnRlbnQgYXMgdGhlIGluaXRpYWwgdmFsdWUuXG4gIC8vIGp1c3QgYmluZCBpdCBhcyBhbiBhdHRyIGRpcmVjdGl2ZSBmb3IgdmFsdWUuXG4gIGlmIChlbC50YWdOYW1lID09PSAnVEVYVEFSRUEnKSB7XG4gICAgdmFyIHRva2VucyA9IHRleHRQYXJzZXIucGFyc2UoZWwudmFsdWUpXG4gICAgaWYgKHRva2Vucykge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCc6dmFsdWUnLCB0ZXh0UGFyc2VyLnRva2Vuc1RvRXhwKHRva2VucykpXG4gICAgICBlbC52YWx1ZSA9ICcnXG4gICAgfVxuICB9XG4gIHZhciBsaW5rRm5cbiAgdmFyIGhhc0F0dHJzID0gZWwuaGFzQXR0cmlidXRlcygpXG4gIC8vIGNoZWNrIHRlcm1pbmFsIGRpcmVjdGl2ZXMgKGZvciAmIGlmKVxuICBpZiAoaGFzQXR0cnMpIHtcbiAgICBsaW5rRm4gPSBjaGVja1Rlcm1pbmFsRGlyZWN0aXZlcyhlbCwgb3B0aW9ucylcbiAgfVxuICAvLyBjaGVjayBlbGVtZW50IGRpcmVjdGl2ZXNcbiAgaWYgKCFsaW5rRm4pIHtcbiAgICBsaW5rRm4gPSBjaGVja0VsZW1lbnREaXJlY3RpdmVzKGVsLCBvcHRpb25zKVxuICB9XG4gIC8vIGNoZWNrIGNvbXBvbmVudFxuICBpZiAoIWxpbmtGbikge1xuICAgIGxpbmtGbiA9IGNoZWNrQ29tcG9uZW50KGVsLCBvcHRpb25zKVxuICB9XG4gIC8vIG5vcm1hbCBkaXJlY3RpdmVzXG4gIGlmICghbGlua0ZuICYmIGhhc0F0dHJzKSB7XG4gICAgbGlua0ZuID0gY29tcGlsZURpcmVjdGl2ZXMoZWwuYXR0cmlidXRlcywgb3B0aW9ucylcbiAgfVxuICByZXR1cm4gbGlua0ZuXG59XG5cbi8qKlxuICogQ29tcGlsZSBhIHRleHROb2RlIGFuZCByZXR1cm4gYSBub2RlTGlua0ZuLlxuICpcbiAqIEBwYXJhbSB7VGV4dE5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtGdW5jdGlvbnxudWxsfSB0ZXh0Tm9kZUxpbmtGblxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVUZXh0Tm9kZSAobm9kZSwgb3B0aW9ucykge1xuICB2YXIgdG9rZW5zID0gdGV4dFBhcnNlci5wYXJzZShub2RlLmRhdGEpXG4gIGlmICghdG9rZW5zKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuICB2YXIgZWwsIHRva2VuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gdG9rZW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHRva2VuID0gdG9rZW5zW2ldXG4gICAgZWwgPSB0b2tlbi50YWdcbiAgICAgID8gcHJvY2Vzc1RleHRUb2tlbih0b2tlbiwgb3B0aW9ucylcbiAgICAgIDogZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodG9rZW4udmFsdWUpXG4gICAgZnJhZy5hcHBlbmRDaGlsZChlbClcbiAgfVxuICByZXR1cm4gbWFrZVRleHROb2RlTGlua0ZuKHRva2VucywgZnJhZywgb3B0aW9ucylcbn1cblxuLyoqXG4gKiBQcm9jZXNzIGEgc2luZ2xlIHRleHQgdG9rZW4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRva2VuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7Tm9kZX1cbiAqL1xuXG5mdW5jdGlvbiBwcm9jZXNzVGV4dFRva2VuICh0b2tlbiwgb3B0aW9ucykge1xuICB2YXIgZWxcbiAgaWYgKHRva2VuLm9uZVRpbWUpIHtcbiAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRva2VuLnZhbHVlKVxuICB9IGVsc2Uge1xuICAgIGlmICh0b2tlbi5odG1sKSB7XG4gICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoJ3YtaHRtbCcpXG4gICAgICBzZXRUb2tlblR5cGUoJ2h0bWwnKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJRSB3aWxsIGNsZWFuIHVwIGVtcHR5IHRleHROb2RlcyBkdXJpbmdcbiAgICAgIC8vIGZyYWcuY2xvbmVOb2RlKHRydWUpLCBzbyB3ZSBoYXZlIHRvIGdpdmUgaXRcbiAgICAgIC8vIHNvbWV0aGluZyBoZXJlLi4uXG4gICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcgJylcbiAgICAgIHNldFRva2VuVHlwZSgndGV4dCcpXG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNldFRva2VuVHlwZSAodHlwZSkge1xuICAgIGlmICh0b2tlbi5kZXNjcmlwdG9yKSByZXR1cm5cbiAgICB2YXIgcGFyc2VkID0gZGlyUGFyc2VyLnBhcnNlKHRva2VuLnZhbHVlKVxuICAgIHRva2VuLmRlc2NyaXB0b3IgPSB7XG4gICAgICBuYW1lOiB0eXBlLFxuICAgICAgZGVmOiBwdWJsaWNEaXJlY3RpdmVzW3R5cGVdLFxuICAgICAgZXhwcmVzc2lvbjogcGFyc2VkLmV4cHJlc3Npb24sXG4gICAgICBmaWx0ZXJzOiBwYXJzZWQuZmlsdGVyc1xuICAgIH1cbiAgfVxuICByZXR1cm4gZWxcbn1cblxuLyoqXG4gKiBCdWlsZCBhIGZ1bmN0aW9uIHRoYXQgcHJvY2Vzc2VzIGEgdGV4dE5vZGUuXG4gKlxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSB0b2tlbnNcbiAqIEBwYXJhbSB7RG9jdW1lbnRGcmFnbWVudH0gZnJhZ1xuICovXG5cbmZ1bmN0aW9uIG1ha2VUZXh0Tm9kZUxpbmtGbiAodG9rZW5zLCBmcmFnKSB7XG4gIHJldHVybiBmdW5jdGlvbiB0ZXh0Tm9kZUxpbmtGbiAodm0sIGVsLCBob3N0LCBzY29wZSkge1xuICAgIHZhciBmcmFnQ2xvbmUgPSBmcmFnLmNsb25lTm9kZSh0cnVlKVxuICAgIHZhciBjaGlsZE5vZGVzID0gXy50b0FycmF5KGZyYWdDbG9uZS5jaGlsZE5vZGVzKVxuICAgIHZhciB0b2tlbiwgdmFsdWUsIG5vZGVcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRva2Vucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRva2VuID0gdG9rZW5zW2ldXG4gICAgICB2YWx1ZSA9IHRva2VuLnZhbHVlXG4gICAgICBpZiAodG9rZW4udGFnKSB7XG4gICAgICAgIG5vZGUgPSBjaGlsZE5vZGVzW2ldXG4gICAgICAgIGlmICh0b2tlbi5vbmVUaW1lKSB7XG4gICAgICAgICAgdmFsdWUgPSAoc2NvcGUgfHwgdm0pLiRldmFsKHZhbHVlKVxuICAgICAgICAgIGlmICh0b2tlbi5odG1sKSB7XG4gICAgICAgICAgICBfLnJlcGxhY2Uobm9kZSwgdGVtcGxhdGVQYXJzZXIucGFyc2UodmFsdWUsIHRydWUpKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlLmRhdGEgPSB2YWx1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2bS5fYmluZERpcih0b2tlbi5kZXNjcmlwdG9yLCBub2RlLCBob3N0LCBzY29wZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBfLnJlcGxhY2UoZWwsIGZyYWdDbG9uZSlcbiAgfVxufVxuXG4vKipcbiAqIENvbXBpbGUgYSBub2RlIGxpc3QgYW5kIHJldHVybiBhIGNoaWxkTGlua0ZuLlxuICpcbiAqIEBwYXJhbSB7Tm9kZUxpc3R9IG5vZGVMaXN0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb258dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVOb2RlTGlzdCAobm9kZUxpc3QsIG9wdGlvbnMpIHtcbiAgdmFyIGxpbmtGbnMgPSBbXVxuICB2YXIgbm9kZUxpbmtGbiwgY2hpbGRMaW5rRm4sIG5vZGVcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlTGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBub2RlID0gbm9kZUxpc3RbaV1cbiAgICBub2RlTGlua0ZuID0gY29tcGlsZU5vZGUobm9kZSwgb3B0aW9ucylcbiAgICBjaGlsZExpbmtGbiA9XG4gICAgICAhKG5vZGVMaW5rRm4gJiYgbm9kZUxpbmtGbi50ZXJtaW5hbCkgJiZcbiAgICAgIG5vZGUudGFnTmFtZSAhPT0gJ1NDUklQVCcgJiZcbiAgICAgIG5vZGUuaGFzQ2hpbGROb2RlcygpXG4gICAgICAgID8gY29tcGlsZU5vZGVMaXN0KG5vZGUuY2hpbGROb2Rlcywgb3B0aW9ucylcbiAgICAgICAgOiBudWxsXG4gICAgbGlua0Zucy5wdXNoKG5vZGVMaW5rRm4sIGNoaWxkTGlua0ZuKVxuICB9XG4gIHJldHVybiBsaW5rRm5zLmxlbmd0aFxuICAgID8gbWFrZUNoaWxkTGlua0ZuKGxpbmtGbnMpXG4gICAgOiBudWxsXG59XG5cbi8qKlxuICogTWFrZSBhIGNoaWxkIGxpbmsgZnVuY3Rpb24gZm9yIGEgbm9kZSdzIGNoaWxkTm9kZXMuXG4gKlxuICogQHBhcmFtIHtBcnJheTxGdW5jdGlvbj59IGxpbmtGbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBjaGlsZExpbmtGblxuICovXG5cbmZ1bmN0aW9uIG1ha2VDaGlsZExpbmtGbiAobGlua0Zucykge1xuICByZXR1cm4gZnVuY3Rpb24gY2hpbGRMaW5rRm4gKHZtLCBub2RlcywgaG9zdCwgc2NvcGUsIGZyYWcpIHtcbiAgICB2YXIgbm9kZSwgbm9kZUxpbmtGbiwgY2hpbGRyZW5MaW5rRm5cbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IDAsIGwgPSBsaW5rRm5zLmxlbmd0aDsgaSA8IGw7IG4rKykge1xuICAgICAgbm9kZSA9IG5vZGVzW25dXG4gICAgICBub2RlTGlua0ZuID0gbGlua0Zuc1tpKytdXG4gICAgICBjaGlsZHJlbkxpbmtGbiA9IGxpbmtGbnNbaSsrXVxuICAgICAgLy8gY2FjaGUgY2hpbGROb2RlcyBiZWZvcmUgbGlua2luZyBwYXJlbnQsIGZpeCAjNjU3XG4gICAgICB2YXIgY2hpbGROb2RlcyA9IF8udG9BcnJheShub2RlLmNoaWxkTm9kZXMpXG4gICAgICBpZiAobm9kZUxpbmtGbikge1xuICAgICAgICBub2RlTGlua0ZuKHZtLCBub2RlLCBob3N0LCBzY29wZSwgZnJhZylcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZHJlbkxpbmtGbikge1xuICAgICAgICBjaGlsZHJlbkxpbmtGbih2bSwgY2hpbGROb2RlcywgaG9zdCwgc2NvcGUsIGZyYWcpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgZm9yIGVsZW1lbnQgZGlyZWN0aXZlcyAoY3VzdG9tIGVsZW1lbnRzIHRoYXQgc2hvdWxkXG4gKiBiZSByZXNvdmxlZCBhcyB0ZXJtaW5hbCBkaXJlY3RpdmVzKS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIGNoZWNrRWxlbWVudERpcmVjdGl2ZXMgKGVsLCBvcHRpb25zKSB7XG4gIHZhciB0YWcgPSBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKClcbiAgaWYgKF8uY29tbW9uVGFnUkUudGVzdCh0YWcpKSByZXR1cm5cbiAgdmFyIGRlZiA9IHJlc29sdmVBc3NldChvcHRpb25zLCAnZWxlbWVudERpcmVjdGl2ZXMnLCB0YWcpXG4gIGlmIChkZWYpIHtcbiAgICByZXR1cm4gbWFrZVRlcm1pbmFsTm9kZUxpbmtGbihlbCwgdGFnLCAnJywgb3B0aW9ucywgZGVmKVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gZWxlbWVudCBpcyBhIGNvbXBvbmVudC4gSWYgeWVzLCByZXR1cm5cbiAqIGEgY29tcG9uZW50IGxpbmsgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBjaGVja0NvbXBvbmVudCAoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIGNvbXBvbmVudCA9IF8uY2hlY2tDb21wb25lbnQoZWwsIG9wdGlvbnMpXG4gIGlmIChjb21wb25lbnQpIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHtcbiAgICAgIG5hbWU6ICdjb21wb25lbnQnLFxuICAgICAgZXhwcmVzc2lvbjogY29tcG9uZW50LmlkLFxuICAgICAgZGVmOiBpbnRlcm5hbERpcmVjdGl2ZXMuY29tcG9uZW50LFxuICAgICAgbW9kaWZpZXJzOiB7XG4gICAgICAgIGxpdGVyYWw6ICFjb21wb25lbnQuZHluYW1pY1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgY29tcG9uZW50TGlua0ZuID0gZnVuY3Rpb24gKHZtLCBlbCwgaG9zdCwgc2NvcGUsIGZyYWcpIHtcbiAgICAgIHZtLl9iaW5kRGlyKGRlc2NyaXB0b3IsIGVsLCBob3N0LCBzY29wZSwgZnJhZylcbiAgICB9XG4gICAgY29tcG9uZW50TGlua0ZuLnRlcm1pbmFsID0gdHJ1ZVxuICAgIHJldHVybiBjb21wb25lbnRMaW5rRm5cbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGFuIGVsZW1lbnQgZm9yIHRlcm1pbmFsIGRpcmVjdGl2ZXMgaW4gZml4ZWQgb3JkZXIuXG4gKiBJZiBpdCBmaW5kcyBvbmUsIHJldHVybiBhIHRlcm1pbmFsIGxpbmsgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0ZXJtaW5hbExpbmtGblxuICovXG5cbmZ1bmN0aW9uIGNoZWNrVGVybWluYWxEaXJlY3RpdmVzIChlbCwgb3B0aW9ucykge1xuICAvLyBza2lwIHYtcHJlXG4gIGlmIChfLmF0dHIoZWwsICd2LXByZScpICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHNraXBcbiAgfVxuICAvLyBza2lwIHYtZWxzZSBibG9jaywgYnV0IG9ubHkgaWYgZm9sbG93aW5nIHYtaWZcbiAgaWYgKGVsLmhhc0F0dHJpYnV0ZSgndi1lbHNlJykpIHtcbiAgICB2YXIgcHJldiA9IGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmdcbiAgICBpZiAocHJldiAmJiBwcmV2Lmhhc0F0dHJpYnV0ZSgndi1pZicpKSB7XG4gICAgICByZXR1cm4gc2tpcFxuICAgIH1cbiAgfVxuICB2YXIgdmFsdWUsIGRpck5hbWVcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB0ZXJtaW5hbERpcmVjdGl2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZGlyTmFtZSA9IHRlcm1pbmFsRGlyZWN0aXZlc1tpXVxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG4gICAgaWYgKHZhbHVlID0gZWwuZ2V0QXR0cmlidXRlKCd2LScgKyBkaXJOYW1lKSkge1xuICAgICAgcmV0dXJuIG1ha2VUZXJtaW5hbE5vZGVMaW5rRm4oZWwsIGRpck5hbWUsIHZhbHVlLCBvcHRpb25zKVxuICAgIH1cbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG4gIH1cbn1cblxuZnVuY3Rpb24gc2tpcCAoKSB7fVxuc2tpcC50ZXJtaW5hbCA9IHRydWVcblxuLyoqXG4gKiBCdWlsZCBhIG5vZGUgbGluayBmdW5jdGlvbiBmb3IgYSB0ZXJtaW5hbCBkaXJlY3RpdmUuXG4gKiBBIHRlcm1pbmFsIGxpbmsgZnVuY3Rpb24gdGVybWluYXRlcyB0aGUgY3VycmVudFxuICogY29tcGlsYXRpb24gcmVjdXJzaW9uIGFuZCBoYW5kbGVzIGNvbXBpbGF0aW9uIG9mIHRoZVxuICogc3VidHJlZSBpbiB0aGUgZGlyZWN0aXZlLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBkaXJOYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gW2RlZl1cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0ZXJtaW5hbExpbmtGblxuICovXG5cbmZ1bmN0aW9uIG1ha2VUZXJtaW5hbE5vZGVMaW5rRm4gKGVsLCBkaXJOYW1lLCB2YWx1ZSwgb3B0aW9ucywgZGVmKSB7XG4gIHZhciBwYXJzZWQgPSBkaXJQYXJzZXIucGFyc2UodmFsdWUpXG4gIHZhciBkZXNjcmlwdG9yID0ge1xuICAgIG5hbWU6IGRpck5hbWUsXG4gICAgZXhwcmVzc2lvbjogcGFyc2VkLmV4cHJlc3Npb24sXG4gICAgZmlsdGVyczogcGFyc2VkLmZpbHRlcnMsXG4gICAgcmF3OiB2YWx1ZSxcbiAgICAvLyBlaXRoZXIgYW4gZWxlbWVudCBkaXJlY3RpdmUsIG9yIGlmL2ZvclxuICAgIGRlZjogZGVmIHx8IHB1YmxpY0RpcmVjdGl2ZXNbZGlyTmFtZV1cbiAgfVxuICB2YXIgZm4gPSBmdW5jdGlvbiB0ZXJtaW5hbE5vZGVMaW5rRm4gKHZtLCBlbCwgaG9zdCwgc2NvcGUsIGZyYWcpIHtcbiAgICB2bS5fYmluZERpcihkZXNjcmlwdG9yLCBlbCwgaG9zdCwgc2NvcGUsIGZyYWcpXG4gIH1cbiAgZm4udGVybWluYWwgPSB0cnVlXG4gIHJldHVybiBmblxufVxuXG4vKipcbiAqIENvbXBpbGUgdGhlIGRpcmVjdGl2ZXMgb24gYW4gZWxlbWVudCBhbmQgcmV0dXJuIGEgbGlua2VyLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl8TmFtZWROb2RlTWFwfSBhdHRyc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVEaXJlY3RpdmVzIChhdHRycywgb3B0aW9ucykge1xuICB2YXIgaSA9IGF0dHJzLmxlbmd0aFxuICB2YXIgZGlycyA9IFtdXG4gIHZhciBhdHRyLCBuYW1lLCB2YWx1ZSwgcmF3TmFtZSwgcmF3VmFsdWUsIGRpck5hbWUsIGFyZywgbW9kaWZpZXJzLCBkaXJEZWYsIHRva2Vuc1xuICB3aGlsZSAoaS0tKSB7XG4gICAgYXR0ciA9IGF0dHJzW2ldXG4gICAgbmFtZSA9IHJhd05hbWUgPSBhdHRyLm5hbWVcbiAgICB2YWx1ZSA9IHJhd1ZhbHVlID0gYXR0ci52YWx1ZVxuICAgIHRva2VucyA9IHRleHRQYXJzZXIucGFyc2UodmFsdWUpXG4gICAgLy8gcmVzZXQgYXJnXG4gICAgYXJnID0gbnVsbFxuICAgIC8vIGNoZWNrIG1vZGlmaWVyc1xuICAgIG1vZGlmaWVycyA9IHBhcnNlTW9kaWZpZXJzKG5hbWUpXG4gICAgbmFtZSA9IG5hbWUucmVwbGFjZShtb2RpZmllclJFLCAnJylcblxuICAgIC8vIGF0dHJpYnV0ZSBpbnRlcnBvbGF0aW9uc1xuICAgIGlmICh0b2tlbnMpIHtcbiAgICAgIHZhbHVlID0gdGV4dFBhcnNlci50b2tlbnNUb0V4cCh0b2tlbnMpXG4gICAgICBhcmcgPSBuYW1lXG4gICAgICBwdXNoRGlyKCdiaW5kJywgcHVibGljRGlyZWN0aXZlcy5iaW5kLCB0cnVlKVxuICAgIH0gZWxzZVxuXG4gICAgLy8gc3BlY2lhbCBhdHRyaWJ1dGU6IHRyYW5zaXRpb25cbiAgICBpZiAodHJhbnNpdGlvblJFLnRlc3QobmFtZSkpIHtcbiAgICAgIG1vZGlmaWVycy5saXRlcmFsID0gIWJpbmRSRS50ZXN0KG5hbWUpXG4gICAgICBwdXNoRGlyKCd0cmFuc2l0aW9uJywgaW50ZXJuYWxEaXJlY3RpdmVzLnRyYW5zaXRpb24pXG4gICAgfSBlbHNlXG5cbiAgICAvLyBldmVudCBoYW5kbGVyc1xuICAgIGlmIChvblJFLnRlc3QobmFtZSkpIHtcbiAgICAgIGFyZyA9IG5hbWUucmVwbGFjZShvblJFLCAnJylcbiAgICAgIHB1c2hEaXIoJ29uJywgcHVibGljRGlyZWN0aXZlcy5vbilcbiAgICB9IGVsc2VcblxuICAgIC8vIGF0dHJpYnV0ZSBiaW5kaW5nc1xuICAgIGlmIChiaW5kUkUudGVzdChuYW1lKSkge1xuICAgICAgZGlyTmFtZSA9IG5hbWUucmVwbGFjZShiaW5kUkUsICcnKVxuICAgICAgaWYgKGRpck5hbWUgPT09ICdzdHlsZScgfHwgZGlyTmFtZSA9PT0gJ2NsYXNzJykge1xuICAgICAgICBwdXNoRGlyKGRpck5hbWUsIGludGVybmFsRGlyZWN0aXZlc1tkaXJOYW1lXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFyZyA9IGRpck5hbWVcbiAgICAgICAgcHVzaERpcignYmluZCcsIHB1YmxpY0RpcmVjdGl2ZXMuYmluZClcbiAgICAgIH1cbiAgICB9IGVsc2VcblxuICAgIC8vIG5vcm1hbCBkaXJlY3RpdmVzXG4gICAgaWYgKG5hbWUuaW5kZXhPZigndi0nKSA9PT0gMCkge1xuICAgICAgLy8gY2hlY2sgYXJnXG4gICAgICBhcmcgPSAoYXJnID0gbmFtZS5tYXRjaChhcmdSRSkpICYmIGFyZ1sxXVxuICAgICAgaWYgKGFyZykge1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGFyZ1JFLCAnJylcbiAgICAgIH1cbiAgICAgIC8vIGV4dHJhY3QgZGlyZWN0aXZlIG5hbWVcbiAgICAgIGRpck5hbWUgPSBuYW1lLnNsaWNlKDIpXG5cbiAgICAgIC8vIHNraXAgdi1lbHNlICh3aGVuIHVzZWQgd2l0aCB2LXNob3cpXG4gICAgICBpZiAoZGlyTmFtZSA9PT0gJ2Vsc2UnKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGRpckRlZiA9IHJlc29sdmVBc3NldChvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpck5hbWUpXG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIF8uYXNzZXJ0QXNzZXQoZGlyRGVmLCAnZGlyZWN0aXZlJywgZGlyTmFtZSlcbiAgICAgIH1cblxuICAgICAgaWYgKGRpckRlZikge1xuICAgICAgICBpZiAoXy5pc0xpdGVyYWwodmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUgPSBfLnN0cmlwUXVvdGVzKHZhbHVlKVxuICAgICAgICAgIG1vZGlmaWVycy5saXRlcmFsID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIHB1c2hEaXIoZGlyTmFtZSwgZGlyRGVmKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQdXNoIGEgZGlyZWN0aXZlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGlyTmFtZVxuICAgKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gZGVmXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ludGVycF1cbiAgICovXG5cbiAgZnVuY3Rpb24gcHVzaERpciAoZGlyTmFtZSwgZGVmLCBpbnRlcnApIHtcbiAgICB2YXIgcGFyc2VkID0gZGlyUGFyc2VyLnBhcnNlKHZhbHVlKVxuICAgIGRpcnMucHVzaCh7XG4gICAgICBuYW1lOiBkaXJOYW1lLFxuICAgICAgYXR0cjogcmF3TmFtZSxcbiAgICAgIHJhdzogcmF3VmFsdWUsXG4gICAgICBkZWY6IGRlZixcbiAgICAgIGFyZzogYXJnLFxuICAgICAgbW9kaWZpZXJzOiBtb2RpZmllcnMsXG4gICAgICBleHByZXNzaW9uOiBwYXJzZWQuZXhwcmVzc2lvbixcbiAgICAgIGZpbHRlcnM6IHBhcnNlZC5maWx0ZXJzLFxuICAgICAgaW50ZXJwOiBpbnRlcnBcbiAgICB9KVxuICB9XG5cbiAgaWYgKGRpcnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG1ha2VOb2RlTGlua0ZuKGRpcnMpXG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBtb2RpZmllcnMgZnJvbSBkaXJlY3RpdmUgYXR0cmlidXRlIG5hbWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZU1vZGlmaWVycyAobmFtZSkge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICB2YXIgbWF0Y2ggPSBuYW1lLm1hdGNoKG1vZGlmaWVyUkUpXG4gIGlmIChtYXRjaCkge1xuICAgIHZhciBpID0gbWF0Y2gubGVuZ3RoXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgcmVzW21hdGNoW2ldLnNsaWNlKDEpXSA9IHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgbGluayBmdW5jdGlvbiBmb3IgYWxsIGRpcmVjdGl2ZXMgb24gYSBzaW5nbGUgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBkaXJlY3RpdmVzXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gZGlyZWN0aXZlc0xpbmtGblxuICovXG5cbmZ1bmN0aW9uIG1ha2VOb2RlTGlua0ZuIChkaXJlY3RpdmVzKSB7XG4gIHJldHVybiBmdW5jdGlvbiBub2RlTGlua0ZuICh2bSwgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKSB7XG4gICAgLy8gcmV2ZXJzZSBhcHBseSBiZWNhdXNlIGl0J3Mgc29ydGVkIGxvdyB0byBoaWdoXG4gICAgdmFyIGkgPSBkaXJlY3RpdmVzLmxlbmd0aFxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZtLl9iaW5kRGlyKGRpcmVjdGl2ZXNbaV0sIGVsLCBob3N0LCBzY29wZSwgZnJhZylcbiAgICB9XG4gIH1cbn1cbiIsInZhciBfID0gcmVxdWlyZSgnLi4vdXRpbCcpXG5cbl8uZXh0ZW5kKGV4cG9ydHMsIHJlcXVpcmUoJy4vY29tcGlsZScpKVxuXy5leHRlbmQoZXhwb3J0cywgcmVxdWlyZSgnLi90cmFuc2NsdWRlJykpXG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWwnKVxudmFyIHRlbXBsYXRlUGFyc2VyID0gcmVxdWlyZSgnLi4vcGFyc2Vycy90ZW1wbGF0ZScpXG52YXIgc3BlY2lhbENoYXJSRSA9IC9bXlxcd1xcLTpcXC5dL1xuXG4vKipcbiAqIFByb2Nlc3MgYW4gZWxlbWVudCBvciBhIERvY3VtZW50RnJhZ21lbnQgYmFzZWQgb24gYVxuICogaW5zdGFuY2Ugb3B0aW9uIG9iamVjdC4gVGhpcyBhbGxvd3MgdXMgdG8gdHJhbnNjbHVkZVxuICogYSB0ZW1wbGF0ZSBub2RlL2ZyYWdtZW50IGJlZm9yZSB0aGUgaW5zdGFuY2UgaXMgY3JlYXRlZCxcbiAqIHNvIHRoZSBwcm9jZXNzZWQgZnJhZ21lbnQgY2FuIHRoZW4gYmUgY2xvbmVkIGFuZCByZXVzZWRcbiAqIGluIHYtZm9yLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9XG4gKi9cblxuZXhwb3J0cy50cmFuc2NsdWRlID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7XG4gIC8vIGV4dHJhY3QgY29udGFpbmVyIGF0dHJpYnV0ZXMgdG8gcGFzcyB0aGVtIGRvd25cbiAgLy8gdG8gY29tcGlsZXIsIGJlY2F1c2UgdGhleSBuZWVkIHRvIGJlIGNvbXBpbGVkIGluXG4gIC8vIHBhcmVudCBzY29wZS4gd2UgYXJlIG11dGF0aW5nIHRoZSBvcHRpb25zIG9iamVjdCBoZXJlXG4gIC8vIGFzc3VtaW5nIHRoZSBzYW1lIG9iamVjdCB3aWxsIGJlIHVzZWQgZm9yIGNvbXBpbGVcbiAgLy8gcmlnaHQgYWZ0ZXIgdGhpcy5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zLl9jb250YWluZXJBdHRycyA9IGV4dHJhY3RBdHRycyhlbClcbiAgfVxuICAvLyBmb3IgdGVtcGxhdGUgdGFncywgd2hhdCB3ZSB3YW50IGlzIGl0cyBjb250ZW50IGFzXG4gIC8vIGEgZG9jdW1lbnRGcmFnbWVudCAoZm9yIGZyYWdtZW50IGluc3RhbmNlcylcbiAgaWYgKF8uaXNUZW1wbGF0ZShlbCkpIHtcbiAgICBlbCA9IHRlbXBsYXRlUGFyc2VyLnBhcnNlKGVsKVxuICB9XG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuX2FzQ29tcG9uZW50ICYmICFvcHRpb25zLnRlbXBsYXRlKSB7XG4gICAgICBvcHRpb25zLnRlbXBsYXRlID0gJzxzbG90Pjwvc2xvdD4nXG4gICAgfVxuICAgIGlmIChvcHRpb25zLnRlbXBsYXRlKSB7XG4gICAgICBvcHRpb25zLl9jb250ZW50ID0gXy5leHRyYWN0Q29udGVudChlbClcbiAgICAgIGVsID0gdHJhbnNjbHVkZVRlbXBsYXRlKGVsLCBvcHRpb25zKVxuICAgIH1cbiAgfVxuICBpZiAoZWwgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KSB7XG4gICAgLy8gYW5jaG9ycyBmb3IgZnJhZ21lbnQgaW5zdGFuY2VcbiAgICAvLyBwYXNzaW5nIGluIGBwZXJzaXN0OiB0cnVlYCB0byBhdm9pZCB0aGVtIGJlaW5nXG4gICAgLy8gZGlzY2FyZGVkIGJ5IElFIGR1cmluZyB0ZW1wbGF0ZSBjbG9uaW5nXG4gICAgXy5wcmVwZW5kKF8uY3JlYXRlQW5jaG9yKCd2LXN0YXJ0JywgdHJ1ZSksIGVsKVxuICAgIGVsLmFwcGVuZENoaWxkKF8uY3JlYXRlQW5jaG9yKCd2LWVuZCcsIHRydWUpKVxuICB9XG4gIHJldHVybiBlbFxufVxuXG4vKipcbiAqIFByb2Nlc3MgdGhlIHRlbXBsYXRlIG9wdGlvbi5cbiAqIElmIHRoZSByZXBsYWNlIG9wdGlvbiBpcyB0cnVlIHRoaXMgd2lsbCBzd2FwIHRoZSAkZWwuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH1cbiAqL1xuXG5mdW5jdGlvbiB0cmFuc2NsdWRlVGVtcGxhdGUgKGVsLCBvcHRpb25zKSB7XG4gIHZhciB0ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGVcbiAgdmFyIGZyYWcgPSB0ZW1wbGF0ZVBhcnNlci5wYXJzZSh0ZW1wbGF0ZSwgdHJ1ZSlcbiAgaWYgKGZyYWcpIHtcbiAgICB2YXIgcmVwbGFjZXIgPSBmcmFnLmZpcnN0Q2hpbGRcbiAgICB2YXIgdGFnID0gcmVwbGFjZXIudGFnTmFtZSAmJiByZXBsYWNlci50YWdOYW1lLnRvTG93ZXJDYXNlKClcbiAgICBpZiAob3B0aW9ucy5yZXBsYWNlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChlbCA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIF8ud2FybihcbiAgICAgICAgICAnWW91IGFyZSBtb3VudGluZyBhbiBpbnN0YW5jZSB3aXRoIGEgdGVtcGxhdGUgdG8gJyArXG4gICAgICAgICAgJzxib2R5Pi4gVGhpcyB3aWxsIHJlcGxhY2UgPGJvZHk+IGVudGlyZWx5LiBZb3UgJyArXG4gICAgICAgICAgJ3Nob3VsZCBwcm9iYWJseSB1c2UgYHJlcGxhY2U6IGZhbHNlYCBoZXJlLidcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgLy8gdGhlcmUgYXJlIG1hbnkgY2FzZXMgd2hlcmUgdGhlIGluc3RhbmNlIG11c3RcbiAgICAgIC8vIGJlY29tZSBhIGZyYWdtZW50IGluc3RhbmNlOiBiYXNpY2FsbHkgYW55dGhpbmcgdGhhdFxuICAgICAgLy8gY2FuIGNyZWF0ZSBtb3JlIHRoYW4gMSByb290IG5vZGVzLlxuICAgICAgaWYgKFxuICAgICAgICAvLyBtdWx0aS1jaGlsZHJlbiB0ZW1wbGF0ZVxuICAgICAgICBmcmFnLmNoaWxkTm9kZXMubGVuZ3RoID4gMSB8fFxuICAgICAgICAvLyBub24tZWxlbWVudCB0ZW1wbGF0ZVxuICAgICAgICByZXBsYWNlci5ub2RlVHlwZSAhPT0gMSB8fFxuICAgICAgICAvLyBzaW5nbGUgbmVzdGVkIGNvbXBvbmVudFxuICAgICAgICB0YWcgPT09ICdjb21wb25lbnQnIHx8XG4gICAgICAgIF8ucmVzb2x2ZUFzc2V0KG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSB8fFxuICAgICAgICByZXBsYWNlci5oYXNBdHRyaWJ1dGUoJ2lzJykgfHxcbiAgICAgICAgcmVwbGFjZXIuaGFzQXR0cmlidXRlKCc6aXMnKSB8fFxuICAgICAgICByZXBsYWNlci5oYXNBdHRyaWJ1dGUoJ3YtYmluZDppcycpIHx8XG4gICAgICAgIC8vIGVsZW1lbnQgZGlyZWN0aXZlXG4gICAgICAgIF8ucmVzb2x2ZUFzc2V0KG9wdGlvbnMsICdlbGVtZW50RGlyZWN0aXZlcycsIHRhZykgfHxcbiAgICAgICAgLy8gZm9yIGJsb2NrXG4gICAgICAgIHJlcGxhY2VyLmhhc0F0dHJpYnV0ZSgndi1mb3InKSB8fFxuICAgICAgICAvLyBpZiBibG9ja1xuICAgICAgICByZXBsYWNlci5oYXNBdHRyaWJ1dGUoJ3YtaWYnKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmcmFnXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zLl9yZXBsYWNlckF0dHJzID0gZXh0cmFjdEF0dHJzKHJlcGxhY2VyKVxuICAgICAgICBtZXJnZUF0dHJzKGVsLCByZXBsYWNlcilcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VyXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmFwcGVuZENoaWxkKGZyYWcpXG4gICAgICByZXR1cm4gZWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBfLndhcm4oXG4gICAgICAnSW52YWxpZCB0ZW1wbGF0ZSBvcHRpb246ICcgKyB0ZW1wbGF0ZVxuICAgIClcbiAgfVxufVxuXG4vKipcbiAqIEhlbHBlciB0byBleHRyYWN0IGEgY29tcG9uZW50IGNvbnRhaW5lcidzIGF0dHJpYnV0ZXNcbiAqIGludG8gYSBwbGFpbiBvYmplY3QgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuZnVuY3Rpb24gZXh0cmFjdEF0dHJzIChlbCkge1xuICBpZiAoZWwubm9kZVR5cGUgPT09IDEgJiYgZWwuaGFzQXR0cmlidXRlcygpKSB7XG4gICAgcmV0dXJuIF8udG9BcnJheShlbC5hdHRyaWJ1dGVzKVxuICB9XG59XG5cbi8qKlxuICogTWVyZ2UgdGhlIGF0dHJpYnV0ZXMgb2YgdHdvIGVsZW1lbnRzLCBhbmQgbWFrZSBzdXJlXG4gKiB0aGUgY2xhc3MgbmFtZXMgYXJlIG1lcmdlZCBwcm9wZXJseS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGZyb21cbiAqIEBwYXJhbSB7RWxlbWVudH0gdG9cbiAqL1xuXG5mdW5jdGlvbiBtZXJnZUF0dHJzIChmcm9tLCB0bykge1xuICB2YXIgYXR0cnMgPSBmcm9tLmF0dHJpYnV0ZXNcbiAgdmFyIGkgPSBhdHRycy5sZW5ndGhcbiAgdmFyIG5hbWUsIHZhbHVlXG4gIHdoaWxlIChpLS0pIHtcbiAgICBuYW1lID0gYXR0cnNbaV0ubmFtZVxuICAgIHZhbHVlID0gYXR0cnNbaV0udmFsdWVcbiAgICBpZiAoIXRvLmhhc0F0dHJpYnV0ZShuYW1lKSAmJiAhc3BlY2lhbENoYXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICB0by5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpXG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAnY2xhc3MnKSB7XG4gICAgICB2YWx1ZSA9IHRvLmdldEF0dHJpYnV0ZShuYW1lKSArICcgJyArIHZhbHVlXG4gICAgICB0by5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpXG4gICAgfVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcblxuICAvKipcbiAgICogV2hldGhlciB0byBwcmludCBkZWJ1ZyBtZXNzYWdlcy5cbiAgICogQWxzbyBlbmFibGVzIHN0YWNrIHRyYWNlIGZvciB3YXJuaW5ncy5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuXG4gIGRlYnVnOiBmYWxzZSxcblxuICAvKipcbiAgICogV2hldGhlciB0byBzdXBwcmVzcyB3YXJuaW5ncy5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuXG4gIHNpbGVudDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gdXNlIGFzeW5jIHJlbmRlcmluZy5cbiAgICovXG5cbiAgYXN5bmM6IHRydWUsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gd2FybiBhZ2FpbnN0IGVycm9ycyBjYXVnaHQgd2hlbiBldmFsdWF0aW5nXG4gICAqIGV4cHJlc3Npb25zLlxuICAgKi9cblxuICB3YXJuRXhwcmVzc2lvbkVycm9yczogdHJ1ZSxcblxuICAvKipcbiAgICogSW50ZXJuYWwgZmxhZyB0byBpbmRpY2F0ZSB0aGUgZGVsaW1pdGVycyBoYXZlIGJlZW5cbiAgICogY2hhbmdlZC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuXG4gIF9kZWxpbWl0ZXJzQ2hhbmdlZDogdHJ1ZSxcblxuICAvKipcbiAgICogTGlzdCBvZiBhc3NldCB0eXBlcyB0aGF0IGEgY29tcG9uZW50IGNhbiBvd24uXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheX1cbiAgICovXG5cbiAgX2Fzc2V0VHlwZXM6IFtcbiAgICAnY29tcG9uZW50JyxcbiAgICAnZGlyZWN0aXZlJyxcbiAgICAnZWxlbWVudERpcmVjdGl2ZScsXG4gICAgJ2ZpbHRlcicsXG4gICAgJ3RyYW5zaXRpb24nLFxuICAgICdwYXJ0aWFsJ1xuICBdLFxuXG4gIC8qKlxuICAgKiBwcm9wIGJpbmRpbmcgbW9kZXNcbiAgICovXG5cbiAgX3Byb3BCaW5kaW5nTW9kZXM6IHtcbiAgICBPTkVfV0FZOiAwLFxuICAgIFRXT19XQVk6IDEsXG4gICAgT05FX1RJTUU6IDJcbiAgfSxcblxuICAvKipcbiAgICogTWF4IGNpcmN1bGFyIHVwZGF0ZXMgYWxsb3dlZCBpbiBhIGJhdGNoZXIgZmx1c2ggY3ljbGUuXG4gICAqL1xuXG4gIF9tYXhVcGRhdGVDb3VudDogMTAwXG5cbn1cblxuLyoqXG4gKiBJbnRlcnBvbGF0aW9uIGRlbGltaXRlcnMuIENoYW5naW5nIHRoZXNlIHdvdWxkIHRyaWdnZXJcbiAqIHRoZSB0ZXh0IHBhcnNlciB0byByZS1jb21waWxlIHRoZSByZWd1bGFyIGV4cHJlc3Npb25zLlxuICpcbiAqIEB0eXBlIHtBcnJheTxTdHJpbmc+fVxuICovXG5cbnZhciBkZWxpbWl0ZXJzID0gWyd7eycsICd9fSddXG52YXIgdW5zYWZlRGVsaW1pdGVycyA9IFsne3t7JywgJ319fSddXG52YXIgdGV4dFBhcnNlciA9IHJlcXVpcmUoJy4vcGFyc2Vycy90ZXh0JylcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZS5leHBvcnRzLCAnZGVsaW1pdGVycycsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRlbGltaXRlcnNcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgZGVsaW1pdGVycyA9IHZhbFxuICAgIHRleHRQYXJzZXIuY29tcGlsZVJlZ2V4KClcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZS5leHBvcnRzLCAndW5zYWZlRGVsaW1pdGVycycsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHVuc2FmZURlbGltaXRlcnNcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgdW5zYWZlRGVsaW1pdGVycyA9IHZhbFxuICAgIHRleHRQYXJzZXIuY29tcGlsZVJlZ2V4KClcbiAgfVxufSlcbiIsInZhciBfID0gcmVxdWlyZSgnLi91dGlsJylcbnZhciBXYXRjaGVyID0gcmVxdWlyZSgnLi93YXRjaGVyJylcbnZhciBleHBQYXJzZXIgPSByZXF1aXJlKCcuL3BhcnNlcnMvZXhwcmVzc2lvbicpXG5mdW5jdGlvbiBub29wICgpIHt9XG5cbi8qKlxuICogQSBkaXJlY3RpdmUgbGlua3MgYSBET00gZWxlbWVudCB3aXRoIGEgcGllY2Ugb2YgZGF0YSxcbiAqIHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgZXZhbHVhdGluZyBhbiBleHByZXNzaW9uLlxuICogSXQgcmVnaXN0ZXJzIGEgd2F0Y2hlciB3aXRoIHRoZSBleHByZXNzaW9uIGFuZCBjYWxsc1xuICogdGhlIERPTSB1cGRhdGUgZnVuY3Rpb24gd2hlbiBhIGNoYW5nZSBpcyB0cmlnZ2VyZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Tm9kZX0gZWxcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtPYmplY3R9IGRlc2NyaXB0b3JcbiAqICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IG5hbWVcbiAqICAgICAgICAgICAgICAgICAtIHtPYmplY3R9IGRlZlxuICogICAgICAgICAgICAgICAgIC0ge1N0cmluZ30gZXhwcmVzc2lvblxuICogICAgICAgICAgICAgICAgIC0ge0FycmF5PE9iamVjdD59IFtmaWx0ZXJzXVxuICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IGxpdGVyYWxcbiAqICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IGF0dHJcbiAqICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IHJhd1xuICogQHBhcmFtIHtPYmplY3R9IGRlZiAtIGRpcmVjdGl2ZSBkZWZpbml0aW9uIG9iamVjdFxuICogQHBhcmFtIHtWdWV9IFtob3N0XSAtIHRyYW5zY2x1c2lvbiBob3N0IGNvbXBvbmVudFxuICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV0gLSB2LWZvciBzY29wZVxuICogQHBhcmFtIHtGcmFnbWVudH0gW2ZyYWddIC0gb3duZXIgZnJhZ21lbnRcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbmZ1bmN0aW9uIERpcmVjdGl2ZSAoZGVzY3JpcHRvciwgdm0sIGVsLCBob3N0LCBzY29wZSwgZnJhZykge1xuICB0aGlzLnZtID0gdm1cbiAgdGhpcy5lbCA9IGVsXG4gIC8vIGNvcHkgZGVzY3JpcHRvciBwcm9wZXJ0aWVzXG4gIHRoaXMuZGVzY3JpcHRvciA9IGRlc2NyaXB0b3JcbiAgdGhpcy5uYW1lID0gZGVzY3JpcHRvci5uYW1lXG4gIHRoaXMuZXhwcmVzc2lvbiA9IGRlc2NyaXB0b3IuZXhwcmVzc2lvblxuICB0aGlzLmFyZyA9IGRlc2NyaXB0b3IuYXJnXG4gIHRoaXMubW9kaWZpZXJzID0gZGVzY3JpcHRvci5tb2RpZmllcnNcbiAgdGhpcy5maWx0ZXJzID0gZGVzY3JpcHRvci5maWx0ZXJzXG4gIHRoaXMubGl0ZXJhbCA9IHRoaXMubW9kaWZpZXJzICYmIHRoaXMubW9kaWZpZXJzLmxpdGVyYWxcbiAgLy8gcHJpdmF0ZVxuICB0aGlzLl9sb2NrZWQgPSBmYWxzZVxuICB0aGlzLl9ib3VuZCA9IGZhbHNlXG4gIHRoaXMuX2xpc3RlbmVycyA9IG51bGxcbiAgLy8gbGluayBjb250ZXh0XG4gIHRoaXMuX2hvc3QgPSBob3N0XG4gIHRoaXMuX3Njb3BlID0gc2NvcGVcbiAgdGhpcy5fZnJhZyA9IGZyYWdcbiAgLy8gc3RvcmUgZGlyZWN0aXZlcyBvbiBub2RlIGluIGRldiBtb2RlXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHRoaXMuZWwpIHtcbiAgICB0aGlzLmVsLl92dWVfZGlyZWN0aXZlcyA9IHRoaXMuZWwuX3Z1ZV9kaXJlY3RpdmVzIHx8IFtdXG4gICAgdGhpcy5lbC5fdnVlX2RpcmVjdGl2ZXMucHVzaCh0aGlzKVxuICB9XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgZGlyZWN0aXZlLCBtaXhpbiBkZWZpbml0aW9uIHByb3BlcnRpZXMsXG4gKiBzZXR1cCB0aGUgd2F0Y2hlciwgY2FsbCBkZWZpbml0aW9uIGJpbmQoKSBhbmQgdXBkYXRlKClcbiAqIGlmIHByZXNlbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRlZlxuICovXG5cbkRpcmVjdGl2ZS5wcm90b3R5cGUuX2JpbmQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBuYW1lID0gdGhpcy5uYW1lXG4gIHZhciBkZXNjcmlwdG9yID0gdGhpcy5kZXNjcmlwdG9yXG5cbiAgLy8gcmVtb3ZlIGF0dHJpYnV0ZVxuICBpZiAoXG4gICAgKG5hbWUgIT09ICdjbG9haycgfHwgdGhpcy52bS5faXNDb21waWxlZCkgJiZcbiAgICB0aGlzLmVsICYmIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlXG4gICkge1xuICAgIHZhciBhdHRyID0gZGVzY3JpcHRvci5hdHRyIHx8ICgndi0nICsgbmFtZSlcbiAgICB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyKVxuICB9XG5cbiAgLy8gY29weSBkZWYgcHJvcGVydGllc1xuICB2YXIgZGVmID0gZGVzY3JpcHRvci5kZWZcbiAgaWYgKHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLnVwZGF0ZSA9IGRlZlxuICB9IGVsc2Uge1xuICAgIF8uZXh0ZW5kKHRoaXMsIGRlZilcbiAgfVxuXG4gIC8vIHNldHVwIGRpcmVjdGl2ZSBwYXJhbXNcbiAgdGhpcy5fc2V0dXBQYXJhbXMoKVxuXG4gIC8vIGluaXRpYWwgYmluZFxuICBpZiAodGhpcy5iaW5kKSB7XG4gICAgdGhpcy5iaW5kKClcbiAgfVxuXG4gIGlmICh0aGlzLmxpdGVyYWwpIHtcbiAgICB0aGlzLnVwZGF0ZSAmJiB0aGlzLnVwZGF0ZShkZXNjcmlwdG9yLnJhdylcbiAgfSBlbHNlIGlmIChcbiAgICAodGhpcy5leHByZXNzaW9uIHx8IHRoaXMubW9kaWZpZXJzKSAmJlxuICAgICh0aGlzLnVwZGF0ZSB8fCB0aGlzLnR3b1dheSkgJiZcbiAgICAhdGhpcy5fY2hlY2tTdGF0ZW1lbnQoKVxuICApIHtcbiAgICAvLyB3cmFwcGVkIHVwZGF0ZXIgZm9yIGNvbnRleHRcbiAgICB2YXIgZGlyID0gdGhpc1xuICAgIGlmICh0aGlzLnVwZGF0ZSkge1xuICAgICAgdGhpcy5fdXBkYXRlID0gZnVuY3Rpb24gKHZhbCwgb2xkVmFsKSB7XG4gICAgICAgIGlmICghZGlyLl9sb2NrZWQpIHtcbiAgICAgICAgICBkaXIudXBkYXRlKHZhbCwgb2xkVmFsKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3VwZGF0ZSA9IG5vb3BcbiAgICB9XG4gICAgdmFyIHByZVByb2Nlc3MgPSB0aGlzLl9wcmVQcm9jZXNzXG4gICAgICA/IF8uYmluZCh0aGlzLl9wcmVQcm9jZXNzLCB0aGlzKVxuICAgICAgOiBudWxsXG4gICAgdmFyIHBvc3RQcm9jZXNzID0gdGhpcy5fcG9zdFByb2Nlc3NcbiAgICAgID8gXy5iaW5kKHRoaXMuX3Bvc3RQcm9jZXNzLCB0aGlzKVxuICAgICAgOiBudWxsXG4gICAgdmFyIHdhdGNoZXIgPSB0aGlzLl93YXRjaGVyID0gbmV3IFdhdGNoZXIoXG4gICAgICB0aGlzLnZtLFxuICAgICAgdGhpcy5leHByZXNzaW9uLFxuICAgICAgdGhpcy5fdXBkYXRlLCAvLyBjYWxsYmFja1xuICAgICAge1xuICAgICAgICBmaWx0ZXJzOiB0aGlzLmZpbHRlcnMsXG4gICAgICAgIHR3b1dheTogdGhpcy50d29XYXksXG4gICAgICAgIGRlZXA6IHRoaXMuZGVlcCxcbiAgICAgICAgcHJlUHJvY2VzczogcHJlUHJvY2VzcyxcbiAgICAgICAgcG9zdFByb2Nlc3M6IHBvc3RQcm9jZXNzLFxuICAgICAgICBzY29wZTogdGhpcy5fc2NvcGVcbiAgICAgIH1cbiAgICApXG4gICAgLy8gdi1tb2RlbCB3aXRoIGluaXRhbCBpbmxpbmUgdmFsdWUgbmVlZCB0byBzeW5jIGJhY2sgdG9cbiAgICAvLyBtb2RlbCBpbnN0ZWFkIG9mIHVwZGF0ZSB0byBET00gb24gaW5pdC4gVGhleSB3b3VsZFxuICAgIC8vIHNldCB0aGUgYWZ0ZXJCaW5kIGhvb2sgdG8gaW5kaWNhdGUgdGhhdC5cbiAgICBpZiAodGhpcy5hZnRlckJpbmQpIHtcbiAgICAgIHRoaXMuYWZ0ZXJCaW5kKClcbiAgICB9IGVsc2UgaWYgKHRoaXMudXBkYXRlKSB7XG4gICAgICB0aGlzLnVwZGF0ZSh3YXRjaGVyLnZhbHVlKVxuICAgIH1cbiAgfVxuICB0aGlzLl9ib3VuZCA9IHRydWVcbn1cblxuLyoqXG4gKiBTZXR1cCBhbGwgcGFyYW0gYXR0cmlidXRlcywgZS5nLiB0cmFjay1ieSxcbiAqIHRyYW5zaXRpb24tbW9kZSwgZXRjLi4uXG4gKi9cblxuRGlyZWN0aXZlLnByb3RvdHlwZS5fc2V0dXBQYXJhbXMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5wYXJhbXMpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgcGFyYW1zID0gdGhpcy5wYXJhbXNcbiAgLy8gc3dhcCB0aGUgcGFyYW1zIGFycmF5IHdpdGggYSBmcmVzaCBvYmplY3QuXG4gIHRoaXMucGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICB2YXIgaSA9IHBhcmFtcy5sZW5ndGhcbiAgdmFyIGtleSwgdmFsLCBtYXBwZWRLZXlcbiAgd2hpbGUgKGktLSkge1xuICAgIGtleSA9IHBhcmFtc1tpXVxuICAgIG1hcHBlZEtleSA9IF8uY2FtZWxpemUoa2V5KVxuICAgIHZhbCA9IF8uZ2V0QmluZEF0dHIodGhpcy5lbCwga2V5KVxuICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgLy8gZHluYW1pY1xuICAgICAgdGhpcy5fc2V0dXBQYXJhbVdhdGNoZXIobWFwcGVkS2V5LCB2YWwpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHN0YXRpY1xuICAgICAgdmFsID0gXy5hdHRyKHRoaXMuZWwsIGtleSlcbiAgICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnBhcmFtc1ttYXBwZWRLZXldID0gdmFsID09PSAnJyA/IHRydWUgOiB2YWxcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBTZXR1cCBhIHdhdGNoZXIgZm9yIGEgZHluYW1pYyBwYXJhbS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwcmVzc2lvblxuICovXG5cbkRpcmVjdGl2ZS5wcm90b3R5cGUuX3NldHVwUGFyYW1XYXRjaGVyID0gZnVuY3Rpb24gKGtleSwgZXhwcmVzc2lvbikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIGNhbGxlZCA9IGZhbHNlXG4gIHZhciB1bndhdGNoID0gKHRoaXMuX3Njb3BlIHx8IHRoaXMudm0pLiR3YXRjaChleHByZXNzaW9uLCBmdW5jdGlvbiAodmFsLCBvbGRWYWwpIHtcbiAgICBzZWxmLnBhcmFtc1trZXldID0gdmFsXG4gICAgLy8gc2luY2Ugd2UgYXJlIGluIGltbWVkaWF0ZSBtb2RlLFxuICAgIC8vIG9ubHkgY2FsbCB0aGUgcGFyYW0gY2hhbmdlIGNhbGxiYWNrcyBpZiB0aGlzIGlzIG5vdCB0aGUgZmlyc3QgdXBkYXRlLlxuICAgIGlmIChjYWxsZWQpIHtcbiAgICAgIHZhciBjYiA9IHNlbGYucGFyYW1XYXRjaGVycyAmJiBzZWxmLnBhcmFtV2F0Y2hlcnNba2V5XVxuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIGNiLmNhbGwoc2VsZiwgdmFsLCBvbGRWYWwpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxlZCA9IHRydWVcbiAgICB9XG4gIH0sIHtcbiAgICBpbW1lZGlhdGU6IHRydWVcbiAgfSlcbiAgOyh0aGlzLl9wYXJhbVVud2F0Y2hGbnMgfHwgKHRoaXMuX3BhcmFtVW53YXRjaEZucyA9IFtdKSkucHVzaCh1bndhdGNoKVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBkaXJlY3RpdmUgaXMgYSBmdW5jdGlvbiBjYWxsZXJcbiAqIGFuZCBpZiB0aGUgZXhwcmVzc2lvbiBpcyBhIGNhbGxhYmxlIG9uZS4gSWYgYm90aCB0cnVlLFxuICogd2Ugd3JhcCB1cCB0aGUgZXhwcmVzc2lvbiBhbmQgdXNlIGl0IGFzIHRoZSBldmVudFxuICogaGFuZGxlci5cbiAqXG4gKiBlLmcuIG9uLWNsaWNrPVwiYSsrXCJcbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbkRpcmVjdGl2ZS5wcm90b3R5cGUuX2NoZWNrU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMuZXhwcmVzc2lvblxuICBpZiAoXG4gICAgZXhwcmVzc2lvbiAmJiB0aGlzLmFjY2VwdFN0YXRlbWVudCAmJlxuICAgICFleHBQYXJzZXIuaXNTaW1wbGVQYXRoKGV4cHJlc3Npb24pXG4gICkge1xuICAgIHZhciBmbiA9IGV4cFBhcnNlci5wYXJzZShleHByZXNzaW9uKS5nZXRcbiAgICB2YXIgc2NvcGUgPSB0aGlzLl9zY29wZSB8fCB0aGlzLnZtXG4gICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmbi5jYWxsKHNjb3BlLCBzY29wZSlcbiAgICB9XG4gICAgaWYgKHRoaXMuZmlsdGVycykge1xuICAgICAgaGFuZGxlciA9IHNjb3BlLl9hcHBseUZpbHRlcnMoaGFuZGxlciwgbnVsbCwgdGhpcy5maWx0ZXJzKVxuICAgIH1cbiAgICB0aGlzLnVwZGF0ZShoYW5kbGVyKVxuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cblxuLyoqXG4gKiBTZXQgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgd2l0aCB0aGUgc2V0dGVyLlxuICogVGhpcyBzaG91bGQgb25seSBiZSB1c2VkIGluIHR3by13YXkgZGlyZWN0aXZlc1xuICogZS5nLiB2LW1vZGVsLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwdWJsaWNcbiAqL1xuXG5EaXJlY3RpdmUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodGhpcy50d29XYXkpIHtcbiAgICB0aGlzLl93aXRoTG9jayhmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl93YXRjaGVyLnNldCh2YWx1ZSlcbiAgICB9KVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBfLndhcm4oXG4gICAgICAnRGlyZWN0aXZlLnNldCgpIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHR3b1dheScgK1xuICAgICAgJ2RpcmVjdGl2ZXMuJ1xuICAgIClcbiAgfVxufVxuXG4vKipcbiAqIEV4ZWN1dGUgYSBmdW5jdGlvbiB3aGlsZSBwcmV2ZW50aW5nIHRoYXQgZnVuY3Rpb24gZnJvbVxuICogdHJpZ2dlcmluZyB1cGRhdGVzIG9uIHRoaXMgZGlyZWN0aXZlIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cblxuRGlyZWN0aXZlLnByb3RvdHlwZS5fd2l0aExvY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHNlbGYuX2xvY2tlZCA9IHRydWVcbiAgZm4uY2FsbChzZWxmKVxuICBfLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9sb2NrZWQgPSBmYWxzZVxuICB9KVxufVxuXG4vKipcbiAqIENvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGF0dGFjaGVzIGEgRE9NIGV2ZW50IGxpc3RlbmVyXG4gKiB0byB0aGUgZGlyZWN0aXZlIGVsZW1lbnQgYW5kIGF1dG9tZXRpY2FsbHkgdGVhcnMgaXQgZG93blxuICogZHVyaW5nIHVuYmluZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAqL1xuXG5EaXJlY3RpdmUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2ZW50LCBoYW5kbGVyKSB7XG4gIF8ub24odGhpcy5lbCwgZXZlbnQsIGhhbmRsZXIpXG4gIDsodGhpcy5fbGlzdGVuZXJzIHx8ICh0aGlzLl9saXN0ZW5lcnMgPSBbXSkpXG4gICAgLnB1c2goW2V2ZW50LCBoYW5kbGVyXSlcbn1cblxuLyoqXG4gKiBUZWFyZG93biB0aGUgd2F0Y2hlciBhbmQgY2FsbCB1bmJpbmQuXG4gKi9cblxuRGlyZWN0aXZlLnByb3RvdHlwZS5fdGVhcmRvd24gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9ib3VuZCkge1xuICAgIHRoaXMuX2JvdW5kID0gZmFsc2VcbiAgICBpZiAodGhpcy51bmJpbmQpIHtcbiAgICAgIHRoaXMudW5iaW5kKClcbiAgICB9XG4gICAgaWYgKHRoaXMuX3dhdGNoZXIpIHtcbiAgICAgIHRoaXMuX3dhdGNoZXIudGVhcmRvd24oKVxuICAgIH1cbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzXG4gICAgdmFyIGlcbiAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICBpID0gbGlzdGVuZXJzLmxlbmd0aFxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBfLm9mZih0aGlzLmVsLCBsaXN0ZW5lcnNbaV1bMF0sIGxpc3RlbmVyc1tpXVsxXSlcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHVud2F0Y2hGbnMgPSB0aGlzLl9wYXJhbVVud2F0Y2hGbnNcbiAgICBpZiAodW53YXRjaEZucykge1xuICAgICAgaSA9IHVud2F0Y2hGbnMubGVuZ3RoXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHVud2F0Y2hGbnNbaV0oKVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0aGlzLmVsKSB7XG4gICAgICB0aGlzLmVsLl92dWVfZGlyZWN0aXZlcy4kcmVtb3ZlKHRoaXMpXG4gICAgfVxuICAgIHRoaXMudm0gPSB0aGlzLmVsID0gdGhpcy5fd2F0Y2hlciA9IHRoaXMuX2xpc3RlbmVycyA9IG51bGxcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERpcmVjdGl2ZVxuIiwiZXhwb3J0cy5zbG90ID0gcmVxdWlyZSgnLi9zbG90JylcbmV4cG9ydHMucGFydGlhbCA9IHJlcXVpcmUoJy4vcGFydGlhbCcpXG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxudmFyIHZJZiA9IHJlcXVpcmUoJy4uL3B1YmxpYy9pZicpXG52YXIgRnJhZ21lbnRGYWN0b3J5ID0gcmVxdWlyZSgnLi4vLi4vZnJhZ21lbnQvZmFjdG9yeScpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIHByaW9yaXR5OiAxNzUwLFxuXG4gIHBhcmFtczogWyduYW1lJ10sXG5cbiAgLy8gd2F0Y2ggY2hhbmdlcyB0byBuYW1lIGZvciBkeW5hbWljIHBhcnRpYWxzXG4gIHBhcmFtV2F0Y2hlcnM6IHtcbiAgICBuYW1lOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHZJZi5yZW1vdmUuY2FsbCh0aGlzKVxuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0KHZhbHVlKVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBiaW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hbmNob3IgPSBfLmNyZWF0ZUFuY2hvcigndi1wYXJ0aWFsJylcbiAgICBfLnJlcGxhY2UodGhpcy5lbCwgdGhpcy5hbmNob3IpXG4gICAgdGhpcy5pbnNlcnQodGhpcy5wYXJhbXMubmFtZSlcbiAgfSxcblxuICBpbnNlcnQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBwYXJ0aWFsID0gXy5yZXNvbHZlQXNzZXQodGhpcy52bS4kb3B0aW9ucywgJ3BhcnRpYWxzJywgaWQpXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIF8uYXNzZXJ0QXNzZXQocGFydGlhbCwgJ3BhcnRpYWwnLCBpZClcbiAgICB9XG4gICAgaWYgKHBhcnRpYWwpIHtcbiAgICAgIHRoaXMuZmFjdG9yeSA9IG5ldyBGcmFnbWVudEZhY3RvcnkodGhpcy52bSwgcGFydGlhbClcbiAgICAgIHZJZi5pbnNlcnQuY2FsbCh0aGlzKVxuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5mcmFnKSB7XG4gICAgICB0aGlzLmZyYWcuZGVzdHJveSgpXG4gICAgfVxuICB9XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxudmFyIHRlbXBsYXRlUGFyc2VyID0gcmVxdWlyZSgnLi4vLi4vcGFyc2Vycy90ZW1wbGF0ZScpXG5cbi8vIFRoaXMgaXMgdGhlIGVsZW1lbnREaXJlY3RpdmUgdGhhdCBoYW5kbGVzIDxjb250ZW50PlxuLy8gdHJhbnNjbHVzaW9ucy4gSXQgcmVsaWVzIG9uIHRoZSByYXcgY29udGVudCBvZiBhblxuLy8gaW5zdGFuY2UgYmVpbmcgc3RvcmVkIGFzIGAkb3B0aW9ucy5fY29udGVudGAgZHVyaW5nXG4vLyB0aGUgdHJhbnNjbHVkZSBwaGFzZS5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgcHJpb3JpdHk6IDE3NTAsXG5cbiAgcGFyYW1zOiBbJ25hbWUnXSxcblxuICBiaW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhvc3QgPSB0aGlzLnZtXG4gICAgdmFyIHJhdyA9IGhvc3QuJG9wdGlvbnMuX2NvbnRlbnRcbiAgICB2YXIgY29udGVudFxuICAgIGlmICghcmF3KSB7XG4gICAgICB0aGlzLmZhbGxiYWNrKClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgY29udGV4dCA9IGhvc3QuX2NvbnRleHRcbiAgICB2YXIgc2xvdE5hbWUgPSB0aGlzLnBhcmFtcy5uYW1lXG4gICAgaWYgKCFzbG90TmFtZSkge1xuICAgICAgLy8gRGVmYXVsdCBjb250ZW50XG4gICAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICAgIHZhciBjb21waWxlRGVmYXVsdENvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuY29tcGlsZShcbiAgICAgICAgICBleHRyYWN0RnJhZ21lbnQocmF3LmNoaWxkTm9kZXMsIHJhdywgdHJ1ZSksXG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICBob3N0XG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIGlmICghaG9zdC5faXNDb21waWxlZCkge1xuICAgICAgICAvLyBkZWZlciB1bnRpbCB0aGUgZW5kIG9mIGluc3RhbmNlIGNvbXBpbGF0aW9uLFxuICAgICAgICAvLyBiZWNhdXNlIHRoZSBkZWZhdWx0IG91dGxldCBtdXN0IHdhaXQgdW50aWwgYWxsXG4gICAgICAgIC8vIG90aGVyIHBvc3NpYmxlIG91dGxldHMgd2l0aCBzZWxlY3RvcnMgaGF2ZSBwaWNrZWRcbiAgICAgICAgLy8gb3V0IHRoZWlyIGNvbnRlbnRzLlxuICAgICAgICBob3N0LiRvbmNlKCdob29rOmNvbXBpbGVkJywgY29tcGlsZURlZmF1bHRDb250ZW50KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcGlsZURlZmF1bHRDb250ZW50KClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNlbGVjdG9yID0gJ1tzbG90PVwiJyArIHNsb3ROYW1lICsgJ1wiXSdcbiAgICAgIHZhciBub2RlcyA9IHJhdy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKVxuICAgICAgaWYgKG5vZGVzLmxlbmd0aCkge1xuICAgICAgICBjb250ZW50ID0gZXh0cmFjdEZyYWdtZW50KG5vZGVzLCByYXcpXG4gICAgICAgIGlmIChjb250ZW50Lmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgIHRoaXMuY29tcGlsZShjb250ZW50LCBjb250ZXh0LCBob3N0KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZmFsbGJhY2soKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZhbGxiYWNrKClcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZmFsbGJhY2s6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNvbXBpbGUoXy5leHRyYWN0Q29udGVudCh0aGlzLmVsLCB0cnVlKSwgdGhpcy52bSlcbiAgfSxcblxuICBjb21waWxlOiBmdW5jdGlvbiAoY29udGVudCwgY29udGV4dCwgaG9zdCkge1xuICAgIGlmIChjb250ZW50ICYmIGNvbnRleHQpIHtcbiAgICAgIHZhciBzY29wZSA9IGhvc3RcbiAgICAgICAgPyBob3N0Ll9zY29wZVxuICAgICAgICA6IHRoaXMuX3Njb3BlXG4gICAgICB0aGlzLnVubGluayA9IGNvbnRleHQuJGNvbXBpbGUoXG4gICAgICAgIGNvbnRlbnQsIGhvc3QsIHNjb3BlLCB0aGlzLl9mcmFnXG4gICAgICApXG4gICAgfVxuICAgIGlmIChjb250ZW50KSB7XG4gICAgICBfLnJlcGxhY2UodGhpcy5lbCwgY29udGVudClcbiAgICB9IGVsc2Uge1xuICAgICAgXy5yZW1vdmUodGhpcy5lbClcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMudW5saW5rKSB7XG4gICAgICB0aGlzLnVubGluaygpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRXh0cmFjdCBxdWFsaWZpZWQgY29udGVudCBub2RlcyBmcm9tIGEgbm9kZSBsaXN0LlxuICpcbiAqIEBwYXJhbSB7Tm9kZUxpc3R9IG5vZGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHBhcmVudFxuICogQHBhcmFtIHtCb29sZWFufSBtYWluXG4gKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fVxuICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RGcmFnbWVudCAobm9kZXMsIHBhcmVudCwgbWFpbikge1xuICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBub2RlID0gbm9kZXNbaV1cbiAgICAvLyBpZiB0aGlzIGlzIHRoZSBtYWluIG91dGxldCwgd2Ugd2FudCB0byBza2lwIGFsbFxuICAgIC8vIHByZXZpb3VzbHkgc2VsZWN0ZWQgbm9kZXM7XG4gICAgLy8gb3RoZXJ3aXNlLCB3ZSB3YW50IHRvIG1hcmsgdGhlIG5vZGUgYXMgc2VsZWN0ZWQuXG4gICAgLy8gY2xvbmUgdGhlIG5vZGUgc28gdGhlIG9yaWdpbmFsIHJhdyBjb250ZW50IHJlbWFpbnNcbiAgICAvLyBpbnRhY3QuIHRoaXMgZW5zdXJlcyBwcm9wZXIgcmUtY29tcGlsYXRpb24gaW4gY2FzZXNcbiAgICAvLyB3aGVyZSB0aGUgb3V0bGV0IGlzIGluc2lkZSBhIGNvbmRpdGlvbmFsIGJsb2NrXG4gICAgaWYgKG1haW4gJiYgIW5vZGUuX192X3NlbGVjdGVkKSB7XG4gICAgICBhcHBlbmQobm9kZSlcbiAgICB9IGVsc2UgaWYgKCFtYWluICYmIG5vZGUucGFyZW50Tm9kZSA9PT0gcGFyZW50KSB7XG4gICAgICBub2RlLl9fdl9zZWxlY3RlZCA9IHRydWVcbiAgICAgIGFwcGVuZChub2RlKVxuICAgIH1cbiAgfVxuICByZXR1cm4gZnJhZ1xuXG4gIGZ1bmN0aW9uIGFwcGVuZCAobm9kZSkge1xuICAgIGlmIChfLmlzVGVtcGxhdGUobm9kZSkgJiZcbiAgICAgICAgIW5vZGUuaGFzQXR0cmlidXRlKCd2LWlmJykgJiZcbiAgICAgICAgIW5vZGUuaGFzQXR0cmlidXRlKCd2LWZvcicpKSB7XG4gICAgICBub2RlID0gdGVtcGxhdGVQYXJzZXIucGFyc2Uobm9kZSlcbiAgICB9XG4gICAgbm9kZSA9IHRlbXBsYXRlUGFyc2VyLmNsb25lKG5vZGUpXG4gICAgZnJhZy5hcHBlbmRDaGlsZChub2RlKVxuICB9XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxudmFyIGFkZENsYXNzID0gXy5hZGRDbGFzc1xudmFyIHJlbW92ZUNsYXNzID0gXy5yZW1vdmVDbGFzc1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICBkZWVwOiB0cnVlLFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuaGFuZGxlT2JqZWN0KHN0cmluZ1RvT2JqZWN0KHZhbHVlKSlcbiAgICB9IGVsc2UgaWYgKF8uaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHRoaXMuaGFuZGxlT2JqZWN0KHZhbHVlKVxuICAgIH0gZWxzZSBpZiAoXy5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdGhpcy5oYW5kbGVBcnJheSh2YWx1ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jbGVhbnVwKClcbiAgICB9XG4gIH0sXG5cbiAgaGFuZGxlT2JqZWN0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLmNsZWFudXAodmFsdWUpXG4gICAgdmFyIGtleXMgPSB0aGlzLnByZXZLZXlzID0gT2JqZWN0LmtleXModmFsdWUpXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV1cbiAgICAgIGlmICh2YWx1ZVtrZXldKSB7XG4gICAgICAgIGFkZENsYXNzKHRoaXMuZWwsIGtleSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZUNsYXNzKHRoaXMuZWwsIGtleSlcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgaGFuZGxlQXJyYXk6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMuY2xlYW51cCh2YWx1ZSlcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHZhbHVlW2ldKSB7XG4gICAgICAgIGFkZENsYXNzKHRoaXMuZWwsIHZhbHVlW2ldKVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnByZXZLZXlzID0gdmFsdWUuc2xpY2UoKVxuICB9LFxuXG4gIGNsZWFudXA6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnByZXZLZXlzKSB7XG4gICAgICB2YXIgaSA9IHRoaXMucHJldktleXMubGVuZ3RoXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHZhciBrZXkgPSB0aGlzLnByZXZLZXlzW2ldXG4gICAgICAgIGlmIChrZXkgJiYgKCF2YWx1ZSB8fCAhY29udGFpbnModmFsdWUsIGtleSkpKSB7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5lbCwga2V5KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0cmluZ1RvT2JqZWN0ICh2YWx1ZSkge1xuICB2YXIgcmVzID0ge31cbiAgdmFyIGtleXMgPSB2YWx1ZS50cmltKCkuc3BsaXQoL1xccysvKVxuICB2YXIgaSA9IGtleXMubGVuZ3RoXG4gIHdoaWxlIChpLS0pIHtcbiAgICByZXNba2V5c1tpXV0gPSB0cnVlXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjb250YWlucyAodmFsdWUsIGtleSkge1xuICByZXR1cm4gXy5pc0FycmF5KHZhbHVlKVxuICAgID8gdmFsdWUuaW5kZXhPZihrZXkpID4gLTFcbiAgICA6IHZhbHVlLmhhc093blByb3BlcnR5KGtleSlcbn1cbiIsInZhciBfID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpXG52YXIgdGVtcGxhdGVQYXJzZXIgPSByZXF1aXJlKCcuLi8uLi9wYXJzZXJzL3RlbXBsYXRlJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgcHJpb3JpdHk6IDE1MDAsXG5cbiAgcGFyYW1zOiBbXG4gICAgJ2tlZXAtYWxpdmUnLFxuICAgICd0cmFuc2l0aW9uLW1vZGUnLFxuICAgICdpbmxpbmUtdGVtcGxhdGUnXG4gIF0sXG5cbiAgLyoqXG4gICAqIFNldHVwLiBUd28gcG9zc2libGUgdXNhZ2VzOlxuICAgKlxuICAgKiAtIHN0YXRpYzpcbiAgICogICA8Y29tcD4gb3IgPGRpdiB2LWNvbXBvbmVudD1cImNvbXBcIj5cbiAgICpcbiAgICogLSBkeW5hbWljOlxuICAgKiAgIDxjb21wb25lbnQgOmlzPVwidmlld1wiPlxuICAgKi9cblxuICBiaW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmVsLl9fdnVlX18pIHtcbiAgICAgIC8vIGNoZWNrIHJlZlxuICAgICAgdGhpcy5yZWYgPSBfLmZpbmRSZWYodGhpcy5lbClcbiAgICAgIHZhciByZWZzID0gKHRoaXMuX3Njb3BlIHx8IHRoaXMudm0pLiRyZWZzXG4gICAgICBpZiAodGhpcy5yZWYgJiYgIXJlZnMuaGFzT3duUHJvcGVydHkodGhpcy5yZWYpKSB7XG4gICAgICAgIF8uZGVmaW5lUmVhY3RpdmUocmVmcywgdGhpcy5yZWYsIG51bGwpXG4gICAgICB9XG4gICAgICAvLyBrZWVwLWFsaXZlIGNhY2hlXG4gICAgICB0aGlzLmtlZXBBbGl2ZSA9IHRoaXMucGFyYW1zLmtlZXBBbGl2ZVxuICAgICAgaWYgKHRoaXMua2VlcEFsaXZlKSB7XG4gICAgICAgIHRoaXMuY2FjaGUgPSB7fVxuICAgICAgfVxuICAgICAgLy8gY2hlY2sgaW5saW5lLXRlbXBsYXRlXG4gICAgICBpZiAodGhpcy5wYXJhbXMuaW5saW5lVGVtcGxhdGUpIHtcbiAgICAgICAgLy8gZXh0cmFjdCBpbmxpbmUgdGVtcGxhdGUgYXMgYSBEb2N1bWVudEZyYWdtZW50XG4gICAgICAgIHRoaXMuaW5saW5lVGVtcGxhdGUgPSBfLmV4dHJhY3RDb250ZW50KHRoaXMuZWwsIHRydWUpXG4gICAgICB9XG4gICAgICAvLyBjb21wb25lbnQgcmVzb2x1dGlvbiByZWxhdGVkIHN0YXRlXG4gICAgICB0aGlzLnBlbmRpbmdDb21wb25lbnRDYiA9XG4gICAgICB0aGlzLkNvbXBvbmVudCA9IG51bGxcbiAgICAgIC8vIHRyYW5zaXRpb24gcmVsYXRlZCBzdGF0ZVxuICAgICAgdGhpcy5wZW5kaW5nUmVtb3ZhbHMgPSAwXG4gICAgICB0aGlzLnBlbmRpbmdSZW1vdmFsQ2IgPSBudWxsXG4gICAgICAvLyBjaGVjayBkeW5hbWljIGNvbXBvbmVudCBwYXJhbXNcbiAgICAgICAgLy8gY3JlYXRlIGEgcmVmIGFuY2hvclxuICAgICAgdGhpcy5hbmNob3IgPSBfLmNyZWF0ZUFuY2hvcigndi1jb21wb25lbnQnKVxuICAgICAgXy5yZXBsYWNlKHRoaXMuZWwsIHRoaXMuYW5jaG9yKVxuICAgICAgLy8gaWYgc3RhdGljLCBidWlsZCByaWdodCBub3cuXG4gICAgICBpZiAodGhpcy5saXRlcmFsKSB7XG4gICAgICAgIHRoaXMuc2V0Q29tcG9uZW50KHRoaXMuZXhwcmVzc2lvbilcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBfLndhcm4oXG4gICAgICAgICdjYW5ub3QgbW91bnQgY29tcG9uZW50IFwiJyArIHRoaXMuZXhwcmVzc2lvbiArICdcIiAnICtcbiAgICAgICAgJ29uIGFscmVhZHkgbW91bnRlZCBlbGVtZW50OiAnICsgdGhpcy5lbFxuICAgICAgKVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUHVibGljIHVwZGF0ZSwgY2FsbGVkIGJ5IHRoZSB3YXRjaGVyIGluIHRoZSBkeW5hbWljXG4gICAqIGxpdGVyYWwgc2NlbmFyaW8sIGUuZy4gPGNvbXBvbmVudCA6aXM9XCJ2aWV3XCI+XG4gICAqL1xuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKCF0aGlzLmxpdGVyYWwpIHtcbiAgICAgIHRoaXMuc2V0Q29tcG9uZW50KHZhbHVlKVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU3dpdGNoIGR5bmFtaWMgY29tcG9uZW50cy4gTWF5IHJlc29sdmUgdGhlIGNvbXBvbmVudFxuICAgKiBhc3luY2hyb25vdXNseSwgYW5kIHBlcmZvcm0gdHJhbnNpdGlvbiBiYXNlZCBvblxuICAgKiBzcGVjaWZpZWQgdHJhbnNpdGlvbiBtb2RlLiBBY2NlcHRzIGEgZmV3IGFkZGl0aW9uYWxcbiAgICogYXJndW1lbnRzIHNwZWNpZmljYWxseSBmb3IgdnVlLXJvdXRlci5cbiAgICpcbiAgICogVGhlIGNhbGxiYWNrIGlzIGNhbGxlZCB3aGVuIHRoZSBmdWxsIHRyYW5zaXRpb24gaXNcbiAgICogZmluaXNoZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqL1xuXG4gIHNldENvbXBvbmVudDogZnVuY3Rpb24gKHZhbHVlLCBjYikge1xuICAgIHRoaXMuaW52YWxpZGF0ZVBlbmRpbmcoKVxuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIC8vIGp1c3QgcmVtb3ZlIGN1cnJlbnRcbiAgICAgIHRoaXMudW5idWlsZCh0cnVlKVxuICAgICAgdGhpcy5yZW1vdmUodGhpcy5jaGlsZFZNLCBjYilcbiAgICAgIHRoaXMuY2hpbGRWTSA9IG51bGxcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgICB0aGlzLnJlc29sdmVDb21wb25lbnQodmFsdWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5tb3VudENvbXBvbmVudChjYilcbiAgICAgIH0pXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXNvbHZlIHRoZSBjb21wb25lbnQgY29uc3RydWN0b3IgdG8gdXNlIHdoZW4gY3JlYXRpbmdcbiAgICogdGhlIGNoaWxkIHZtLlxuICAgKi9cblxuICByZXNvbHZlQ29tcG9uZW50OiBmdW5jdGlvbiAoaWQsIGNiKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgdGhpcy5wZW5kaW5nQ29tcG9uZW50Q2IgPSBfLmNhbmNlbGxhYmxlKGZ1bmN0aW9uIChDb21wb25lbnQpIHtcbiAgICAgIHNlbGYuQ29tcG9uZW50TmFtZSA9IENvbXBvbmVudC5vcHRpb25zLm5hbWUgfHwgaWRcbiAgICAgIHNlbGYuQ29tcG9uZW50ID0gQ29tcG9uZW50XG4gICAgICBjYigpXG4gICAgfSlcbiAgICB0aGlzLnZtLl9yZXNvbHZlQ29tcG9uZW50KGlkLCB0aGlzLnBlbmRpbmdDb21wb25lbnRDYilcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIHVzaW5nIHRoZSBjdXJyZW50IGNvbnN0cnVjdG9yIGFuZFxuICAgKiByZXBsYWNlIHRoZSBleGlzdGluZyBpbnN0YW5jZS4gVGhpcyBtZXRob2QgZG9lc24ndCBjYXJlXG4gICAqIHdoZXRoZXIgdGhlIG5ldyBjb21wb25lbnQgYW5kIHRoZSBvbGQgb25lIGFyZSBhY3R1YWxseVxuICAgKiB0aGUgc2FtZS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgKi9cblxuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGNiKSB7XG4gICAgLy8gYWN0dWFsIG1vdW50XG4gICAgdGhpcy51bmJ1aWxkKHRydWUpXG4gICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgdmFyIGFjdGl2YXRlSG9vayA9IHRoaXMuQ29tcG9uZW50Lm9wdGlvbnMuYWN0aXZhdGVcbiAgICB2YXIgY2FjaGVkID0gdGhpcy5nZXRDYWNoZWQoKVxuICAgIHZhciBuZXdDb21wb25lbnQgPSB0aGlzLmJ1aWxkKClcbiAgICBpZiAoYWN0aXZhdGVIb29rICYmICFjYWNoZWQpIHtcbiAgICAgIHRoaXMud2FpdGluZ0ZvciA9IG5ld0NvbXBvbmVudFxuICAgICAgYWN0aXZhdGVIb29rLmNhbGwobmV3Q29tcG9uZW50LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYud2FpdGluZ0ZvciA9IG51bGxcbiAgICAgICAgc2VsZi50cmFuc2l0aW9uKG5ld0NvbXBvbmVudCwgY2IpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRyYW5zaXRpb24obmV3Q29tcG9uZW50LCBjYilcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIGNvbXBvbmVudCBjaGFuZ2VzIG9yIHVuYmluZHMgYmVmb3JlIGFuIGFzeW5jXG4gICAqIGNvbnN0cnVjdG9yIGlzIHJlc29sdmVkLCB3ZSBuZWVkIHRvIGludmFsaWRhdGUgaXRzXG4gICAqIHBlbmRpbmcgY2FsbGJhY2suXG4gICAqL1xuXG4gIGludmFsaWRhdGVQZW5kaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucGVuZGluZ0NvbXBvbmVudENiKSB7XG4gICAgICB0aGlzLnBlbmRpbmdDb21wb25lbnRDYi5jYW5jZWwoKVxuICAgICAgdGhpcy5wZW5kaW5nQ29tcG9uZW50Q2IgPSBudWxsXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbnN0YW50aWF0ZS9pbnNlcnQgYSBuZXcgY2hpbGQgdm0uXG4gICAqIElmIGtlZXAgYWxpdmUgYW5kIGhhcyBjYWNoZWQgaW5zdGFuY2UsIGluc2VydCB0aGF0XG4gICAqIGluc3RhbmNlOyBvdGhlcndpc2UgYnVpbGQgYSBuZXcgb25lIGFuZCBjYWNoZSBpdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtleHRyYU9wdGlvbnNdXG4gICAqIEByZXR1cm4ge1Z1ZX0gLSB0aGUgY3JlYXRlZCBpbnN0YW5jZVxuICAgKi9cblxuICBidWlsZDogZnVuY3Rpb24gKGV4dHJhT3B0aW9ucykge1xuICAgIHZhciBjYWNoZWQgPSB0aGlzLmdldENhY2hlZCgpXG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZFxuICAgIH1cbiAgICBpZiAodGhpcy5Db21wb25lbnQpIHtcbiAgICAgIC8vIGRlZmF1bHQgb3B0aW9uc1xuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIG5hbWU6IHRoaXMuQ29tcG9uZW50TmFtZSxcbiAgICAgICAgZWw6IHRlbXBsYXRlUGFyc2VyLmNsb25lKHRoaXMuZWwpLFxuICAgICAgICB0ZW1wbGF0ZTogdGhpcy5pbmxpbmVUZW1wbGF0ZSxcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRvIGFkZCB0aGUgY2hpbGQgd2l0aCBjb3JyZWN0IHBhcmVudFxuICAgICAgICAvLyBpZiB0aGlzIGlzIGEgdHJhbnNjbHVkZWQgY29tcG9uZW50LCBpdHMgcGFyZW50XG4gICAgICAgIC8vIHNob3VsZCBiZSB0aGUgdHJhbnNjbHVzaW9uIGhvc3QuXG4gICAgICAgIHBhcmVudDogdGhpcy5faG9zdCB8fCB0aGlzLnZtLFxuICAgICAgICAvLyBpZiBubyBpbmxpbmUtdGVtcGxhdGUsIHRoZW4gdGhlIGNvbXBpbGVkXG4gICAgICAgIC8vIGxpbmtlciBjYW4gYmUgY2FjaGVkIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuXG4gICAgICAgIF9saW5rZXJDYWNoYWJsZTogIXRoaXMuaW5saW5lVGVtcGxhdGUsXG4gICAgICAgIF9yZWY6IHRoaXMucmVmLFxuICAgICAgICBfYXNDb21wb25lbnQ6IHRydWUsXG4gICAgICAgIF9pc1JvdXRlclZpZXc6IHRoaXMuX2lzUm91dGVyVmlldyxcbiAgICAgICAgLy8gaWYgdGhpcyBpcyBhIHRyYW5zY2x1ZGVkIGNvbXBvbmVudCwgY29udGV4dFxuICAgICAgICAvLyB3aWxsIGJlIHRoZSBjb21tb24gcGFyZW50IHZtIG9mIHRoaXMgaW5zdGFuY2VcbiAgICAgICAgLy8gYW5kIGl0cyBob3N0LlxuICAgICAgICBfY29udGV4dDogdGhpcy52bSxcbiAgICAgICAgLy8gaWYgdGhpcyBpcyBpbnNpZGUgYW4gaW5saW5lIHYtZm9yLCB0aGUgc2NvcGVcbiAgICAgICAgLy8gd2lsbCBiZSB0aGUgaW50ZXJtZWRpYXRlIHNjb3BlIGNyZWF0ZWQgZm9yIHRoaXNcbiAgICAgICAgLy8gcmVwZWF0IGZyYWdtZW50LiB0aGlzIGlzIHVzZWQgZm9yIGxpbmtpbmcgcHJvcHNcbiAgICAgICAgLy8gYW5kIGNvbnRhaW5lciBkaXJlY3RpdmVzLlxuICAgICAgICBfc2NvcGU6IHRoaXMuX3Njb3BlLFxuICAgICAgICAvLyBwYXNzIGluIHRoZSBvd25lciBmcmFnbWVudCBvZiB0aGlzIGNvbXBvbmVudC5cbiAgICAgICAgLy8gdGhpcyBpcyBuZWNlc3Nhcnkgc28gdGhhdCB0aGUgZnJhZ21lbnQgY2FuIGtlZXBcbiAgICAgICAgLy8gdHJhY2sgb2YgaXRzIGNvbnRhaW5lZCBjb21wb25lbnRzIGluIG9yZGVyIHRvXG4gICAgICAgIC8vIGNhbGwgYXR0YWNoL2RldGFjaCBob29rcyBmb3IgdGhlbS5cbiAgICAgICAgX2ZyYWc6IHRoaXMuX2ZyYWdcbiAgICAgIH1cbiAgICAgIC8vIGV4dHJhIG9wdGlvbnNcbiAgICAgIC8vIGluIDEuMC4wIHRoaXMgaXMgdXNlZCBieSB2dWUtcm91dGVyIG9ubHlcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGV4dHJhT3B0aW9ucykge1xuICAgICAgICBfLmV4dGVuZChvcHRpb25zLCBleHRyYU9wdGlvbnMpXG4gICAgICB9XG4gICAgICB2YXIgY2hpbGQgPSBuZXcgdGhpcy5Db21wb25lbnQob3B0aW9ucylcbiAgICAgIGlmICh0aGlzLmtlZXBBbGl2ZSkge1xuICAgICAgICB0aGlzLmNhY2hlW3RoaXMuQ29tcG9uZW50LmNpZF0gPSBjaGlsZFxuICAgICAgfVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgIHRoaXMuZWwuaGFzQXR0cmlidXRlKCd0cmFuc2l0aW9uJykgJiZcbiAgICAgICAgICBjaGlsZC5faXNGcmFnbWVudCkge1xuICAgICAgICBfLndhcm4oXG4gICAgICAgICAgJ1RyYW5zaXRpb25zIHdpbGwgbm90IHdvcmsgb24gYSBmcmFnbWVudCBpbnN0YW5jZS4gJyArXG4gICAgICAgICAgJ1RlbXBsYXRlOiAnICsgY2hpbGQuJG9wdGlvbnMudGVtcGxhdGVcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNoaWxkXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBUcnkgdG8gZ2V0IGEgY2FjaGVkIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IGNvbXBvbmVudC5cbiAgICpcbiAgICogQHJldHVybiB7VnVlfHVuZGVmaW5lZH1cbiAgICovXG5cbiAgZ2V0Q2FjaGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMua2VlcEFsaXZlICYmIHRoaXMuY2FjaGVbdGhpcy5Db21wb25lbnQuY2lkXVxuICB9LFxuXG4gIC8qKlxuICAgKiBUZWFyZG93biB0aGUgY3VycmVudCBjaGlsZCwgYnV0IGRlZmVycyBjbGVhbnVwIHNvXG4gICAqIHRoYXQgd2UgY2FuIHNlcGFyYXRlIHRoZSBkZXN0cm95IGFuZCByZW1vdmFsIHN0ZXBzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRlZmVyXG4gICAqL1xuXG4gIHVuYnVpbGQ6IGZ1bmN0aW9uIChkZWZlcikge1xuICAgIGlmICh0aGlzLndhaXRpbmdGb3IpIHtcbiAgICAgIHRoaXMud2FpdGluZ0Zvci4kZGVzdHJveSgpXG4gICAgICB0aGlzLndhaXRpbmdGb3IgPSBudWxsXG4gICAgfVxuICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRWTVxuICAgIGlmICghY2hpbGQgfHwgdGhpcy5rZWVwQWxpdmUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyB0aGUgc29sZSBwdXJwb3NlIG9mIGBkZWZlckNsZWFudXBgIGlzIHNvIHRoYXQgd2UgY2FuXG4gICAgLy8gXCJkZWFjdGl2YXRlXCIgdGhlIHZtIHJpZ2h0IG5vdyBhbmQgcGVyZm9ybSBET00gcmVtb3ZhbFxuICAgIC8vIGxhdGVyLlxuICAgIGNoaWxkLiRkZXN0cm95KGZhbHNlLCBkZWZlcilcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlIGN1cnJlbnQgZGVzdHJveWVkIGNoaWxkIGFuZCBtYW51YWxseSBkb1xuICAgKiB0aGUgY2xlYW51cCBhZnRlciByZW1vdmFsLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgKi9cblxuICByZW1vdmU6IGZ1bmN0aW9uIChjaGlsZCwgY2IpIHtcbiAgICB2YXIga2VlcEFsaXZlID0gdGhpcy5rZWVwQWxpdmVcbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIC8vIHdlIG1heSBoYXZlIGEgY29tcG9uZW50IHN3aXRjaCB3aGVuIGEgcHJldmlvdXNcbiAgICAgIC8vIGNvbXBvbmVudCBpcyBzdGlsbCBiZWluZyB0cmFuc2l0aW9uZWQgb3V0LlxuICAgICAgLy8gd2Ugd2FudCB0byB0cmlnZ2VyIG9ubHkgb25lIGxhc3Rlc3QgaW5zZXJ0aW9uIGNiXG4gICAgICAvLyB3aGVuIHRoZSBleGlzdGluZyB0cmFuc2l0aW9uIGZpbmlzaGVzLiAoIzExMTkpXG4gICAgICB0aGlzLnBlbmRpbmdSZW1vdmFscysrXG4gICAgICB0aGlzLnBlbmRpbmdSZW1vdmFsQ2IgPSBjYlxuICAgICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgICBjaGlsZC4kcmVtb3ZlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5wZW5kaW5nUmVtb3ZhbHMtLVxuICAgICAgICBpZiAoIWtlZXBBbGl2ZSkgY2hpbGQuX2NsZWFudXAoKVxuICAgICAgICBpZiAoIXNlbGYucGVuZGluZ1JlbW92YWxzICYmIHNlbGYucGVuZGluZ1JlbW92YWxDYikge1xuICAgICAgICAgIHNlbGYucGVuZGluZ1JlbW92YWxDYigpXG4gICAgICAgICAgc2VsZi5wZW5kaW5nUmVtb3ZhbENiID0gbnVsbFxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0gZWxzZSBpZiAoY2IpIHtcbiAgICAgIGNiKClcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFjdHVhbGx5IHN3YXAgdGhlIGNvbXBvbmVudHMsIGRlcGVuZGluZyBvbiB0aGVcbiAgICogdHJhbnNpdGlvbiBtb2RlLiBEZWZhdWx0cyB0byBzaW11bHRhbmVvdXMuXG4gICAqXG4gICAqIEBwYXJhbSB7VnVlfSB0YXJnZXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgKi9cblxuICB0cmFuc2l0aW9uOiBmdW5jdGlvbiAodGFyZ2V0LCBjYikge1xuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5jaGlsZFZNXG4gICAgLy8gZm9yIGRldnRvb2wgaW5zcGVjdGlvblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoY3VycmVudCkgY3VycmVudC5faW5hY3RpdmUgPSB0cnVlXG4gICAgICB0YXJnZXQuX2luYWN0aXZlID0gZmFsc2VcbiAgICB9XG4gICAgdGhpcy5jaGlsZFZNID0gdGFyZ2V0XG4gICAgc3dpdGNoIChzZWxmLnBhcmFtcy50cmFuc2l0aW9uTW9kZSkge1xuICAgICAgY2FzZSAnaW4tb3V0JzpcbiAgICAgICAgdGFyZ2V0LiRiZWZvcmUoc2VsZi5hbmNob3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzZWxmLnJlbW92ZShjdXJyZW50LCBjYilcbiAgICAgICAgfSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ291dC1pbic6XG4gICAgICAgIHNlbGYucmVtb3ZlKGN1cnJlbnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0YXJnZXQuJGJlZm9yZShzZWxmLmFuY2hvciwgY2IpXG4gICAgICAgIH0pXG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzZWxmLnJlbW92ZShjdXJyZW50KVxuICAgICAgICB0YXJnZXQuJGJlZm9yZShzZWxmLmFuY2hvciwgY2IpXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBVbmJpbmQuXG4gICAqL1xuXG4gIHVuYmluZDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaW52YWxpZGF0ZVBlbmRpbmcoKVxuICAgIC8vIERvIG5vdCBkZWZlciBjbGVhbnVwIHdoZW4gdW5iaW5kaW5nXG4gICAgdGhpcy51bmJ1aWxkKClcbiAgICAvLyBkZXN0cm95IGFsbCBrZWVwLWFsaXZlIGNhY2hlZCBpbnN0YW5jZXNcbiAgICBpZiAodGhpcy5jYWNoZSkge1xuICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuY2FjaGUpIHtcbiAgICAgICAgdGhpcy5jYWNoZVtrZXldLiRkZXN0cm95KClcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FjaGUgPSBudWxsXG4gICAgfVxuICB9XG59XG4iLCJleHBvcnRzLnN0eWxlID0gcmVxdWlyZSgnLi9zdHlsZScpXG5leHBvcnRzWydjbGFzcyddID0gcmVxdWlyZSgnLi9jbGFzcycpXG5leHBvcnRzLmNvbXBvbmVudCA9IHJlcXVpcmUoJy4vY29tcG9uZW50JylcbmV4cG9ydHMucHJvcCA9IHJlcXVpcmUoJy4vcHJvcCcpXG5leHBvcnRzLnRyYW5zaXRpb24gPSByZXF1aXJlKCcuL3RyYW5zaXRpb24nKVxuIiwiLy8gTk9URTogdGhlIHByb3AgaW50ZXJuYWwgZGlyZWN0aXZlIGlzIGNvbXBpbGVkIGFuZCBsaW5rZWRcbi8vIGR1cmluZyBfaW5pdFNjb3BlKCksIGJlZm9yZSB0aGUgY3JlYXRlZCBob29rIGlzIGNhbGxlZC5cbi8vIFRoZSBwdXJwb3NlIGlzIHRvIG1ha2UgdGhlIGluaXRpYWwgcHJvcCB2YWx1ZXMgYXZhaWxhYmxlXG4vLyBpbnNpZGUgYGNyZWF0ZWRgIGhvb2tzIGFuZCBgZGF0YWAgZnVuY3Rpb25zLlxuXG52YXIgXyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxudmFyIFdhdGNoZXIgPSByZXF1aXJlKCcuLi8uLi93YXRjaGVyJylcbnZhciBiaW5kaW5nTW9kZXMgPSByZXF1aXJlKCcuLi8uLi9jb25maWcnKS5fcHJvcEJpbmRpbmdNb2Rlc1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICBiaW5kOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgY2hpbGQgPSB0aGlzLnZtXG4gICAgdmFyIHBhcmVudCA9IGNoaWxkLl9jb250ZXh0XG4gICAgLy8gcGFzc2VkIGluIGZyb20gY29tcGlsZXIgZGlyZWN0bHlcbiAgICB2YXIgcHJvcCA9IHRoaXMuZGVzY3JpcHRvci5wcm9wXG4gICAgdmFyIGNoaWxkS2V5ID0gcHJvcC5wYXRoXG4gICAgdmFyIHBhcmVudEtleSA9IHByb3AucGFyZW50UGF0aFxuICAgIHZhciB0d29XYXkgPSBwcm9wLm1vZGUgPT09IGJpbmRpbmdNb2Rlcy5UV09fV0FZXG5cbiAgICB2YXIgcGFyZW50V2F0Y2hlciA9IHRoaXMucGFyZW50V2F0Y2hlciA9IG5ldyBXYXRjaGVyKFxuICAgICAgcGFyZW50LFxuICAgICAgcGFyZW50S2V5LFxuICAgICAgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICBpZiAoXy5hc3NlcnRQcm9wKHByb3AsIHZhbCkpIHtcbiAgICAgICAgICBjaGlsZFtjaGlsZEtleV0gPSB2YWxcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICB0d29XYXk6IHR3b1dheSxcbiAgICAgICAgZmlsdGVyczogcHJvcC5maWx0ZXJzLFxuICAgICAgICAvLyBpbXBvcnRhbnQ6IHByb3BzIG5lZWQgdG8gYmUgb2JzZXJ2ZWQgb24gdGhlXG4gICAgICAgIC8vIHYtZm9yIHNjb3BlIGlmIHByZXNlbnRcbiAgICAgICAgc2NvcGU6IHRoaXMuX3Njb3BlXG4gICAgICB9XG4gICAgKVxuXG4gICAgLy8gc2V0IHRoZSBjaGlsZCBpbml0aWFsIHZhbHVlLlxuICAgIF8uaW5pdFByb3AoY2hpbGQsIHByb3AsIHBhcmVudFdhdGNoZXIudmFsdWUpXG5cbiAgICAvLyBzZXR1cCB0d28td2F5IGJpbmRpbmdcbiAgICBpZiAodHdvV2F5KSB7XG4gICAgICAvLyBpbXBvcnRhbnQ6IGRlZmVyIHRoZSBjaGlsZCB3YXRjaGVyIGNyZWF0aW9uIHVudGlsXG4gICAgICAvLyB0aGUgY3JlYXRlZCBob29rIChhZnRlciBkYXRhIG9ic2VydmF0aW9uKVxuICAgICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgICBjaGlsZC4kb25jZSgnaG9vazpjcmVhdGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLmNoaWxkV2F0Y2hlciA9IG5ldyBXYXRjaGVyKFxuICAgICAgICAgIGNoaWxkLFxuICAgICAgICAgIGNoaWxkS2V5LFxuICAgICAgICAgIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHBhcmVudFdhdGNoZXIuc2V0KHZhbClcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIH0pXG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucGFyZW50V2F0Y2hlci50ZWFyZG93bigpXG4gICAgaWYgKHRoaXMuY2hpbGRXYXRjaGVyKSB7XG4gICAgICB0aGlzLmNoaWxkV2F0Y2hlci50ZWFyZG93bigpXG4gICAgfVxuICB9XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxudmFyIHByZWZpeGVzID0gWyctd2Via2l0LScsICctbW96LScsICctbXMtJ11cbnZhciBjYW1lbFByZWZpeGVzID0gWydXZWJraXQnLCAnTW96JywgJ21zJ11cbnZhciBpbXBvcnRhbnRSRSA9IC8haW1wb3J0YW50Oz8kL1xudmFyIHRlc3RFbCA9IG51bGxcbnZhciBwcm9wQ2FjaGUgPSB7fVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICBkZWVwOiB0cnVlLFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuZWwuc3R5bGUuY3NzVGV4dCA9IHZhbHVlXG4gICAgfSBlbHNlIGlmIChfLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB0aGlzLmhhbmRsZU9iamVjdCh2YWx1ZS5yZWR1Y2UoXy5leHRlbmQsIHt9KSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oYW5kbGVPYmplY3QodmFsdWUgfHwge30pXG4gICAgfVxuICB9LFxuXG4gIGhhbmRsZU9iamVjdDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gY2FjaGUgb2JqZWN0IHN0eWxlcyBzbyB0aGF0IG9ubHkgY2hhbmdlZCBwcm9wc1xuICAgIC8vIGFyZSBhY3R1YWxseSB1cGRhdGVkLlxuICAgIHZhciBjYWNoZSA9IHRoaXMuY2FjaGUgfHwgKHRoaXMuY2FjaGUgPSB7fSlcbiAgICB2YXIgbmFtZSwgdmFsXG4gICAgZm9yIChuYW1lIGluIGNhY2hlKSB7XG4gICAgICBpZiAoIShuYW1lIGluIHZhbHVlKSkge1xuICAgICAgICB0aGlzLmhhbmRsZVNpbmdsZShuYW1lLCBudWxsKVxuICAgICAgICBkZWxldGUgY2FjaGVbbmFtZV1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChuYW1lIGluIHZhbHVlKSB7XG4gICAgICB2YWwgPSB2YWx1ZVtuYW1lXVxuICAgICAgaWYgKHZhbCAhPT0gY2FjaGVbbmFtZV0pIHtcbiAgICAgICAgY2FjaGVbbmFtZV0gPSB2YWxcbiAgICAgICAgdGhpcy5oYW5kbGVTaW5nbGUobmFtZSwgdmFsKVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBoYW5kbGVTaW5nbGU6IGZ1bmN0aW9uIChwcm9wLCB2YWx1ZSkge1xuICAgIHByb3AgPSBub3JtYWxpemUocHJvcClcbiAgICBpZiAoIXByb3ApIHJldHVybiAvLyB1bnN1cHBvcnRlZCBwcm9wXG4gICAgLy8gY2FzdCBwb3NzaWJsZSBudW1iZXJzL2Jvb2xlYW5zIGludG8gc3RyaW5nc1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB2YWx1ZSArPSAnJ1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdmFyIGlzSW1wb3J0YW50ID0gaW1wb3J0YW50UkUudGVzdCh2YWx1ZSlcbiAgICAgICAgPyAnaW1wb3J0YW50J1xuICAgICAgICA6ICcnXG4gICAgICBpZiAoaXNJbXBvcnRhbnQpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKGltcG9ydGFudFJFLCAnJykudHJpbSgpXG4gICAgICB9XG4gICAgICB0aGlzLmVsLnN0eWxlLnNldFByb3BlcnR5KHByb3AsIHZhbHVlLCBpc0ltcG9ydGFudClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShwcm9wKVxuICAgIH1cbiAgfVxuXG59XG5cbi8qKlxuICogTm9ybWFsaXplIGEgQ1NTIHByb3BlcnR5IG5hbWUuXG4gKiAtIGNhY2hlIHJlc3VsdFxuICogLSBhdXRvIHByZWZpeFxuICogLSBjYW1lbENhc2UgLT4gZGFzaC1jYXNlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemUgKHByb3ApIHtcbiAgaWYgKHByb3BDYWNoZVtwcm9wXSkge1xuICAgIHJldHVybiBwcm9wQ2FjaGVbcHJvcF1cbiAgfVxuICB2YXIgcmVzID0gcHJlZml4KHByb3ApXG4gIHByb3BDYWNoZVtwcm9wXSA9IHByb3BDYWNoZVtyZXNdID0gcmVzXG4gIHJldHVybiByZXNcbn1cblxuLyoqXG4gKiBBdXRvIGRldGVjdCB0aGUgYXBwcm9wcmlhdGUgcHJlZml4IGZvciBhIENTUyBwcm9wZXJ0eS5cbiAqIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxpcmlzaC81MjM2OTJcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIHByZWZpeCAocHJvcCkge1xuICBwcm9wID0gXy5oeXBoZW5hdGUocHJvcClcbiAgdmFyIGNhbWVsID0gXy5jYW1lbGl6ZShwcm9wKVxuICB2YXIgdXBwZXIgPSBjYW1lbC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGNhbWVsLnNsaWNlKDEpXG4gIGlmICghdGVzdEVsKSB7XG4gICAgdGVzdEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgfVxuICBpZiAoY2FtZWwgaW4gdGVzdEVsLnN0eWxlKSB7XG4gICAgcmV0dXJuIHByb3BcbiAgfVxuICB2YXIgaSA9IHByZWZpeGVzLmxlbmd0aFxuICB2YXIgcHJlZml4ZWRcbiAgd2hpbGUgKGktLSkge1xuICAgIHByZWZpeGVkID0gY2FtZWxQcmVmaXhlc1tpXSArIHVwcGVyXG4gICAgaWYgKHByZWZpeGVkIGluIHRlc3RFbC5zdHlsZSkge1xuICAgICAgcmV0dXJuIHByZWZpeGVzW2ldICsgcHJvcFxuICAgIH1cbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi8uLi91dGlsJylcbnZhciBUcmFuc2l0aW9uID0gcmVxdWlyZSgnLi4vLi4vdHJhbnNpdGlvbi90cmFuc2l0aW9uJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgcHJpb3JpdHk6IDEwMDAsXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiAoaWQsIG9sZElkKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbFxuICAgIC8vIHJlc29sdmUgb24gb3duZXIgdm1cbiAgICB2YXIgaG9va3MgPSBfLnJlc29sdmVBc3NldCh0aGlzLnZtLiRvcHRpb25zLCAndHJhbnNpdGlvbnMnLCBpZClcbiAgICBpZCA9IGlkIHx8ICd2J1xuICAgIC8vIGFwcGx5IG9uIGNsb3Nlc3Qgdm1cbiAgICBlbC5fX3ZfdHJhbnMgPSBuZXcgVHJhbnNpdGlvbihlbCwgaWQsIGhvb2tzLCB0aGlzLmVsLl9fdnVlX18gfHwgdGhpcy52bSlcbiAgICBpZiAob2xkSWQpIHtcbiAgICAgIF8ucmVtb3ZlQ2xhc3MoZWwsIG9sZElkICsgJy10cmFuc2l0aW9uJylcbiAgICB9XG4gICAgXy5hZGRDbGFzcyhlbCwgaWQgKyAnLXRyYW5zaXRpb24nKVxuICB9XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxuXG4vLyB4bGlua1xudmFyIHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaydcbnZhciB4bGlua1JFID0gL154bGluazovXG5cbi8vIHRoZXNlIGlucHV0IGVsZW1lbnQgYXR0cmlidXRlcyBzaG91bGQgYWxzbyBzZXQgdGhlaXJcbi8vIGNvcnJlc3BvbmRpbmcgcHJvcGVydGllc1xudmFyIGlucHV0UHJvcHMgPSB7XG4gIHZhbHVlOiAxLFxuICBjaGVja2VkOiAxLFxuICBzZWxlY3RlZDogMVxufVxuXG4vLyB0aGVzZSBhdHRyaWJ1dGVzIHNob3VsZCBzZXQgYSBoaWRkZW4gcHJvcGVydHkgZm9yXG4vLyBiaW5kaW5nIHYtbW9kZWwgdG8gb2JqZWN0IHZhbHVlc1xudmFyIG1vZGVsUHJvcHMgPSB7XG4gIHZhbHVlOiAnX3ZhbHVlJyxcbiAgJ3RydWUtdmFsdWUnOiAnX3RydWVWYWx1ZScsXG4gICdmYWxzZS12YWx1ZSc6ICdfZmFsc2VWYWx1ZSdcbn1cblxuLy8gY2hlY2sgZm9yIGF0dHJpYnV0ZXMgdGhhdCBwcm9oaWJpdCBpbnRlcnBvbGF0aW9uc1xudmFyIGRpc2FsbG93ZWRJbnRlcnBBdHRyUkUgPSAvXnYtfF46fF5AfF4oaXN8dHJhbnNpdGlvbnx0cmFuc2l0aW9uLW1vZGV8ZGVib3VuY2V8dHJhY2stYnl8c3RhZ2dlcnxlbnRlci1zdGFnZ2VyfGxlYXZlLXN0YWdnZXIpJC9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgcHJpb3JpdHk6IDg1MCxcblxuICBiaW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGF0dHIgPSB0aGlzLmFyZ1xuICAgIHZhciB0YWcgPSB0aGlzLmVsLnRhZ05hbWVcbiAgICAvLyBzaG91bGQgYmUgZGVlcCB3YXRjaCBvbiBvYmplY3QgbW9kZVxuICAgIGlmICghYXR0cikge1xuICAgICAgdGhpcy5kZWVwID0gdHJ1ZVxuICAgIH1cbiAgICAvLyBoYW5kbGUgaW50ZXJwb2xhdGlvbiBiaW5kaW5nc1xuICAgIGlmICh0aGlzLmRlc2NyaXB0b3IuaW50ZXJwKSB7XG4gICAgICAvLyBvbmx5IGFsbG93IGJpbmRpbmcgb24gbmF0aXZlIGF0dHJpYnV0ZXNcbiAgICAgIGlmIChcbiAgICAgICAgZGlzYWxsb3dlZEludGVycEF0dHJSRS50ZXN0KGF0dHIpIHx8XG4gICAgICAgIChhdHRyID09PSAnbmFtZScgJiYgKHRhZyA9PT0gJ1BBUlRJQUwnIHx8IHRhZyA9PT0gJ1NMT1QnKSlcbiAgICAgICkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIF8ud2FybihcbiAgICAgICAgICBhdHRyICsgJz1cIicgKyB0aGlzLmRlc2NyaXB0b3IucmF3ICsgJ1wiOiAnICtcbiAgICAgICAgICAnYXR0cmlidXRlIGludGVycG9sYXRpb24gaXMgbm90IGFsbG93ZWQgaW4gVnVlLmpzICcgK1xuICAgICAgICAgICdkaXJlY3RpdmVzIGFuZCBzcGVjaWFsIGF0dHJpYnV0ZXMuJ1xuICAgICAgICApXG4gICAgICAgIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKGF0dHIpXG4gICAgICAgIHRoaXMuaW52YWxpZCA9IHRydWVcbiAgICAgIH1cblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIgcmF3ID0gYXR0ciArICc9XCInICsgdGhpcy5kZXNjcmlwdG9yLnJhdyArICdcIjogJ1xuICAgICAgICAvLyB3YXJuIHNyY1xuICAgICAgICBpZiAoYXR0ciA9PT0gJ3NyYycpIHtcbiAgICAgICAgICBfLndhcm4oXG4gICAgICAgICAgICByYXcgKyAnaW50ZXJwb2xhdGlvbiBpbiBcInNyY1wiIGF0dHJpYnV0ZSB3aWxsIGNhdXNlICcgK1xuICAgICAgICAgICAgJ2EgNDA0IHJlcXVlc3QuIFVzZSB2LWJpbmQ6c3JjIGluc3RlYWQuJ1xuICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdhcm4gc3R5bGVcbiAgICAgICAgaWYgKGF0dHIgPT09ICdzdHlsZScpIHtcbiAgICAgICAgICBfLndhcm4oXG4gICAgICAgICAgICByYXcgKyAnaW50ZXJwb2xhdGlvbiBpbiBcInN0eWxlXCIgYXR0cmlidXRlIHdpbGwgY2F1c2UgJyArXG4gICAgICAgICAgICAndGhlIGF0dHJpYnV0ZSB0byBiZSBkaXNjYXJkZWQgaW4gSW50ZXJuZXQgRXhwbG9yZXIuICcgK1xuICAgICAgICAgICAgJ1VzZSB2LWJpbmQ6c3R5bGUgaW5zdGVhZC4nXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaW52YWxpZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBhdHRyID0gdGhpcy5hcmdcbiAgICBpZiAodGhpcy5hcmcpIHtcbiAgICAgIHRoaXMuaGFuZGxlU2luZ2xlKGF0dHIsIHZhbHVlKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhhbmRsZU9iamVjdCh2YWx1ZSB8fCB7fSlcbiAgICB9XG4gIH0sXG5cbiAgLy8gc2hhcmUgb2JqZWN0IGhhbmRsZXIgd2l0aCB2LWJpbmQ6Y2xhc3NcbiAgaGFuZGxlT2JqZWN0OiByZXF1aXJlKCcuLi9pbnRlcm5hbC9zdHlsZScpLmhhbmRsZU9iamVjdCxcblxuICBoYW5kbGVTaW5nbGU6IGZ1bmN0aW9uIChhdHRyLCB2YWx1ZSkge1xuICAgIGlmIChpbnB1dFByb3BzW2F0dHJdICYmIGF0dHIgaW4gdGhpcy5lbCkge1xuICAgICAgdGhpcy5lbFthdHRyXSA9IGF0dHIgPT09ICd2YWx1ZSdcbiAgICAgICAgPyAodmFsdWUgfHwgJycpIC8vIElFOSB3aWxsIHNldCBpbnB1dC52YWx1ZSB0byBcIm51bGxcIiBmb3IgbnVsbC4uLlxuICAgICAgICA6IHZhbHVlXG4gICAgfVxuICAgIC8vIHNldCBtb2RlbCBwcm9wc1xuICAgIHZhciBtb2RlbFByb3AgPSBtb2RlbFByb3BzW2F0dHJdXG4gICAgaWYgKG1vZGVsUHJvcCkge1xuICAgICAgdGhpcy5lbFttb2RlbFByb3BdID0gdmFsdWVcbiAgICAgIC8vIHVwZGF0ZSB2LW1vZGVsIGlmIHByZXNlbnRcbiAgICAgIHZhciBtb2RlbCA9IHRoaXMuZWwuX192X21vZGVsXG4gICAgICBpZiAobW9kZWwpIHtcbiAgICAgICAgbW9kZWwubGlzdGVuZXIoKVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBkbyBub3Qgc2V0IHZhbHVlIGF0dHJpYnV0ZSBmb3IgdGV4dGFyZWFcbiAgICBpZiAoYXR0ciA9PT0gJ3ZhbHVlJyAmJiB0aGlzLmVsLnRhZ05hbWUgPT09ICdURVhUQVJFQScpIHtcbiAgICAgIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKGF0dHIpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gdXBkYXRlIGF0dHJpYnV0ZVxuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSBmYWxzZSkge1xuICAgICAgaWYgKHhsaW5rUkUudGVzdChhdHRyKSkge1xuICAgICAgICB0aGlzLmVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGF0dHIsIHZhbHVlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWUpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKGF0dHIpXG4gICAgfVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgYmluZDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbCA9IHRoaXMuZWxcbiAgICB0aGlzLnZtLiRvbmNlKCdob29rOmNvbXBpbGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCd2LWNsb2FrJylcbiAgICB9KVxuICB9XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICBwcmlvcml0eTogMTUwMCxcblxuICBiaW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCF0aGlzLmFyZykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBpZCA9IHRoaXMuaWQgPSBfLmNhbWVsaXplKHRoaXMuYXJnKVxuICAgIHZhciByZWZzID0gKHRoaXMuX3Njb3BlIHx8IHRoaXMudm0pLiRlbHNcbiAgICBpZiAocmVmcy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgIHJlZnNbaWRdID0gdGhpcy5lbFxuICAgIH0gZWxzZSB7XG4gICAgICBfLmRlZmluZVJlYWN0aXZlKHJlZnMsIGlkLCB0aGlzLmVsKVxuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVmcyA9ICh0aGlzLl9zY29wZSB8fCB0aGlzLnZtKS4kZWxzXG4gICAgaWYgKHJlZnNbdGhpcy5pZF0gPT09IHRoaXMuZWwpIHtcbiAgICAgIHJlZnNbdGhpcy5pZF0gPSBudWxsXG4gICAgfVxuICB9XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxudmFyIEZyYWdtZW50RmFjdG9yeSA9IHJlcXVpcmUoJy4uLy4uL2ZyYWdtZW50L2ZhY3RvcnknKVxudmFyIGlzT2JqZWN0ID0gXy5pc09iamVjdFxudmFyIHVpZCA9IDBcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgcHJpb3JpdHk6IDIwMDAsXG5cbiAgcGFyYW1zOiBbXG4gICAgJ3RyYWNrLWJ5JyxcbiAgICAnc3RhZ2dlcicsXG4gICAgJ2VudGVyLXN0YWdnZXInLFxuICAgICdsZWF2ZS1zdGFnZ2VyJ1xuICBdLFxuXG4gIGJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBzdXBwb3J0IFwiaXRlbSBpbiBpdGVtc1wiIHN5bnRheFxuICAgIHZhciBpbk1hdGNoID0gdGhpcy5leHByZXNzaW9uLm1hdGNoKC8oLiopIGluICguKikvKVxuICAgIGlmIChpbk1hdGNoKSB7XG4gICAgICB2YXIgaXRNYXRjaCA9IGluTWF0Y2hbMV0ubWF0Y2goL1xcKCguKiksKC4qKVxcKS8pXG4gICAgICBpZiAoaXRNYXRjaCkge1xuICAgICAgICB0aGlzLml0ZXJhdG9yID0gaXRNYXRjaFsxXS50cmltKClcbiAgICAgICAgdGhpcy5hbGlhcyA9IGl0TWF0Y2hbMl0udHJpbSgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFsaWFzID0gaW5NYXRjaFsxXS50cmltKClcbiAgICAgIH1cbiAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGluTWF0Y2hbMl1cbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuYWxpYXMpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgXy53YXJuKFxuICAgICAgICAnQWxpYXMgaXMgcmVxdWlyZWQgaW4gdi1mb3IuJ1xuICAgICAgKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gdWlkIGFzIGEgY2FjaGUgaWRlbnRpZmllclxuICAgIHRoaXMuaWQgPSAnX192LWZvcl9fJyArICgrK3VpZClcblxuICAgIC8vIGNoZWNrIGlmIHRoaXMgaXMgYW4gb3B0aW9uIGxpc3QsXG4gICAgLy8gc28gdGhhdCB3ZSBrbm93IGlmIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSA8c2VsZWN0PidzXG4gICAgLy8gdi1tb2RlbCB3aGVuIHRoZSBvcHRpb24gbGlzdCBoYXMgY2hhbmdlZC5cbiAgICAvLyBiZWNhdXNlIHYtbW9kZWwgaGFzIGEgbG93ZXIgcHJpb3JpdHkgdGhhbiB2LWZvcixcbiAgICAvLyB0aGUgdi1tb2RlbCBpcyBub3QgYm91bmQgaGVyZSB5ZXQsIHNvIHdlIGhhdmUgdG9cbiAgICAvLyByZXRyaXZlIGl0IGluIHRoZSBhY3R1YWwgdXBkYXRlTW9kZWwoKSBmdW5jdGlvbi5cbiAgICB2YXIgdGFnID0gdGhpcy5lbC50YWdOYW1lXG4gICAgdGhpcy5pc09wdGlvbiA9XG4gICAgICAodGFnID09PSAnT1BUSU9OJyB8fCB0YWcgPT09ICdPUFRHUk9VUCcpICYmXG4gICAgICB0aGlzLmVsLnBhcmVudE5vZGUudGFnTmFtZSA9PT0gJ1NFTEVDVCdcblxuICAgIC8vIHNldHVwIGFuY2hvciBub2Rlc1xuICAgIHRoaXMuc3RhcnQgPSBfLmNyZWF0ZUFuY2hvcigndi1mb3Itc3RhcnQnKVxuICAgIHRoaXMuZW5kID0gXy5jcmVhdGVBbmNob3IoJ3YtZm9yLWVuZCcpXG4gICAgXy5yZXBsYWNlKHRoaXMuZWwsIHRoaXMuZW5kKVxuICAgIF8uYmVmb3JlKHRoaXMuc3RhcnQsIHRoaXMuZW5kKVxuXG4gICAgLy8gY2hlY2sgcmVmXG4gICAgdGhpcy5yZWYgPSBfLmZpbmRSZWYodGhpcy5lbClcblxuICAgIC8vIGNhY2hlXG4gICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICAgIC8vIGZyYWdtZW50IGZhY3RvcnlcbiAgICB0aGlzLmZhY3RvcnkgPSBuZXcgRnJhZ21lbnRGYWN0b3J5KHRoaXMudm0sIHRoaXMuZWwpXG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHRoaXMuZGlmZihkYXRhKVxuICAgIHRoaXMudXBkYXRlUmVmKClcbiAgICB0aGlzLnVwZGF0ZU1vZGVsKClcbiAgfSxcblxuICAvKipcbiAgICogRGlmZiwgYmFzZWQgb24gbmV3IGRhdGEgYW5kIG9sZCBkYXRhLCBkZXRlcm1pbmUgdGhlXG4gICAqIG1pbmltdW0gYW1vdW50IG9mIERPTSBtYW5pcHVsYXRpb25zIG5lZWRlZCB0byBtYWtlIHRoZVxuICAgKiBET00gcmVmbGVjdCB0aGUgbmV3IGRhdGEgQXJyYXkuXG4gICAqXG4gICAqIFRoZSBhbGdvcml0aG0gZGlmZnMgdGhlIG5ldyBkYXRhIEFycmF5IGJ5IHN0b3JpbmcgYVxuICAgKiBoaWRkZW4gcmVmZXJlbmNlIHRvIGFuIG93bmVyIHZtIGluc3RhbmNlIG9uIHByZXZpb3VzbHlcbiAgICogc2VlbiBkYXRhLiBUaGlzIGFsbG93cyB1cyB0byBhY2hpZXZlIE8obikgd2hpY2ggaXNcbiAgICogYmV0dGVyIHRoYW4gYSBsZXZlbnNodGVpbiBkaXN0YW5jZSBiYXNlZCBhbGdvcml0aG0sXG4gICAqIHdoaWNoIGlzIE8obSAqIG4pLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhXG4gICAqL1xuXG4gIGRpZmY6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgLy8gY2hlY2sgaWYgdGhlIEFycmF5IHdhcyBjb252ZXJ0ZWQgZnJvbSBhbiBPYmplY3RcbiAgICB2YXIgaXRlbSA9IGRhdGFbMF1cbiAgICB2YXIgY29udmVydGVkRnJvbU9iamVjdCA9IHRoaXMuZnJvbU9iamVjdCA9XG4gICAgICBpc09iamVjdChpdGVtKSAmJlxuICAgICAgaXRlbS5oYXNPd25Qcm9wZXJ0eSgnJGtleScpICYmXG4gICAgICBpdGVtLmhhc093blByb3BlcnR5KCckdmFsdWUnKVxuXG4gICAgdmFyIHRyYWNrQnlLZXkgPSB0aGlzLnBhcmFtcy50cmFja0J5XG4gICAgdmFyIG9sZEZyYWdzID0gdGhpcy5mcmFnc1xuICAgIHZhciBmcmFncyA9IHRoaXMuZnJhZ3MgPSBuZXcgQXJyYXkoZGF0YS5sZW5ndGgpXG4gICAgdmFyIGFsaWFzID0gdGhpcy5hbGlhc1xuICAgIHZhciBpdGVyYXRvciA9IHRoaXMuaXRlcmF0b3JcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnN0YXJ0XG4gICAgdmFyIGVuZCA9IHRoaXMuZW5kXG4gICAgdmFyIGluRG9jID0gXy5pbkRvYyhzdGFydClcbiAgICB2YXIgaW5pdCA9ICFvbGRGcmFnc1xuICAgIHZhciBpLCBsLCBmcmFnLCBrZXksIHZhbHVlLCBwcmltaXRpdmVcblxuICAgIC8vIEZpcnN0IHBhc3MsIGdvIHRocm91Z2ggdGhlIG5ldyBBcnJheSBhbmQgZmlsbCB1cFxuICAgIC8vIHRoZSBuZXcgZnJhZ3MgYXJyYXkuIElmIGEgcGllY2Ugb2YgZGF0YSBoYXMgYSBjYWNoZWRcbiAgICAvLyBpbnN0YW5jZSBmb3IgaXQsIHdlIHJldXNlIGl0LiBPdGhlcndpc2UgYnVpbGQgYSBuZXdcbiAgICAvLyBpbnN0YW5jZS5cbiAgICBmb3IgKGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGl0ZW0gPSBkYXRhW2ldXG4gICAgICBrZXkgPSBjb252ZXJ0ZWRGcm9tT2JqZWN0ID8gaXRlbS4ka2V5IDogbnVsbFxuICAgICAgdmFsdWUgPSBjb252ZXJ0ZWRGcm9tT2JqZWN0ID8gaXRlbS4kdmFsdWUgOiBpdGVtXG4gICAgICBwcmltaXRpdmUgPSAhaXNPYmplY3QodmFsdWUpXG4gICAgICBmcmFnID0gIWluaXQgJiYgdGhpcy5nZXRDYWNoZWRGcmFnKHZhbHVlLCBpLCBrZXkpXG4gICAgICBpZiAoZnJhZykgeyAvLyByZXVzYWJsZSBmcmFnbWVudFxuICAgICAgICBmcmFnLnJldXNlZCA9IHRydWVcbiAgICAgICAgLy8gdXBkYXRlICRpbmRleFxuICAgICAgICBmcmFnLnNjb3BlLiRpbmRleCA9IGlcbiAgICAgICAgLy8gdXBkYXRlICRrZXlcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgIGZyYWcuc2NvcGUuJGtleSA9IGtleVxuICAgICAgICB9XG4gICAgICAgIC8vIHVwZGF0ZSBpdGVyYXRvclxuICAgICAgICBpZiAoaXRlcmF0b3IpIHtcbiAgICAgICAgICBmcmFnLnNjb3BlW2l0ZXJhdG9yXSA9IGtleSAhPT0gbnVsbCA/IGtleSA6IGlcbiAgICAgICAgfVxuICAgICAgICAvLyB1cGRhdGUgZGF0YSBmb3IgdHJhY2stYnksIG9iamVjdCByZXBlYXQgJlxuICAgICAgICAvLyBwcmltaXRpdmUgdmFsdWVzLlxuICAgICAgICBpZiAodHJhY2tCeUtleSB8fCBjb252ZXJ0ZWRGcm9tT2JqZWN0IHx8IHByaW1pdGl2ZSkge1xuICAgICAgICAgIGZyYWcuc2NvcGVbYWxpYXNdID0gdmFsdWVcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHsgLy8gbmV3IGlzbnRhbmNlXG4gICAgICAgIGZyYWcgPSB0aGlzLmNyZWF0ZSh2YWx1ZSwgYWxpYXMsIGksIGtleSlcbiAgICAgICAgZnJhZy5mcmVzaCA9ICFpbml0XG4gICAgICB9XG4gICAgICBmcmFnc1tpXSA9IGZyYWdcbiAgICAgIGlmIChpbml0KSB7XG4gICAgICAgIGZyYWcuYmVmb3JlKGVuZClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB3ZSdyZSBkb25lIGZvciB0aGUgaW5pdGlhbCByZW5kZXIuXG4gICAgaWYgKGluaXQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIFNlY29uZCBwYXNzLCBnbyB0aHJvdWdoIHRoZSBvbGQgZnJhZ21lbnRzIGFuZFxuICAgIC8vIGRlc3Ryb3kgdGhvc2Ugd2hvIGFyZSBub3QgcmV1c2VkIChhbmQgcmVtb3ZlIHRoZW1cbiAgICAvLyBmcm9tIGNhY2hlKVxuICAgIHZhciByZW1vdmFsSW5kZXggPSAwXG4gICAgdmFyIHRvdGFsUmVtb3ZlZCA9IG9sZEZyYWdzLmxlbmd0aCAtIGZyYWdzLmxlbmd0aFxuICAgIGZvciAoaSA9IDAsIGwgPSBvbGRGcmFncy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZyYWcgPSBvbGRGcmFnc1tpXVxuICAgICAgaWYgKCFmcmFnLnJldXNlZCkge1xuICAgICAgICB0aGlzLmRlbGV0ZUNhY2hlZEZyYWcoZnJhZylcbiAgICAgICAgdGhpcy5yZW1vdmUoZnJhZywgcmVtb3ZhbEluZGV4KyssIHRvdGFsUmVtb3ZlZCwgaW5Eb2MpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRmluYWwgcGFzcywgbW92ZS9pbnNlcnQgbmV3IGZyYWdtZW50cyBpbnRvIHRoZVxuICAgIC8vIHJpZ2h0IHBsYWNlLlxuICAgIHZhciB0YXJnZXRQcmV2LCBwcmV2RWwsIGN1cnJlbnRQcmV2XG4gICAgdmFyIGluc2VydGlvbkluZGV4ID0gMFxuICAgIGZvciAoaSA9IDAsIGwgPSBmcmFncy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZyYWcgPSBmcmFnc1tpXVxuICAgICAgLy8gdGhpcyBpcyB0aGUgZnJhZyB0aGF0IHdlIHNob3VsZCBiZSBhZnRlclxuICAgICAgdGFyZ2V0UHJldiA9IGZyYWdzW2kgLSAxXVxuICAgICAgcHJldkVsID0gdGFyZ2V0UHJldlxuICAgICAgICA/IHRhcmdldFByZXYuc3RhZ2dlckNiXG4gICAgICAgICAgPyB0YXJnZXRQcmV2LnN0YWdnZXJBbmNob3JcbiAgICAgICAgICA6IHRhcmdldFByZXYuZW5kIHx8IHRhcmdldFByZXYubm9kZVxuICAgICAgICA6IHN0YXJ0XG4gICAgICBpZiAoZnJhZy5yZXVzZWQgJiYgIWZyYWcuc3RhZ2dlckNiKSB7XG4gICAgICAgIGN1cnJlbnRQcmV2ID0gZmluZFByZXZGcmFnKGZyYWcsIHN0YXJ0LCB0aGlzLmlkKVxuICAgICAgICBpZiAoY3VycmVudFByZXYgIT09IHRhcmdldFByZXYpIHtcbiAgICAgICAgICB0aGlzLm1vdmUoZnJhZywgcHJldkVsKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBuZXcgaW5zdGFuY2UsIG9yIHN0aWxsIGluIHN0YWdnZXIuXG4gICAgICAgIC8vIGluc2VydCB3aXRoIHVwZGF0ZWQgc3RhZ2dlciBpbmRleC5cbiAgICAgICAgdGhpcy5pbnNlcnQoZnJhZywgaW5zZXJ0aW9uSW5kZXgrKywgcHJldkVsLCBpbkRvYylcbiAgICAgIH1cbiAgICAgIGZyYWcucmV1c2VkID0gZnJhZy5mcmVzaCA9IGZhbHNlXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgZnJhZ21lbnQgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFsaWFzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2tleV1cbiAgICogQHJldHVybiB7RnJhZ21lbnR9XG4gICAqL1xuXG4gIGNyZWF0ZTogZnVuY3Rpb24gKHZhbHVlLCBhbGlhcywgaW5kZXgsIGtleSkge1xuICAgIHZhciBob3N0ID0gdGhpcy5faG9zdFxuICAgIC8vIGNyZWF0ZSBpdGVyYXRpb24gc2NvcGVcbiAgICB2YXIgcGFyZW50U2NvcGUgPSB0aGlzLl9zY29wZSB8fCB0aGlzLnZtXG4gICAgdmFyIHNjb3BlID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRTY29wZSlcbiAgICAvLyByZWYgaG9sZGVyIGZvciB0aGUgc2NvcGVcbiAgICBzY29wZS4kcmVmcyA9IE9iamVjdC5jcmVhdGUocGFyZW50U2NvcGUuJHJlZnMpXG4gICAgc2NvcGUuJGVscyA9IE9iamVjdC5jcmVhdGUocGFyZW50U2NvcGUuJGVscylcbiAgICAvLyBtYWtlIHN1cmUgcG9pbnQgJHBhcmVudCB0byBwYXJlbnQgc2NvcGVcbiAgICBzY29wZS4kcGFyZW50ID0gcGFyZW50U2NvcGVcbiAgICAvLyBmb3IgdHdvLXdheSBiaW5kaW5nIG9uIGFsaWFzXG4gICAgc2NvcGUuJGZvckNvbnRleHQgPSB0aGlzXG4gICAgLy8gZGVmaW5lIHNjb3BlIHByb3BlcnRpZXNcbiAgICBfLmRlZmluZVJlYWN0aXZlKHNjb3BlLCBhbGlhcywgdmFsdWUpXG4gICAgXy5kZWZpbmVSZWFjdGl2ZShzY29wZSwgJyRpbmRleCcsIGluZGV4KVxuICAgIGlmIChrZXkpIHtcbiAgICAgIF8uZGVmaW5lUmVhY3RpdmUoc2NvcGUsICcka2V5Jywga2V5KVxuICAgIH0gZWxzZSBpZiAoc2NvcGUuJGtleSkge1xuICAgICAgLy8gYXZvaWQgYWNjaWRlbnRhbCBmYWxsYmFja1xuICAgICAgXy5kZWZpbmUoc2NvcGUsICcka2V5JywgbnVsbClcbiAgICB9XG4gICAgaWYgKHRoaXMuaXRlcmF0b3IpIHtcbiAgICAgIF8uZGVmaW5lUmVhY3RpdmUoc2NvcGUsIHRoaXMuaXRlcmF0b3IsIGtleSAhPT0gbnVsbCA/IGtleSA6IGluZGV4KVxuICAgIH1cbiAgICB2YXIgZnJhZyA9IHRoaXMuZmFjdG9yeS5jcmVhdGUoaG9zdCwgc2NvcGUsIHRoaXMuX2ZyYWcpXG4gICAgZnJhZy5mb3JJZCA9IHRoaXMuaWRcbiAgICB0aGlzLmNhY2hlRnJhZyh2YWx1ZSwgZnJhZywgaW5kZXgsIGtleSlcbiAgICByZXR1cm4gZnJhZ1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHYtcmVmIG9uIG93bmVyIHZtLlxuICAgKi9cblxuICB1cGRhdGVSZWY6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVmID0gdGhpcy5yZWZcbiAgICBpZiAoIXJlZikgcmV0dXJuXG4gICAgdmFyIGhhc2ggPSAodGhpcy5fc2NvcGUgfHwgdGhpcy52bSkuJHJlZnNcbiAgICB2YXIgcmVmc1xuICAgIGlmICghdGhpcy5mcm9tT2JqZWN0KSB7XG4gICAgICByZWZzID0gdGhpcy5mcmFncy5tYXAoZmluZFZtRnJvbUZyYWcpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZnMgPSB7fVxuICAgICAgdGhpcy5mcmFncy5mb3JFYWNoKGZ1bmN0aW9uIChmcmFnKSB7XG4gICAgICAgIHJlZnNbZnJhZy5zY29wZS4ka2V5XSA9IGZpbmRWbUZyb21GcmFnKGZyYWcpXG4gICAgICB9KVxuICAgIH1cbiAgICBpZiAoIWhhc2guaGFzT3duUHJvcGVydHkocmVmKSkge1xuICAgICAgXy5kZWZpbmVSZWFjdGl2ZShoYXNoLCByZWYsIHJlZnMpXG4gICAgfSBlbHNlIHtcbiAgICAgIGhhc2hbcmVmXSA9IHJlZnNcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvciBvcHRpb24gbGlzdHMsIHVwZGF0ZSB0aGUgY29udGFpbmluZyB2LW1vZGVsIG9uXG4gICAqIHBhcmVudCA8c2VsZWN0Pi5cbiAgICovXG5cbiAgdXBkYXRlTW9kZWw6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5pc09wdGlvbikge1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXMuc3RhcnQucGFyZW50Tm9kZVxuICAgICAgdmFyIG1vZGVsID0gcGFyZW50ICYmIHBhcmVudC5fX3ZfbW9kZWxcbiAgICAgIGlmIChtb2RlbCkge1xuICAgICAgICBtb2RlbC5mb3JjZVVwZGF0ZSgpXG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbnNlcnQgYSBmcmFnbWVudC4gSGFuZGxlcyBzdGFnZ2VyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge0ZyYWdtZW50fSBmcmFnXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge05vZGV9IHByZXZFbFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGluRG9jXG4gICAqL1xuXG4gIGluc2VydDogZnVuY3Rpb24gKGZyYWcsIGluZGV4LCBwcmV2RWwsIGluRG9jKSB7XG4gICAgaWYgKGZyYWcuc3RhZ2dlckNiKSB7XG4gICAgICBmcmFnLnN0YWdnZXJDYi5jYW5jZWwoKVxuICAgICAgZnJhZy5zdGFnZ2VyQ2IgPSBudWxsXG4gICAgfVxuICAgIHZhciBzdGFnZ2VyQW1vdW50ID0gdGhpcy5nZXRTdGFnZ2VyKGZyYWcsIGluZGV4LCBudWxsLCAnZW50ZXInKVxuICAgIGlmIChpbkRvYyAmJiBzdGFnZ2VyQW1vdW50KSB7XG4gICAgICAvLyBjcmVhdGUgYW4gYW5jaG9yIGFuZCBpbnNlcnQgaXQgc3luY2hyb25vdXNseSxcbiAgICAgIC8vIHNvIHRoYXQgd2UgY2FuIHJlc29sdmUgdGhlIGNvcnJlY3Qgb3JkZXIgd2l0aG91dFxuICAgICAgLy8gd29ycnlpbmcgYWJvdXQgc29tZSBlbGVtZW50cyBub3QgaW5zZXJ0ZWQgeWV0XG4gICAgICB2YXIgYW5jaG9yID0gZnJhZy5zdGFnZ2VyQW5jaG9yXG4gICAgICBpZiAoIWFuY2hvcikge1xuICAgICAgICBhbmNob3IgPSBmcmFnLnN0YWdnZXJBbmNob3IgPSBfLmNyZWF0ZUFuY2hvcignc3RhZ2dlci1hbmNob3InKVxuICAgICAgICBhbmNob3IuX192ZnJhZ19fID0gZnJhZ1xuICAgICAgfVxuICAgICAgXy5hZnRlcihhbmNob3IsIHByZXZFbClcbiAgICAgIHZhciBvcCA9IGZyYWcuc3RhZ2dlckNiID0gXy5jYW5jZWxsYWJsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZyYWcuc3RhZ2dlckNiID0gbnVsbFxuICAgICAgICBmcmFnLmJlZm9yZShhbmNob3IpXG4gICAgICAgIF8ucmVtb3ZlKGFuY2hvcilcbiAgICAgIH0pXG4gICAgICBzZXRUaW1lb3V0KG9wLCBzdGFnZ2VyQW1vdW50KVxuICAgIH0gZWxzZSB7XG4gICAgICBmcmFnLmJlZm9yZShwcmV2RWwubmV4dFNpYmxpbmcpXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBmcmFnbWVudC4gSGFuZGxlcyBzdGFnZ2VyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge0ZyYWdtZW50fSBmcmFnXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge051bWJlcn0gdG90YWxcbiAgICogQHBhcmFtIHtCb29sZWFufSBpbkRvY1xuICAgKi9cblxuICByZW1vdmU6IGZ1bmN0aW9uIChmcmFnLCBpbmRleCwgdG90YWwsIGluRG9jKSB7XG4gICAgaWYgKGZyYWcuc3RhZ2dlckNiKSB7XG4gICAgICBmcmFnLnN0YWdnZXJDYi5jYW5jZWwoKVxuICAgICAgZnJhZy5zdGFnZ2VyQ2IgPSBudWxsXG4gICAgICAvLyBpdCdzIG5vdCBwb3NzaWJsZSBmb3IgdGhlIHNhbWUgZnJhZyB0byBiZSByZW1vdmVkXG4gICAgICAvLyB0d2ljZSwgc28gaWYgd2UgaGF2ZSBhIHBlbmRpbmcgc3RhZ2dlciBjYWxsYmFjayxcbiAgICAgIC8vIGl0IG1lYW5zIHRoaXMgZnJhZyBpcyBxdWV1ZWQgZm9yIGVudGVyIGJ1dCByZW1vdmVkXG4gICAgICAvLyBiZWZvcmUgaXRzIHRyYW5zaXRpb24gc3RhcnRlZC4gU2luY2UgaXQgaXMgYWxyZWFkeVxuICAgICAgLy8gZGVzdHJveWVkLCB3ZSBjYW4ganVzdCBsZWF2ZSBpdCBpbiBkZXRhY2hlZCBzdGF0ZS5cbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgc3RhZ2dlckFtb3VudCA9IHRoaXMuZ2V0U3RhZ2dlcihmcmFnLCBpbmRleCwgdG90YWwsICdsZWF2ZScpXG4gICAgaWYgKGluRG9jICYmIHN0YWdnZXJBbW91bnQpIHtcbiAgICAgIHZhciBvcCA9IGZyYWcuc3RhZ2dlckNiID0gXy5jYW5jZWxsYWJsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZyYWcuc3RhZ2dlckNiID0gbnVsbFxuICAgICAgICBmcmFnLnJlbW92ZSh0cnVlKVxuICAgICAgfSlcbiAgICAgIHNldFRpbWVvdXQob3AsIHN0YWdnZXJBbW91bnQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYWcucmVtb3ZlKHRydWUpXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlIGEgZnJhZ21lbnQgdG8gYSBuZXcgcG9zaXRpb24uXG4gICAqIEZvcmNlIG5vIHRyYW5zaXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7RnJhZ21lbnR9IGZyYWdcbiAgICogQHBhcmFtIHtOb2RlfSBwcmV2RWxcbiAgICovXG5cbiAgbW92ZTogZnVuY3Rpb24gKGZyYWcsIHByZXZFbCkge1xuICAgIGZyYWcuYmVmb3JlKHByZXZFbC5uZXh0U2libGluZywgZmFsc2UpXG4gIH0sXG5cbiAgLyoqXG4gICAqIENhY2hlIGEgZnJhZ21lbnQgdXNpbmcgdHJhY2stYnkgb3IgdGhlIG9iamVjdCBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtrZXldXG4gICAqL1xuXG4gIGNhY2hlRnJhZzogZnVuY3Rpb24gKHZhbHVlLCBmcmFnLCBpbmRleCwga2V5KSB7XG4gICAgdmFyIHRyYWNrQnlLZXkgPSB0aGlzLnBhcmFtcy50cmFja0J5XG4gICAgdmFyIGNhY2hlID0gdGhpcy5jYWNoZVxuICAgIHZhciBwcmltaXRpdmUgPSAhaXNPYmplY3QodmFsdWUpXG4gICAgdmFyIGlkXG4gICAgaWYgKGtleSB8fCB0cmFja0J5S2V5IHx8IHByaW1pdGl2ZSkge1xuICAgICAgaWQgPSB0cmFja0J5S2V5XG4gICAgICAgID8gdHJhY2tCeUtleSA9PT0gJyRpbmRleCdcbiAgICAgICAgICA/IGluZGV4XG4gICAgICAgICAgOiB2YWx1ZVt0cmFja0J5S2V5XVxuICAgICAgICA6IChrZXkgfHwgdmFsdWUpXG4gICAgICBpZiAoIWNhY2hlW2lkXSkge1xuICAgICAgICBjYWNoZVtpZF0gPSBmcmFnXG4gICAgICB9IGVsc2UgaWYgKHRyYWNrQnlLZXkgIT09ICckaW5kZXgnKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgdGhpcy53YXJuRHVwbGljYXRlKHZhbHVlKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZCA9IHRoaXMuaWRcbiAgICAgIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgaWYgKHZhbHVlW2lkXSA9PT0gbnVsbCkge1xuICAgICAgICAgIHZhbHVlW2lkXSA9IGZyYWdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgdGhpcy53YXJuRHVwbGljYXRlKHZhbHVlKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfLmRlZmluZSh2YWx1ZSwgaWQsIGZyYWcpXG4gICAgICB9XG4gICAgfVxuICAgIGZyYWcucmF3ID0gdmFsdWVcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGEgY2FjaGVkIGZyYWdtZW50IGZyb20gdGhlIHZhbHVlL2luZGV4L2tleVxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAqIEByZXR1cm4ge0ZyYWdtZW50fVxuICAgKi9cblxuICBnZXRDYWNoZWRGcmFnOiBmdW5jdGlvbiAodmFsdWUsIGluZGV4LCBrZXkpIHtcbiAgICB2YXIgdHJhY2tCeUtleSA9IHRoaXMucGFyYW1zLnRyYWNrQnlcbiAgICB2YXIgcHJpbWl0aXZlID0gIWlzT2JqZWN0KHZhbHVlKVxuICAgIHZhciBmcmFnXG4gICAgaWYgKGtleSB8fCB0cmFja0J5S2V5IHx8IHByaW1pdGl2ZSkge1xuICAgICAgdmFyIGlkID0gdHJhY2tCeUtleVxuICAgICAgICA/IHRyYWNrQnlLZXkgPT09ICckaW5kZXgnXG4gICAgICAgICAgPyBpbmRleFxuICAgICAgICAgIDogdmFsdWVbdHJhY2tCeUtleV1cbiAgICAgICAgOiAoa2V5IHx8IHZhbHVlKVxuICAgICAgZnJhZyA9IHRoaXMuY2FjaGVbaWRdXG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYWcgPSB2YWx1ZVt0aGlzLmlkXVxuICAgIH1cbiAgICBpZiAoZnJhZyAmJiAoZnJhZy5yZXVzZWQgfHwgZnJhZy5mcmVzaCkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIHRoaXMud2FybkR1cGxpY2F0ZSh2YWx1ZSlcbiAgICB9XG4gICAgcmV0dXJuIGZyYWdcbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlIGEgZnJhZ21lbnQgZnJvbSBjYWNoZS5cbiAgICpcbiAgICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICAgKi9cblxuICBkZWxldGVDYWNoZWRGcmFnOiBmdW5jdGlvbiAoZnJhZykge1xuICAgIHZhciB2YWx1ZSA9IGZyYWcucmF3XG4gICAgdmFyIHRyYWNrQnlLZXkgPSB0aGlzLnBhcmFtcy50cmFja0J5XG4gICAgdmFyIHNjb3BlID0gZnJhZy5zY29wZVxuICAgIHZhciBpbmRleCA9IHNjb3BlLiRpbmRleFxuICAgIC8vIGZpeCAjOTQ4OiBhdm9pZCBhY2NpZGVudGFsbHkgZmFsbCB0aHJvdWdoIHRvXG4gICAgLy8gYSBwYXJlbnQgcmVwZWF0ZXIgd2hpY2ggaGFwcGVucyB0byBoYXZlICRrZXkuXG4gICAgdmFyIGtleSA9IHNjb3BlLmhhc093blByb3BlcnR5KCcka2V5JykgJiYgc2NvcGUuJGtleVxuICAgIHZhciBwcmltaXRpdmUgPSAhaXNPYmplY3QodmFsdWUpXG4gICAgaWYgKHRyYWNrQnlLZXkgfHwga2V5IHx8IHByaW1pdGl2ZSkge1xuICAgICAgdmFyIGlkID0gdHJhY2tCeUtleVxuICAgICAgICA/IHRyYWNrQnlLZXkgPT09ICckaW5kZXgnXG4gICAgICAgICAgPyBpbmRleFxuICAgICAgICAgIDogdmFsdWVbdHJhY2tCeUtleV1cbiAgICAgICAgOiAoa2V5IHx8IHZhbHVlKVxuICAgICAgdGhpcy5jYWNoZVtpZF0gPSBudWxsXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlW3RoaXMuaWRdID0gbnVsbFxuICAgICAgZnJhZy5yYXcgPSBudWxsXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0YWdnZXIgYW1vdW50IGZvciBhbiBpbnNlcnRpb24vcmVtb3ZhbC5cbiAgICpcbiAgICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRvdGFsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqL1xuXG4gIGdldFN0YWdnZXI6IGZ1bmN0aW9uIChmcmFnLCBpbmRleCwgdG90YWwsIHR5cGUpIHtcbiAgICB0eXBlID0gdHlwZSArICdTdGFnZ2VyJ1xuICAgIHZhciB0cmFucyA9IGZyYWcubm9kZS5fX3ZfdHJhbnNcbiAgICB2YXIgaG9va3MgPSB0cmFucyAmJiB0cmFucy5ob29rc1xuICAgIHZhciBob29rID0gaG9va3MgJiYgKGhvb2tzW3R5cGVdIHx8IGhvb2tzLnN0YWdnZXIpXG4gICAgcmV0dXJuIGhvb2tcbiAgICAgID8gaG9vay5jYWxsKGZyYWcsIGluZGV4LCB0b3RhbClcbiAgICAgIDogaW5kZXggKiBwYXJzZUludCh0aGlzLnBhcmFtc1t0eXBlXSB8fCB0aGlzLnBhcmFtcy5zdGFnZ2VyLCAxMClcbiAgfSxcblxuICAvKipcbiAgICogUHJlLXByb2Nlc3MgdGhlIHZhbHVlIGJlZm9yZSBwaXBpbmcgaXQgdGhyb3VnaCB0aGVcbiAgICogZmlsdGVycy4gVGhpcyBpcyBwYXNzZWQgdG8gYW5kIGNhbGxlZCBieSB0aGUgd2F0Y2hlci5cbiAgICovXG5cbiAgX3ByZVByb2Nlc3M6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHJlZ2FyZGxlc3Mgb2YgdHlwZSwgc3RvcmUgdGhlIHVuLWZpbHRlcmVkIHJhdyB2YWx1ZS5cbiAgICB0aGlzLnJhd1ZhbHVlID0gdmFsdWVcbiAgICByZXR1cm4gdmFsdWVcbiAgfSxcblxuICAvKipcbiAgICogUG9zdC1wcm9jZXNzIHRoZSB2YWx1ZSBhZnRlciBpdCBoYXMgYmVlbiBwaXBlZCB0aHJvdWdoXG4gICAqIHRoZSBmaWx0ZXJzLiBUaGlzIGlzIHBhc3NlZCB0byBhbmQgY2FsbGVkIGJ5IHRoZSB3YXRjaGVyLlxuICAgKlxuICAgKiBJdCBpcyBuZWNlc3NhcnkgZm9yIHRoaXMgdG8gYmUgY2FsbGVkIGR1cmluZyB0aGVcbiAgICogd2F0aGNlcidzIGRlcGVuZGVuY3kgY29sbGVjdGlvbiBwaGFzZSBiZWNhdXNlIHdlIHdhbnRcbiAgICogdGhlIHYtZm9yIHRvIHVwZGF0ZSB3aGVuIHRoZSBzb3VyY2UgT2JqZWN0IGlzIG11dGF0ZWQuXG4gICAqL1xuXG4gIF9wb3N0UHJvY2VzczogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKF8uaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH0gZWxzZSBpZiAoXy5pc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgLy8gY29udmVydCBwbGFpbiBvYmplY3QgdG8gYXJyYXkuXG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKVxuICAgICAgdmFyIGkgPSBrZXlzLmxlbmd0aFxuICAgICAgdmFyIHJlcyA9IG5ldyBBcnJheShpKVxuICAgICAgdmFyIGtleVxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBrZXkgPSBrZXlzW2ldXG4gICAgICAgIHJlc1tpXSA9IHtcbiAgICAgICAgICAka2V5OiBrZXksXG4gICAgICAgICAgJHZhbHVlOiB2YWx1ZVtrZXldXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWVcbiAgICAgIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICB2YWx1ZSA9IHJhbmdlKHZhbHVlKVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YWx1ZSA9IF8udG9BcnJheSh2YWx1ZSlcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZSB8fCBbXVxuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5yZWYpIHtcbiAgICAgICh0aGlzLl9zY29wZSB8fCB0aGlzLnZtKS4kcmVmc1t0aGlzLnJlZl0gPSBudWxsXG4gICAgfVxuICAgIGlmICh0aGlzLmZyYWdzKSB7XG4gICAgICB2YXIgaSA9IHRoaXMuZnJhZ3MubGVuZ3RoXG4gICAgICB2YXIgZnJhZ1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBmcmFnID0gdGhpcy5mcmFnc1tpXVxuICAgICAgICB0aGlzLmRlbGV0ZUNhY2hlZEZyYWcoZnJhZylcbiAgICAgICAgZnJhZy5kZXN0cm95KClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gZmluZCB0aGUgcHJldmlvdXMgZWxlbWVudCB0aGF0IGlzIGEgZnJhZ21lbnRcbiAqIGFuY2hvci4gVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBhIGRlc3Ryb3llZCBmcmFnJ3NcbiAqIGVsZW1lbnQgY291bGQgc3RpbGwgYmUgbGluZ2VyaW5nIGluIHRoZSBET00gYmVmb3JlIGl0c1xuICogbGVhdmluZyB0cmFuc2l0aW9uIGZpbmlzaGVzLCBidXQgaXRzIGluc2VydGVkIGZsYWdcbiAqIHNob3VsZCBoYXZlIGJlZW4gc2V0IHRvIGZhbHNlIHNvIHdlIGNhbiBza2lwIHRoZW0uXG4gKlxuICogSWYgdGhpcyBpcyBhIGJsb2NrIHJlcGVhdCwgd2Ugd2FudCB0byBtYWtlIHN1cmUgd2Ugb25seVxuICogcmV0dXJuIGZyYWcgdGhhdCBpcyBib3VuZCB0byB0aGlzIHYtZm9yLiAoc2VlICM5MjkpXG4gKlxuICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICogQHBhcmFtIHtDb21tZW50fFRleHR9IGFuY2hvclxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKiBAcmV0dXJuIHtGcmFnbWVudH1cbiAqL1xuXG5mdW5jdGlvbiBmaW5kUHJldkZyYWcgKGZyYWcsIGFuY2hvciwgaWQpIHtcbiAgdmFyIGVsID0gZnJhZy5ub2RlLnByZXZpb3VzU2libGluZ1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFlbCkgcmV0dXJuXG4gIGZyYWcgPSBlbC5fX3ZmcmFnX19cbiAgd2hpbGUgKFxuICAgICghZnJhZyB8fCBmcmFnLmZvcklkICE9PSBpZCB8fCAhZnJhZy5pbnNlcnRlZCkgJiZcbiAgICBlbCAhPT0gYW5jaG9yXG4gICkge1xuICAgIGVsID0gZWwucHJldmlvdXNTaWJsaW5nXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFlbCkgcmV0dXJuXG4gICAgZnJhZyA9IGVsLl9fdmZyYWdfX1xuICB9XG4gIHJldHVybiBmcmFnXG59XG5cbi8qKlxuICogRmluZCBhIHZtIGZyb20gYSBmcmFnbWVudC5cbiAqXG4gKiBAcGFyYW0ge0ZyYWdtZW50fSBmcmFnXG4gKiBAcmV0dXJuIHtWdWV8dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIGZpbmRWbUZyb21GcmFnIChmcmFnKSB7XG4gIHJldHVybiBmcmFnLm5vZGUuX192dWVfXyB8fCBmcmFnLm5vZGUubmV4dFNpYmxpbmcuX192dWVfX1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHJhbmdlIGFycmF5IGZyb20gZ2l2ZW4gbnVtYmVyLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5mdW5jdGlvbiByYW5nZSAobikge1xuICB2YXIgaSA9IC0xXG4gIHZhciByZXQgPSBuZXcgQXJyYXkobilcbiAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICByZXRbaV0gPSBpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cy53YXJuRHVwbGljYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgXy53YXJuKFxuICAgICAgJ0R1cGxpY2F0ZSB2YWx1ZSBmb3VuZCBpbiB2LWZvcj1cIicgKyB0aGlzLmRlc2NyaXB0b3IucmF3ICsgJ1wiOiAnICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArICcuIFVzZSB0cmFjay1ieT1cIiRpbmRleFwiIGlmICcgK1xuICAgICAgJ3lvdSBhcmUgZXhwZWN0aW5nIGR1cGxpY2F0ZSB2YWx1ZXMuJ1xuICAgIClcbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi8uLi91dGlsJylcbnZhciB0ZW1wbGF0ZVBhcnNlciA9IHJlcXVpcmUoJy4uLy4uL3BhcnNlcnMvdGVtcGxhdGUnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICBiaW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gYSBjb21tZW50IG5vZGUgbWVhbnMgdGhpcyBpcyBhIGJpbmRpbmcgZm9yXG4gICAgLy8ge3t7IGlubGluZSB1bmVzY2FwZWQgaHRtbCB9fX1cbiAgICBpZiAodGhpcy5lbC5ub2RlVHlwZSA9PT0gOCkge1xuICAgICAgLy8gaG9sZCBub2Rlc1xuICAgICAgdGhpcy5ub2RlcyA9IFtdXG4gICAgICAvLyByZXBsYWNlIHRoZSBwbGFjZWhvbGRlciB3aXRoIHByb3BlciBhbmNob3JcbiAgICAgIHRoaXMuYW5jaG9yID0gXy5jcmVhdGVBbmNob3IoJ3YtaHRtbCcpXG4gICAgICBfLnJlcGxhY2UodGhpcy5lbCwgdGhpcy5hbmNob3IpXG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFsdWUgPSBfLnRvU3RyaW5nKHZhbHVlKVxuICAgIGlmICh0aGlzLm5vZGVzKSB7XG4gICAgICB0aGlzLnN3YXAodmFsdWUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZWwuaW5uZXJIVE1MID0gdmFsdWVcbiAgICB9XG4gIH0sXG5cbiAgc3dhcDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gcmVtb3ZlIG9sZCBub2Rlc1xuICAgIHZhciBpID0gdGhpcy5ub2Rlcy5sZW5ndGhcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBfLnJlbW92ZSh0aGlzLm5vZGVzW2ldKVxuICAgIH1cbiAgICAvLyBjb252ZXJ0IG5ldyB2YWx1ZSB0byBhIGZyYWdtZW50XG4gICAgLy8gZG8gbm90IGF0dGVtcHQgdG8gcmV0cmlldmUgZnJvbSBpZCBzZWxlY3RvclxuICAgIHZhciBmcmFnID0gdGVtcGxhdGVQYXJzZXIucGFyc2UodmFsdWUsIHRydWUsIHRydWUpXG4gICAgLy8gc2F2ZSBhIHJlZmVyZW5jZSB0byB0aGVzZSBub2RlcyBzbyB3ZSBjYW4gcmVtb3ZlIGxhdGVyXG4gICAgdGhpcy5ub2RlcyA9IF8udG9BcnJheShmcmFnLmNoaWxkTm9kZXMpXG4gICAgXy5iZWZvcmUoZnJhZywgdGhpcy5hbmNob3IpXG4gIH1cbn1cbiIsInZhciBfID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpXG52YXIgRnJhZ21lbnRGYWN0b3J5ID0gcmVxdWlyZSgnLi4vLi4vZnJhZ21lbnQvZmFjdG9yeScpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIHByaW9yaXR5OiAyMDAwLFxuXG4gIGJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsXG4gICAgaWYgKCFlbC5fX3Z1ZV9fKSB7XG4gICAgICAvLyBjaGVjayBlbHNlIGJsb2NrXG4gICAgICB2YXIgbmV4dCA9IGVsLm5leHRFbGVtZW50U2libGluZ1xuICAgICAgaWYgKG5leHQgJiYgXy5hdHRyKG5leHQsICd2LWVsc2UnKSAhPT0gbnVsbCkge1xuICAgICAgICBfLnJlbW92ZShuZXh0KVxuICAgICAgICB0aGlzLmVsc2VGYWN0b3J5ID0gbmV3IEZyYWdtZW50RmFjdG9yeSh0aGlzLnZtLCBuZXh0KVxuICAgICAgfVxuICAgICAgLy8gY2hlY2sgbWFpbiBibG9ja1xuICAgICAgdGhpcy5hbmNob3IgPSBfLmNyZWF0ZUFuY2hvcigndi1pZicpXG4gICAgICBfLnJlcGxhY2UoZWwsIHRoaXMuYW5jaG9yKVxuICAgICAgdGhpcy5mYWN0b3J5ID0gbmV3IEZyYWdtZW50RmFjdG9yeSh0aGlzLnZtLCBlbClcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBfLndhcm4oXG4gICAgICAgICd2LWlmPVwiJyArIHRoaXMuZXhwcmVzc2lvbiArICdcIiBjYW5ub3QgYmUgJyArXG4gICAgICAgICd1c2VkIG9uIGFuIGluc3RhbmNlIHJvb3QgZWxlbWVudC4nXG4gICAgICApXG4gICAgICB0aGlzLmludmFsaWQgPSB0cnVlXG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaW52YWxpZCkgcmV0dXJuXG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBpZiAoIXRoaXMuZnJhZykge1xuICAgICAgICB0aGlzLmluc2VydCgpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlKClcbiAgICB9XG4gIH0sXG5cbiAgaW5zZXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZWxzZUZyYWcpIHtcbiAgICAgIHRoaXMuZWxzZUZyYWcucmVtb3ZlKHRydWUpXG4gICAgICB0aGlzLmVsc2VGcmFnID0gbnVsbFxuICAgIH1cbiAgICB0aGlzLmZyYWcgPSB0aGlzLmZhY3RvcnkuY3JlYXRlKHRoaXMuX2hvc3QsIHRoaXMuX3Njb3BlLCB0aGlzLl9mcmFnKVxuICAgIHRoaXMuZnJhZy5iZWZvcmUodGhpcy5hbmNob3IpXG4gIH0sXG5cbiAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZnJhZykge1xuICAgICAgdGhpcy5mcmFnLnJlbW92ZSh0cnVlKVxuICAgICAgdGhpcy5mcmFnID0gbnVsbFxuICAgIH1cbiAgICBpZiAodGhpcy5lbHNlRmFjdG9yeSkge1xuICAgICAgdGhpcy5lbHNlRnJhZyA9IHRoaXMuZWxzZUZhY3RvcnkuY3JlYXRlKHRoaXMuX2hvc3QsIHRoaXMuX3Njb3BlLCB0aGlzLl9mcmFnKVxuICAgICAgdGhpcy5lbHNlRnJhZy5iZWZvcmUodGhpcy5hbmNob3IpXG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmZyYWcpIHtcbiAgICAgIHRoaXMuZnJhZy5kZXN0cm95KClcbiAgICB9XG4gIH1cbn1cbiIsIi8vIHRleHQgJiBodG1sXG5leHBvcnRzLnRleHQgPSByZXF1aXJlKCcuL3RleHQnKVxuZXhwb3J0cy5odG1sID0gcmVxdWlyZSgnLi9odG1sJylcblxuLy8gbG9naWMgY29udHJvbFxuZXhwb3J0c1snZm9yJ10gPSByZXF1aXJlKCcuL2ZvcicpXG5leHBvcnRzWydpZiddID0gcmVxdWlyZSgnLi9pZicpXG5leHBvcnRzLnNob3cgPSByZXF1aXJlKCcuL3Nob3cnKVxuXG4vLyB0d28td2F5IGJpbmRpbmdcbmV4cG9ydHMubW9kZWwgPSByZXF1aXJlKCcuL21vZGVsJylcblxuLy8gZXZlbnQgaGFuZGxpbmdcbmV4cG9ydHMub24gPSByZXF1aXJlKCcuL29uJylcblxuLy8gYXR0cmlidXRlc1xuZXhwb3J0cy5iaW5kID0gcmVxdWlyZSgnLi9iaW5kJylcblxuLy8gcmVmICYgZWxcbmV4cG9ydHMuZWwgPSByZXF1aXJlKCcuL2VsJylcbmV4cG9ydHMucmVmID0gcmVxdWlyZSgnLi9yZWYnKVxuXG4vLyBjbG9ha1xuZXhwb3J0cy5jbG9hayA9IHJlcXVpcmUoJy4vY2xvYWsnKVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgYmluZDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIHZhciBlbCA9IHRoaXMuZWxcblxuICAgIHRoaXMuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZWwuaGFzT3duUHJvcGVydHkoJ192YWx1ZScpXG4gICAgICAgID8gZWwuX3ZhbHVlXG4gICAgICAgIDogc2VsZi5wYXJhbXMubnVtYmVyXG4gICAgICAgICAgPyBfLnRvTnVtYmVyKGVsLnZhbHVlKVxuICAgICAgICAgIDogZWwudmFsdWVcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRCb29sZWFuVmFsdWUgKCkge1xuICAgICAgdmFyIHZhbCA9IGVsLmNoZWNrZWRcbiAgICAgIGlmICh2YWwgJiYgZWwuaGFzT3duUHJvcGVydHkoJ190cnVlVmFsdWUnKSkge1xuICAgICAgICByZXR1cm4gZWwuX3RydWVWYWx1ZVxuICAgICAgfVxuICAgICAgaWYgKCF2YWwgJiYgZWwuaGFzT3duUHJvcGVydHkoJ19mYWxzZVZhbHVlJykpIHtcbiAgICAgICAgcmV0dXJuIGVsLl9mYWxzZVZhbHVlXG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsXG4gICAgfVxuXG4gICAgdGhpcy5saXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBtb2RlbCA9IHNlbGYuX3dhdGNoZXIudmFsdWVcbiAgICAgIGlmIChfLmlzQXJyYXkobW9kZWwpKSB7XG4gICAgICAgIHZhciB2YWwgPSBzZWxmLmdldFZhbHVlKClcbiAgICAgICAgaWYgKGVsLmNoZWNrZWQpIHtcbiAgICAgICAgICBpZiAoXy5pbmRleE9mKG1vZGVsLCB2YWwpIDwgMCkge1xuICAgICAgICAgICAgbW9kZWwucHVzaCh2YWwpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vZGVsLiRyZW1vdmUodmFsKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLnNldChnZXRCb29sZWFuVmFsdWUoKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm9uKCdjaGFuZ2UnLCB0aGlzLmxpc3RlbmVyKVxuICAgIGlmIChlbC5jaGVja2VkKSB7XG4gICAgICB0aGlzLmFmdGVyQmluZCA9IHRoaXMubGlzdGVuZXJcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsXG4gICAgaWYgKF8uaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGVsLmNoZWNrZWQgPSBfLmluZGV4T2YodmFsdWUsIHRoaXMuZ2V0VmFsdWUoKSkgPiAtMVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZWwuaGFzT3duUHJvcGVydHkoJ190cnVlVmFsdWUnKSkge1xuICAgICAgICBlbC5jaGVja2VkID0gXy5sb29zZUVxdWFsKHZhbHVlLCBlbC5fdHJ1ZVZhbHVlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuY2hlY2tlZCA9ICEhdmFsdWVcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiIsInZhciBfID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbCcpXG5cbnZhciBoYW5kbGVycyA9IHtcbiAgdGV4dDogcmVxdWlyZSgnLi90ZXh0JyksXG4gIHJhZGlvOiByZXF1aXJlKCcuL3JhZGlvJyksXG4gIHNlbGVjdDogcmVxdWlyZSgnLi9zZWxlY3QnKSxcbiAgY2hlY2tib3g6IHJlcXVpcmUoJy4vY2hlY2tib3gnKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICBwcmlvcml0eTogODAwLFxuICB0d29XYXk6IHRydWUsXG4gIGhhbmRsZXJzOiBoYW5kbGVycyxcbiAgcGFyYW1zOiBbJ2xhenknLCAnbnVtYmVyJywgJ2RlYm91bmNlJ10sXG5cbiAgLyoqXG4gICAqIFBvc3NpYmxlIGVsZW1lbnRzOlxuICAgKiAgIDxzZWxlY3Q+XG4gICAqICAgPHRleHRhcmVhPlxuICAgKiAgIDxpbnB1dCB0eXBlPVwiKlwiPlxuICAgKiAgICAgLSB0ZXh0XG4gICAqICAgICAtIGNoZWNrYm94XG4gICAqICAgICAtIHJhZGlvXG4gICAqICAgICAtIG51bWJlclxuICAgKi9cblxuICBiaW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gZnJpZW5kbHkgd2FybmluZy4uLlxuICAgIHRoaXMuY2hlY2tGaWx0ZXJzKClcbiAgICBpZiAodGhpcy5oYXNSZWFkICYmICF0aGlzLmhhc1dyaXRlKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIF8ud2FybihcbiAgICAgICAgJ0l0IHNlZW1zIHlvdSBhcmUgdXNpbmcgYSByZWFkLW9ubHkgZmlsdGVyIHdpdGggJyArXG4gICAgICAgICd2LW1vZGVsLiBZb3UgbWlnaHQgd2FudCB0byB1c2UgYSB0d28td2F5IGZpbHRlciAnICtcbiAgICAgICAgJ3RvIGVuc3VyZSBjb3JyZWN0IGJlaGF2aW9yLidcbiAgICAgIClcbiAgICB9XG4gICAgdmFyIGVsID0gdGhpcy5lbFxuICAgIHZhciB0YWcgPSBlbC50YWdOYW1lXG4gICAgdmFyIGhhbmRsZXJcbiAgICBpZiAodGFnID09PSAnSU5QVVQnKSB7XG4gICAgICBoYW5kbGVyID0gaGFuZGxlcnNbZWwudHlwZV0gfHwgaGFuZGxlcnMudGV4dFxuICAgIH0gZWxzZSBpZiAodGFnID09PSAnU0VMRUNUJykge1xuICAgICAgaGFuZGxlciA9IGhhbmRsZXJzLnNlbGVjdFxuICAgIH0gZWxzZSBpZiAodGFnID09PSAnVEVYVEFSRUEnKSB7XG4gICAgICBoYW5kbGVyID0gaGFuZGxlcnMudGV4dFxuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIF8ud2FybihcbiAgICAgICAgJ3YtbW9kZWwgZG9lcyBub3Qgc3VwcG9ydCBlbGVtZW50IHR5cGU6ICcgKyB0YWdcbiAgICAgIClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBlbC5fX3ZfbW9kZWwgPSB0aGlzXG4gICAgaGFuZGxlci5iaW5kLmNhbGwodGhpcylcbiAgICB0aGlzLnVwZGF0ZSA9IGhhbmRsZXIudXBkYXRlXG4gICAgdGhpcy5fdW5iaW5kID0gaGFuZGxlci51bmJpbmRcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2sgcmVhZC93cml0ZSBmaWx0ZXIgc3RhdHMuXG4gICAqL1xuXG4gIGNoZWNrRmlsdGVyczogZnVuY3Rpb24gKCkge1xuICAgIHZhciBmaWx0ZXJzID0gdGhpcy5maWx0ZXJzXG4gICAgaWYgKCFmaWx0ZXJzKSByZXR1cm5cbiAgICB2YXIgaSA9IGZpbHRlcnMubGVuZ3RoXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFyIGZpbHRlciA9IF8ucmVzb2x2ZUFzc2V0KHRoaXMudm0uJG9wdGlvbnMsICdmaWx0ZXJzJywgZmlsdGVyc1tpXS5uYW1lKVxuICAgICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicgfHwgZmlsdGVyLnJlYWQpIHtcbiAgICAgICAgdGhpcy5oYXNSZWFkID0gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKGZpbHRlci53cml0ZSkge1xuICAgICAgICB0aGlzLmhhc1dyaXRlID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVsLl9fdl9tb2RlbCA9IG51bGxcbiAgICB0aGlzLl91bmJpbmQgJiYgdGhpcy5fdW5iaW5kKClcbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgYmluZDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIHZhciBlbCA9IHRoaXMuZWxcblxuICAgIHRoaXMuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyB2YWx1ZSBvdmVyd3JpdGUgdmlhIHYtYmluZDp2YWx1ZVxuICAgICAgaWYgKGVsLmhhc093blByb3BlcnR5KCdfdmFsdWUnKSkge1xuICAgICAgICByZXR1cm4gZWwuX3ZhbHVlXG4gICAgICB9XG4gICAgICB2YXIgdmFsID0gZWwudmFsdWVcbiAgICAgIGlmIChzZWxmLnBhcmFtcy5udW1iZXIpIHtcbiAgICAgICAgdmFsID0gXy50b051bWJlcih2YWwpXG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsXG4gICAgfVxuXG4gICAgdGhpcy5saXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuc2V0KHNlbGYuZ2V0VmFsdWUoKSlcbiAgICB9XG4gICAgdGhpcy5vbignY2hhbmdlJywgdGhpcy5saXN0ZW5lcilcblxuICAgIGlmIChlbC5jaGVja2VkKSB7XG4gICAgICB0aGlzLmFmdGVyQmluZCA9IHRoaXMubGlzdGVuZXJcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLmVsLmNoZWNrZWQgPSBfLmxvb3NlRXF1YWwodmFsdWUsIHRoaXMuZ2V0VmFsdWUoKSlcbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgYmluZDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIHZhciBlbCA9IHRoaXMuZWxcblxuICAgIC8vIG1ldGhvZCB0byBmb3JjZSB1cGRhdGUgRE9NIHVzaW5nIGxhdGVzdCB2YWx1ZS5cbiAgICB0aGlzLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuX3dhdGNoZXIpIHtcbiAgICAgICAgc2VsZi51cGRhdGUoc2VsZi5fd2F0Y2hlci5nZXQoKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiB0aGlzIGlzIGEgbXVsdGlwbGUgc2VsZWN0XG4gICAgdmFyIG11bHRpcGxlID0gdGhpcy5tdWx0aXBsZSA9IGVsLmhhc0F0dHJpYnV0ZSgnbXVsdGlwbGUnKVxuXG4gICAgLy8gYXR0YWNoIGxpc3RlbmVyXG4gICAgdGhpcy5saXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldFZhbHVlKGVsLCBtdWx0aXBsZSlcbiAgICAgIHZhbHVlID0gc2VsZi5wYXJhbXMubnVtYmVyXG4gICAgICAgID8gXy5pc0FycmF5KHZhbHVlKVxuICAgICAgICAgID8gdmFsdWUubWFwKF8udG9OdW1iZXIpXG4gICAgICAgICAgOiBfLnRvTnVtYmVyKHZhbHVlKVxuICAgICAgICA6IHZhbHVlXG4gICAgICBzZWxmLnNldCh2YWx1ZSlcbiAgICB9XG4gICAgdGhpcy5vbignY2hhbmdlJywgdGhpcy5saXN0ZW5lcilcblxuICAgIC8vIGlmIGhhcyBpbml0aWFsIHZhbHVlLCBzZXQgYWZ0ZXJCaW5kXG4gICAgdmFyIGluaXRWYWx1ZSA9IGdldFZhbHVlKGVsLCBtdWx0aXBsZSwgdHJ1ZSlcbiAgICBpZiAoKG11bHRpcGxlICYmIGluaXRWYWx1ZS5sZW5ndGgpIHx8XG4gICAgICAgICghbXVsdGlwbGUgJiYgaW5pdFZhbHVlICE9PSBudWxsKSkge1xuICAgICAgdGhpcy5hZnRlckJpbmQgPSB0aGlzLmxpc3RlbmVyXG4gICAgfVxuXG4gICAgLy8gQWxsIG1ham9yIGJyb3dzZXJzIGV4Y2VwdCBGaXJlZm94IHJlc2V0c1xuICAgIC8vIHNlbGVjdGVkSW5kZXggd2l0aCB2YWx1ZSAtMSB0byAwIHdoZW4gdGhlIGVsZW1lbnRcbiAgICAvLyBpcyBhcHBlbmRlZCB0byBhIG5ldyBwYXJlbnQsIHRoZXJlZm9yZSB3ZSBoYXZlIHRvXG4gICAgLy8gZm9yY2UgYSBET00gdXBkYXRlIHdoZW5ldmVyIHRoYXQgaGFwcGVucy4uLlxuICAgIHRoaXMudm0uJG9uKCdob29rOmF0dGFjaGVkJywgdGhpcy5mb3JjZVVwZGF0ZSlcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBlbCA9IHRoaXMuZWxcbiAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTFcbiAgICB2YXIgbXVsdGkgPSB0aGlzLm11bHRpcGxlICYmIF8uaXNBcnJheSh2YWx1ZSlcbiAgICB2YXIgb3B0aW9ucyA9IGVsLm9wdGlvbnNcbiAgICB2YXIgaSA9IG9wdGlvbnMubGVuZ3RoXG4gICAgdmFyIG9wLCB2YWxcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBvcCA9IG9wdGlvbnNbaV1cbiAgICAgIHZhbCA9IG9wLmhhc093blByb3BlcnR5KCdfdmFsdWUnKVxuICAgICAgICA/IG9wLl92YWx1ZVxuICAgICAgICA6IG9wLnZhbHVlXG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBlcWVxZXEgKi9cbiAgICAgIG9wLnNlbGVjdGVkID0gbXVsdGlcbiAgICAgICAgPyBpbmRleE9mKHZhbHVlLCB2YWwpID4gLTFcbiAgICAgICAgOiBfLmxvb3NlRXF1YWwodmFsdWUsIHZhbClcbiAgICAgIC8qIGVzbGludC1lbmFibGUgZXFlcWVxICovXG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdGhpcy52bS4kb2ZmKCdob29rOmF0dGFjaGVkJywgdGhpcy5mb3JjZVVwZGF0ZSlcbiAgfVxufVxuXG4vKipcbiAqIEdldCBzZWxlY3QgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge1NlbGVjdEVsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG11bHRpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGluaXRcbiAqIEByZXR1cm4ge0FycmF5fCp9XG4gKi9cblxuZnVuY3Rpb24gZ2V0VmFsdWUgKGVsLCBtdWx0aSwgaW5pdCkge1xuICB2YXIgcmVzID0gbXVsdGkgPyBbXSA6IG51bGxcbiAgdmFyIG9wLCB2YWwsIHNlbGVjdGVkXG4gIGZvciAodmFyIGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvcCA9IGVsLm9wdGlvbnNbaV1cbiAgICBzZWxlY3RlZCA9IGluaXRcbiAgICAgID8gb3AuaGFzQXR0cmlidXRlKCdzZWxlY3RlZCcpXG4gICAgICA6IG9wLnNlbGVjdGVkXG4gICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICB2YWwgPSBvcC5oYXNPd25Qcm9wZXJ0eSgnX3ZhbHVlJylcbiAgICAgICAgPyBvcC5fdmFsdWVcbiAgICAgICAgOiBvcC52YWx1ZVxuICAgICAgaWYgKG11bHRpKSB7XG4gICAgICAgIHJlcy5wdXNoKHZhbClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKipcbiAqIE5hdGl2ZSBBcnJheS5pbmRleE9mIHVzZXMgc3RyaWN0IGVxdWFsLCBidXQgaW4gdGhpc1xuICogY2FzZSB3ZSBuZWVkIHRvIG1hdGNoIHN0cmluZy9udW1iZXJzIHdpdGggY3VzdG9tIGVxdWFsLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICogQHBhcmFtIHsqfSB2YWxcbiAqL1xuXG5mdW5jdGlvbiBpbmRleE9mIChhcnIsIHZhbCkge1xuICB2YXIgaSA9IGFyci5sZW5ndGhcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChfLmxvb3NlRXF1YWwoYXJyW2ldLCB2YWwpKSB7XG4gICAgICByZXR1cm4gaVxuICAgIH1cbiAgfVxuICByZXR1cm4gLTFcbn1cbiIsInZhciBfID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbCcpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIGJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICB2YXIgZWwgPSB0aGlzLmVsXG4gICAgdmFyIGlzUmFuZ2UgPSBlbC50eXBlID09PSAncmFuZ2UnXG4gICAgdmFyIGxhenkgPSB0aGlzLnBhcmFtcy5sYXp5XG4gICAgdmFyIG51bWJlciA9IHRoaXMucGFyYW1zLm51bWJlclxuICAgIHZhciBkZWJvdW5jZSA9IHRoaXMucGFyYW1zLmRlYm91bmNlXG5cbiAgICAvLyBoYW5kbGUgY29tcG9zaXRpb24gZXZlbnRzLlxuICAgIC8vICAgaHR0cDovL2Jsb2cuZXZhbnlvdS5tZS8yMDE0LzAxLzAzL2NvbXBvc2l0aW9uLWV2ZW50L1xuICAgIC8vIHNraXAgdGhpcyBmb3IgQW5kcm9pZCBiZWNhdXNlIGl0IGhhbmRsZXMgY29tcG9zaXRpb25cbiAgICAvLyBldmVudHMgcXVpdGUgZGlmZmVyZW50bHkuIEFuZHJvaWQgZG9lc24ndCB0cmlnZ2VyXG4gICAgLy8gY29tcG9zaXRpb24gZXZlbnRzIGZvciBsYW5ndWFnZSBpbnB1dCBtZXRob2RzIGUuZy5cbiAgICAvLyBDaGluZXNlLCBidXQgaW5zdGVhZCB0cmlnZ2VycyB0aGVtIGZvciBzcGVsbGluZ1xuICAgIC8vIHN1Z2dlc3Rpb25zLi4uIChzZWUgRGlzY3Vzc2lvbi8jMTYyKVxuICAgIHZhciBjb21wb3NpbmcgPSBmYWxzZVxuICAgIGlmICghXy5pc0FuZHJvaWQgJiYgIWlzUmFuZ2UpIHtcbiAgICAgIHRoaXMub24oJ2NvbXBvc2l0aW9uc3RhcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbXBvc2luZyA9IHRydWVcbiAgICAgIH0pXG4gICAgICB0aGlzLm9uKCdjb21wb3NpdGlvbmVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29tcG9zaW5nID0gZmFsc2VcbiAgICAgICAgLy8gaW4gSUUxMSB0aGUgXCJjb21wb3NpdGlvbmVuZFwiIGV2ZW50IGZpcmVzIEFGVEVSXG4gICAgICAgIC8vIHRoZSBcImlucHV0XCIgZXZlbnQsIHNvIHRoZSBpbnB1dCBoYW5kbGVyIGlzIGJsb2NrZWRcbiAgICAgICAgLy8gYXQgdGhlIGVuZC4uLiBoYXZlIHRvIGNhbGwgaXQgaGVyZS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gIzEzMjc6IGluIGxhenkgbW9kZSB0aGlzIGlzIHVuZWNlc3NhcnkuXG4gICAgICAgIGlmICghbGF6eSkge1xuICAgICAgICAgIHNlbGYubGlzdGVuZXIoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIHByZXZlbnQgbWVzc2luZyB3aXRoIHRoZSBpbnB1dCB3aGVuIHVzZXIgaXMgdHlwaW5nLFxuICAgIC8vIGFuZCBmb3JjZSB1cGRhdGUgb24gYmx1ci5cbiAgICB0aGlzLmZvY3VzZWQgPSBmYWxzZVxuICAgIGlmICghaXNSYW5nZSkge1xuICAgICAgdGhpcy5vbignZm9jdXMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuZm9jdXNlZCA9IHRydWVcbiAgICAgIH0pXG4gICAgICB0aGlzLm9uKCdibHVyJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLmZvY3VzZWQgPSBmYWxzZVxuICAgICAgICBzZWxmLmxpc3RlbmVyKClcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gTm93IGF0dGFjaCB0aGUgbWFpbiBsaXN0ZW5lclxuICAgIHRoaXMubGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoY29tcG9zaW5nKSByZXR1cm5cbiAgICAgIHZhciB2YWwgPSBudW1iZXIgfHwgaXNSYW5nZVxuICAgICAgICA/IF8udG9OdW1iZXIoZWwudmFsdWUpXG4gICAgICAgIDogZWwudmFsdWVcbiAgICAgIHNlbGYuc2V0KHZhbClcbiAgICAgIC8vIGZvcmNlIHVwZGF0ZSBvbiBuZXh0IHRpY2sgdG8gYXZvaWQgbG9jayAmIHNhbWUgdmFsdWVcbiAgICAgIC8vIGFsc28gb25seSB1cGRhdGUgd2hlbiB1c2VyIGlzIG5vdCB0eXBpbmdcbiAgICAgIF8ubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoc2VsZi5fYm91bmQgJiYgIXNlbGYuZm9jdXNlZCkge1xuICAgICAgICAgIHNlbGYudXBkYXRlKHNlbGYuX3dhdGNoZXIudmFsdWUpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gYXBwbHkgZGVib3VuY2VcbiAgICBpZiAoZGVib3VuY2UpIHtcbiAgICAgIHRoaXMubGlzdGVuZXIgPSBfLmRlYm91bmNlKHRoaXMubGlzdGVuZXIsIGRlYm91bmNlKVxuICAgIH1cblxuICAgIC8vIFN1cHBvcnQgalF1ZXJ5IGV2ZW50cywgc2luY2UgalF1ZXJ5LnRyaWdnZXIoKSBkb2Vzbid0XG4gICAgLy8gdHJpZ2dlciBuYXRpdmUgZXZlbnRzIGluIHNvbWUgY2FzZXMgYW5kIHNvbWUgcGx1Z2luc1xuICAgIC8vIHJlbHkgb24gJC50cmlnZ2VyKClcbiAgICAvL1xuICAgIC8vIFdlIHdhbnQgdG8gbWFrZSBzdXJlIGlmIGEgbGlzdGVuZXIgaXMgYXR0YWNoZWQgdXNpbmdcbiAgICAvLyBqUXVlcnksIGl0IGlzIGFsc28gcmVtb3ZlZCB3aXRoIGpRdWVyeSwgdGhhdCdzIHdoeVxuICAgIC8vIHdlIGRvIHRoZSBjaGVjayBmb3IgZWFjaCBkaXJlY3RpdmUgaW5zdGFuY2UgYW5kXG4gICAgLy8gc3RvcmUgdGhhdCBjaGVjayByZXN1bHQgb24gaXRzZWxmLiBUaGlzIGFsc28gYWxsb3dzXG4gICAgLy8gZWFzaWVyIHRlc3QgY292ZXJhZ2UgY29udHJvbCBieSB1bnNldHRpbmcgdGhlIGdsb2JhbFxuICAgIC8vIGpRdWVyeSB2YXJpYWJsZSBpbiB0ZXN0cy5cbiAgICB0aGlzLmhhc2pRdWVyeSA9IHR5cGVvZiBqUXVlcnkgPT09ICdmdW5jdGlvbidcbiAgICBpZiAodGhpcy5oYXNqUXVlcnkpIHtcbiAgICAgIGpRdWVyeShlbCkub24oJ2NoYW5nZScsIHRoaXMubGlzdGVuZXIpXG4gICAgICBpZiAoIWxhenkpIHtcbiAgICAgICAgalF1ZXJ5KGVsKS5vbignaW5wdXQnLCB0aGlzLmxpc3RlbmVyKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uKCdjaGFuZ2UnLCB0aGlzLmxpc3RlbmVyKVxuICAgICAgaWYgKCFsYXp5KSB7XG4gICAgICAgIHRoaXMub24oJ2lucHV0JywgdGhpcy5saXN0ZW5lcilcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJRTkgZG9lc24ndCBmaXJlIGlucHV0IGV2ZW50IG9uIGJhY2tzcGFjZS9kZWwvY3V0XG4gICAgaWYgKCFsYXp5ICYmIF8uaXNJRTkpIHtcbiAgICAgIHRoaXMub24oJ2N1dCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgXy5uZXh0VGljayhzZWxmLmxpc3RlbmVyKVxuICAgICAgfSlcbiAgICAgIHRoaXMub24oJ2tleXVwJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gNDYgfHwgZS5rZXlDb2RlID09PSA4KSB7XG4gICAgICAgICAgc2VsZi5saXN0ZW5lcigpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gc2V0IGluaXRpYWwgdmFsdWUgaWYgcHJlc2VudFxuICAgIGlmIChcbiAgICAgIGVsLmhhc0F0dHJpYnV0ZSgndmFsdWUnKSB8fFxuICAgICAgKGVsLnRhZ05hbWUgPT09ICdURVhUQVJFQScgJiYgZWwudmFsdWUudHJpbSgpKVxuICAgICkge1xuICAgICAgdGhpcy5hZnRlckJpbmQgPSB0aGlzLmxpc3RlbmVyXG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy5lbC52YWx1ZSA9IF8udG9TdHJpbmcodmFsdWUpXG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbFxuICAgIGlmICh0aGlzLmhhc2pRdWVyeSkge1xuICAgICAgalF1ZXJ5KGVsKS5vZmYoJ2NoYW5nZScsIHRoaXMubGlzdGVuZXIpXG4gICAgICBqUXVlcnkoZWwpLm9mZignaW5wdXQnLCB0aGlzLmxpc3RlbmVyKVxuICAgIH1cbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi8uLi91dGlsJylcblxuLy8ga2V5Q29kZSBhbGlhc2VzXG52YXIga2V5Q29kZXMgPSB7XG4gIGVzYzogMjcsXG4gIHRhYjogOSxcbiAgZW50ZXI6IDEzLFxuICBzcGFjZTogMzIsXG4gICdkZWxldGUnOiA0NixcbiAgdXA6IDM4LFxuICBsZWZ0OiAzNyxcbiAgcmlnaHQ6IDM5LFxuICBkb3duOiA0MFxufVxuXG5mdW5jdGlvbiBrZXlGaWx0ZXIgKGhhbmRsZXIsIGtleXMpIHtcbiAgdmFyIGNvZGVzID0ga2V5cy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBjb2RlID0ga2V5Q29kZXNba2V5XVxuICAgIGlmICghY29kZSkge1xuICAgICAgY29kZSA9IHBhcnNlSW50KGtleSwgMTApXG4gICAgfVxuICAgIHJldHVybiBjb2RlXG4gIH0pXG4gIHJldHVybiBmdW5jdGlvbiBrZXlIYW5kbGVyIChlKSB7XG4gICAgaWYgKGNvZGVzLmluZGV4T2YoZS5rZXlDb2RlKSA+IC0xKSB7XG4gICAgICByZXR1cm4gaGFuZGxlci5jYWxsKHRoaXMsIGUpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BGaWx0ZXIgKGhhbmRsZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN0b3BIYW5kbGVyIChlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgIHJldHVybiBoYW5kbGVyLmNhbGwodGhpcywgZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmV2ZW50RmlsdGVyIChoYW5kbGVyKSB7XG4gIHJldHVybiBmdW5jdGlvbiBwcmV2ZW50SGFuZGxlciAoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIHJldHVybiBoYW5kbGVyLmNhbGwodGhpcywgZSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICBhY2NlcHRTdGF0ZW1lbnQ6IHRydWUsXG4gIHByaW9yaXR5OiA3MDAsXG5cbiAgYmluZDogZnVuY3Rpb24gKCkge1xuICAgIC8vIGRlYWwgd2l0aCBpZnJhbWVzXG4gICAgaWYgKFxuICAgICAgdGhpcy5lbC50YWdOYW1lID09PSAnSUZSQU1FJyAmJlxuICAgICAgdGhpcy5hcmcgIT09ICdsb2FkJ1xuICAgICkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgICB0aGlzLmlmcmFtZUJpbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF8ub24oc2VsZi5lbC5jb250ZW50V2luZG93LCBzZWxmLmFyZywgc2VsZi5oYW5kbGVyKVxuICAgICAgfVxuICAgICAgdGhpcy5vbignbG9hZCcsIHRoaXMuaWZyYW1lQmluZClcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgIC8vIHN0dWIgYSBub29wIGZvciB2LW9uIHdpdGggbm8gdmFsdWUsXG4gICAgLy8gZS5nLiBAbW91c2Vkb3duLnByZXZlbnRcbiAgICBpZiAoIXRoaXMuZGVzY3JpcHRvci5yYXcpIHtcbiAgICAgIGhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7fVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBfLndhcm4oXG4gICAgICAgICd2LW9uOicgKyB0aGlzLmFyZyArICc9XCInICtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uICsgJ1wiIGV4cGVjdHMgYSBmdW5jdGlvbiB2YWx1ZSwgJyArXG4gICAgICAgICdnb3QgJyArIGhhbmRsZXJcbiAgICAgIClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGFwcGx5IG1vZGlmaWVyc1xuICAgIGlmICh0aGlzLm1vZGlmaWVycy5zdG9wKSB7XG4gICAgICBoYW5kbGVyID0gc3RvcEZpbHRlcihoYW5kbGVyKVxuICAgIH1cbiAgICBpZiAodGhpcy5tb2RpZmllcnMucHJldmVudCkge1xuICAgICAgaGFuZGxlciA9IHByZXZlbnRGaWx0ZXIoaGFuZGxlcilcbiAgICB9XG4gICAgLy8ga2V5IGZpbHRlclxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGhpcy5tb2RpZmllcnMpXG4gICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleSAhPT0gJ3N0b3AnICYmIGtleSAhPT0gJ3ByZXZlbnQnXG4gICAgICB9KVxuICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgaGFuZGxlciA9IGtleUZpbHRlcihoYW5kbGVyLCBrZXlzKVxuICAgIH1cblxuICAgIHRoaXMucmVzZXQoKVxuICAgIHZhciBzY29wZSA9IHRoaXMuX3Njb3BlIHx8IHRoaXMudm1cbiAgICB0aGlzLmhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgc2NvcGUuJGV2ZW50ID0gZVxuICAgICAgdmFyIHJlcyA9IGhhbmRsZXIoZSlcbiAgICAgIHNjb3BlLiRldmVudCA9IG51bGxcbiAgICAgIHJldHVybiByZXNcbiAgICB9XG4gICAgaWYgKHRoaXMuaWZyYW1lQmluZCkge1xuICAgICAgdGhpcy5pZnJhbWVCaW5kKClcbiAgICB9IGVsc2Uge1xuICAgICAgXy5vbih0aGlzLmVsLCB0aGlzLmFyZywgdGhpcy5oYW5kbGVyKVxuICAgIH1cbiAgfSxcblxuICByZXNldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbCA9IHRoaXMuaWZyYW1lQmluZFxuICAgICAgPyB0aGlzLmVsLmNvbnRlbnRXaW5kb3dcbiAgICAgIDogdGhpcy5lbFxuICAgIGlmICh0aGlzLmhhbmRsZXIpIHtcbiAgICAgIF8ub2ZmKGVsLCB0aGlzLmFyZywgdGhpcy5oYW5kbGVyKVxuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlc2V0KClcbiAgfVxufVxuIiwiaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYmluZDogZnVuY3Rpb24gKCkge1xuICAgICAgcmVxdWlyZSgnLi4vLi4vdXRpbCcpLndhcm4oXG4gICAgICAgICd2LXJlZjonICsgdGhpcy5hcmcgKyAnIG11c3QgYmUgdXNlZCBvbiBhIGNoaWxkICcgK1xuICAgICAgICAnY29tcG9uZW50LiBGb3VuZCBvbiA8JyArIHRoaXMuZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpICsgJz4uJ1xuICAgICAgKVxuICAgIH1cbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi8uLi91dGlsJylcbnZhciB0cmFuc2l0aW9uID0gcmVxdWlyZSgnLi4vLi4vdHJhbnNpdGlvbicpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIGJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBjaGVjayBlbHNlIGJsb2NrXG4gICAgdmFyIG5leHQgPSB0aGlzLmVsLm5leHRFbGVtZW50U2libGluZ1xuICAgIGlmIChuZXh0ICYmIF8uYXR0cihuZXh0LCAndi1lbHNlJykgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuZWxzZUVsID0gbmV4dFxuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBlbCA9IHRoaXMuZWxcbiAgICB0cmFuc2l0aW9uLmFwcGx5KGVsLCB2YWx1ZSA/IDEgOiAtMSwgZnVuY3Rpb24gKCkge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gJycgOiAnbm9uZSdcbiAgICB9LCB0aGlzLnZtKVxuICAgIHZhciBlbHNlRWwgPSB0aGlzLmVsc2VFbFxuICAgIGlmIChlbHNlRWwpIHtcbiAgICAgIHRyYW5zaXRpb24uYXBwbHkoZWxzZUVsLCB2YWx1ZSA/IC0xIDogMSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBlbHNlRWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gJ25vbmUnIDogJydcbiAgICAgIH0sIHRoaXMudm0pXG4gICAgfVxuICB9XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICBiaW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hdHRyID0gdGhpcy5lbC5ub2RlVHlwZSA9PT0gM1xuICAgICAgPyAnZGF0YSdcbiAgICAgIDogJ3RleHRDb250ZW50J1xuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy5lbFt0aGlzLmF0dHJdID0gXy50b1N0cmluZyh2YWx1ZSlcbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi91dGlsJylcbnZhciBQYXRoID0gcmVxdWlyZSgnLi4vcGFyc2Vycy9wYXRoJylcbnZhciB0b0FycmF5ID0gcmVxdWlyZSgnLi4vZGlyZWN0aXZlcy9wdWJsaWMvZm9yJykuX3Bvc3RQcm9jZXNzXG5cbi8qKlxuICogTGltaXQgZmlsdGVyIGZvciBhcnJheXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICovXG5cbmV4cG9ydHMubGltaXRCeSA9IGZ1bmN0aW9uIChhcnIsIG4pIHtcbiAgcmV0dXJuIHR5cGVvZiBuID09PSAnbnVtYmVyJ1xuICAgID8gYXJyLnNsaWNlKDAsIG4pXG4gICAgOiBhcnJcbn1cblxuLyoqXG4gKiBGaWx0ZXIgZmlsdGVyIGZvciBhcnJheXNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VhcmNoS2V5XG4gKiBAcGFyYW0ge1N0cmluZ30gW2RlbGltaXRlcl1cbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhS2V5XG4gKi9cblxuZXhwb3J0cy5maWx0ZXJCeSA9IGZ1bmN0aW9uIChhcnIsIHNlYXJjaCwgZGVsaW1pdGVyIC8qIC4uLmRhdGFLZXlzICovKSB7XG4gIGFyciA9IHRvQXJyYXkoYXJyKVxuICBpZiAoc2VhcmNoID09IG51bGwpIHtcbiAgICByZXR1cm4gYXJyXG4gIH1cbiAgaWYgKHR5cGVvZiBzZWFyY2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gYXJyLmZpbHRlcihzZWFyY2gpXG4gIH1cbiAgLy8gY2FzdCB0byBsb3dlcmNhc2Ugc3RyaW5nXG4gIHNlYXJjaCA9ICgnJyArIHNlYXJjaCkudG9Mb3dlckNhc2UoKVxuICAvLyBhbGxvdyBvcHRpb25hbCBgaW5gIGRlbGltaXRlclxuICAvLyBiZWNhdXNlIHdoeSBub3RcbiAgdmFyIG4gPSBkZWxpbWl0ZXIgPT09ICdpbicgPyAzIDogMlxuICAvLyBleHRyYWN0IGFuZCBmbGF0dGVuIGtleXNcbiAgdmFyIGtleXMgPSBfLnRvQXJyYXkoYXJndW1lbnRzLCBuKS5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cikge1xuICAgIHJldHVybiBwcmV2LmNvbmNhdChjdXIpXG4gIH0sIFtdKVxuICB2YXIgcmVzID0gW11cbiAgdmFyIGl0ZW0sIGtleSwgdmFsLCBqXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGl0ZW0gPSBhcnJbaV1cbiAgICB2YWwgPSAoaXRlbSAmJiBpdGVtLiR2YWx1ZSkgfHwgaXRlbVxuICAgIGogPSBrZXlzLmxlbmd0aFxuICAgIGlmIChqKSB7XG4gICAgICB3aGlsZSAoai0tKSB7XG4gICAgICAgIGtleSA9IGtleXNbal1cbiAgICAgICAgaWYgKChrZXkgPT09ICcka2V5JyAmJiBjb250YWlucyhpdGVtLiRrZXksIHNlYXJjaCkpIHx8XG4gICAgICAgICAgICBjb250YWlucyhQYXRoLmdldCh2YWwsIGtleSksIHNlYXJjaCkpIHtcbiAgICAgICAgICByZXMucHVzaChpdGVtKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNvbnRhaW5zKGl0ZW0sIHNlYXJjaCkpIHtcbiAgICAgIHJlcy5wdXNoKGl0ZW0pXG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyoqXG4gKiBGaWx0ZXIgZmlsdGVyIGZvciBhcnJheXNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc29ydEtleVxuICogQHBhcmFtIHtTdHJpbmd9IHJldmVyc2VcbiAqL1xuXG5leHBvcnRzLm9yZGVyQnkgPSBmdW5jdGlvbiAoYXJyLCBzb3J0S2V5LCByZXZlcnNlKSB7XG4gIGFyciA9IHRvQXJyYXkoYXJyKVxuICBpZiAoIXNvcnRLZXkpIHtcbiAgICByZXR1cm4gYXJyXG4gIH1cbiAgdmFyIG9yZGVyID0gKHJldmVyc2UgJiYgcmV2ZXJzZSA8IDApID8gLTEgOiAxXG4gIC8vIHNvcnQgb24gYSBjb3B5IHRvIGF2b2lkIG11dGF0aW5nIG9yaWdpbmFsIGFycmF5XG4gIHJldHVybiBhcnIuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgaWYgKHNvcnRLZXkgIT09ICcka2V5Jykge1xuICAgICAgaWYgKF8uaXNPYmplY3QoYSkgJiYgJyR2YWx1ZScgaW4gYSkgYSA9IGEuJHZhbHVlXG4gICAgICBpZiAoXy5pc09iamVjdChiKSAmJiAnJHZhbHVlJyBpbiBiKSBiID0gYi4kdmFsdWVcbiAgICB9XG4gICAgYSA9IF8uaXNPYmplY3QoYSkgPyBQYXRoLmdldChhLCBzb3J0S2V5KSA6IGFcbiAgICBiID0gXy5pc09iamVjdChiKSA/IFBhdGguZ2V0KGIsIHNvcnRLZXkpIDogYlxuICAgIHJldHVybiBhID09PSBiID8gMCA6IGEgPiBiID8gb3JkZXIgOiAtb3JkZXJcbiAgfSlcbn1cblxuLyoqXG4gKiBTdHJpbmcgY29udGFpbiBoZWxwZXJcbiAqXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHBhcmFtIHtTdHJpbmd9IHNlYXJjaFxuICovXG5cbmZ1bmN0aW9uIGNvbnRhaW5zICh2YWwsIHNlYXJjaCkge1xuICB2YXIgaVxuICBpZiAoXy5pc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbClcbiAgICBpID0ga2V5cy5sZW5ndGhcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBpZiAoY29udGFpbnModmFsW2tleXNbaV1dLCBzZWFyY2gpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKF8uaXNBcnJheSh2YWwpKSB7XG4gICAgaSA9IHZhbC5sZW5ndGhcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBpZiAoY29udGFpbnModmFsW2ldLCBzZWFyY2gpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbC50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihzZWFyY2gpID4gLTFcbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi91dGlsJylcblxuLyoqXG4gKiBTdHJpbmdpZnkgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGVudFxuICovXG5cbmV4cG9ydHMuanNvbiA9IHtcbiAgcmVhZDogZnVuY3Rpb24gKHZhbHVlLCBpbmRlbnQpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJ1xuICAgICAgPyB2YWx1ZVxuICAgICAgOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgbnVsbCwgTnVtYmVyKGluZGVudCkgfHwgMilcbiAgfSxcbiAgd3JpdGU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSlcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiAnYWJjJyA9PiAnQWJjJ1xuICovXG5cbmV4cG9ydHMuY2FwaXRhbGl6ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBpZiAoIXZhbHVlICYmIHZhbHVlICE9PSAwKSByZXR1cm4gJydcbiAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpXG4gIHJldHVybiB2YWx1ZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHZhbHVlLnNsaWNlKDEpXG59XG5cbi8qKlxuICogJ2FiYycgPT4gJ0FCQydcbiAqL1xuXG5leHBvcnRzLnVwcGVyY2FzZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gKHZhbHVlIHx8IHZhbHVlID09PSAwKVxuICAgID8gdmFsdWUudG9TdHJpbmcoKS50b1VwcGVyQ2FzZSgpXG4gICAgOiAnJ1xufVxuXG4vKipcbiAqICdBYkMnID0+ICdhYmMnXG4gKi9cblxuZXhwb3J0cy5sb3dlcmNhc2UgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuICh2YWx1ZSB8fCB2YWx1ZSA9PT0gMClcbiAgICA/IHZhbHVlLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKVxuICAgIDogJydcbn1cblxuLyoqXG4gKiAxMjM0NSA9PiAkMTIsMzQ1LjAwXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNpZ25cbiAqL1xuXG52YXIgZGlnaXRzUkUgPSAvKFxcZHszfSkoPz1cXGQpL2dcbmV4cG9ydHMuY3VycmVuY3kgPSBmdW5jdGlvbiAodmFsdWUsIGN1cnJlbmN5KSB7XG4gIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSlcbiAgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkgfHwgKCF2YWx1ZSAmJiB2YWx1ZSAhPT0gMCkpIHJldHVybiAnJ1xuICBjdXJyZW5jeSA9IGN1cnJlbmN5ICE9IG51bGwgPyBjdXJyZW5jeSA6ICckJ1xuICB2YXIgc3RyaW5naWZpZWQgPSBNYXRoLmFicyh2YWx1ZSkudG9GaXhlZCgyKVxuICB2YXIgX2ludCA9IHN0cmluZ2lmaWVkLnNsaWNlKDAsIC0zKVxuICB2YXIgaSA9IF9pbnQubGVuZ3RoICUgM1xuICB2YXIgaGVhZCA9IGkgPiAwXG4gICAgPyAoX2ludC5zbGljZSgwLCBpKSArIChfaW50Lmxlbmd0aCA+IDMgPyAnLCcgOiAnJykpXG4gICAgOiAnJ1xuICB2YXIgX2Zsb2F0ID0gc3RyaW5naWZpZWQuc2xpY2UoLTMpXG4gIHZhciBzaWduID0gdmFsdWUgPCAwID8gJy0nIDogJydcbiAgcmV0dXJuIGN1cnJlbmN5ICsgc2lnbiArIGhlYWQgK1xuICAgIF9pbnQuc2xpY2UoaSkucmVwbGFjZShkaWdpdHNSRSwgJyQxLCcpICtcbiAgICBfZmxvYXRcbn1cblxuLyoqXG4gKiAnaXRlbScgPT4gJ2l0ZW1zJ1xuICpcbiAqIEBwYXJhbXNcbiAqICBhbiBhcnJheSBvZiBzdHJpbmdzIGNvcnJlc3BvbmRpbmcgdG9cbiAqICB0aGUgc2luZ2xlLCBkb3VibGUsIHRyaXBsZSAuLi4gZm9ybXMgb2YgdGhlIHdvcmQgdG9cbiAqICBiZSBwbHVyYWxpemVkLiBXaGVuIHRoZSBudW1iZXIgdG8gYmUgcGx1cmFsaXplZFxuICogIGV4Y2VlZHMgdGhlIGxlbmd0aCBvZiB0aGUgYXJncywgaXQgd2lsbCB1c2UgdGhlIGxhc3RcbiAqICBlbnRyeSBpbiB0aGUgYXJyYXkuXG4gKlxuICogIGUuZy4gWydzaW5nbGUnLCAnZG91YmxlJywgJ3RyaXBsZScsICdtdWx0aXBsZSddXG4gKi9cblxuZXhwb3J0cy5wbHVyYWxpemUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIGFyZ3MgPSBfLnRvQXJyYXkoYXJndW1lbnRzLCAxKVxuICByZXR1cm4gYXJncy5sZW5ndGggPiAxXG4gICAgPyAoYXJnc1t2YWx1ZSAlIDEwIC0gMV0gfHwgYXJnc1thcmdzLmxlbmd0aCAtIDFdKVxuICAgIDogKGFyZ3NbMF0gKyAodmFsdWUgPT09IDEgPyAnJyA6ICdzJykpXG59XG5cbi8qKlxuICogRGVib3VuY2UgYSBoYW5kbGVyIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheSA9IDMwMFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZXhwb3J0cy5kZWJvdW5jZSA9IGZ1bmN0aW9uIChoYW5kbGVyLCBkZWxheSkge1xuICBpZiAoIWhhbmRsZXIpIHJldHVyblxuICBpZiAoIWRlbGF5KSB7XG4gICAgZGVsYXkgPSAzMDBcbiAgfVxuICByZXR1cm4gXy5kZWJvdW5jZShoYW5kbGVyLCBkZWxheSlcbn1cblxuLyoqXG4gKiBJbnN0YWxsIHNwZWNpYWwgYXJyYXkgZmlsdGVyc1xuICovXG5cbl8uZXh0ZW5kKGV4cG9ydHMsIHJlcXVpcmUoJy4vYXJyYXktZmlsdGVycycpKVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi91dGlsJylcbnZhciBjb21waWxlciA9IHJlcXVpcmUoJy4uL2NvbXBpbGVyJylcbnZhciB0ZW1wbGF0ZVBhcnNlciA9IHJlcXVpcmUoJy4uL3BhcnNlcnMvdGVtcGxhdGUnKVxudmFyIEZyYWdtZW50ID0gcmVxdWlyZSgnLi9mcmFnbWVudCcpXG52YXIgQ2FjaGUgPSByZXF1aXJlKCcuLi9jYWNoZScpXG52YXIgbGlua2VyQ2FjaGUgPSBuZXcgQ2FjaGUoNTAwMClcblxuLyoqXG4gKiBBIGZhY3RvcnkgdGhhdCBjYW4gYmUgdXNlZCB0byBjcmVhdGUgaW5zdGFuY2VzIG9mIGFcbiAqIGZyYWdtZW50LiBDYWNoZXMgdGhlIGNvbXBpbGVkIGxpbmtlciBpZiBwb3NzaWJsZS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7RWxlbWVudHxTdHJpbmd9IGVsXG4gKi9cblxuZnVuY3Rpb24gRnJhZ21lbnRGYWN0b3J5ICh2bSwgZWwpIHtcbiAgdGhpcy52bSA9IHZtXG4gIHZhciB0ZW1wbGF0ZVxuICB2YXIgaXNTdHJpbmcgPSB0eXBlb2YgZWwgPT09ICdzdHJpbmcnXG4gIGlmIChpc1N0cmluZyB8fCBfLmlzVGVtcGxhdGUoZWwpKSB7XG4gICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZVBhcnNlci5wYXJzZShlbCwgdHJ1ZSlcbiAgfSBlbHNlIHtcbiAgICB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuICAgIHRlbXBsYXRlLmFwcGVuZENoaWxkKGVsKVxuICB9XG4gIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZVxuICAvLyBsaW5rZXIgY2FuIGJlIGNhY2hlZCwgYnV0IG9ubHkgZm9yIGNvbXBvbmVudHNcbiAgdmFyIGxpbmtlclxuICB2YXIgY2lkID0gdm0uY29uc3RydWN0b3IuY2lkXG4gIGlmIChjaWQgPiAwKSB7XG4gICAgdmFyIGNhY2hlSWQgPSBjaWQgKyAoaXNTdHJpbmcgPyBlbCA6IGVsLm91dGVySFRNTClcbiAgICBsaW5rZXIgPSBsaW5rZXJDYWNoZS5nZXQoY2FjaGVJZClcbiAgICBpZiAoIWxpbmtlcikge1xuICAgICAgbGlua2VyID0gY29tcGlsZXIuY29tcGlsZSh0ZW1wbGF0ZSwgdm0uJG9wdGlvbnMsIHRydWUpXG4gICAgICBsaW5rZXJDYWNoZS5wdXQoY2FjaGVJZCwgbGlua2VyKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsaW5rZXIgPSBjb21waWxlci5jb21waWxlKHRlbXBsYXRlLCB2bS4kb3B0aW9ucywgdHJ1ZSlcbiAgfVxuICB0aGlzLmxpbmtlciA9IGxpbmtlclxufVxuXG4vKipcbiAqIENyZWF0ZSBhIGZyYWdtZW50IGluc3RhbmNlIHdpdGggZ2l2ZW4gaG9zdCBhbmQgc2NvcGUuXG4gKlxuICogQHBhcmFtIHtWdWV9IGhvc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZVxuICogQHBhcmFtIHtGcmFnbWVudH0gcGFyZW50RnJhZ1xuICovXG5cbkZyYWdtZW50RmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKGhvc3QsIHNjb3BlLCBwYXJlbnRGcmFnKSB7XG4gIHZhciBmcmFnID0gdGVtcGxhdGVQYXJzZXIuY2xvbmUodGhpcy50ZW1wbGF0ZSlcbiAgcmV0dXJuIG5ldyBGcmFnbWVudCh0aGlzLmxpbmtlciwgdGhpcy52bSwgZnJhZywgaG9zdCwgc2NvcGUsIHBhcmVudEZyYWcpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gRnJhZ21lbnRGYWN0b3J5XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWwnKVxudmFyIHRyYW5zaXRpb24gPSByZXF1aXJlKCcuLi90cmFuc2l0aW9uJylcblxuLyoqXG4gKiBBYnN0cmFjdGlvbiBmb3IgYSBwYXJ0aWFsbHktY29tcGlsZWQgZnJhZ21lbnQuXG4gKiBDYW4gb3B0aW9uYWxseSBjb21waWxlIGNvbnRlbnQgd2l0aCBhIGNoaWxkIHNjb3BlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxpbmtlclxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IGZyYWdcbiAqIEBwYXJhbSB7VnVlfSBbaG9zdF1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdXG4gKi9cblxuZnVuY3Rpb24gRnJhZ21lbnQgKGxpbmtlciwgdm0sIGZyYWcsIGhvc3QsIHNjb3BlLCBwYXJlbnRGcmFnKSB7XG4gIHRoaXMuY2hpbGRyZW4gPSBbXVxuICB0aGlzLmNoaWxkRnJhZ3MgPSBbXVxuICB0aGlzLnZtID0gdm1cbiAgdGhpcy5zY29wZSA9IHNjb3BlXG4gIHRoaXMuaW5zZXJ0ZWQgPSBmYWxzZVxuICB0aGlzLnBhcmVudEZyYWcgPSBwYXJlbnRGcmFnXG4gIGlmIChwYXJlbnRGcmFnKSB7XG4gICAgcGFyZW50RnJhZy5jaGlsZEZyYWdzLnB1c2godGhpcylcbiAgfVxuICB0aGlzLnVubGluayA9IGxpbmtlcih2bSwgZnJhZywgaG9zdCwgc2NvcGUsIHRoaXMpXG4gIHZhciBzaW5nbGUgPSB0aGlzLnNpbmdsZSA9IGZyYWcuY2hpbGROb2Rlcy5sZW5ndGggPT09IDFcbiAgaWYgKHNpbmdsZSkge1xuICAgIHRoaXMubm9kZSA9IGZyYWcuY2hpbGROb2Rlc1swXVxuICAgIHRoaXMuYmVmb3JlID0gc2luZ2xlQmVmb3JlXG4gICAgdGhpcy5yZW1vdmUgPSBzaW5nbGVSZW1vdmVcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm5vZGUgPSBfLmNyZWF0ZUFuY2hvcignZnJhZ21lbnQtc3RhcnQnKVxuICAgIHRoaXMuZW5kID0gXy5jcmVhdGVBbmNob3IoJ2ZyYWdtZW50LWVuZCcpXG4gICAgdGhpcy5mcmFnID0gZnJhZ1xuICAgIF8ucHJlcGVuZCh0aGlzLm5vZGUsIGZyYWcpXG4gICAgZnJhZy5hcHBlbmRDaGlsZCh0aGlzLmVuZClcbiAgICB0aGlzLmJlZm9yZSA9IG11bHRpQmVmb3JlXG4gICAgdGhpcy5yZW1vdmUgPSBtdWx0aVJlbW92ZVxuICB9XG4gIHRoaXMubm9kZS5fX3ZmcmFnX18gPSB0aGlzXG59XG5cbi8qKlxuICogQ2FsbCBhdHRhY2gvZGV0YWNoIGZvciBhbGwgY29tcG9uZW50cyBjb250YWluZWQgd2l0aGluXG4gKiB0aGlzIGZyYWdtZW50LiBBbHNvIGRvIHNvIHJlY3Vyc2l2ZWx5IGZvciBhbGwgY2hpbGRcbiAqIGZyYWdtZW50cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBob29rXG4gKi9cblxuRnJhZ21lbnQucHJvdG90eXBlLmNhbGxIb29rID0gZnVuY3Rpb24gKGhvb2spIHtcbiAgdmFyIGksIGxcbiAgZm9yIChpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaG9vayh0aGlzLmNoaWxkcmVuW2ldKVxuICB9XG4gIGZvciAoaSA9IDAsIGwgPSB0aGlzLmNoaWxkRnJhZ3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdGhpcy5jaGlsZEZyYWdzW2ldLmNhbGxIb29rKGhvb2spXG4gIH1cbn1cblxuLyoqXG4gKiBEZXN0cm95IHRoZSBmcmFnbWVudC5cbiAqL1xuXG5GcmFnbWVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMucGFyZW50RnJhZykge1xuICAgIHRoaXMucGFyZW50RnJhZy5jaGlsZEZyYWdzLiRyZW1vdmUodGhpcylcbiAgfVxuICB0aGlzLnVubGluaygpXG59XG5cbi8qKlxuICogSW5zZXJ0IGZyYWdtZW50IGJlZm9yZSB0YXJnZXQsIHNpbmdsZSBub2RlIHZlcnNpb25cbiAqXG4gKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICogQHBhcmFtIHtCb29sZWFufSB3aXRoVHJhbnNpdGlvblxuICovXG5cbmZ1bmN0aW9uIHNpbmdsZUJlZm9yZSAodGFyZ2V0LCB3aXRoVHJhbnNpdGlvbikge1xuICB0aGlzLmluc2VydGVkID0gdHJ1ZVxuICB2YXIgbWV0aG9kID0gd2l0aFRyYW5zaXRpb24gIT09IGZhbHNlXG4gICAgPyB0cmFuc2l0aW9uLmJlZm9yZVxuICAgIDogXy5iZWZvcmVcbiAgbWV0aG9kKHRoaXMubm9kZSwgdGFyZ2V0LCB0aGlzLnZtKVxuICBpZiAoXy5pbkRvYyh0aGlzLm5vZGUpKSB7XG4gICAgdGhpcy5jYWxsSG9vayhhdHRhY2gpXG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgZnJhZ21lbnQsIHNpbmdsZSBub2RlIHZlcnNpb25cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtkZXN0cm95XVxuICovXG5cbmZ1bmN0aW9uIHNpbmdsZVJlbW92ZSAoZGVzdHJveSkge1xuICB0aGlzLmluc2VydGVkID0gZmFsc2VcbiAgdmFyIHNob3VsZENhbGxSZW1vdmUgPSBfLmluRG9jKHRoaXMubm9kZSlcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHRyYW5zaXRpb24ucmVtb3ZlKHRoaXMubm9kZSwgdGhpcy52bSwgZnVuY3Rpb24gKCkge1xuICAgIGlmIChzaG91bGRDYWxsUmVtb3ZlKSB7XG4gICAgICBzZWxmLmNhbGxIb29rKGRldGFjaClcbiAgICB9XG4gICAgaWYgKGRlc3Ryb3kpIHtcbiAgICAgIHNlbGYuZGVzdHJveSgpXG4gICAgfVxuICB9KVxufVxuXG4vKipcbiAqIEluc2VydCBmcmFnbWVudCBiZWZvcmUgdGFyZ2V0LCBtdWx0aS1ub2RlcyB2ZXJzaW9uXG4gKlxuICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gd2l0aFRyYW5zaXRpb25cbiAqL1xuXG5mdW5jdGlvbiBtdWx0aUJlZm9yZSAodGFyZ2V0LCB3aXRoVHJhbnNpdGlvbikge1xuICB0aGlzLmluc2VydGVkID0gdHJ1ZVxuICB2YXIgdm0gPSB0aGlzLnZtXG4gIHZhciBtZXRob2QgPSB3aXRoVHJhbnNpdGlvbiAhPT0gZmFsc2VcbiAgICA/IHRyYW5zaXRpb24uYmVmb3JlXG4gICAgOiBfLmJlZm9yZVxuICBfLm1hcE5vZGVSYW5nZSh0aGlzLm5vZGUsIHRoaXMuZW5kLCBmdW5jdGlvbiAobm9kZSkge1xuICAgIG1ldGhvZChub2RlLCB0YXJnZXQsIHZtKVxuICB9KVxuICBpZiAoXy5pbkRvYyh0aGlzLm5vZGUpKSB7XG4gICAgdGhpcy5jYWxsSG9vayhhdHRhY2gpXG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgZnJhZ21lbnQsIG11bHRpLW5vZGVzIHZlcnNpb25cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtkZXN0cm95XVxuICovXG5cbmZ1bmN0aW9uIG11bHRpUmVtb3ZlIChkZXN0cm95KSB7XG4gIHRoaXMuaW5zZXJ0ZWQgPSBmYWxzZVxuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIHNob3VsZENhbGxSZW1vdmUgPSBfLmluRG9jKHRoaXMubm9kZSlcbiAgXy5yZW1vdmVOb2RlUmFuZ2UodGhpcy5ub2RlLCB0aGlzLmVuZCwgdGhpcy52bSwgdGhpcy5mcmFnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNob3VsZENhbGxSZW1vdmUpIHtcbiAgICAgIHNlbGYuY2FsbEhvb2soZGV0YWNoKVxuICAgIH1cbiAgICBpZiAoZGVzdHJveSkge1xuICAgICAgc2VsZi5kZXN0cm95KClcbiAgICB9XG4gIH0pXG59XG5cbi8qKlxuICogQ2FsbCBhdHRhY2ggaG9vayBmb3IgYSBWdWUgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtWdWV9IGNoaWxkXG4gKi9cblxuZnVuY3Rpb24gYXR0YWNoIChjaGlsZCkge1xuICBpZiAoIWNoaWxkLl9pc0F0dGFjaGVkKSB7XG4gICAgY2hpbGQuX2NhbGxIb29rKCdhdHRhY2hlZCcpXG4gIH1cbn1cblxuLyoqXG4gKiBDYWxsIGRldGFjaCBob29rIGZvciBhIFZ1ZSBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gY2hpbGRcbiAqL1xuXG5mdW5jdGlvbiBkZXRhY2ggKGNoaWxkKSB7XG4gIGlmIChjaGlsZC5faXNBdHRhY2hlZCkge1xuICAgIGNoaWxkLl9jYWxsSG9vaygnZGV0YWNoZWQnKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRnJhZ21lbnRcbiIsInZhciBfID0gcmVxdWlyZSgnLi4vdXRpbCcpXG52YXIgaW5Eb2MgPSBfLmluRG9jXG52YXIgZXZlbnRSRSA9IC9edi1vbjp8XkAvXG5cbi8qKlxuICogU2V0dXAgdGhlIGluc3RhbmNlJ3Mgb3B0aW9uIGV2ZW50cyAmIHdhdGNoZXJzLlxuICogSWYgdGhlIHZhbHVlIGlzIGEgc3RyaW5nLCB3ZSBwdWxsIGl0IGZyb20gdGhlXG4gKiBpbnN0YW5jZSdzIG1ldGhvZHMgYnkgbmFtZS5cbiAqL1xuXG5leHBvcnRzLl9pbml0RXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnNcbiAgaWYgKG9wdGlvbnMuX2FzQ29tcG9uZW50KSB7XG4gICAgcmVnaXN0ZXJDb21wb25lbnRFdmVudHModGhpcywgb3B0aW9ucy5lbClcbiAgfVxuICByZWdpc3RlckNhbGxiYWNrcyh0aGlzLCAnJG9uJywgb3B0aW9ucy5ldmVudHMpXG4gIHJlZ2lzdGVyQ2FsbGJhY2tzKHRoaXMsICckd2F0Y2gnLCBvcHRpb25zLndhdGNoKVxufVxuXG4vKipcbiAqIFJlZ2lzdGVyIHYtb24gZXZlbnRzIG9uIGEgY2hpbGQgY29tcG9uZW50XG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKi9cblxuZnVuY3Rpb24gcmVnaXN0ZXJDb21wb25lbnRFdmVudHMgKHZtLCBlbCkge1xuICB2YXIgYXR0cnMgPSBlbC5hdHRyaWJ1dGVzXG4gIHZhciBuYW1lLCBoYW5kbGVyXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbmFtZSA9IGF0dHJzW2ldLm5hbWVcbiAgICBpZiAoZXZlbnRSRS50ZXN0KG5hbWUpKSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGV2ZW50UkUsICcnKVxuICAgICAgaGFuZGxlciA9ICh2bS5fc2NvcGUgfHwgdm0uX2NvbnRleHQpLiRldmFsKGF0dHJzW2ldLnZhbHVlLCB0cnVlKVxuICAgICAgdm0uJG9uKG5hbWUucmVwbGFjZShldmVudFJFKSwgaGFuZGxlcilcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZWdpc3RlciBjYWxsYmFja3MgZm9yIG9wdGlvbiBldmVudHMgYW5kIHdhdGNoZXJzLlxuICpcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvblxuICogQHBhcmFtIHtPYmplY3R9IGhhc2hcbiAqL1xuXG5mdW5jdGlvbiByZWdpc3RlckNhbGxiYWNrcyAodm0sIGFjdGlvbiwgaGFzaCkge1xuICBpZiAoIWhhc2gpIHJldHVyblxuICB2YXIgaGFuZGxlcnMsIGtleSwgaSwgalxuICBmb3IgKGtleSBpbiBoYXNoKSB7XG4gICAgaGFuZGxlcnMgPSBoYXNoW2tleV1cbiAgICBpZiAoXy5pc0FycmF5KGhhbmRsZXJzKSkge1xuICAgICAgZm9yIChpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICByZWdpc3Rlcih2bSwgYWN0aW9uLCBrZXksIGhhbmRsZXJzW2ldKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWdpc3Rlcih2bSwgYWN0aW9uLCBrZXksIGhhbmRsZXJzKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEhlbHBlciB0byByZWdpc3RlciBhbiBldmVudC93YXRjaCBjYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfE9iamVjdH0gaGFuZGxlclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICovXG5cbmZ1bmN0aW9uIHJlZ2lzdGVyICh2bSwgYWN0aW9uLCBrZXksIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgaGFuZGxlclxuICBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZtW2FjdGlvbl0oa2V5LCBoYW5kbGVyLCBvcHRpb25zKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIG1ldGhvZHMgPSB2bS4kb3B0aW9ucy5tZXRob2RzXG4gICAgdmFyIG1ldGhvZCA9IG1ldGhvZHMgJiYgbWV0aG9kc1toYW5kbGVyXVxuICAgIGlmIChtZXRob2QpIHtcbiAgICAgIHZtW2FjdGlvbl0oa2V5LCBtZXRob2QsIG9wdGlvbnMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgXy53YXJuKFxuICAgICAgICAnVW5rbm93biBtZXRob2Q6IFwiJyArIGhhbmRsZXIgKyAnXCIgd2hlbiAnICtcbiAgICAgICAgJ3JlZ2lzdGVyaW5nIGNhbGxiYWNrIGZvciAnICsgYWN0aW9uICtcbiAgICAgICAgJzogXCInICsga2V5ICsgJ1wiLidcbiAgICAgIClcbiAgICB9XG4gIH0gZWxzZSBpZiAoaGFuZGxlciAmJiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHJlZ2lzdGVyKHZtLCBhY3Rpb24sIGtleSwgaGFuZGxlci5oYW5kbGVyLCBoYW5kbGVyKVxuICB9XG59XG5cbi8qKlxuICogU2V0dXAgcmVjdXJzaXZlIGF0dGFjaGVkL2RldGFjaGVkIGNhbGxzXG4gKi9cblxuZXhwb3J0cy5faW5pdERPTUhvb2tzID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLiRvbignaG9vazphdHRhY2hlZCcsIG9uQXR0YWNoZWQpXG4gIHRoaXMuJG9uKCdob29rOmRldGFjaGVkJywgb25EZXRhY2hlZClcbn1cblxuLyoqXG4gKiBDYWxsYmFjayB0byByZWN1cnNpdmVseSBjYWxsIGF0dGFjaGVkIGhvb2sgb24gY2hpbGRyZW5cbiAqL1xuXG5mdW5jdGlvbiBvbkF0dGFjaGVkICgpIHtcbiAgaWYgKCF0aGlzLl9pc0F0dGFjaGVkKSB7XG4gICAgdGhpcy5faXNBdHRhY2hlZCA9IHRydWVcbiAgICB0aGlzLiRjaGlsZHJlbi5mb3JFYWNoKGNhbGxBdHRhY2gpXG4gIH1cbn1cblxuLyoqXG4gKiBJdGVyYXRvciB0byBjYWxsIGF0dGFjaGVkIGhvb2tcbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gY2hpbGRcbiAqL1xuXG5mdW5jdGlvbiBjYWxsQXR0YWNoIChjaGlsZCkge1xuICBpZiAoIWNoaWxkLl9pc0F0dGFjaGVkICYmIGluRG9jKGNoaWxkLiRlbCkpIHtcbiAgICBjaGlsZC5fY2FsbEhvb2soJ2F0dGFjaGVkJylcbiAgfVxufVxuXG4vKipcbiAqIENhbGxiYWNrIHRvIHJlY3Vyc2l2ZWx5IGNhbGwgZGV0YWNoZWQgaG9vayBvbiBjaGlsZHJlblxuICovXG5cbmZ1bmN0aW9uIG9uRGV0YWNoZWQgKCkge1xuICBpZiAodGhpcy5faXNBdHRhY2hlZCkge1xuICAgIHRoaXMuX2lzQXR0YWNoZWQgPSBmYWxzZVxuICAgIHRoaXMuJGNoaWxkcmVuLmZvckVhY2goY2FsbERldGFjaClcbiAgfVxufVxuXG4vKipcbiAqIEl0ZXJhdG9yIHRvIGNhbGwgZGV0YWNoZWQgaG9va1xuICpcbiAqIEBwYXJhbSB7VnVlfSBjaGlsZFxuICovXG5cbmZ1bmN0aW9uIGNhbGxEZXRhY2ggKGNoaWxkKSB7XG4gIGlmIChjaGlsZC5faXNBdHRhY2hlZCAmJiAhaW5Eb2MoY2hpbGQuJGVsKSkge1xuICAgIGNoaWxkLl9jYWxsSG9vaygnZGV0YWNoZWQnKVxuICB9XG59XG5cbi8qKlxuICogVHJpZ2dlciBhbGwgaGFuZGxlcnMgZm9yIGEgaG9va1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBob29rXG4gKi9cblxuZXhwb3J0cy5fY2FsbEhvb2sgPSBmdW5jdGlvbiAoaG9vaykge1xuICB2YXIgaGFuZGxlcnMgPSB0aGlzLiRvcHRpb25zW2hvb2tdXG4gIGlmIChoYW5kbGVycykge1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICBoYW5kbGVyc1tpXS5jYWxsKHRoaXMpXG4gICAgfVxuICB9XG4gIHRoaXMuJGVtaXQoJ2hvb2s6JyArIGhvb2spXG59XG4iLCJ2YXIgbWVyZ2VPcHRpb25zID0gcmVxdWlyZSgnLi4vdXRpbCcpLm1lcmdlT3B0aW9uc1xudmFyIHVpZCA9IDBcblxuLyoqXG4gKiBUaGUgbWFpbiBpbml0IHNlcXVlbmNlLiBUaGlzIGlzIGNhbGxlZCBmb3IgZXZlcnlcbiAqIGluc3RhbmNlLCBpbmNsdWRpbmcgb25lcyB0aGF0IGFyZSBjcmVhdGVkIGZyb20gZXh0ZW5kZWRcbiAqIGNvbnN0cnVjdG9ycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIHRoaXMgb3B0aW9ucyBvYmplY3Qgc2hvdWxkIGJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSByZXN1bHQgb2YgbWVyZ2luZyBjbGFzc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zIGFuZCB0aGUgb3B0aW9ucyBwYXNzZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gdG8gdGhlIGNvbnN0cnVjdG9yLlxuICovXG5cbmV4cG9ydHMuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgdGhpcy4kZWwgPSBudWxsXG4gIHRoaXMuJHBhcmVudCA9IG9wdGlvbnMucGFyZW50XG4gIHRoaXMuJHJvb3QgPSB0aGlzLiRwYXJlbnRcbiAgICA/IHRoaXMuJHBhcmVudC4kcm9vdFxuICAgIDogdGhpc1xuICB0aGlzLiRjaGlsZHJlbiA9IFtdXG4gIHRoaXMuJHJlZnMgPSB7fSAgICAgICAvLyBjaGlsZCB2bSByZWZlcmVuY2VzXG4gIHRoaXMuJGVscyA9IHt9ICAgICAgICAvLyBlbGVtZW50IHJlZmVyZW5jZXNcbiAgdGhpcy5fd2F0Y2hlcnMgPSBbXSAgIC8vIGFsbCB3YXRjaGVycyBhcyBhbiBhcnJheVxuICB0aGlzLl9kaXJlY3RpdmVzID0gW10gLy8gYWxsIGRpcmVjdGl2ZXNcblxuICAvLyBhIHVpZFxuICB0aGlzLl91aWQgPSB1aWQrK1xuXG4gIC8vIGEgZmxhZyB0byBhdm9pZCB0aGlzIGJlaW5nIG9ic2VydmVkXG4gIHRoaXMuX2lzVnVlID0gdHJ1ZVxuXG4gIC8vIGV2ZW50cyBib29ra2VlcGluZ1xuICB0aGlzLl9ldmVudHMgPSB7fSAgICAgICAgICAgIC8vIHJlZ2lzdGVyZWQgY2FsbGJhY2tzXG4gIHRoaXMuX2V2ZW50c0NvdW50ID0ge30gICAgICAgLy8gZm9yICRicm9hZGNhc3Qgb3B0aW1pemF0aW9uXG4gIHRoaXMuX3Nob3VsZFByb3BhZ2F0ZSA9IGZhbHNlIC8vIGZvciBldmVudCBwcm9wYWdhdGlvblxuXG4gIC8vIGZyYWdtZW50IGluc3RhbmNlIHByb3BlcnRpZXNcbiAgdGhpcy5faXNGcmFnbWVudCA9IGZhbHNlXG4gIHRoaXMuX2ZyYWdtZW50ID0gICAgICAgICAvLyBAdHlwZSB7RG9jdW1lbnRGcmFnbWVudH1cbiAgdGhpcy5fZnJhZ21lbnRTdGFydCA9ICAgIC8vIEB0eXBlIHtUZXh0fENvbW1lbnR9XG4gIHRoaXMuX2ZyYWdtZW50RW5kID0gbnVsbCAvLyBAdHlwZSB7VGV4dHxDb21tZW50fVxuXG4gIC8vIGxpZmVjeWNsZSBzdGF0ZVxuICB0aGlzLl9pc0NvbXBpbGVkID1cbiAgdGhpcy5faXNEZXN0cm95ZWQgPVxuICB0aGlzLl9pc1JlYWR5ID1cbiAgdGhpcy5faXNBdHRhY2hlZCA9XG4gIHRoaXMuX2lzQmVpbmdEZXN0cm95ZWQgPSBmYWxzZVxuICB0aGlzLl91bmxpbmtGbiA9IG51bGxcblxuICAvLyBjb250ZXh0OlxuICAvLyBpZiB0aGlzIGlzIGEgdHJhbnNjbHVkZWQgY29tcG9uZW50LCBjb250ZXh0XG4gIC8vIHdpbGwgYmUgdGhlIGNvbW1vbiBwYXJlbnQgdm0gb2YgdGhpcyBpbnN0YW5jZVxuICAvLyBhbmQgaXRzIGhvc3QuXG4gIHRoaXMuX2NvbnRleHQgPSBvcHRpb25zLl9jb250ZXh0IHx8IHRoaXMuJHBhcmVudFxuXG4gIC8vIHNjb3BlOlxuICAvLyBpZiB0aGlzIGlzIGluc2lkZSBhbiBpbmxpbmUgdi1mb3IsIHRoZSBzY29wZVxuICAvLyB3aWxsIGJlIHRoZSBpbnRlcm1lZGlhdGUgc2NvcGUgY3JlYXRlZCBmb3IgdGhpc1xuICAvLyByZXBlYXQgZnJhZ21lbnQuIHRoaXMgaXMgdXNlZCBmb3IgbGlua2luZyBwcm9wc1xuICAvLyBhbmQgY29udGFpbmVyIGRpcmVjdGl2ZXMuXG4gIHRoaXMuX3Njb3BlID0gb3B0aW9ucy5fc2NvcGVcblxuICAvLyBmcmFnbWVudDpcbiAgLy8gaWYgdGhpcyBpbnN0YW5jZSBpcyBjb21waWxlZCBpbnNpZGUgYSBGcmFnbWVudCwgaXRcbiAgLy8gbmVlZHMgdG8gcmVpZ3N0ZXIgaXRzZWxmIGFzIGEgY2hpbGQgb2YgdGhhdCBmcmFnbWVudFxuICAvLyBmb3IgYXR0YWNoL2RldGFjaCB0byB3b3JrIHByb3Blcmx5LlxuICB0aGlzLl9mcmFnID0gb3B0aW9ucy5fZnJhZ1xuICBpZiAodGhpcy5fZnJhZykge1xuICAgIHRoaXMuX2ZyYWcuY2hpbGRyZW4ucHVzaCh0aGlzKVxuICB9XG5cbiAgLy8gcHVzaCBzZWxmIGludG8gcGFyZW50IC8gdHJhbnNjbHVzaW9uIGhvc3RcbiAgaWYgKHRoaXMuJHBhcmVudCkge1xuICAgIHRoaXMuJHBhcmVudC4kY2hpbGRyZW4ucHVzaCh0aGlzKVxuICB9XG5cbiAgLy8gc2V0IHJlZlxuICBpZiAob3B0aW9ucy5fcmVmKSB7XG4gICAgKHRoaXMuX3Njb3BlIHx8IHRoaXMuX2NvbnRleHQpLiRyZWZzW29wdGlvbnMuX3JlZl0gPSB0aGlzXG4gIH1cblxuICAvLyBtZXJnZSBvcHRpb25zLlxuICBvcHRpb25zID0gdGhpcy4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICB0aGlzLmNvbnN0cnVjdG9yLm9wdGlvbnMsXG4gICAgb3B0aW9ucyxcbiAgICB0aGlzXG4gIClcblxuICAvLyBpbml0aWFsaXplIGRhdGEgYXMgZW1wdHkgb2JqZWN0LlxuICAvLyBpdCB3aWxsIGJlIGZpbGxlZCB1cCBpbiBfaW5pdFNjb3BlKCkuXG4gIHRoaXMuX2RhdGEgPSB7fVxuXG4gIC8vIGNhbGwgaW5pdCBob29rXG4gIHRoaXMuX2NhbGxIb29rKCdpbml0JylcblxuICAvLyBpbml0aWFsaXplIGRhdGEgb2JzZXJ2YXRpb24gYW5kIHNjb3BlIGluaGVyaXRhbmNlLlxuICB0aGlzLl9pbml0U3RhdGUoKVxuXG4gIC8vIHNldHVwIGV2ZW50IHN5c3RlbSBhbmQgb3B0aW9uIGV2ZW50cy5cbiAgdGhpcy5faW5pdEV2ZW50cygpXG5cbiAgLy8gY2FsbCBjcmVhdGVkIGhvb2tcbiAgdGhpcy5fY2FsbEhvb2soJ2NyZWF0ZWQnKVxuXG4gIC8vIGlmIGBlbGAgb3B0aW9uIGlzIHBhc3NlZCwgc3RhcnQgY29tcGlsYXRpb24uXG4gIGlmIChvcHRpb25zLmVsKSB7XG4gICAgdGhpcy4kbW91bnQob3B0aW9ucy5lbClcbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi91dGlsJylcbnZhciBEaXJlY3RpdmUgPSByZXF1aXJlKCcuLi9kaXJlY3RpdmUnKVxudmFyIGNvbXBpbGVyID0gcmVxdWlyZSgnLi4vY29tcGlsZXInKVxuXG4vKipcbiAqIFRyYW5zY2x1ZGUsIGNvbXBpbGUgYW5kIGxpbmsgZWxlbWVudC5cbiAqXG4gKiBJZiBhIHByZS1jb21waWxlZCBsaW5rZXIgaXMgYXZhaWxhYmxlLCB0aGF0IG1lYW5zIHRoZVxuICogcGFzc2VkIGluIGVsZW1lbnQgd2lsbCBiZSBwcmUtdHJhbnNjbHVkZWQgYW5kIGNvbXBpbGVkXG4gKiBhcyB3ZWxsIC0gYWxsIHdlIG5lZWQgdG8gZG8gaXMgdG8gY2FsbCB0aGUgbGlua2VyLlxuICpcbiAqIE90aGVyd2lzZSB3ZSBuZWVkIHRvIGNhbGwgdHJhbnNjbHVkZS9jb21waWxlL2xpbmsgaGVyZS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG5cbmV4cG9ydHMuX2NvbXBpbGUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zXG5cbiAgLy8gdHJhbnNjbHVkZSBhbmQgaW5pdCBlbGVtZW50XG4gIC8vIHRyYW5zY2x1ZGUgY2FuIHBvdGVudGlhbGx5IHJlcGxhY2Ugb3JpZ2luYWxcbiAgLy8gc28gd2UgbmVlZCB0byBrZWVwIHJlZmVyZW5jZTsgdGhpcyBzdGVwIGFsc28gaW5qZWN0c1xuICAvLyB0aGUgdGVtcGxhdGUgYW5kIGNhY2hlcyB0aGUgb3JpZ2luYWwgYXR0cmlidXRlc1xuICAvLyBvbiB0aGUgY29udGFpbmVyIG5vZGUgYW5kIHJlcGxhY2VyIG5vZGUuXG4gIHZhciBvcmlnaW5hbCA9IGVsXG4gIGVsID0gY29tcGlsZXIudHJhbnNjbHVkZShlbCwgb3B0aW9ucylcbiAgdGhpcy5faW5pdEVsZW1lbnQoZWwpXG5cbiAgLy8gcm9vdCBpcyBhbHdheXMgY29tcGlsZWQgcGVyLWluc3RhbmNlLCBiZWNhdXNlXG4gIC8vIGNvbnRhaW5lciBhdHRycyBhbmQgcHJvcHMgY2FuIGJlIGRpZmZlcmVudCBldmVyeSB0aW1lLlxuICB2YXIgY29udGV4dE9wdGlvbnMgPSB0aGlzLl9jb250ZXh0ICYmIHRoaXMuX2NvbnRleHQuJG9wdGlvbnNcbiAgdmFyIHJvb3RMaW5rZXIgPSBjb21waWxlci5jb21waWxlUm9vdChlbCwgb3B0aW9ucywgY29udGV4dE9wdGlvbnMpXG5cbiAgLy8gY29tcGlsZSBhbmQgbGluayB0aGUgcmVzdFxuICB2YXIgY29udGVudExpbmtGblxuICB2YXIgY3RvciA9IHRoaXMuY29uc3RydWN0b3JcbiAgLy8gY29tcG9uZW50IGNvbXBpbGF0aW9uIGNhbiBiZSBjYWNoZWRcbiAgLy8gYXMgbG9uZyBhcyBpdCdzIG5vdCB1c2luZyBpbmxpbmUtdGVtcGxhdGVcbiAgaWYgKG9wdGlvbnMuX2xpbmtlckNhY2hhYmxlKSB7XG4gICAgY29udGVudExpbmtGbiA9IGN0b3IubGlua2VyXG4gICAgaWYgKCFjb250ZW50TGlua0ZuKSB7XG4gICAgICBjb250ZW50TGlua0ZuID0gY3Rvci5saW5rZXIgPSBjb21waWxlci5jb21waWxlKGVsLCBvcHRpb25zKVxuICAgIH1cbiAgfVxuXG4gIC8vIGxpbmsgcGhhc2VcbiAgLy8gbWFrZSBzdXJlIHRvIGxpbmsgcm9vdCB3aXRoIHByb3Agc2NvcGUhXG4gIHZhciByb290VW5saW5rRm4gPSByb290TGlua2VyKHRoaXMsIGVsLCB0aGlzLl9zY29wZSlcbiAgdmFyIGNvbnRlbnRVbmxpbmtGbiA9IGNvbnRlbnRMaW5rRm5cbiAgICA/IGNvbnRlbnRMaW5rRm4odGhpcywgZWwpXG4gICAgOiBjb21waWxlci5jb21waWxlKGVsLCBvcHRpb25zKSh0aGlzLCBlbClcblxuICAvLyByZWdpc3RlciBjb21wb3NpdGUgdW5saW5rIGZ1bmN0aW9uXG4gIC8vIHRvIGJlIGNhbGxlZCBkdXJpbmcgaW5zdGFuY2UgZGVzdHJ1Y3Rpb25cbiAgdGhpcy5fdW5saW5rRm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgcm9vdFVubGlua0ZuKClcbiAgICAvLyBwYXNzaW5nIGRlc3Ryb3lpbmc6IHRydWUgdG8gYXZvaWQgc2VhcmNoaW5nIGFuZFxuICAgIC8vIHNwbGljaW5nIHRoZSBkaXJlY3RpdmVzXG4gICAgY29udGVudFVubGlua0ZuKHRydWUpXG4gIH1cblxuICAvLyBmaW5hbGx5IHJlcGxhY2Ugb3JpZ2luYWxcbiAgaWYgKG9wdGlvbnMucmVwbGFjZSkge1xuICAgIF8ucmVwbGFjZShvcmlnaW5hbCwgZWwpXG4gIH1cblxuICB0aGlzLl9pc0NvbXBpbGVkID0gdHJ1ZVxuICB0aGlzLl9jYWxsSG9vaygnY29tcGlsZWQnKVxuICByZXR1cm4gZWxcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIGluc3RhbmNlIGVsZW1lbnQuIENhbGxlZCBpbiB0aGUgcHVibGljXG4gKiAkbW91bnQoKSBtZXRob2QuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICovXG5cbmV4cG9ydHMuX2luaXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsKSB7XG4gIGlmIChlbCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICB0aGlzLl9pc0ZyYWdtZW50ID0gdHJ1ZVxuICAgIHRoaXMuJGVsID0gdGhpcy5fZnJhZ21lbnRTdGFydCA9IGVsLmZpcnN0Q2hpbGRcbiAgICB0aGlzLl9mcmFnbWVudEVuZCA9IGVsLmxhc3RDaGlsZFxuICAgIC8vIHNldCBwZXJzaXN0ZWQgdGV4dCBhbmNob3JzIHRvIGVtcHR5XG4gICAgaWYgKHRoaXMuX2ZyYWdtZW50U3RhcnQubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgIHRoaXMuX2ZyYWdtZW50U3RhcnQuZGF0YSA9IHRoaXMuX2ZyYWdtZW50RW5kLmRhdGEgPSAnJ1xuICAgIH1cbiAgICB0aGlzLl9mcmFnbWVudCA9IGVsXG4gIH0gZWxzZSB7XG4gICAgdGhpcy4kZWwgPSBlbFxuICB9XG4gIHRoaXMuJGVsLl9fdnVlX18gPSB0aGlzXG4gIHRoaXMuX2NhbGxIb29rKCdiZWZvcmVDb21waWxlJylcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW5kIGJpbmQgYSBkaXJlY3RpdmUgdG8gYW4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIGRpcmVjdGl2ZSBuYW1lXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgICAtIHRhcmdldCBub2RlXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzYyAtIHBhcnNlZCBkaXJlY3RpdmUgZGVzY3JpcHRvclxuICogQHBhcmFtIHtPYmplY3R9IGRlZiAgLSBkaXJlY3RpdmUgZGVmaW5pdGlvbiBvYmplY3RcbiAqIEBwYXJhbSB7VnVlfSBbaG9zdF0gLSB0cmFuc2NsdXNpb24gaG9zdCBjb21wb25lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdIC0gdi1mb3Igc2NvcGVcbiAqIEBwYXJhbSB7RnJhZ21lbnR9IFtmcmFnXSAtIG93bmVyIGZyYWdtZW50XG4gKi9cblxuZXhwb3J0cy5fYmluZERpciA9IGZ1bmN0aW9uIChkZXNjcmlwdG9yLCBub2RlLCBob3N0LCBzY29wZSwgZnJhZykge1xuICB0aGlzLl9kaXJlY3RpdmVzLnB1c2goXG4gICAgbmV3IERpcmVjdGl2ZShkZXNjcmlwdG9yLCB0aGlzLCBub2RlLCBob3N0LCBzY29wZSwgZnJhZylcbiAgKVxufVxuXG4vKipcbiAqIFRlYXJkb3duIGFuIGluc3RhbmNlLCB1bm9ic2VydmVzIHRoZSBkYXRhLCB1bmJpbmQgYWxsIHRoZVxuICogZGlyZWN0aXZlcywgdHVybiBvZmYgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMsIGV0Yy5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHJlbW92ZSAtIHdoZXRoZXIgdG8gcmVtb3ZlIHRoZSBET00gbm9kZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGVmZXJDbGVhbnVwIC0gaWYgdHJ1ZSwgZGVmZXIgY2xlYW51cCB0b1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZSBjYWxsZWQgbGF0ZXJcbiAqL1xuXG5leHBvcnRzLl9kZXN0cm95ID0gZnVuY3Rpb24gKHJlbW92ZSwgZGVmZXJDbGVhbnVwKSB7XG4gIGlmICh0aGlzLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdGhpcy5fY2FsbEhvb2soJ2JlZm9yZURlc3Ryb3knKVxuICB0aGlzLl9pc0JlaW5nRGVzdHJveWVkID0gdHJ1ZVxuICB2YXIgaVxuICAvLyByZW1vdmUgc2VsZiBmcm9tIHBhcmVudC4gb25seSBuZWNlc3NhcnlcbiAgLy8gaWYgcGFyZW50IGlzIG5vdCBiZWluZyBkZXN0cm95ZWQgYXMgd2VsbC5cbiAgdmFyIHBhcmVudCA9IHRoaXMuJHBhcmVudFxuICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICBwYXJlbnQuJGNoaWxkcmVuLiRyZW1vdmUodGhpcylcbiAgICAvLyB1bnJlZ2lzdGVyIHJlZlxuICAgIHZhciByZWYgPSB0aGlzLiRvcHRpb25zLl9yZWZcbiAgICBpZiAocmVmKSB7XG4gICAgICB2YXIgc2NvcGUgPSB0aGlzLl9zY29wZSB8fCB0aGlzLl9jb250ZXh0XG4gICAgICBpZiAoc2NvcGUuJHJlZnNbcmVmXSA9PT0gdGhpcykge1xuICAgICAgICBzY29wZS4kcmVmc1tyZWZdID0gbnVsbFxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyByZW1vdmUgc2VsZiBmcm9tIG93bmVyIGZyYWdtZW50XG4gIGlmICh0aGlzLl9mcmFnKSB7XG4gICAgdGhpcy5fZnJhZy5jaGlsZHJlbi4kcmVtb3ZlKHRoaXMpXG4gIH1cbiAgLy8gZGVzdHJveSBhbGwgY2hpbGRyZW4uXG4gIGkgPSB0aGlzLiRjaGlsZHJlbi5sZW5ndGhcbiAgd2hpbGUgKGktLSkge1xuICAgIHRoaXMuJGNoaWxkcmVuW2ldLiRkZXN0cm95KClcbiAgfVxuICAvLyB0ZWFyZG93biBwcm9wc1xuICBpZiAodGhpcy5fcHJvcHNVbmxpbmtGbikge1xuICAgIHRoaXMuX3Byb3BzVW5saW5rRm4oKVxuICB9XG4gIC8vIHRlYXJkb3duIGFsbCBkaXJlY3RpdmVzLiB0aGlzIGFsc28gdGVhcnNkb3duIGFsbFxuICAvLyBkaXJlY3RpdmUtb3duZWQgd2F0Y2hlcnMuXG4gIGlmICh0aGlzLl91bmxpbmtGbikge1xuICAgIHRoaXMuX3VubGlua0ZuKClcbiAgfVxuICBpID0gdGhpcy5fd2F0Y2hlcnMubGVuZ3RoXG4gIHdoaWxlIChpLS0pIHtcbiAgICB0aGlzLl93YXRjaGVyc1tpXS50ZWFyZG93bigpXG4gIH1cbiAgLy8gcmVtb3ZlIHJlZmVyZW5jZSB0byBzZWxmIG9uICRlbFxuICBpZiAodGhpcy4kZWwpIHtcbiAgICB0aGlzLiRlbC5fX3Z1ZV9fID0gbnVsbFxuICB9XG4gIC8vIHJlbW92ZSBET00gZWxlbWVudFxuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHJlbW92ZSAmJiB0aGlzLiRlbCkge1xuICAgIHRoaXMuJHJlbW92ZShmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLl9jbGVhbnVwKClcbiAgICB9KVxuICB9IGVsc2UgaWYgKCFkZWZlckNsZWFudXApIHtcbiAgICB0aGlzLl9jbGVhbnVwKClcbiAgfVxufVxuXG4vKipcbiAqIENsZWFuIHVwIHRvIGVuc3VyZSBnYXJiYWdlIGNvbGxlY3Rpb24uXG4gKiBUaGlzIGlzIGNhbGxlZCBhZnRlciB0aGUgbGVhdmUgdHJhbnNpdGlvbiBpZiB0aGVyZVxuICogaXMgYW55LlxuICovXG5cbmV4cG9ydHMuX2NsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIHJlbW92ZSByZWZlcmVuY2UgZnJvbSBkYXRhIG9iXG4gIC8vIGZyb3plbiBvYmplY3QgbWF5IG5vdCBoYXZlIG9ic2VydmVyLlxuICBpZiAodGhpcy5fZGF0YS5fX29iX18pIHtcbiAgICB0aGlzLl9kYXRhLl9fb2JfXy5yZW1vdmVWbSh0aGlzKVxuICB9XG4gIC8vIENsZWFuIHVwIHJlZmVyZW5jZXMgdG8gcHJpdmF0ZSBwcm9wZXJ0aWVzIGFuZCBvdGhlclxuICAvLyBpbnN0YW5jZXMuIHByZXNlcnZlIHJlZmVyZW5jZSB0byBfZGF0YSBzbyB0aGF0IHByb3h5XG4gIC8vIGFjY2Vzc29ycyBzdGlsbCB3b3JrLiBUaGUgb25seSBwb3RlbnRpYWwgc2lkZSBlZmZlY3RcbiAgLy8gaGVyZSBpcyB0aGF0IG11dGF0aW5nIHRoZSBpbnN0YW5jZSBhZnRlciBpdCdzIGRlc3Ryb3llZFxuICAvLyBtYXkgYWZmZWN0IHRoZSBzdGF0ZSBvZiBvdGhlciBjb21wb25lbnRzIHRoYXQgYXJlIHN0aWxsXG4gIC8vIG9ic2VydmluZyB0aGUgc2FtZSBvYmplY3QsIGJ1dCB0aGF0IHNlZW1zIHRvIGJlIGFcbiAgLy8gcmVhc29uYWJsZSByZXNwb25zaWJpbGl0eSBmb3IgdGhlIHVzZXIgcmF0aGVyIHRoYW5cbiAgLy8gYWx3YXlzIHRocm93aW5nIGFuIGVycm9yIG9uIHRoZW0uXG4gIHRoaXMuJGVsID1cbiAgdGhpcy4kcGFyZW50ID1cbiAgdGhpcy4kcm9vdCA9XG4gIHRoaXMuJGNoaWxkcmVuID1cbiAgdGhpcy5fd2F0Y2hlcnMgPVxuICB0aGlzLl9jb250ZXh0ID1cbiAgdGhpcy5fc2NvcGUgPVxuICB0aGlzLl9kaXJlY3RpdmVzID0gbnVsbFxuICAvLyBjYWxsIHRoZSBsYXN0IGhvb2suLi5cbiAgdGhpcy5faXNEZXN0cm95ZWQgPSB0cnVlXG4gIHRoaXMuX2NhbGxIb29rKCdkZXN0cm95ZWQnKVxuICAvLyB0dXJuIG9mZiBhbGwgaW5zdGFuY2UgbGlzdGVuZXJzLlxuICB0aGlzLiRvZmYoKVxufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi91dGlsJylcblxuLyoqXG4gKiBBcHBseSBhIGxpc3Qgb2YgZmlsdGVyIChkZXNjcmlwdG9ycykgdG8gYSB2YWx1ZS5cbiAqIFVzaW5nIHBsYWluIGZvciBsb29wcyBoZXJlIGJlY2F1c2UgdGhpcyB3aWxsIGJlIGNhbGxlZCBpblxuICogdGhlIGdldHRlciBvZiBhbnkgd2F0Y2hlciB3aXRoIGZpbHRlcnMgc28gaXQgaXMgdmVyeVxuICogcGVyZm9ybWFuY2Ugc2Vuc2l0aXZlLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7Kn0gW29sZFZhbHVlXVxuICogQHBhcmFtIHtBcnJheX0gZmlsdGVyc1xuICogQHBhcmFtIHtCb29sZWFufSB3cml0ZVxuICogQHJldHVybiB7Kn1cbiAqL1xuXG5leHBvcnRzLl9hcHBseUZpbHRlcnMgPSBmdW5jdGlvbiAodmFsdWUsIG9sZFZhbHVlLCBmaWx0ZXJzLCB3cml0ZSkge1xuICB2YXIgZmlsdGVyLCBmbiwgYXJncywgYXJnLCBvZmZzZXQsIGksIGwsIGosIGtcbiAgZm9yIChpID0gMCwgbCA9IGZpbHRlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZmlsdGVyID0gZmlsdGVyc1tpXVxuICAgIGZuID0gXy5yZXNvbHZlQXNzZXQodGhpcy4kb3B0aW9ucywgJ2ZpbHRlcnMnLCBmaWx0ZXIubmFtZSlcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgXy5hc3NlcnRBc3NldChmbiwgJ2ZpbHRlcicsIGZpbHRlci5uYW1lKVxuICAgIH1cbiAgICBpZiAoIWZuKSBjb250aW51ZVxuICAgIGZuID0gd3JpdGUgPyBmbi53cml0ZSA6IChmbi5yZWFkIHx8IGZuKVxuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIGNvbnRpbnVlXG4gICAgYXJncyA9IHdyaXRlID8gW3ZhbHVlLCBvbGRWYWx1ZV0gOiBbdmFsdWVdXG4gICAgb2Zmc2V0ID0gd3JpdGUgPyAyIDogMVxuICAgIGlmIChmaWx0ZXIuYXJncykge1xuICAgICAgZm9yIChqID0gMCwgayA9IGZpbHRlci5hcmdzLmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICBhcmcgPSBmaWx0ZXIuYXJnc1tqXVxuICAgICAgICBhcmdzW2ogKyBvZmZzZXRdID0gYXJnLmR5bmFtaWNcbiAgICAgICAgICA/IHRoaXMuJGdldChhcmcudmFsdWUpXG4gICAgICAgICAgOiBhcmcudmFsdWVcbiAgICAgIH1cbiAgICB9XG4gICAgdmFsdWUgPSBmbi5hcHBseSh0aGlzLCBhcmdzKVxuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIFJlc29sdmUgYSBjb21wb25lbnQsIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBjb21wb25lbnRcbiAqIGlzIGRlZmluZWQgbm9ybWFsbHkgb3IgdXNpbmcgYW4gYXN5bmMgZmFjdG9yeSBmdW5jdGlvbi5cbiAqIFJlc29sdmVzIHN5bmNocm9ub3VzbHkgaWYgYWxyZWFkeSByZXNvbHZlZCwgb3RoZXJ3aXNlXG4gKiByZXNvbHZlcyBhc3luY2hyb25vdXNseSBhbmQgY2FjaGVzIHRoZSByZXNvbHZlZFxuICogY29uc3RydWN0b3Igb24gdGhlIGZhY3RvcnkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICovXG5cbmV4cG9ydHMuX3Jlc29sdmVDb21wb25lbnQgPSBmdW5jdGlvbiAoaWQsIGNiKSB7XG4gIHZhciBmYWN0b3J5ID0gXy5yZXNvbHZlQXNzZXQodGhpcy4kb3B0aW9ucywgJ2NvbXBvbmVudHMnLCBpZClcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBfLmFzc2VydEFzc2V0KGZhY3RvcnksICdjb21wb25lbnQnLCBpZClcbiAgfVxuICBpZiAoIWZhY3RvcnkpIHtcbiAgICByZXR1cm5cbiAgfVxuICAvLyBhc3luYyBjb21wb25lbnQgZmFjdG9yeVxuICBpZiAoIWZhY3Rvcnkub3B0aW9ucykge1xuICAgIGlmIChmYWN0b3J5LnJlc29sdmVkKSB7XG4gICAgICAvLyBjYWNoZWRcbiAgICAgIGNiKGZhY3RvcnkucmVzb2x2ZWQpXG4gICAgfSBlbHNlIGlmIChmYWN0b3J5LnJlcXVlc3RlZCkge1xuICAgICAgLy8gcG9vbCBjYWxsYmFja3NcbiAgICAgIGZhY3RvcnkucGVuZGluZ0NhbGxiYWNrcy5wdXNoKGNiKVxuICAgIH0gZWxzZSB7XG4gICAgICBmYWN0b3J5LnJlcXVlc3RlZCA9IHRydWVcbiAgICAgIHZhciBjYnMgPSBmYWN0b3J5LnBlbmRpbmdDYWxsYmFja3MgPSBbY2JdXG4gICAgICBmYWN0b3J5KGZ1bmN0aW9uIHJlc29sdmUgKHJlcykge1xuICAgICAgICBpZiAoXy5pc1BsYWluT2JqZWN0KHJlcykpIHtcbiAgICAgICAgICByZXMgPSBfLlZ1ZS5leHRlbmQocmVzKVxuICAgICAgICB9XG4gICAgICAgIC8vIGNhY2hlIHJlc29sdmVkXG4gICAgICAgIGZhY3RvcnkucmVzb2x2ZWQgPSByZXNcbiAgICAgICAgLy8gaW52b2tlIGNhbGxiYWNrc1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBjYnNbaV0ocmVzKVxuICAgICAgICB9XG4gICAgICB9LCBmdW5jdGlvbiByZWplY3QgKHJlYXNvbikge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIF8ud2FybihcbiAgICAgICAgICAnRmFpbGVkIHRvIHJlc29sdmUgYXN5bmMgY29tcG9uZW50OiAnICsgaWQgKyAnLiAnICtcbiAgICAgICAgICAocmVhc29uID8gJ1xcblJlYXNvbjogJyArIHJlYXNvbiA6ICcnKVxuICAgICAgICApXG4gICAgICB9KVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBub3JtYWwgY29tcG9uZW50XG4gICAgY2IoZmFjdG9yeSlcbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi91dGlsJylcbnZhciBjb21waWxlciA9IHJlcXVpcmUoJy4uL2NvbXBpbGVyJylcbnZhciBPYnNlcnZlciA9IHJlcXVpcmUoJy4uL29ic2VydmVyJylcbnZhciBEZXAgPSByZXF1aXJlKCcuLi9vYnNlcnZlci9kZXAnKVxudmFyIFdhdGNoZXIgPSByZXF1aXJlKCcuLi93YXRjaGVyJylcblxuLyoqXG4gKiBTZXR1cCB0aGUgc2NvcGUgb2YgYW4gaW5zdGFuY2UsIHdoaWNoIGNvbnRhaW5zOlxuICogLSBvYnNlcnZlZCBkYXRhXG4gKiAtIGNvbXB1dGVkIHByb3BlcnRpZXNcbiAqIC0gdXNlciBtZXRob2RzXG4gKiAtIG1ldGEgcHJvcGVydGllc1xuICovXG5cbmV4cG9ydHMuX2luaXRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5faW5pdFByb3BzKClcbiAgdGhpcy5faW5pdE1ldGEoKVxuICB0aGlzLl9pbml0TWV0aG9kcygpXG4gIHRoaXMuX2luaXREYXRhKClcbiAgdGhpcy5faW5pdENvbXB1dGVkKClcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIHByb3BzLlxuICovXG5cbmV4cG9ydHMuX2luaXRQcm9wcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zXG4gIHZhciBlbCA9IG9wdGlvbnMuZWxcbiAgdmFyIHByb3BzID0gb3B0aW9ucy5wcm9wc1xuICBpZiAocHJvcHMgJiYgIWVsKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBfLndhcm4oXG4gICAgICAnUHJvcHMgd2lsbCBub3QgYmUgY29tcGlsZWQgaWYgbm8gYGVsYCBvcHRpb24gaXMgJyArXG4gICAgICAncHJvdmlkZWQgYXQgaW5zdGFudGlhdGlvbi4nXG4gICAgKVxuICB9XG4gIC8vIG1ha2Ugc3VyZSB0byBjb252ZXJ0IHN0cmluZyBzZWxlY3RvcnMgaW50byBlbGVtZW50IG5vd1xuICBlbCA9IG9wdGlvbnMuZWwgPSBfLnF1ZXJ5KGVsKVxuICB0aGlzLl9wcm9wc1VubGlua0ZuID0gZWwgJiYgZWwubm9kZVR5cGUgPT09IDEgJiYgcHJvcHNcbiAgICAvLyBwcm9wcyBtdXN0IGJlIGxpbmtlZCBpbiBwcm9wZXIgc2NvcGUgaWYgaW5zaWRlIHYtZm9yXG4gICAgPyBjb21waWxlci5jb21waWxlQW5kTGlua1Byb3BzKHRoaXMsIGVsLCBwcm9wcywgdGhpcy5fc2NvcGUpXG4gICAgOiBudWxsXG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgZGF0YS5cbiAqL1xuXG5leHBvcnRzLl9pbml0RGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHByb3BzRGF0YSA9IHRoaXMuX2RhdGFcbiAgdmFyIG9wdGlvbnNEYXRhRm4gPSB0aGlzLiRvcHRpb25zLmRhdGFcbiAgdmFyIG9wdGlvbnNEYXRhID0gb3B0aW9uc0RhdGFGbiAmJiBvcHRpb25zRGF0YUZuKClcbiAgaWYgKG9wdGlvbnNEYXRhKSB7XG4gICAgdGhpcy5fZGF0YSA9IG9wdGlvbnNEYXRhXG4gICAgZm9yICh2YXIgcHJvcCBpbiBwcm9wc0RhdGEpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgb3B0aW9uc0RhdGEuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgXy53YXJuKFxuICAgICAgICAgICdEYXRhIGZpZWxkIFwiJyArIHByb3AgKyAnXCIgaXMgYWxyZWFkeSBkZWZpbmVkICcgK1xuICAgICAgICAgICdhcyBhIHByb3AuIFVzZSBwcm9wIGRlZmF1bHQgdmFsdWUgaW5zdGVhZC4nXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9wcm9wc1twcm9wXS5yYXcgIT09IG51bGwgfHxcbiAgICAgICAgICAhb3B0aW9uc0RhdGEuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgXy5zZXQob3B0aW9uc0RhdGEsIHByb3AsIHByb3BzRGF0YVtwcm9wXSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhXG4gIC8vIHByb3h5IGRhdGEgb24gaW5zdGFuY2VcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKVxuICB2YXIgaSwga2V5XG4gIGkgPSBrZXlzLmxlbmd0aFxuICB3aGlsZSAoaS0tKSB7XG4gICAga2V5ID0ga2V5c1tpXVxuICAgIHRoaXMuX3Byb3h5KGtleSlcbiAgfVxuICAvLyBvYnNlcnZlIGRhdGFcbiAgT2JzZXJ2ZXIuY3JlYXRlKGRhdGEsIHRoaXMpXG59XG5cbi8qKlxuICogU3dhcCB0aGUgaXNudGFuY2UncyAkZGF0YS4gQ2FsbGVkIGluICRkYXRhJ3Mgc2V0dGVyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBuZXdEYXRhXG4gKi9cblxuZXhwb3J0cy5fc2V0RGF0YSA9IGZ1bmN0aW9uIChuZXdEYXRhKSB7XG4gIG5ld0RhdGEgPSBuZXdEYXRhIHx8IHt9XG4gIHZhciBvbGREYXRhID0gdGhpcy5fZGF0YVxuICB0aGlzLl9kYXRhID0gbmV3RGF0YVxuICB2YXIga2V5cywga2V5LCBpXG4gIC8vIHVucHJveHkga2V5cyBub3QgcHJlc2VudCBpbiBuZXcgZGF0YVxuICBrZXlzID0gT2JqZWN0LmtleXMob2xkRGF0YSlcbiAgaSA9IGtleXMubGVuZ3RoXG4gIHdoaWxlIChpLS0pIHtcbiAgICBrZXkgPSBrZXlzW2ldXG4gICAgaWYgKCEoa2V5IGluIG5ld0RhdGEpKSB7XG4gICAgICB0aGlzLl91bnByb3h5KGtleSlcbiAgICB9XG4gIH1cbiAgLy8gcHJveHkga2V5cyBub3QgYWxyZWFkeSBwcm94aWVkLFxuICAvLyBhbmQgdHJpZ2dlciBjaGFuZ2UgZm9yIGNoYW5nZWQgdmFsdWVzXG4gIGtleXMgPSBPYmplY3Qua2V5cyhuZXdEYXRhKVxuICBpID0ga2V5cy5sZW5ndGhcbiAgd2hpbGUgKGktLSkge1xuICAgIGtleSA9IGtleXNbaV1cbiAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgLy8gbmV3IHByb3BlcnR5XG4gICAgICB0aGlzLl9wcm94eShrZXkpXG4gICAgfVxuICB9XG4gIG9sZERhdGEuX19vYl9fLnJlbW92ZVZtKHRoaXMpXG4gIE9ic2VydmVyLmNyZWF0ZShuZXdEYXRhLCB0aGlzKVxuICB0aGlzLl9kaWdlc3QoKVxufVxuXG4vKipcbiAqIFByb3h5IGEgcHJvcGVydHksIHNvIHRoYXRcbiAqIHZtLnByb3AgPT09IHZtLl9kYXRhLnByb3BcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKi9cblxuZXhwb3J0cy5fcHJveHkgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIGlmICghXy5pc1Jlc2VydmVkKGtleSkpIHtcbiAgICAvLyBuZWVkIHRvIHN0b3JlIHJlZiB0byBzZWxmIGhlcmVcbiAgICAvLyBiZWNhdXNlIHRoZXNlIGdldHRlci9zZXR0ZXJzIG1pZ2h0XG4gICAgLy8gYmUgY2FsbGVkIGJ5IGNoaWxkIHNjb3BlcyB2aWFcbiAgICAvLyBwcm90b3R5cGUgaW5oZXJpdGFuY2UuXG4gICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIGtleSwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gcHJveHlHZXR0ZXIgKCkge1xuICAgICAgICByZXR1cm4gc2VsZi5fZGF0YVtrZXldXG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBwcm94eVNldHRlciAodmFsKSB7XG4gICAgICAgIHNlbGYuX2RhdGFba2V5XSA9IHZhbFxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiBVbnByb3h5IGEgcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICovXG5cbmV4cG9ydHMuX3VucHJveHkgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIGlmICghXy5pc1Jlc2VydmVkKGtleSkpIHtcbiAgICBkZWxldGUgdGhpc1trZXldXG4gIH1cbn1cblxuLyoqXG4gKiBGb3JjZSB1cGRhdGUgb24gZXZlcnkgd2F0Y2hlciBpbiBzY29wZS5cbiAqL1xuXG5leHBvcnRzLl9kaWdlc3QgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fd2F0Y2hlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdGhpcy5fd2F0Y2hlcnNbaV0udXBkYXRlKHRydWUpIC8vIHNoYWxsb3cgdXBkYXRlc1xuICB9XG59XG5cbi8qKlxuICogU2V0dXAgY29tcHV0ZWQgcHJvcGVydGllcy4gVGhleSBhcmUgZXNzZW50aWFsbHlcbiAqIHNwZWNpYWwgZ2V0dGVyL3NldHRlcnNcbiAqL1xuXG5mdW5jdGlvbiBub29wICgpIHt9XG5leHBvcnRzLl9pbml0Q29tcHV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjb21wdXRlZCA9IHRoaXMuJG9wdGlvbnMuY29tcHV0ZWRcbiAgaWYgKGNvbXB1dGVkKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgICB2YXIgdXNlckRlZiA9IGNvbXB1dGVkW2tleV1cbiAgICAgIHZhciBkZWYgPSB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRlZi5nZXQgPSBtYWtlQ29tcHV0ZWRHZXR0ZXIodXNlckRlZiwgdGhpcylcbiAgICAgICAgZGVmLnNldCA9IG5vb3BcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZi5nZXQgPSB1c2VyRGVmLmdldFxuICAgICAgICAgID8gdXNlckRlZi5jYWNoZSAhPT0gZmFsc2VcbiAgICAgICAgICAgID8gbWFrZUNvbXB1dGVkR2V0dGVyKHVzZXJEZWYuZ2V0LCB0aGlzKVxuICAgICAgICAgICAgOiBfLmJpbmQodXNlckRlZi5nZXQsIHRoaXMpXG4gICAgICAgICAgOiBub29wXG4gICAgICAgIGRlZi5zZXQgPSB1c2VyRGVmLnNldFxuICAgICAgICAgID8gXy5iaW5kKHVzZXJEZWYuc2V0LCB0aGlzKVxuICAgICAgICAgIDogbm9vcFxuICAgICAgfVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwgZGVmKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlQ29tcHV0ZWRHZXR0ZXIgKGdldHRlciwgb3duZXIpIHtcbiAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcihvd25lciwgZ2V0dGVyLCBudWxsLCB7XG4gICAgbGF6eTogdHJ1ZVxuICB9KVxuICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xuICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICB3YXRjaGVyLmV2YWx1YXRlKClcbiAgICB9XG4gICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgIHdhdGNoZXIuZGVwZW5kKClcbiAgICB9XG4gICAgcmV0dXJuIHdhdGNoZXIudmFsdWVcbiAgfVxufVxuXG4vKipcbiAqIFNldHVwIGluc3RhbmNlIG1ldGhvZHMuIE1ldGhvZHMgbXVzdCBiZSBib3VuZCB0byB0aGVcbiAqIGluc3RhbmNlIHNpbmNlIHRoZXkgbWlnaHQgYmUgcGFzc2VkIGRvd24gYXMgYSBwcm9wIHRvXG4gKiBjaGlsZCBjb21wb25lbnRzLlxuICovXG5cbmV4cG9ydHMuX2luaXRNZXRob2RzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbWV0aG9kcyA9IHRoaXMuJG9wdGlvbnMubWV0aG9kc1xuICBpZiAobWV0aG9kcykge1xuICAgIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSB7XG4gICAgICB0aGlzW2tleV0gPSBfLmJpbmQobWV0aG9kc1trZXldLCB0aGlzKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEluaXRpYWxpemUgbWV0YSBpbmZvcm1hdGlvbiBsaWtlICRpbmRleCwgJGtleSAmICR2YWx1ZS5cbiAqL1xuXG5leHBvcnRzLl9pbml0TWV0YSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG1ldGFzID0gdGhpcy4kb3B0aW9ucy5fbWV0YVxuICBpZiAobWV0YXMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gbWV0YXMpIHtcbiAgICAgIF8uZGVmaW5lUmVhY3RpdmUodGhpcywga2V5LCBtZXRhc1trZXldKVxuICAgIH1cbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi91dGlsJylcbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlXG52YXIgYXJyYXlNZXRob2RzID0gT2JqZWN0LmNyZWF0ZShhcnJheVByb3RvKVxuXG4vKipcbiAqIEludGVyY2VwdCBtdXRhdGluZyBtZXRob2RzIGFuZCBlbWl0IGV2ZW50c1xuICovXG5cbjtbXG4gICdwdXNoJyxcbiAgJ3BvcCcsXG4gICdzaGlmdCcsXG4gICd1bnNoaWZ0JyxcbiAgJ3NwbGljZScsXG4gICdzb3J0JyxcbiAgJ3JldmVyc2UnXG5dXG4uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gIC8vIGNhY2hlIG9yaWdpbmFsIG1ldGhvZFxuICB2YXIgb3JpZ2luYWwgPSBhcnJheVByb3RvW21ldGhvZF1cbiAgXy5kZWZpbmUoYXJyYXlNZXRob2RzLCBtZXRob2QsIGZ1bmN0aW9uIG11dGF0b3IgKCkge1xuICAgIC8vIGF2b2lkIGxlYWtpbmcgYXJndW1lbnRzOlxuICAgIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2Nsb3N1cmUtd2l0aC1hcmd1bWVudHNcbiAgICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShpKVxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV1cbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgdmFyIG9iID0gdGhpcy5fX29iX19cbiAgICB2YXIgaW5zZXJ0ZWRcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgY2FzZSAncHVzaCc6XG4gICAgICAgIGluc2VydGVkID0gYXJnc1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAndW5zaGlmdCc6XG4gICAgICAgIGluc2VydGVkID0gYXJnc1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnc3BsaWNlJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzLnNsaWNlKDIpXG4gICAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChpbnNlcnRlZCkgb2Iub2JzZXJ2ZUFycmF5KGluc2VydGVkKVxuICAgIC8vIG5vdGlmeSBjaGFuZ2VcbiAgICBvYi5kZXAubm90aWZ5KClcbiAgICByZXR1cm4gcmVzdWx0XG4gIH0pXG59KVxuXG4vKipcbiAqIFN3YXAgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4IHdpdGggYSBuZXcgdmFsdWVcbiAqIGFuZCBlbWl0cyBjb3JyZXNwb25kaW5nIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4geyp9IC0gcmVwbGFjZWQgZWxlbWVudFxuICovXG5cbl8uZGVmaW5lKFxuICBhcnJheVByb3RvLFxuICAnJHNldCcsXG4gIGZ1bmN0aW9uICRzZXQgKGluZGV4LCB2YWwpIHtcbiAgICBpZiAoaW5kZXggPj0gdGhpcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMubGVuZ3RoID0gaW5kZXggKyAxXG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNwbGljZShpbmRleCwgMSwgdmFsKVswXVxuICB9XG4pXG5cbi8qKlxuICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIHJlbW92ZSB0aGUgZWxlbWVudCBhdCBnaXZlbiBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKi9cblxuXy5kZWZpbmUoXG4gIGFycmF5UHJvdG8sXG4gICckcmVtb3ZlJyxcbiAgZnVuY3Rpb24gJHJlbW92ZSAoaXRlbSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghdGhpcy5sZW5ndGgpIHJldHVyblxuICAgIHZhciBpbmRleCA9IF8uaW5kZXhPZih0aGlzLCBpdGVtKVxuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICByZXR1cm4gdGhpcy5zcGxpY2UoaW5kZXgsIDEpXG4gICAgfVxuICB9XG4pXG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlNZXRob2RzXG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWwnKVxudmFyIHVpZCA9IDBcblxuLyoqXG4gKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcbiAqIGRpcmVjdGl2ZXMgc3Vic2NyaWJpbmcgdG8gaXQuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuZnVuY3Rpb24gRGVwICgpIHtcbiAgdGhpcy5pZCA9IHVpZCsrXG4gIHRoaXMuc3VicyA9IFtdXG59XG5cbi8vIHRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbi8vIHRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb25seSBvbmVcbi8vIHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkIGF0IGFueSB0aW1lLlxuRGVwLnRhcmdldCA9IG51bGxcblxuLyoqXG4gKiBBZGQgYSBkaXJlY3RpdmUgc3Vic2NyaWJlci5cbiAqXG4gKiBAcGFyYW0ge0RpcmVjdGl2ZX0gc3ViXG4gKi9cblxuRGVwLnByb3RvdHlwZS5hZGRTdWIgPSBmdW5jdGlvbiAoc3ViKSB7XG4gIHRoaXMuc3Vicy5wdXNoKHN1Yilcbn1cblxuLyoqXG4gKiBSZW1vdmUgYSBkaXJlY3RpdmUgc3Vic2NyaWJlci5cbiAqXG4gKiBAcGFyYW0ge0RpcmVjdGl2ZX0gc3ViXG4gKi9cblxuRGVwLnByb3RvdHlwZS5yZW1vdmVTdWIgPSBmdW5jdGlvbiAoc3ViKSB7XG4gIHRoaXMuc3Vicy4kcmVtb3ZlKHN1Yilcbn1cblxuLyoqXG4gKiBBZGQgc2VsZiBhcyBhIGRlcGVuZGVuY3kgdG8gdGhlIHRhcmdldCB3YXRjaGVyLlxuICovXG5cbkRlcC5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gKCkge1xuICBEZXAudGFyZ2V0LmFkZERlcCh0aGlzKVxufVxuXG4vKipcbiAqIE5vdGlmeSBhbGwgc3Vic2NyaWJlcnMgb2YgYSBuZXcgdmFsdWUuXG4gKi9cblxuRGVwLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIHN0YWJsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgdmFyIHN1YnMgPSBfLnRvQXJyYXkodGhpcy5zdWJzKVxuICBmb3IgKHZhciBpID0gMCwgbCA9IHN1YnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgc3Vic1tpXS51cGRhdGUoKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGVwXG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWwnKVxudmFyIERlcCA9IHJlcXVpcmUoJy4vZGVwJylcbnZhciBhcnJheU1ldGhvZHMgPSByZXF1aXJlKCcuL2FycmF5JylcbnZhciBhcnJheUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcnJheU1ldGhvZHMpXG5cbi8qKlxuICogT2JzZXJ2ZXIgY2xhc3MgdGhhdCBhcmUgYXR0YWNoZWQgdG8gZWFjaCBvYnNlcnZlZFxuICogb2JqZWN0LiBPbmNlIGF0dGFjaGVkLCB0aGUgb2JzZXJ2ZXIgY29udmVydHMgdGFyZ2V0XG4gKiBvYmplY3QncyBwcm9wZXJ0eSBrZXlzIGludG8gZ2V0dGVyL3NldHRlcnMgdGhhdFxuICogY29sbGVjdCBkZXBlbmRlbmNpZXMgYW5kIGRpc3BhdGNoZXMgdXBkYXRlcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gdmFsdWVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbmZ1bmN0aW9uIE9ic2VydmVyICh2YWx1ZSkge1xuICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgdGhpcy5kZXAgPSBuZXcgRGVwKClcbiAgXy5kZWZpbmUodmFsdWUsICdfX29iX18nLCB0aGlzKVxuICBpZiAoXy5pc0FycmF5KHZhbHVlKSkge1xuICAgIHZhciBhdWdtZW50ID0gXy5oYXNQcm90b1xuICAgICAgPyBwcm90b0F1Z21lbnRcbiAgICAgIDogY29weUF1Z21lbnRcbiAgICBhdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMsIGFycmF5S2V5cylcbiAgICB0aGlzLm9ic2VydmVBcnJheSh2YWx1ZSlcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndhbGsodmFsdWUpXG4gIH1cbn1cblxuLy8gU3RhdGljIG1ldGhvZHNcblxuLyoqXG4gKiBBdHRlbXB0IHRvIGNyZWF0ZSBhbiBvYnNlcnZlciBpbnN0YW5jZSBmb3IgYSB2YWx1ZSxcbiAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXG4gKiBvciB0aGUgZXhpc3Rpbmcgb2JzZXJ2ZXIgaWYgdGhlIHZhbHVlIGFscmVhZHkgaGFzIG9uZS5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcGFyYW0ge1Z1ZX0gW3ZtXVxuICogQHJldHVybiB7T2JzZXJ2ZXJ8dW5kZWZpbmVkfVxuICogQHN0YXRpY1xuICovXG5cbk9ic2VydmVyLmNyZWF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgdm0pIHtcbiAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9iXG4gIGlmIChcbiAgICB2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgnX19vYl9fJykgJiZcbiAgICB2YWx1ZS5fX29iX18gaW5zdGFuY2VvZiBPYnNlcnZlclxuICApIHtcbiAgICBvYiA9IHZhbHVlLl9fb2JfX1xuICB9IGVsc2UgaWYgKFxuICAgIChfLmlzQXJyYXkodmFsdWUpIHx8IF8uaXNQbGFpbk9iamVjdCh2YWx1ZSkpICYmXG4gICAgIU9iamVjdC5pc0Zyb3plbih2YWx1ZSkgJiZcbiAgICAhdmFsdWUuX2lzVnVlXG4gICkge1xuICAgIG9iID0gbmV3IE9ic2VydmVyKHZhbHVlKVxuICB9XG4gIGlmIChvYiAmJiB2bSkge1xuICAgIG9iLmFkZFZtKHZtKVxuICB9XG4gIHJldHVybiBvYlxufVxuXG4vLyBJbnN0YW5jZSBtZXRob2RzXG5cbi8qKlxuICogV2FsayB0aHJvdWdoIGVhY2ggcHJvcGVydHkgYW5kIGNvbnZlcnQgdGhlbSBpbnRvXG4gKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cbiAqIHZhbHVlIHR5cGUgaXMgT2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqL1xuXG5PYnNlcnZlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopXG4gIHZhciBpID0ga2V5cy5sZW5ndGhcbiAgd2hpbGUgKGktLSkge1xuICAgIHRoaXMuY29udmVydChrZXlzW2ldLCBvYmpba2V5c1tpXV0pXG4gIH1cbn1cblxuLyoqXG4gKiBPYnNlcnZlIGEgbGlzdCBvZiBBcnJheSBpdGVtcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBpdGVtc1xuICovXG5cbk9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlQXJyYXkgPSBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgdmFyIGkgPSBpdGVtcy5sZW5ndGhcbiAgd2hpbGUgKGktLSkge1xuICAgIE9ic2VydmVyLmNyZWF0ZShpdGVtc1tpXSlcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSBwcm9wZXJ0eSBpbnRvIGdldHRlci9zZXR0ZXIgc28gd2UgY2FuIGVtaXRcbiAqIHRoZSBldmVudHMgd2hlbiB0aGUgcHJvcGVydHkgaXMgYWNjZXNzZWQvY2hhbmdlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0geyp9IHZhbFxuICovXG5cbk9ic2VydmVyLnByb3RvdHlwZS5jb252ZXJ0ID0gZnVuY3Rpb24gKGtleSwgdmFsKSB7XG4gIGRlZmluZVJlYWN0aXZlKHRoaXMudmFsdWUsIGtleSwgdmFsKVxufVxuXG4vKipcbiAqIEFkZCBhbiBvd25lciB2bSwgc28gdGhhdCB3aGVuICRzZXQvJGRlbGV0ZSBtdXRhdGlvbnNcbiAqIGhhcHBlbiB3ZSBjYW4gbm90aWZ5IG93bmVyIHZtcyB0byBwcm94eSB0aGUga2V5cyBhbmRcbiAqIGRpZ2VzdCB0aGUgd2F0Y2hlcnMuIFRoaXMgaXMgb25seSBjYWxsZWQgd2hlbiB0aGUgb2JqZWN0XG4gKiBpcyBvYnNlcnZlZCBhcyBhbiBpbnN0YW5jZSdzIHJvb3QgJGRhdGEuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKi9cblxuT2JzZXJ2ZXIucHJvdG90eXBlLmFkZFZtID0gZnVuY3Rpb24gKHZtKSB7XG4gICh0aGlzLnZtcyB8fCAodGhpcy52bXMgPSBbXSkpLnB1c2godm0pXG59XG5cbi8qKlxuICogUmVtb3ZlIGFuIG93bmVyIHZtLiBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoZSBvYmplY3QgaXNcbiAqIHN3YXBwZWQgb3V0IGFzIGFuIGluc3RhbmNlJ3MgJGRhdGEgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICovXG5cbk9ic2VydmVyLnByb3RvdHlwZS5yZW1vdmVWbSA9IGZ1bmN0aW9uICh2bSkge1xuICB0aGlzLnZtcy4kcmVtb3ZlKHZtKVxufVxuXG4vLyBoZWxwZXJzXG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGludGVyY2VwdGluZ1xuICogdGhlIHByb3RvdHlwZSBjaGFpbiB1c2luZyBfX3Byb3RvX19cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gdGFyZ2V0XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG9cbiAqL1xuXG5mdW5jdGlvbiBwcm90b0F1Z21lbnQgKHRhcmdldCwgc3JjKSB7XG4gIHRhcmdldC5fX3Byb3RvX18gPSBzcmNcbn1cblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcbiAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSB0YXJnZXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b1xuICovXG5cbmZ1bmN0aW9uIGNvcHlBdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xuICB2YXIgaSA9IGtleXMubGVuZ3RoXG4gIHZhciBrZXlcbiAgd2hpbGUgKGktLSkge1xuICAgIGtleSA9IGtleXNbaV1cbiAgICBfLmRlZmluZSh0YXJnZXQsIGtleSwgc3JjW2tleV0pXG4gIH1cbn1cblxuLyoqXG4gKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHsqfSB2YWxcbiAqL1xuXG5mdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZSAob2JqLCBrZXksIHZhbCkge1xuICB2YXIgZGVwID0gbmV3IERlcCgpXG4gIHZhciBjaGlsZE9iID0gT2JzZXJ2ZXIuY3JlYXRlKHZhbClcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBtZXRhR2V0dGVyICgpIHtcbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIGRlcC5kZXBlbmQoKVxuICAgICAgICBpZiAoY2hpbGRPYikge1xuICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKF8uaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgZm9yICh2YXIgZSwgaSA9IDAsIGwgPSB2YWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBlID0gdmFsW2ldXG4gICAgICAgICAgICBlICYmIGUuX19vYl9fICYmIGUuX19vYl9fLmRlcC5kZXBlbmQoKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbFxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBtZXRhU2V0dGVyIChuZXdWYWwpIHtcbiAgICAgIGlmIChuZXdWYWwgPT09IHZhbCkgcmV0dXJuXG4gICAgICB2YWwgPSBuZXdWYWxcbiAgICAgIGNoaWxkT2IgPSBPYnNlcnZlci5jcmVhdGUobmV3VmFsKVxuICAgICAgZGVwLm5vdGlmeSgpXG4gICAgfVxuICB9KVxufVxuXG4vLyBBdHRhY2ggdG8gdGhlIHV0aWwgb2JqZWN0IHNvIGl0IGNhbiBiZSB1c2VkIGVsc2V3aGVyZS5cbl8uZGVmaW5lUmVhY3RpdmUgPSBkZWZpbmVSZWFjdGl2ZVxuXG5tb2R1bGUuZXhwb3J0cyA9IE9ic2VydmVyXG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWwnKVxudmFyIENhY2hlID0gcmVxdWlyZSgnLi4vY2FjaGUnKVxudmFyIGNhY2hlID0gbmV3IENhY2hlKDEwMDApXG52YXIgZmlsdGVyVG9rZW5SRSA9IC9bXlxccydcIl0rfCdbXiddKid8XCJbXlwiXSpcIi9nXG52YXIgcmVzZXJ2ZWRBcmdSRSA9IC9eaW4kfF4tP1xcZCsvXG5cbi8qKlxuICogUGFyc2VyIHN0YXRlXG4gKi9cblxudmFyIHN0ciwgZGlyXG52YXIgYywgaSwgbCwgbGFzdEZpbHRlckluZGV4XG52YXIgaW5TaW5nbGUsIGluRG91YmxlLCBjdXJseSwgc3F1YXJlLCBwYXJlblxuXG4vKipcbiAqIFB1c2ggYSBmaWx0ZXIgdG8gdGhlIGN1cnJlbnQgZGlyZWN0aXZlIG9iamVjdFxuICovXG5cbmZ1bmN0aW9uIHB1c2hGaWx0ZXIgKCkge1xuICB2YXIgZXhwID0gc3RyLnNsaWNlKGxhc3RGaWx0ZXJJbmRleCwgaSkudHJpbSgpXG4gIHZhciBmaWx0ZXJcbiAgaWYgKGV4cCkge1xuICAgIGZpbHRlciA9IHt9XG4gICAgdmFyIHRva2VucyA9IGV4cC5tYXRjaChmaWx0ZXJUb2tlblJFKVxuICAgIGZpbHRlci5uYW1lID0gdG9rZW5zWzBdXG4gICAgaWYgKHRva2Vucy5sZW5ndGggPiAxKSB7XG4gICAgICBmaWx0ZXIuYXJncyA9IHRva2Vucy5zbGljZSgxKS5tYXAocHJvY2Vzc0ZpbHRlckFyZylcbiAgICB9XG4gIH1cbiAgaWYgKGZpbHRlcikge1xuICAgIChkaXIuZmlsdGVycyA9IGRpci5maWx0ZXJzIHx8IFtdKS5wdXNoKGZpbHRlcilcbiAgfVxuICBsYXN0RmlsdGVySW5kZXggPSBpICsgMVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGFuIGFyZ3VtZW50IGlzIGR5bmFtaWMgYW5kIHN0cmlwIHF1b3Rlcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYXJnXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gcHJvY2Vzc0ZpbHRlckFyZyAoYXJnKSB7XG4gIGlmIChyZXNlcnZlZEFyZ1JFLnRlc3QoYXJnKSkge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogXy50b051bWJlcihhcmcpLFxuICAgICAgZHluYW1pYzogZmFsc2VcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHN0cmlwcGVkID0gXy5zdHJpcFF1b3RlcyhhcmcpXG4gICAgdmFyIGR5bmFtaWMgPSBzdHJpcHBlZCA9PT0gYXJnXG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBkeW5hbWljID8gYXJnIDogc3RyaXBwZWQsXG4gICAgICBkeW5hbWljOiBkeW5hbWljXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUGFyc2UgYSBkaXJlY3RpdmUgdmFsdWUgYW5kIGV4dHJhY3QgdGhlIGV4cHJlc3Npb25cbiAqIGFuZCBpdHMgZmlsdGVycyBpbnRvIGEgZGVzY3JpcHRvci5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIFwiYSArIDEgfCB1cHBlcmNhc2VcIiB3aWxsIHlpZWxkOlxuICoge1xuICogICBleHByZXNzaW9uOiAnYSArIDEnLFxuICogICBmaWx0ZXJzOiBbXG4gKiAgICAgeyBuYW1lOiAndXBwZXJjYXNlJywgYXJnczogbnVsbCB9XG4gKiAgIF1cbiAqIH1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIChzKSB7XG5cbiAgdmFyIGhpdCA9IGNhY2hlLmdldChzKVxuICBpZiAoaGl0KSB7XG4gICAgcmV0dXJuIGhpdFxuICB9XG5cbiAgLy8gcmVzZXQgcGFyc2VyIHN0YXRlXG4gIHN0ciA9IHNcbiAgaW5TaW5nbGUgPSBpbkRvdWJsZSA9IGZhbHNlXG4gIGN1cmx5ID0gc3F1YXJlID0gcGFyZW4gPSAwXG4gIGxhc3RGaWx0ZXJJbmRleCA9IDBcbiAgZGlyID0ge31cblxuICBmb3IgKGkgPSAwLCBsID0gc3RyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGlmIChpblNpbmdsZSkge1xuICAgICAgLy8gY2hlY2sgc2luZ2xlIHF1b3RlXG4gICAgICBpZiAoYyA9PT0gMHgyNykgaW5TaW5nbGUgPSAhaW5TaW5nbGVcbiAgICB9IGVsc2UgaWYgKGluRG91YmxlKSB7XG4gICAgICAvLyBjaGVjayBkb3VibGUgcXVvdGVcbiAgICAgIGlmIChjID09PSAweDIyKSBpbkRvdWJsZSA9ICFpbkRvdWJsZVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBjID09PSAweDdDICYmIC8vIHBpcGVcbiAgICAgIHN0ci5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gMHg3QyAmJlxuICAgICAgc3RyLmNoYXJDb2RlQXQoaSAtIDEpICE9PSAweDdDXG4gICAgKSB7XG4gICAgICBpZiAoZGlyLmV4cHJlc3Npb24gPT0gbnVsbCkge1xuICAgICAgICAvLyBmaXJzdCBmaWx0ZXIsIGVuZCBvZiBleHByZXNzaW9uXG4gICAgICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxXG4gICAgICAgIGRpci5leHByZXNzaW9uID0gc3RyLnNsaWNlKDAsIGkpLnRyaW0oKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYWxyZWFkeSBoYXMgZmlsdGVyXG4gICAgICAgIHB1c2hGaWx0ZXIoKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgY2FzZSAweDIyOiBpbkRvdWJsZSA9IHRydWU7IGJyZWFrIC8vIFwiXG4gICAgICAgIGNhc2UgMHgyNzogaW5TaW5nbGUgPSB0cnVlOyBicmVhayAvLyAnXG4gICAgICAgIGNhc2UgMHgyODogcGFyZW4rKzsgYnJlYWsgICAgICAgICAvLyAoXG4gICAgICAgIGNhc2UgMHgyOTogcGFyZW4tLTsgYnJlYWsgICAgICAgICAvLyApXG4gICAgICAgIGNhc2UgMHg1Qjogc3F1YXJlKys7IGJyZWFrICAgICAgICAvLyBbXG4gICAgICAgIGNhc2UgMHg1RDogc3F1YXJlLS07IGJyZWFrICAgICAgICAvLyBdXG4gICAgICAgIGNhc2UgMHg3QjogY3VybHkrKzsgYnJlYWsgICAgICAgICAvLyB7XG4gICAgICAgIGNhc2UgMHg3RDogY3VybHktLTsgYnJlYWsgICAgICAgICAvLyB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpci5leHByZXNzaW9uID09IG51bGwpIHtcbiAgICBkaXIuZXhwcmVzc2lvbiA9IHN0ci5zbGljZSgwLCBpKS50cmltKClcbiAgfSBlbHNlIGlmIChsYXN0RmlsdGVySW5kZXggIT09IDApIHtcbiAgICBwdXNoRmlsdGVyKClcbiAgfVxuXG4gIGNhY2hlLnB1dChzLCBkaXIpXG4gIHJldHVybiBkaXJcbn1cbiIsInZhciBfID0gcmVxdWlyZSgnLi4vdXRpbCcpXG52YXIgUGF0aCA9IHJlcXVpcmUoJy4vcGF0aCcpXG52YXIgQ2FjaGUgPSByZXF1aXJlKCcuLi9jYWNoZScpXG52YXIgZXhwcmVzc2lvbkNhY2hlID0gbmV3IENhY2hlKDEwMDApXG5cbnZhciBhbGxvd2VkS2V5d29yZHMgPVxuICAnTWF0aCxEYXRlLHRoaXMsdHJ1ZSxmYWxzZSxudWxsLHVuZGVmaW5lZCxJbmZpbml0eSxOYU4sJyArXG4gICdpc05hTixpc0Zpbml0ZSxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSwnICtcbiAgJ2VuY29kZVVSSUNvbXBvbmVudCxwYXJzZUludCxwYXJzZUZsb2F0J1xudmFyIGFsbG93ZWRLZXl3b3Jkc1JFID1cbiAgbmV3IFJlZ0V4cCgnXignICsgYWxsb3dlZEtleXdvcmRzLnJlcGxhY2UoLywvZywgJ1xcXFxifCcpICsgJ1xcXFxiKScpXG5cbi8vIGtleXdvcmRzIHRoYXQgZG9uJ3QgbWFrZSBzZW5zZSBpbnNpZGUgZXhwcmVzc2lvbnNcbnZhciBpbXByb3BlcktleXdvcmRzID1cbiAgJ2JyZWFrLGNhc2UsY2xhc3MsY2F0Y2gsY29uc3QsY29udGludWUsZGVidWdnZXIsZGVmYXVsdCwnICtcbiAgJ2RlbGV0ZSxkbyxlbHNlLGV4cG9ydCxleHRlbmRzLGZpbmFsbHksZm9yLGZ1bmN0aW9uLGlmLCcgK1xuICAnaW1wb3J0LGluLGluc3RhbmNlb2YsbGV0LHJldHVybixzdXBlcixzd2l0Y2gsdGhyb3csdHJ5LCcgK1xuICAndmFyLHdoaWxlLHdpdGgseWllbGQsZW51bSxhd2FpdCxpbXBsZW1lbnRzLHBhY2thZ2UsJyArXG4gICdwcm9jdGVjdGVkLHN0YXRpYyxpbnRlcmZhY2UscHJpdmF0ZSxwdWJsaWMnXG52YXIgaW1wcm9wZXJLZXl3b3Jkc1JFID1cbiAgbmV3IFJlZ0V4cCgnXignICsgaW1wcm9wZXJLZXl3b3Jkcy5yZXBsYWNlKC8sL2csICdcXFxcYnwnKSArICdcXFxcYiknKVxuXG52YXIgd3NSRSA9IC9cXHMvZ1xudmFyIG5ld2xpbmVSRSA9IC9cXG4vZ1xudmFyIHNhdmVSRSA9IC9bXFx7LF1cXHMqW1xcd1xcJF9dK1xccyo6fCgnW14nXSonfFwiW15cIl0qXCIpfG5ldyB8dHlwZW9mIHx2b2lkIC9nXG52YXIgcmVzdG9yZVJFID0gL1wiKFxcZCspXCIvZ1xudmFyIHBhdGhUZXN0UkUgPSAvXltBLVphLXpfJF1bXFx3JF0qKFxcLltBLVphLXpfJF1bXFx3JF0qfFxcWycuKj8nXFxdfFxcW1wiLio/XCJcXF18XFxbXFxkK1xcXXxcXFtbQS1aYS16XyRdW1xcdyRdKlxcXSkqJC9cbnZhciBwYXRoUmVwbGFjZVJFID0gL1teXFx3JFxcLl0oW0EtWmEtel8kXVtcXHckXSooXFwuW0EtWmEtel8kXVtcXHckXSp8XFxbJy4qPydcXF18XFxbXCIuKj9cIlxcXSkqKS9nXG52YXIgYm9vbGVhbkxpdGVyYWxSRSA9IC9eKHRydWV8ZmFsc2UpJC9cblxuLyoqXG4gKiBTYXZlIC8gUmV3cml0ZSAvIFJlc3RvcmVcbiAqXG4gKiBXaGVuIHJld3JpdGluZyBwYXRocyBmb3VuZCBpbiBhbiBleHByZXNzaW9uLCBpdCBpc1xuICogcG9zc2libGUgZm9yIHRoZSBzYW1lIGxldHRlciBzZXF1ZW5jZXMgdG8gYmUgZm91bmQgaW5cbiAqIHN0cmluZ3MgYW5kIE9iamVjdCBsaXRlcmFsIHByb3BlcnR5IGtleXMuIFRoZXJlZm9yZSB3ZVxuICogcmVtb3ZlIGFuZCBzdG9yZSB0aGVzZSBwYXJ0cyBpbiBhIHRlbXBvcmFyeSBhcnJheSwgYW5kXG4gKiByZXN0b3JlIHRoZW0gYWZ0ZXIgdGhlIHBhdGggcmV3cml0ZS5cbiAqL1xuXG52YXIgc2F2ZWQgPSBbXVxuXG4vKipcbiAqIFNhdmUgcmVwbGFjZXJcbiAqXG4gKiBUaGUgc2F2ZSByZWdleCBjYW4gbWF0Y2ggdHdvIHBvc3NpYmxlIGNhc2VzOlxuICogMS4gQW4gb3BlbmluZyBvYmplY3QgbGl0ZXJhbFxuICogMi4gQSBzdHJpbmdcbiAqIElmIG1hdGNoZWQgYXMgYSBwbGFpbiBzdHJpbmcsIHdlIG5lZWQgdG8gZXNjYXBlIGl0c1xuICogbmV3bGluZXMsIHNpbmNlIHRoZSBzdHJpbmcgbmVlZHMgdG8gYmUgcHJlc2VydmVkIHdoZW5cbiAqIGdlbmVyYXRpbmcgdGhlIGZ1bmN0aW9uIGJvZHkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtTdHJpbmd9IGlzU3RyaW5nIC0gc3RyIGlmIG1hdGNoZWQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm4ge1N0cmluZ30gLSBwbGFjZWhvbGRlciB3aXRoIGluZGV4XG4gKi9cblxuZnVuY3Rpb24gc2F2ZSAoc3RyLCBpc1N0cmluZykge1xuICB2YXIgaSA9IHNhdmVkLmxlbmd0aFxuICBzYXZlZFtpXSA9IGlzU3RyaW5nXG4gICAgPyBzdHIucmVwbGFjZShuZXdsaW5lUkUsICdcXFxcbicpXG4gICAgOiBzdHJcbiAgcmV0dXJuICdcIicgKyBpICsgJ1wiJ1xufVxuXG4vKipcbiAqIFBhdGggcmV3cml0ZSByZXBsYWNlclxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSByYXdcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiByZXdyaXRlIChyYXcpIHtcbiAgdmFyIGMgPSByYXcuY2hhckF0KDApXG4gIHZhciBwYXRoID0gcmF3LnNsaWNlKDEpXG4gIGlmIChhbGxvd2VkS2V5d29yZHNSRS50ZXN0KHBhdGgpKSB7XG4gICAgcmV0dXJuIHJhd1xuICB9IGVsc2Uge1xuICAgIHBhdGggPSBwYXRoLmluZGV4T2YoJ1wiJykgPiAtMVxuICAgICAgPyBwYXRoLnJlcGxhY2UocmVzdG9yZVJFLCByZXN0b3JlKVxuICAgICAgOiBwYXRoXG4gICAgcmV0dXJuIGMgKyAnc2NvcGUuJyArIHBhdGhcbiAgfVxufVxuXG4vKipcbiAqIFJlc3RvcmUgcmVwbGFjZXJcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge1N0cmluZ30gaSAtIG1hdGNoZWQgc2F2ZSBpbmRleFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIHJlc3RvcmUgKHN0ciwgaSkge1xuICByZXR1cm4gc2F2ZWRbaV1cbn1cblxuLyoqXG4gKiBSZXdyaXRlIGFuIGV4cHJlc3Npb24sIHByZWZpeGluZyBhbGwgcGF0aCBhY2Nlc3NvcnMgd2l0aFxuICogYHNjb3BlLmAgYW5kIGdlbmVyYXRlIGdldHRlci9zZXR0ZXIgZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHBcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gbmVlZFNldFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZUV4cEZucyAoZXhwLCBuZWVkU2V0KSB7XG4gIGlmIChpbXByb3BlcktleXdvcmRzUkUudGVzdChleHApKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBfLndhcm4oXG4gICAgICAnQXZvaWQgdXNpbmcgcmVzZXJ2ZWQga2V5d29yZHMgaW4gZXhwcmVzc2lvbjogJyArIGV4cFxuICAgIClcbiAgfVxuICAvLyByZXNldCBzdGF0ZVxuICBzYXZlZC5sZW5ndGggPSAwXG4gIC8vIHNhdmUgc3RyaW5ncyBhbmQgb2JqZWN0IGxpdGVyYWwga2V5c1xuICB2YXIgYm9keSA9IGV4cFxuICAgIC5yZXBsYWNlKHNhdmVSRSwgc2F2ZSlcbiAgICAucmVwbGFjZSh3c1JFLCAnJylcbiAgLy8gcmV3cml0ZSBhbGwgcGF0aHNcbiAgLy8gcGFkIDEgc3BhY2UgaGVyZSBiZWNhdWUgdGhlIHJlZ2V4IG1hdGNoZXMgMSBleHRyYSBjaGFyXG4gIGJvZHkgPSAoJyAnICsgYm9keSlcbiAgICAucmVwbGFjZShwYXRoUmVwbGFjZVJFLCByZXdyaXRlKVxuICAgIC5yZXBsYWNlKHJlc3RvcmVSRSwgcmVzdG9yZSlcbiAgdmFyIGdldHRlciA9IG1ha2VHZXR0ZXIoYm9keSlcbiAgaWYgKGdldHRlcikge1xuICAgIHJldHVybiB7XG4gICAgICBnZXQ6IGdldHRlcixcbiAgICAgIGJvZHk6IGJvZHksXG4gICAgICBzZXQ6IG5lZWRTZXRcbiAgICAgICAgPyBtYWtlU2V0dGVyKGJvZHkpXG4gICAgICAgIDogbnVsbFxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENvbXBpbGUgZ2V0dGVyIHNldHRlcnMgZm9yIGEgc2ltcGxlIHBhdGguXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV4cFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZVBhdGhGbnMgKGV4cCkge1xuICB2YXIgZ2V0dGVyLCBwYXRoXG4gIGlmIChleHAuaW5kZXhPZignWycpIDwgMCkge1xuICAgIC8vIHJlYWxseSBzaW1wbGUgcGF0aFxuICAgIHBhdGggPSBleHAuc3BsaXQoJy4nKVxuICAgIHBhdGgucmF3ID0gZXhwXG4gICAgZ2V0dGVyID0gUGF0aC5jb21waWxlR2V0dGVyKHBhdGgpXG4gIH0gZWxzZSB7XG4gICAgLy8gZG8gdGhlIHJlYWwgcGFyc2luZ1xuICAgIHBhdGggPSBQYXRoLnBhcnNlKGV4cClcbiAgICBnZXR0ZXIgPSBwYXRoLmdldFxuICB9XG4gIHJldHVybiB7XG4gICAgZ2V0OiBnZXR0ZXIsXG4gICAgLy8gYWx3YXlzIGdlbmVyYXRlIHNldHRlciBmb3Igc2ltcGxlIHBhdGhzXG4gICAgc2V0OiBmdW5jdGlvbiAob2JqLCB2YWwpIHtcbiAgICAgIFBhdGguc2V0KG9iaiwgcGF0aCwgdmFsKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEJ1aWxkIGEgZ2V0dGVyIGZ1bmN0aW9uLiBSZXF1aXJlcyBldmFsLlxuICpcbiAqIFdlIGlzb2xhdGUgdGhlIHRyeS9jYXRjaCBzbyBpdCBkb2Vzbid0IGFmZmVjdCB0aGVcbiAqIG9wdGltaXphdGlvbiBvZiB0aGUgcGFyc2UgZnVuY3Rpb24gd2hlbiBpdCBpcyBub3QgY2FsbGVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBib2R5XG4gKiBAcmV0dXJuIHtGdW5jdGlvbnx1bmRlZmluZWR9XG4gKi9cblxuZnVuY3Rpb24gbWFrZUdldHRlciAoYm9keSkge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oJ3Njb3BlJywgJ3JldHVybiAnICsgYm9keSArICc7JylcbiAgfSBjYXRjaCAoZSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgXy53YXJuKFxuICAgICAgJ0ludmFsaWQgZXhwcmVzc2lvbi4gJyArXG4gICAgICAnR2VuZXJhdGVkIGZ1bmN0aW9uIGJvZHk6ICcgKyBib2R5XG4gICAgKVxuICB9XG59XG5cbi8qKlxuICogQnVpbGQgYSBzZXR0ZXIgZnVuY3Rpb24uXG4gKlxuICogVGhpcyBpcyBvbmx5IG5lZWRlZCBpbiByYXJlIHNpdHVhdGlvbnMgbGlrZSBcImFbYl1cIiB3aGVyZVxuICogYSBzZXR0YWJsZSBwYXRoIHJlcXVpcmVzIGR5bmFtaWMgZXZhbHVhdGlvbi5cbiAqXG4gKiBUaGlzIHNldHRlciBmdW5jdGlvbiBtYXkgdGhyb3cgZXJyb3Igd2hlbiBjYWxsZWQgaWYgdGhlXG4gKiBleHByZXNzaW9uIGJvZHkgaXMgbm90IGEgdmFsaWQgbGVmdC1oYW5kIGV4cHJlc3Npb24gaW5cbiAqIGFzc2lnbm1lbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGJvZHlcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBtYWtlU2V0dGVyIChib2R5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbignc2NvcGUnLCAndmFsdWUnLCBib2R5ICsgJz12YWx1ZTsnKVxuICB9IGNhdGNoIChlKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBfLndhcm4oXG4gICAgICAnSW52YWxpZCBzZXR0ZXIgZnVuY3Rpb24gYm9keTogJyArIGJvZHlcbiAgICApXG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBmb3Igc2V0dGVyIGV4aXN0ZW5jZSBvbiBhIGNhY2hlIGhpdC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoaXRcbiAqL1xuXG5mdW5jdGlvbiBjaGVja1NldHRlciAoaGl0KSB7XG4gIGlmICghaGl0LnNldCkge1xuICAgIGhpdC5zZXQgPSBtYWtlU2V0dGVyKGhpdC5ib2R5KVxuICB9XG59XG5cbi8qKlxuICogUGFyc2UgYW4gZXhwcmVzc2lvbiBpbnRvIHJlLXdyaXR0ZW4gZ2V0dGVyL3NldHRlcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV4cFxuICogQHBhcmFtIHtCb29sZWFufSBuZWVkU2V0XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKGV4cCwgbmVlZFNldCkge1xuICBleHAgPSBleHAudHJpbSgpXG4gIC8vIHRyeSBjYWNoZVxuICB2YXIgaGl0ID0gZXhwcmVzc2lvbkNhY2hlLmdldChleHApXG4gIGlmIChoaXQpIHtcbiAgICBpZiAobmVlZFNldCkge1xuICAgICAgY2hlY2tTZXR0ZXIoaGl0KVxuICAgIH1cbiAgICByZXR1cm4gaGl0XG4gIH1cbiAgLy8gd2UgZG8gYSBzaW1wbGUgcGF0aCBjaGVjayB0byBvcHRpbWl6ZSBmb3IgdGhlbS5cbiAgLy8gdGhlIGNoZWNrIGZhaWxzIHZhbGlkIHBhdGhzIHdpdGggdW51c2FsIHdoaXRlc3BhY2VzLFxuICAvLyBidXQgdGhhdCdzIHRvbyByYXJlIGFuZCB3ZSBkb24ndCBjYXJlLlxuICAvLyBhbHNvIHNraXAgYm9vbGVhbiBsaXRlcmFscyBhbmQgcGF0aHMgdGhhdCBzdGFydCB3aXRoXG4gIC8vIGdsb2JhbCBcIk1hdGhcIlxuICB2YXIgcmVzID0gZXhwb3J0cy5pc1NpbXBsZVBhdGgoZXhwKVxuICAgID8gY29tcGlsZVBhdGhGbnMoZXhwKVxuICAgIDogY29tcGlsZUV4cEZucyhleHAsIG5lZWRTZXQpXG4gIGV4cHJlc3Npb25DYWNoZS5wdXQoZXhwLCByZXMpXG4gIHJldHVybiByZXNcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBleHByZXNzaW9uIGlzIGEgc2ltcGxlIHBhdGguXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV4cFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5leHBvcnRzLmlzU2ltcGxlUGF0aCA9IGZ1bmN0aW9uIChleHApIHtcbiAgcmV0dXJuIHBhdGhUZXN0UkUudGVzdChleHApICYmXG4gICAgLy8gZG9uJ3QgdHJlYXQgdHJ1ZS9mYWxzZSBhcyBwYXRoc1xuICAgICFib29sZWFuTGl0ZXJhbFJFLnRlc3QoZXhwKSAmJlxuICAgIC8vIE1hdGggY29uc3RhbnRzIGUuZy4gTWF0aC5QSSwgTWF0aC5FIGV0Yy5cbiAgICBleHAuc2xpY2UoMCwgNSkgIT09ICdNYXRoLidcbn1cbiIsInZhciBfID0gcmVxdWlyZSgnLi4vdXRpbCcpXG52YXIgQ2FjaGUgPSByZXF1aXJlKCcuLi9jYWNoZScpXG52YXIgcGF0aENhY2hlID0gbmV3IENhY2hlKDEwMDApXG52YXIgaWRlbnRSRSA9IGV4cG9ydHMuaWRlbnRSRSA9IC9eWyRfYS16QS1aXStbXFx3JF0qJC9cblxuLy8gYWN0aW9uc1xudmFyIEFQUEVORCA9IDBcbnZhciBQVVNIID0gMVxuXG4vLyBzdGF0ZXNcbnZhciBCRUZPUkVfUEFUSCA9IDBcbnZhciBJTl9QQVRIID0gMVxudmFyIEJFRk9SRV9JREVOVCA9IDJcbnZhciBJTl9JREVOVCA9IDNcbnZhciBCRUZPUkVfRUxFTUVOVCA9IDRcbnZhciBBRlRFUl9aRVJPID0gNVxudmFyIElOX0lOREVYID0gNlxudmFyIElOX1NJTkdMRV9RVU9URSA9IDdcbnZhciBJTl9ET1VCTEVfUVVPVEUgPSA4XG52YXIgSU5fU1VCX1BBVEggPSA5XG52YXIgQUZURVJfRUxFTUVOVCA9IDEwXG52YXIgQUZURVJfUEFUSCA9IDExXG52YXIgRVJST1IgPSAxMlxuXG52YXIgcGF0aFN0YXRlTWFjaGluZSA9IFtdXG5cbnBhdGhTdGF0ZU1hY2hpbmVbQkVGT1JFX1BBVEhdID0ge1xuICAnd3MnOiBbQkVGT1JFX1BBVEhdLFxuICAnaWRlbnQnOiBbSU5fSURFTlQsIEFQUEVORF0sXG4gICdbJzogW0JFRk9SRV9FTEVNRU5UXSxcbiAgJ2VvZic6IFtBRlRFUl9QQVRIXVxufVxuXG5wYXRoU3RhdGVNYWNoaW5lW0lOX1BBVEhdID0ge1xuICAnd3MnOiBbSU5fUEFUSF0sXG4gICcuJzogW0JFRk9SRV9JREVOVF0sXG4gICdbJzogW0JFRk9SRV9FTEVNRU5UXSxcbiAgJ2VvZic6IFtBRlRFUl9QQVRIXVxufVxuXG5wYXRoU3RhdGVNYWNoaW5lW0JFRk9SRV9JREVOVF0gPSB7XG4gICd3cyc6IFtCRUZPUkVfSURFTlRdLFxuICAnaWRlbnQnOiBbSU5fSURFTlQsIEFQUEVORF1cbn1cblxucGF0aFN0YXRlTWFjaGluZVtJTl9JREVOVF0gPSB7XG4gICdpZGVudCc6IFtJTl9JREVOVCwgQVBQRU5EXSxcbiAgJzAnOiBbSU5fSURFTlQsIEFQUEVORF0sXG4gICdudW1iZXInOiBbSU5fSURFTlQsIEFQUEVORF0sXG4gICd3cyc6IFtJTl9QQVRILCBQVVNIXSxcbiAgJy4nOiBbQkVGT1JFX0lERU5ULCBQVVNIXSxcbiAgJ1snOiBbQkVGT1JFX0VMRU1FTlQsIFBVU0hdLFxuICAnZW9mJzogW0FGVEVSX1BBVEgsIFBVU0hdXG59XG5cbnBhdGhTdGF0ZU1hY2hpbmVbQkVGT1JFX0VMRU1FTlRdID0ge1xuICAnd3MnOiBbQkVGT1JFX0VMRU1FTlRdLFxuICAnMCc6IFtBRlRFUl9aRVJPLCBBUFBFTkRdLFxuICAnbnVtYmVyJzogW0lOX0lOREVYLCBBUFBFTkRdLFxuICBcIidcIjogW0lOX1NJTkdMRV9RVU9URSwgQVBQRU5ELCAnJ10sXG4gICdcIic6IFtJTl9ET1VCTEVfUVVPVEUsIEFQUEVORCwgJyddLFxuICAnaWRlbnQnOiBbSU5fU1VCX1BBVEgsIEFQUEVORCwgJyonXVxufVxuXG5wYXRoU3RhdGVNYWNoaW5lW0FGVEVSX1pFUk9dID0ge1xuICAnd3MnOiBbQUZURVJfRUxFTUVOVCwgUFVTSF0sXG4gICddJzogW0lOX1BBVEgsIFBVU0hdXG59XG5cbnBhdGhTdGF0ZU1hY2hpbmVbSU5fSU5ERVhdID0ge1xuICAnMCc6IFtJTl9JTkRFWCwgQVBQRU5EXSxcbiAgJ251bWJlcic6IFtJTl9JTkRFWCwgQVBQRU5EXSxcbiAgJ3dzJzogW0FGVEVSX0VMRU1FTlRdLFxuICAnXSc6IFtJTl9QQVRILCBQVVNIXVxufVxuXG5wYXRoU3RhdGVNYWNoaW5lW0lOX1NJTkdMRV9RVU9URV0gPSB7XG4gIFwiJ1wiOiBbQUZURVJfRUxFTUVOVF0sXG4gICdlb2YnOiBFUlJPUixcbiAgJ2Vsc2UnOiBbSU5fU0lOR0xFX1FVT1RFLCBBUFBFTkRdXG59XG5cbnBhdGhTdGF0ZU1hY2hpbmVbSU5fRE9VQkxFX1FVT1RFXSA9IHtcbiAgJ1wiJzogW0FGVEVSX0VMRU1FTlRdLFxuICAnZW9mJzogRVJST1IsXG4gICdlbHNlJzogW0lOX0RPVUJMRV9RVU9URSwgQVBQRU5EXVxufVxuXG5wYXRoU3RhdGVNYWNoaW5lW0lOX1NVQl9QQVRIXSA9IHtcbiAgJ2lkZW50JzogW0lOX1NVQl9QQVRILCBBUFBFTkRdLFxuICAnMCc6IFtJTl9TVUJfUEFUSCwgQVBQRU5EXSxcbiAgJ251bWJlcic6IFtJTl9TVUJfUEFUSCwgQVBQRU5EXSxcbiAgJ3dzJzogW0FGVEVSX0VMRU1FTlRdLFxuICAnXSc6IFtJTl9QQVRILCBQVVNIXVxufVxuXG5wYXRoU3RhdGVNYWNoaW5lW0FGVEVSX0VMRU1FTlRdID0ge1xuICAnd3MnOiBbQUZURVJfRUxFTUVOVF0sXG4gICddJzogW0lOX1BBVEgsIFBVU0hdXG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIHRoZSB0eXBlIG9mIGEgY2hhcmFjdGVyIGluIGEga2V5cGF0aC5cbiAqXG4gKiBAcGFyYW0ge0NoYXJ9IGNoXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHR5cGVcbiAqL1xuXG5mdW5jdGlvbiBnZXRQYXRoQ2hhclR5cGUgKGNoKSB7XG4gIGlmIChjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuICdlb2YnXG4gIH1cblxuICB2YXIgY29kZSA9IGNoLmNoYXJDb2RlQXQoMClcblxuICBzd2l0Y2ggKGNvZGUpIHtcbiAgICBjYXNlIDB4NUI6IC8vIFtcbiAgICBjYXNlIDB4NUQ6IC8vIF1cbiAgICBjYXNlIDB4MkU6IC8vIC5cbiAgICBjYXNlIDB4MjI6IC8vIFwiXG4gICAgY2FzZSAweDI3OiAvLyAnXG4gICAgY2FzZSAweDMwOiAvLyAwXG4gICAgICByZXR1cm4gY2hcblxuICAgIGNhc2UgMHg1RjogLy8gX1xuICAgIGNhc2UgMHgyNDogLy8gJFxuICAgICAgcmV0dXJuICdpZGVudCdcblxuICAgIGNhc2UgMHgyMDogLy8gU3BhY2VcbiAgICBjYXNlIDB4MDk6IC8vIFRhYlxuICAgIGNhc2UgMHgwQTogLy8gTmV3bGluZVxuICAgIGNhc2UgMHgwRDogLy8gUmV0dXJuXG4gICAgY2FzZSAweEEwOiAgLy8gTm8tYnJlYWsgc3BhY2VcbiAgICBjYXNlIDB4RkVGRjogIC8vIEJ5dGUgT3JkZXIgTWFya1xuICAgIGNhc2UgMHgyMDI4OiAgLy8gTGluZSBTZXBhcmF0b3JcbiAgICBjYXNlIDB4MjAyOTogIC8vIFBhcmFncmFwaCBTZXBhcmF0b3JcbiAgICAgIHJldHVybiAnd3MnXG4gIH1cblxuICAvLyBhLXosIEEtWlxuICBpZiAoXG4gICAgKGNvZGUgPj0gMHg2MSAmJiBjb2RlIDw9IDB4N0EpIHx8XG4gICAgKGNvZGUgPj0gMHg0MSAmJiBjb2RlIDw9IDB4NUEpXG4gICkge1xuICAgIHJldHVybiAnaWRlbnQnXG4gIH1cblxuICAvLyAxLTlcbiAgaWYgKGNvZGUgPj0gMHgzMSAmJiBjb2RlIDw9IDB4MzkpIHtcbiAgICByZXR1cm4gJ251bWJlcidcbiAgfVxuXG4gIHJldHVybiAnZWxzZSdcbn1cblxuLyoqXG4gKiBQYXJzZSBhIHN0cmluZyBwYXRoIGludG8gYW4gYXJyYXkgb2Ygc2VnbWVudHNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybiB7QXJyYXl8dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICB2YXIga2V5cyA9IFtdXG4gIHZhciBpbmRleCA9IC0xXG4gIHZhciBtb2RlID0gQkVGT1JFX1BBVEhcbiAgdmFyIGMsIG5ld0NoYXIsIGtleSwgdHlwZSwgdHJhbnNpdGlvbiwgYWN0aW9uLCB0eXBlTWFwXG5cbiAgdmFyIGFjdGlvbnMgPSBbXVxuICBhY3Rpb25zW1BVU0hdID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGtleXMucHVzaChrZXkpXG4gICAga2V5ID0gdW5kZWZpbmVkXG4gIH1cbiAgYWN0aW9uc1tBUFBFTkRdID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAga2V5ID0gbmV3Q2hhclxuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgKz0gbmV3Q2hhclxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1heWJlVW5lc2NhcGVRdW90ZSAoKSB7XG4gICAgdmFyIG5leHRDaGFyID0gcGF0aFtpbmRleCArIDFdXG4gICAgaWYgKChtb2RlID09PSBJTl9TSU5HTEVfUVVPVEUgJiYgbmV4dENoYXIgPT09IFwiJ1wiKSB8fFxuICAgICAgICAobW9kZSA9PT0gSU5fRE9VQkxFX1FVT1RFICYmIG5leHRDaGFyID09PSAnXCInKSkge1xuICAgICAgaW5kZXgrK1xuICAgICAgbmV3Q2hhciA9IG5leHRDaGFyXG4gICAgICBhY3Rpb25zW0FQUEVORF0oKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICB3aGlsZSAobW9kZSAhPSBudWxsKSB7XG4gICAgaW5kZXgrK1xuICAgIGMgPSBwYXRoW2luZGV4XVxuXG4gICAgaWYgKGMgPT09ICdcXFxcJyAmJiBtYXliZVVuZXNjYXBlUXVvdGUoKSkge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICB0eXBlID0gZ2V0UGF0aENoYXJUeXBlKGMpXG4gICAgdHlwZU1hcCA9IHBhdGhTdGF0ZU1hY2hpbmVbbW9kZV1cbiAgICB0cmFuc2l0aW9uID0gdHlwZU1hcFt0eXBlXSB8fCB0eXBlTWFwWydlbHNlJ10gfHwgRVJST1JcblxuICAgIGlmICh0cmFuc2l0aW9uID09PSBFUlJPUikge1xuICAgICAgcmV0dXJuIC8vIHBhcnNlIGVycm9yXG4gICAgfVxuXG4gICAgbW9kZSA9IHRyYW5zaXRpb25bMF1cbiAgICBhY3Rpb24gPSBhY3Rpb25zW3RyYW5zaXRpb25bMV1dXG4gICAgaWYgKGFjdGlvbikge1xuICAgICAgbmV3Q2hhciA9IHRyYW5zaXRpb25bMl1cbiAgICAgIG5ld0NoYXIgPSBuZXdDaGFyID09PSB1bmRlZmluZWRcbiAgICAgICAgPyBjXG4gICAgICAgIDogbmV3Q2hhciA9PT0gJyonXG4gICAgICAgICAgPyBuZXdDaGFyICsgY1xuICAgICAgICAgIDogbmV3Q2hhclxuICAgICAgYWN0aW9uKClcbiAgICB9XG5cbiAgICBpZiAobW9kZSA9PT0gQUZURVJfUEFUSCkge1xuICAgICAga2V5cy5yYXcgPSBwYXRoXG4gICAgICByZXR1cm4ga2V5c1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEZvcm1hdCBhIGFjY2Vzc29yIHNlZ21lbnQgYmFzZWQgb24gaXRzIHR5cGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBY2Nlc3NvciAoa2V5KSB7XG4gIGlmIChpZGVudFJFLnRlc3Qoa2V5KSkgeyAvLyBpZGVudGlmaWVyXG4gICAgcmV0dXJuICcuJyArIGtleVxuICB9IGVsc2UgaWYgKCtrZXkgPT09IGtleSA+Pj4gMCkgeyAvLyBicmFja2V0IGluZGV4XG4gICAgcmV0dXJuICdbJyArIGtleSArICddJ1xuICB9IGVsc2UgaWYgKGtleS5jaGFyQXQoMCkgPT09ICcqJykge1xuICAgIHJldHVybiAnW28nICsgZm9ybWF0QWNjZXNzb3Ioa2V5LnNsaWNlKDEpKSArICddJ1xuICB9IGVsc2UgeyAvLyBicmFja2V0IHN0cmluZ1xuICAgIHJldHVybiAnW1wiJyArIGtleS5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykgKyAnXCJdJ1xuICB9XG59XG5cbi8qKlxuICogQ29tcGlsZXMgYSBnZXR0ZXIgZnVuY3Rpb24gd2l0aCBhIGZpeGVkIHBhdGguXG4gKiBUaGUgZml4ZWQgcGF0aCBnZXR0ZXIgc3VwcmVzc2VzIGVycm9ycy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYXRoXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5leHBvcnRzLmNvbXBpbGVHZXR0ZXIgPSBmdW5jdGlvbiAocGF0aCkge1xuICB2YXIgYm9keSA9ICdyZXR1cm4gbycgKyBwYXRoLm1hcChmb3JtYXRBY2Nlc3Nvcikuam9pbignJylcbiAgcmV0dXJuIG5ldyBGdW5jdGlvbignbycsIGJvZHkpXG59XG5cbi8qKlxuICogRXh0ZXJuYWwgcGFyc2UgdGhhdCBjaGVjayBmb3IgYSBjYWNoZSBoaXQgZmlyc3RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybiB7QXJyYXl8dW5kZWZpbmVkfVxuICovXG5cbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAocGF0aCkge1xuICB2YXIgaGl0ID0gcGF0aENhY2hlLmdldChwYXRoKVxuICBpZiAoIWhpdCkge1xuICAgIGhpdCA9IHBhcnNlUGF0aChwYXRoKVxuICAgIGlmIChoaXQpIHtcbiAgICAgIGhpdC5nZXQgPSBleHBvcnRzLmNvbXBpbGVHZXR0ZXIoaGl0KVxuICAgICAgcGF0aENhY2hlLnB1dChwYXRoLCBoaXQpXG4gICAgfVxuICB9XG4gIHJldHVybiBoaXRcbn1cblxuLyoqXG4gKiBHZXQgZnJvbSBhbiBvYmplY3QgZnJvbSBhIHBhdGggc3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqL1xuXG5leHBvcnRzLmdldCA9IGZ1bmN0aW9uIChvYmosIHBhdGgpIHtcbiAgcGF0aCA9IGV4cG9ydHMucGFyc2UocGF0aClcbiAgaWYgKHBhdGgpIHtcbiAgICByZXR1cm4gcGF0aC5nZXQob2JqKVxuICB9XG59XG5cbi8qKlxuICogV2FybiBhZ2FpbnN0IHNldHRpbmcgbm9uLWV4aXN0ZW50IHJvb3QgcGF0aCBvbiBhIHZtLlxuICovXG5cbnZhciB3YXJuTm9uRXhpc3RlbnRcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHdhcm5Ob25FeGlzdGVudCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgXy53YXJuKFxuICAgICAgJ1lvdSBhcmUgc2V0dGluZyBhIG5vbi1leGlzdGVudCBwYXRoIFwiJyArIHBhdGgucmF3ICsgJ1wiICcgK1xuICAgICAgJ29uIGEgdm0gaW5zdGFuY2UuIENvbnNpZGVyIHByZS1pbml0aWFsaXppbmcgdGhlIHByb3BlcnR5ICcgK1xuICAgICAgJ3dpdGggdGhlIFwiZGF0YVwiIG9wdGlvbiBmb3IgbW9yZSByZWxpYWJsZSByZWFjdGl2aXR5ICcgK1xuICAgICAgJ2FuZCBiZXR0ZXIgcGVyZm9ybWFuY2UuJ1xuICAgIClcbiAgfVxufVxuXG4vKipcbiAqIFNldCBvbiBhbiBvYmplY3QgZnJvbSBhIHBhdGhcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZyB8IEFycmF5fSBwYXRoXG4gKiBAcGFyYW0geyp9IHZhbFxuICovXG5cbmV4cG9ydHMuc2V0ID0gZnVuY3Rpb24gKG9iaiwgcGF0aCwgdmFsKSB7XG4gIHZhciBvcmlnaW5hbCA9IG9ialxuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgcGF0aCA9IGV4cG9ydHMucGFyc2UocGF0aClcbiAgfVxuICBpZiAoIXBhdGggfHwgIV8uaXNPYmplY3Qob2JqKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHZhciBsYXN0LCBrZXlcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXRoLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGxhc3QgPSBvYmpcbiAgICBrZXkgPSBwYXRoW2ldXG4gICAgaWYgKGtleS5jaGFyQXQoMCkgPT09ICcqJykge1xuICAgICAga2V5ID0gb3JpZ2luYWxba2V5LnNsaWNlKDEpXVxuICAgIH1cbiAgICBpZiAoaSA8IGwgLSAxKSB7XG4gICAgICBvYmogPSBvYmpba2V5XVxuICAgICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHtcbiAgICAgICAgb2JqID0ge31cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgbGFzdC5faXNWdWUpIHtcbiAgICAgICAgICB3YXJuTm9uRXhpc3RlbnQocGF0aClcbiAgICAgICAgfVxuICAgICAgICBfLnNldChsYXN0LCBrZXksIG9iailcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKF8uaXNBcnJheShvYmopKSB7XG4gICAgICAgIG9iai4kc2V0KGtleSwgdmFsKVxuICAgICAgfSBlbHNlIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBvYmouX2lzVnVlKSB7XG4gICAgICAgICAgd2Fybk5vbkV4aXN0ZW50KHBhdGgpXG4gICAgICAgIH1cbiAgICAgICAgXy5zZXQob2JqLCBrZXksIHZhbClcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cbiIsInZhciBfID0gcmVxdWlyZSgnLi4vdXRpbCcpXG52YXIgQ2FjaGUgPSByZXF1aXJlKCcuLi9jYWNoZScpXG52YXIgdGVtcGxhdGVDYWNoZSA9IG5ldyBDYWNoZSgxMDAwKVxudmFyIGlkU2VsZWN0b3JDYWNoZSA9IG5ldyBDYWNoZSgxMDAwKVxuXG52YXIgbWFwID0ge1xuICBfZGVmYXVsdDogWzAsICcnLCAnJ10sXG4gIGxlZ2VuZDogWzEsICc8ZmllbGRzZXQ+JywgJzwvZmllbGRzZXQ+J10sXG4gIHRyOiBbMiwgJzx0YWJsZT48dGJvZHk+JywgJzwvdGJvZHk+PC90YWJsZT4nXSxcbiAgY29sOiBbXG4gICAgMixcbiAgICAnPHRhYmxlPjx0Ym9keT48L3Rib2R5Pjxjb2xncm91cD4nLFxuICAgICc8L2NvbGdyb3VwPjwvdGFibGU+J1xuICBdXG59XG5cbm1hcC50ZCA9XG5tYXAudGggPSBbXG4gIDMsXG4gICc8dGFibGU+PHRib2R5Pjx0cj4nLFxuICAnPC90cj48L3Rib2R5PjwvdGFibGU+J1xuXVxuXG5tYXAub3B0aW9uID1cbm1hcC5vcHRncm91cCA9IFtcbiAgMSxcbiAgJzxzZWxlY3QgbXVsdGlwbGU9XCJtdWx0aXBsZVwiPicsXG4gICc8L3NlbGVjdD4nXG5dXG5cbm1hcC50aGVhZCA9XG5tYXAudGJvZHkgPVxubWFwLmNvbGdyb3VwID1cbm1hcC5jYXB0aW9uID1cbm1hcC50Zm9vdCA9IFsxLCAnPHRhYmxlPicsICc8L3RhYmxlPiddXG5cbm1hcC5nID1cbm1hcC5kZWZzID1cbm1hcC5zeW1ib2wgPVxubWFwLnVzZSA9XG5tYXAuaW1hZ2UgPVxubWFwLnRleHQgPVxubWFwLmNpcmNsZSA9XG5tYXAuZWxsaXBzZSA9XG5tYXAubGluZSA9XG5tYXAucGF0aCA9XG5tYXAucG9seWdvbiA9XG5tYXAucG9seWxpbmUgPVxubWFwLnJlY3QgPSBbXG4gIDEsXG4gICc8c3ZnICcgK1xuICAgICd4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgJyArXG4gICAgJ3htbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiICcgK1xuICAgICd4bWxuczpldj1cImh0dHA6Ly93d3cudzMub3JnLzIwMDEveG1sLWV2ZW50c1wiJyArXG4gICAgJ3ZlcnNpb249XCIxLjFcIj4nLFxuICAnPC9zdmc+J1xuXVxuXG4vKipcbiAqIENoZWNrIGlmIGEgbm9kZSBpcyBhIHN1cHBvcnRlZCB0ZW1wbGF0ZSBub2RlIHdpdGggYVxuICogRG9jdW1lbnRGcmFnbWVudCBjb250ZW50LlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBpc1JlYWxUZW1wbGF0ZSAobm9kZSkge1xuICByZXR1cm4gXy5pc1RlbXBsYXRlKG5vZGUpICYmXG4gICAgbm9kZS5jb250ZW50IGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudFxufVxuXG52YXIgdGFnUkUgPSAvPChbXFx3Ol0rKS9cbnZhciBlbnRpdHlSRSA9IC8mXFx3Kzt8JiNcXGQrO3wmI3hbXFxkQS1GXSs7L1xuXG4vKipcbiAqIENvbnZlcnQgYSBzdHJpbmcgdGVtcGxhdGUgdG8gYSBEb2N1bWVudEZyYWdtZW50LlxuICogRGV0ZXJtaW5lcyBjb3JyZWN0IHdyYXBwaW5nIGJ5IHRhZyB0eXBlcy4gV3JhcHBpbmdcbiAqIHN0cmF0ZWd5IGZvdW5kIGluIGpRdWVyeSAmIGNvbXBvbmVudC9kb21pZnkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRlbXBsYXRlU3RyaW5nXG4gKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fVxuICovXG5cbmZ1bmN0aW9uIHN0cmluZ1RvRnJhZ21lbnQgKHRlbXBsYXRlU3RyaW5nKSB7XG4gIC8vIHRyeSBhIGNhY2hlIGhpdCBmaXJzdFxuICB2YXIgaGl0ID0gdGVtcGxhdGVDYWNoZS5nZXQodGVtcGxhdGVTdHJpbmcpXG4gIGlmIChoaXQpIHtcbiAgICByZXR1cm4gaGl0XG4gIH1cblxuICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuICB2YXIgdGFnTWF0Y2ggPSB0ZW1wbGF0ZVN0cmluZy5tYXRjaCh0YWdSRSlcbiAgdmFyIGVudGl0eU1hdGNoID0gZW50aXR5UkUudGVzdCh0ZW1wbGF0ZVN0cmluZylcblxuICBpZiAoIXRhZ01hdGNoICYmICFlbnRpdHlNYXRjaCkge1xuICAgIC8vIHRleHQgb25seSwgcmV0dXJuIGEgc2luZ2xlIHRleHQgbm9kZS5cbiAgICBmcmFnLmFwcGVuZENoaWxkKFxuICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGVtcGxhdGVTdHJpbmcpXG4gICAgKVxuICB9IGVsc2Uge1xuXG4gICAgdmFyIHRhZyA9IHRhZ01hdGNoICYmIHRhZ01hdGNoWzFdXG4gICAgdmFyIHdyYXAgPSBtYXBbdGFnXSB8fCBtYXAuX2RlZmF1bHRcbiAgICB2YXIgZGVwdGggPSB3cmFwWzBdXG4gICAgdmFyIHByZWZpeCA9IHdyYXBbMV1cbiAgICB2YXIgc3VmZml4ID0gd3JhcFsyXVxuICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcblxuICAgIG5vZGUuaW5uZXJIVE1MID0gcHJlZml4ICsgdGVtcGxhdGVTdHJpbmcudHJpbSgpICsgc3VmZml4XG4gICAgd2hpbGUgKGRlcHRoLS0pIHtcbiAgICAgIG5vZGUgPSBub2RlLmxhc3RDaGlsZFxuICAgIH1cblxuICAgIHZhciBjaGlsZFxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG4gICAgd2hpbGUgKGNoaWxkID0gbm9kZS5maXJzdENoaWxkKSB7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICAgICAgZnJhZy5hcHBlbmRDaGlsZChjaGlsZClcbiAgICB9XG4gIH1cblxuICB0ZW1wbGF0ZUNhY2hlLnB1dCh0ZW1wbGF0ZVN0cmluZywgZnJhZylcbiAgcmV0dXJuIGZyYWdcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgdGVtcGxhdGUgbm9kZSB0byBhIERvY3VtZW50RnJhZ21lbnQuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fVxuICovXG5cbmZ1bmN0aW9uIG5vZGVUb0ZyYWdtZW50IChub2RlKSB7XG4gIC8vIGlmIGl0cyBhIHRlbXBsYXRlIHRhZyBhbmQgdGhlIGJyb3dzZXIgc3VwcG9ydHMgaXQsXG4gIC8vIGl0cyBjb250ZW50IGlzIGFscmVhZHkgYSBkb2N1bWVudCBmcmFnbWVudC5cbiAgaWYgKGlzUmVhbFRlbXBsYXRlKG5vZGUpKSB7XG4gICAgXy50cmltTm9kZShub2RlLmNvbnRlbnQpXG4gICAgcmV0dXJuIG5vZGUuY29udGVudFxuICB9XG4gIC8vIHNjcmlwdCB0ZW1wbGF0ZVxuICBpZiAobm9kZS50YWdOYW1lID09PSAnU0NSSVBUJykge1xuICAgIHJldHVybiBzdHJpbmdUb0ZyYWdtZW50KG5vZGUudGV4dENvbnRlbnQpXG4gIH1cbiAgLy8gbm9ybWFsIG5vZGUsIGNsb25lIGl0IHRvIGF2b2lkIG11dGF0aW5nIHRoZSBvcmlnaW5hbFxuICB2YXIgY2xvbmUgPSBleHBvcnRzLmNsb25lKG5vZGUpXG4gIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG4gIHZhciBjaGlsZFxuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICB3aGlsZSAoY2hpbGQgPSBjbG9uZS5maXJzdENoaWxkKSB7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgICBmcmFnLmFwcGVuZENoaWxkKGNoaWxkKVxuICB9XG4gIF8udHJpbU5vZGUoZnJhZylcbiAgcmV0dXJuIGZyYWdcbn1cblxuLy8gVGVzdCBmb3IgdGhlIHByZXNlbmNlIG9mIHRoZSBTYWZhcmkgdGVtcGxhdGUgY2xvbmluZyBidWdcbi8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzc3NTVcbnZhciBoYXNCcm9rZW5UZW1wbGF0ZSA9IChmdW5jdGlvbiAoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChfLmluQnJvd3Nlcikge1xuICAgIHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICBhLmlubmVySFRNTCA9ICc8dGVtcGxhdGU+MTwvdGVtcGxhdGU+J1xuICAgIHJldHVybiAhYS5jbG9uZU5vZGUodHJ1ZSkuZmlyc3RDaGlsZC5pbm5lckhUTUxcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufSkoKVxuXG4vLyBUZXN0IGZvciBJRTEwLzExIHRleHRhcmVhIHBsYWNlaG9sZGVyIGNsb25lIGJ1Z1xudmFyIGhhc1RleHRhcmVhQ2xvbmVCdWcgPSAoZnVuY3Rpb24gKCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoXy5pbkJyb3dzZXIpIHtcbiAgICB2YXIgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJylcbiAgICB0LnBsYWNlaG9sZGVyID0gJ3QnXG4gICAgcmV0dXJuIHQuY2xvbmVOb2RlKHRydWUpLnZhbHVlID09PSAndCdcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufSkoKVxuXG4vKipcbiAqIDEuIERlYWwgd2l0aCBTYWZhcmkgY2xvbmluZyBuZXN0ZWQgPHRlbXBsYXRlPiBidWcgYnlcbiAqICAgIG1hbnVhbGx5IGNsb25pbmcgYWxsIHRlbXBsYXRlIGluc3RhbmNlcy5cbiAqIDIuIERlYWwgd2l0aCBJRTEwLzExIHRleHRhcmVhIHBsYWNlaG9sZGVyIGJ1ZyBieSBzZXR0aW5nXG4gKiAgICB0aGUgY29ycmVjdCB2YWx1ZSBhZnRlciBjbG9uaW5nLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fSBub2RlXG4gKiBAcmV0dXJuIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9XG4gKi9cblxuZXhwb3J0cy5jbG9uZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmICghbm9kZS5xdWVyeVNlbGVjdG9yQWxsKSB7XG4gICAgcmV0dXJuIG5vZGUuY2xvbmVOb2RlKClcbiAgfVxuICB2YXIgcmVzID0gbm9kZS5jbG9uZU5vZGUodHJ1ZSlcbiAgdmFyIGksIG9yaWdpbmFsLCBjbG9uZWRcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChoYXNCcm9rZW5UZW1wbGF0ZSkge1xuICAgIHZhciBjbG9uZSA9IHJlc1xuICAgIGlmIChpc1JlYWxUZW1wbGF0ZShub2RlKSkge1xuICAgICAgbm9kZSA9IG5vZGUuY29udGVudFxuICAgICAgY2xvbmUgPSByZXMuY29udGVudFxuICAgIH1cbiAgICBvcmlnaW5hbCA9IG5vZGUucXVlcnlTZWxlY3RvckFsbCgndGVtcGxhdGUnKVxuICAgIGlmIChvcmlnaW5hbC5sZW5ndGgpIHtcbiAgICAgIGNsb25lZCA9IGNsb25lLnF1ZXJ5U2VsZWN0b3JBbGwoJ3RlbXBsYXRlJylcbiAgICAgIGkgPSBjbG9uZWQubGVuZ3RoXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGNsb25lZFtpXS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChcbiAgICAgICAgICBleHBvcnRzLmNsb25lKG9yaWdpbmFsW2ldKSxcbiAgICAgICAgICBjbG9uZWRbaV1cbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGhhc1RleHRhcmVhQ2xvbmVCdWcpIHtcbiAgICBpZiAobm9kZS50YWdOYW1lID09PSAnVEVYVEFSRUEnKSB7XG4gICAgICByZXMudmFsdWUgPSBub2RlLnZhbHVlXG4gICAgfSBlbHNlIHtcbiAgICAgIG9yaWdpbmFsID0gbm9kZS5xdWVyeVNlbGVjdG9yQWxsKCd0ZXh0YXJlYScpXG4gICAgICBpZiAob3JpZ2luYWwubGVuZ3RoKSB7XG4gICAgICAgIGNsb25lZCA9IHJlcy5xdWVyeVNlbGVjdG9yQWxsKCd0ZXh0YXJlYScpXG4gICAgICAgIGkgPSBjbG9uZWQubGVuZ3RoXG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICBjbG9uZWRbaV0udmFsdWUgPSBvcmlnaW5hbFtpXS52YWx1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyoqXG4gKiBQcm9jZXNzIHRoZSB0ZW1wbGF0ZSBvcHRpb24gYW5kIG5vcm1hbGl6ZXMgaXQgaW50byBhXG4gKiBhIERvY3VtZW50RnJhZ21lbnQgdGhhdCBjYW4gYmUgdXNlZCBhcyBhIHBhcnRpYWwgb3IgYVxuICogaW5zdGFuY2UgdGVtcGxhdGUuXG4gKlxuICogQHBhcmFtIHsqfSB0ZW1wbGF0ZVxuICogICAgUG9zc2libGUgdmFsdWVzIGluY2x1ZGU6XG4gKiAgICAtIERvY3VtZW50RnJhZ21lbnQgb2JqZWN0XG4gKiAgICAtIE5vZGUgb2JqZWN0IG9mIHR5cGUgVGVtcGxhdGVcbiAqICAgIC0gaWQgc2VsZWN0b3I6ICcjc29tZS10ZW1wbGF0ZS1pZCdcbiAqICAgIC0gdGVtcGxhdGUgc3RyaW5nOiAnPGRpdj48c3Bhbj57e21zZ319PC9zcGFuPjwvZGl2PidcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY2xvbmVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gbm9TZWxlY3RvclxuICogQHJldHVybiB7RG9jdW1lbnRGcmFnbWVudHx1bmRlZmluZWR9XG4gKi9cblxuZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSwgY2xvbmUsIG5vU2VsZWN0b3IpIHtcbiAgdmFyIG5vZGUsIGZyYWdcblxuICAvLyBpZiB0aGUgdGVtcGxhdGUgaXMgYWxyZWFkeSBhIGRvY3VtZW50IGZyYWdtZW50LFxuICAvLyBkbyBub3RoaW5nXG4gIGlmICh0ZW1wbGF0ZSBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICBfLnRyaW1Ob2RlKHRlbXBsYXRlKVxuICAgIHJldHVybiBjbG9uZVxuICAgICAgPyBleHBvcnRzLmNsb25lKHRlbXBsYXRlKVxuICAgICAgOiB0ZW1wbGF0ZVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBpZCBzZWxlY3RvclxuICAgIGlmICghbm9TZWxlY3RvciAmJiB0ZW1wbGF0ZS5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgLy8gaWQgc2VsZWN0b3IgY2FuIGJlIGNhY2hlZCB0b29cbiAgICAgIGZyYWcgPSBpZFNlbGVjdG9yQ2FjaGUuZ2V0KHRlbXBsYXRlKVxuICAgICAgaWYgKCFmcmFnKSB7XG4gICAgICAgIG5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0ZW1wbGF0ZS5zbGljZSgxKSlcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICBmcmFnID0gbm9kZVRvRnJhZ21lbnQobm9kZSlcbiAgICAgICAgICAvLyBzYXZlIHNlbGVjdG9yIHRvIGNhY2hlXG4gICAgICAgICAgaWRTZWxlY3RvckNhY2hlLnB1dCh0ZW1wbGF0ZSwgZnJhZylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBub3JtYWwgc3RyaW5nIHRlbXBsYXRlXG4gICAgICBmcmFnID0gc3RyaW5nVG9GcmFnbWVudCh0ZW1wbGF0ZSlcbiAgICB9XG4gIH0gZWxzZSBpZiAodGVtcGxhdGUubm9kZVR5cGUpIHtcbiAgICAvLyBhIGRpcmVjdCBub2RlXG4gICAgZnJhZyA9IG5vZGVUb0ZyYWdtZW50KHRlbXBsYXRlKVxuICB9XG5cbiAgcmV0dXJuIGZyYWcgJiYgY2xvbmVcbiAgICA/IGV4cG9ydHMuY2xvbmUoZnJhZylcbiAgICA6IGZyYWdcbn1cbiIsInZhciBDYWNoZSA9IHJlcXVpcmUoJy4uL2NhY2hlJylcbnZhciBjb25maWcgPSByZXF1aXJlKCcuLi9jb25maWcnKVxudmFyIGRpclBhcnNlciA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlJylcbnZhciByZWdleEVzY2FwZVJFID0gL1stLiorP14ke30oKXxbXFxdXFwvXFxcXF0vZ1xudmFyIGNhY2hlLCB0YWdSRSwgaHRtbFJFXG5cbi8qKlxuICogRXNjYXBlIGEgc3RyaW5nIHNvIGl0IGNhbiBiZSB1c2VkIGluIGEgUmVnRXhwXG4gKiBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlUmVnZXggKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpXG59XG5cbmV4cG9ydHMuY29tcGlsZVJlZ2V4ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3BlbiA9IGVzY2FwZVJlZ2V4KGNvbmZpZy5kZWxpbWl0ZXJzWzBdKVxuICB2YXIgY2xvc2UgPSBlc2NhcGVSZWdleChjb25maWcuZGVsaW1pdGVyc1sxXSlcbiAgdmFyIHVuc2FmZU9wZW4gPSBlc2NhcGVSZWdleChjb25maWcudW5zYWZlRGVsaW1pdGVyc1swXSlcbiAgdmFyIHVuc2FmZUNsb3NlID0gZXNjYXBlUmVnZXgoY29uZmlnLnVuc2FmZURlbGltaXRlcnNbMV0pXG4gIHRhZ1JFID0gbmV3IFJlZ0V4cChcbiAgICB1bnNhZmVPcGVuICsgJyguKz8pJyArIHVuc2FmZUNsb3NlICsgJ3wnICtcbiAgICBvcGVuICsgJyguKz8pJyArIGNsb3NlLFxuICAgICdnJ1xuICApXG4gIGh0bWxSRSA9IG5ldyBSZWdFeHAoXG4gICAgJ14nICsgdW5zYWZlT3BlbiArICcuKicgKyB1bnNhZmVDbG9zZSArICckJ1xuICApXG4gIC8vIHJlc2V0IGNhY2hlXG4gIGNhY2hlID0gbmV3IENhY2hlKDEwMDApXG59XG5cbi8qKlxuICogUGFyc2UgYSB0ZW1wbGF0ZSB0ZXh0IHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIHRva2Vucy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICogQHJldHVybiB7QXJyYXk8T2JqZWN0PiB8IG51bGx9XG4gKiAgICAgICAgICAgICAgIC0ge1N0cmluZ30gdHlwZVxuICogICAgICAgICAgICAgICAtIHtTdHJpbmd9IHZhbHVlXG4gKiAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IFtodG1sXVxuICogICAgICAgICAgICAgICAtIHtCb29sZWFufSBbb25lVGltZV1cbiAqL1xuXG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgaWYgKCFjYWNoZSkge1xuICAgIGV4cG9ydHMuY29tcGlsZVJlZ2V4KClcbiAgfVxuICB2YXIgaGl0ID0gY2FjaGUuZ2V0KHRleHQpXG4gIGlmIChoaXQpIHtcbiAgICByZXR1cm4gaGl0XG4gIH1cbiAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxuL2csICcnKVxuICBpZiAoIXRhZ1JFLnRlc3QodGV4dCkpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIHZhciB0b2tlbnMgPSBbXVxuICB2YXIgbGFzdEluZGV4ID0gdGFnUkUubGFzdEluZGV4ID0gMFxuICB2YXIgbWF0Y2gsIGluZGV4LCBodG1sLCB2YWx1ZSwgZmlyc3QsIG9uZVRpbWVcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgd2hpbGUgKG1hdGNoID0gdGFnUkUuZXhlYyh0ZXh0KSkge1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG4gICAgaW5kZXggPSBtYXRjaC5pbmRleFxuICAgIC8vIHB1c2ggdGV4dCB0b2tlblxuICAgIGlmIChpbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB2YWx1ZTogdGV4dC5zbGljZShsYXN0SW5kZXgsIGluZGV4KVxuICAgICAgfSlcbiAgICB9XG4gICAgLy8gdGFnIHRva2VuXG4gICAgaHRtbCA9IGh0bWxSRS50ZXN0KG1hdGNoWzBdKVxuICAgIHZhbHVlID0gaHRtbCA/IG1hdGNoWzFdIDogbWF0Y2hbMl1cbiAgICBmaXJzdCA9IHZhbHVlLmNoYXJDb2RlQXQoMClcbiAgICBvbmVUaW1lID0gZmlyc3QgPT09IDQyIC8vICpcbiAgICB2YWx1ZSA9IG9uZVRpbWVcbiAgICAgID8gdmFsdWUuc2xpY2UoMSlcbiAgICAgIDogdmFsdWVcbiAgICB0b2tlbnMucHVzaCh7XG4gICAgICB0YWc6IHRydWUsXG4gICAgICB2YWx1ZTogdmFsdWUudHJpbSgpLFxuICAgICAgaHRtbDogaHRtbCxcbiAgICAgIG9uZVRpbWU6IG9uZVRpbWVcbiAgICB9KVxuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoXG4gIH1cbiAgaWYgKGxhc3RJbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgdG9rZW5zLnB1c2goe1xuICAgICAgdmFsdWU6IHRleHQuc2xpY2UobGFzdEluZGV4KVxuICAgIH0pXG4gIH1cbiAgY2FjaGUucHV0KHRleHQsIHRva2VucylcbiAgcmV0dXJuIHRva2Vuc1xufVxuXG4vKipcbiAqIEZvcm1hdCBhIGxpc3Qgb2YgdG9rZW5zIGludG8gYW4gZXhwcmVzc2lvbi5cbiAqIGUuZy4gdG9rZW5zIHBhcnNlZCBmcm9tICdhIHt7Yn19IGMnIGNhbiBiZSBzZXJpYWxpemVkXG4gKiBpbnRvIG9uZSBzaW5nbGUgZXhwcmVzc2lvbiBhcyAnXCJhIFwiICsgYiArIFwiIGNcIicuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gdG9rZW5zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZXhwb3J0cy50b2tlbnNUb0V4cCA9IGZ1bmN0aW9uICh0b2tlbnMpIHtcbiAgaWYgKHRva2Vucy5sZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuIHRva2Vucy5tYXAoZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICByZXR1cm4gZm9ybWF0VG9rZW4odG9rZW4pXG4gICAgfSkuam9pbignKycpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZvcm1hdFRva2VuKHRva2Vuc1swXSwgdHJ1ZSlcbiAgfVxufVxuXG4vKipcbiAqIEZvcm1hdCBhIHNpbmdsZSB0b2tlbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdG9rZW5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc2luZ2xlXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0VG9rZW4gKHRva2VuLCBzaW5nbGUpIHtcbiAgcmV0dXJuIHRva2VuLnRhZ1xuICAgID8gaW5saW5lRmlsdGVycyh0b2tlbi52YWx1ZSwgc2luZ2xlKVxuICAgIDogJ1wiJyArIHRva2VuLnZhbHVlICsgJ1wiJ1xufVxuXG4vKipcbiAqIEZvciBhbiBhdHRyaWJ1dGUgd2l0aCBtdWx0aXBsZSBpbnRlcnBvbGF0aW9uIHRhZ3MsXG4gKiBlLmcuIGF0dHI9XCJzb21lLXt7dGhpbmcgfCBmaWx0ZXJ9fVwiLCBpbiBvcmRlciB0byBjb21iaW5lXG4gKiB0aGUgd2hvbGUgdGhpbmcgaW50byBhIHNpbmdsZSB3YXRjaGFibGUgZXhwcmVzc2lvbiwgd2VcbiAqIGhhdmUgdG8gaW5saW5lIHRob3NlIGZpbHRlcnMuIFRoaXMgZnVuY3Rpb24gZG9lcyBleGFjdGx5XG4gKiB0aGF0LiBUaGlzIGlzIGEgYml0IGhhY2t5IGJ1dCBpdCBhdm9pZHMgaGVhdnkgY2hhbmdlc1xuICogdG8gZGlyZWN0aXZlIHBhcnNlciBhbmQgd2F0Y2hlciBtZWNoYW5pc20uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV4cFxuICogQHBhcmFtIHtCb29sZWFufSBzaW5nbGVcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG52YXIgZmlsdGVyUkUgPSAvW158XVxcfFtefF0vXG5mdW5jdGlvbiBpbmxpbmVGaWx0ZXJzIChleHAsIHNpbmdsZSkge1xuICBpZiAoIWZpbHRlclJFLnRlc3QoZXhwKSkge1xuICAgIHJldHVybiBzaW5nbGVcbiAgICAgID8gZXhwXG4gICAgICA6ICcoJyArIGV4cCArICcpJ1xuICB9IGVsc2Uge1xuICAgIHZhciBkaXIgPSBkaXJQYXJzZXIucGFyc2UoZXhwKVxuICAgIGlmICghZGlyLmZpbHRlcnMpIHtcbiAgICAgIHJldHVybiAnKCcgKyBleHAgKyAnKSdcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICd0aGlzLl9hcHBseUZpbHRlcnMoJyArXG4gICAgICAgIGRpci5leHByZXNzaW9uICsgLy8gdmFsdWVcbiAgICAgICAgJyxudWxsLCcgKyAgICAgICAvLyBvbGRWYWx1ZSAobnVsbCBmb3IgcmVhZClcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkoZGlyLmZpbHRlcnMpICsgLy8gZmlsdGVyIGRlc2NyaXB0b3JzXG4gICAgICAgICcsZmFsc2UpJyAgICAgICAgLy8gd3JpdGU/XG4gICAgfVxuICB9XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWwnKVxuXG4vKipcbiAqIEFwcGVuZCB3aXRoIHRyYW5zaXRpb24uXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICovXG5cbmV4cG9ydHMuYXBwZW5kID0gZnVuY3Rpb24gKGVsLCB0YXJnZXQsIHZtLCBjYikge1xuICBhcHBseShlbCwgMSwgZnVuY3Rpb24gKCkge1xuICAgIHRhcmdldC5hcHBlbmRDaGlsZChlbClcbiAgfSwgdm0sIGNiKVxufVxuXG4vKipcbiAqIEluc2VydEJlZm9yZSB3aXRoIHRyYW5zaXRpb24uXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICovXG5cbmV4cG9ydHMuYmVmb3JlID0gZnVuY3Rpb24gKGVsLCB0YXJnZXQsIHZtLCBjYikge1xuICBhcHBseShlbCwgMSwgZnVuY3Rpb24gKCkge1xuICAgIF8uYmVmb3JlKGVsLCB0YXJnZXQpXG4gIH0sIHZtLCBjYilcbn1cblxuLyoqXG4gKiBSZW1vdmUgd2l0aCB0cmFuc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICovXG5cbmV4cG9ydHMucmVtb3ZlID0gZnVuY3Rpb24gKGVsLCB2bSwgY2IpIHtcbiAgYXBwbHkoZWwsIC0xLCBmdW5jdGlvbiAoKSB7XG4gICAgXy5yZW1vdmUoZWwpXG4gIH0sIHZtLCBjYilcbn1cblxuLyoqXG4gKiBBcHBseSB0cmFuc2l0aW9ucyB3aXRoIGFuIG9wZXJhdGlvbiBjYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge051bWJlcn0gZGlyZWN0aW9uXG4gKiAgICAgICAgICAgICAgICAgIDE6IGVudGVyXG4gKiAgICAgICAgICAgICAgICAgLTE6IGxlYXZlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcCAtIHRoZSBhY3R1YWwgRE9NIG9wZXJhdGlvblxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gKi9cblxudmFyIGFwcGx5ID0gZXhwb3J0cy5hcHBseSA9IGZ1bmN0aW9uIChlbCwgZGlyZWN0aW9uLCBvcCwgdm0sIGNiKSB7XG4gIHZhciB0cmFuc2l0aW9uID0gZWwuX192X3RyYW5zXG4gIGlmIChcbiAgICAhdHJhbnNpdGlvbiB8fFxuICAgIC8vIHNraXAgaWYgdGhlcmUgYXJlIG5vIGpzIGhvb2tzIGFuZCBDU1MgdHJhbnNpdGlvbiBpc1xuICAgIC8vIG5vdCBzdXBwb3J0ZWRcbiAgICAoIXRyYW5zaXRpb24uaG9va3MgJiYgIV8udHJhbnNpdGlvbkVuZEV2ZW50KSB8fFxuICAgIC8vIHNraXAgdHJhbnNpdGlvbnMgZm9yIGluaXRpYWwgY29tcGlsZVxuICAgICF2bS5faXNDb21waWxlZCB8fFxuICAgIC8vIGlmIHRoZSB2bSBpcyBiZWluZyBtYW5pcHVsYXRlZCBieSBhIHBhcmVudCBkaXJlY3RpdmVcbiAgICAvLyBkdXJpbmcgdGhlIHBhcmVudCdzIGNvbXBpbGF0aW9uIHBoYXNlLCBza2lwIHRoZVxuICAgIC8vIGFuaW1hdGlvbi5cbiAgICAodm0uJHBhcmVudCAmJiAhdm0uJHBhcmVudC5faXNDb21waWxlZClcbiAgKSB7XG4gICAgb3AoKVxuICAgIGlmIChjYikgY2IoKVxuICAgIHJldHVyblxuICB9XG4gIHZhciBhY3Rpb24gPSBkaXJlY3Rpb24gPiAwID8gJ2VudGVyJyA6ICdsZWF2ZSdcbiAgdHJhbnNpdGlvblthY3Rpb25dKG9wLCBjYilcbn1cbiIsInZhciBfID0gcmVxdWlyZSgnLi4vdXRpbCcpXG52YXIgcXVldWUgPSBbXVxudmFyIHF1ZXVlZCA9IGZhbHNlXG5cbi8qKlxuICogUHVzaCBhIGpvYiBpbnRvIHRoZSBxdWV1ZS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBqb2JcbiAqL1xuXG5leHBvcnRzLnB1c2ggPSBmdW5jdGlvbiAoam9iKSB7XG4gIHF1ZXVlLnB1c2goam9iKVxuICBpZiAoIXF1ZXVlZCkge1xuICAgIHF1ZXVlZCA9IHRydWVcbiAgICBfLm5leHRUaWNrKGZsdXNoKVxuICB9XG59XG5cbi8qKlxuICogRmx1c2ggdGhlIHF1ZXVlLCBhbmQgZG8gb25lIGZvcmNlZCByZWZsb3cgYmVmb3JlXG4gKiB0cmlnZ2VyaW5nIHRyYW5zaXRpb25zLlxuICovXG5cbmZ1bmN0aW9uIGZsdXNoICgpIHtcbiAgLy8gRm9yY2UgbGF5b3V0XG4gIHZhciBmID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm9mZnNldEhlaWdodFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgcXVldWVbaV0oKVxuICB9XG4gIHF1ZXVlID0gW11cbiAgcXVldWVkID0gZmFsc2VcbiAgLy8gZHVtbXkgcmV0dXJuLCBzbyBqcyBsaW50ZXJzIGRvbid0IGNvbXBsYWluIGFib3V0XG4gIC8vIHVudXNlZCB2YXJpYWJsZSBmXG4gIHJldHVybiBmXG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWwnKVxudmFyIHF1ZXVlID0gcmVxdWlyZSgnLi9xdWV1ZScpXG52YXIgYWRkQ2xhc3MgPSBfLmFkZENsYXNzXG52YXIgcmVtb3ZlQ2xhc3MgPSBfLnJlbW92ZUNsYXNzXG52YXIgdHJhbnNpdGlvbkVuZEV2ZW50ID0gXy50cmFuc2l0aW9uRW5kRXZlbnRcbnZhciBhbmltYXRpb25FbmRFdmVudCA9IF8uYW5pbWF0aW9uRW5kRXZlbnRcbnZhciB0cmFuc0R1cmF0aW9uUHJvcCA9IF8udHJhbnNpdGlvblByb3AgKyAnRHVyYXRpb24nXG52YXIgYW5pbUR1cmF0aW9uUHJvcCA9IF8uYW5pbWF0aW9uUHJvcCArICdEdXJhdGlvbidcblxudmFyIFRZUEVfVFJBTlNJVElPTiA9IDFcbnZhciBUWVBFX0FOSU1BVElPTiA9IDJcblxuLyoqXG4gKiBBIFRyYW5zaXRpb24gb2JqZWN0IHRoYXQgZW5jYXBzdWxhdGVzIHRoZSBzdGF0ZSBhbmQgbG9naWNcbiAqIG9mIHRoZSB0cmFuc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICogQHBhcmFtIHtPYmplY3R9IGhvb2tzXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqL1xuXG5mdW5jdGlvbiBUcmFuc2l0aW9uIChlbCwgaWQsIGhvb2tzLCB2bSkge1xuICB0aGlzLmlkID0gaWRcbiAgdGhpcy5lbCA9IGVsXG4gIHRoaXMuZW50ZXJDbGFzcyA9IGlkICsgJy1lbnRlcidcbiAgdGhpcy5sZWF2ZUNsYXNzID0gaWQgKyAnLWxlYXZlJ1xuICB0aGlzLmhvb2tzID0gaG9va3NcbiAgdGhpcy52bSA9IHZtXG4gIC8vIGFzeW5jIHN0YXRlXG4gIHRoaXMucGVuZGluZ0Nzc0V2ZW50ID1cbiAgdGhpcy5wZW5kaW5nQ3NzQ2IgPVxuICB0aGlzLmNhbmNlbCA9XG4gIHRoaXMucGVuZGluZ0pzQ2IgPVxuICB0aGlzLm9wID1cbiAgdGhpcy5jYiA9IG51bGxcbiAgdGhpcy5qdXN0RW50ZXJlZCA9IGZhbHNlXG4gIHRoaXMuZW50ZXJlZCA9IHRoaXMubGVmdCA9IGZhbHNlXG4gIHRoaXMudHlwZUNhY2hlID0ge31cbiAgLy8gYmluZFxuICB2YXIgc2VsZiA9IHRoaXNcbiAgO1snZW50ZXJOZXh0VGljaycsICdlbnRlckRvbmUnLCAnbGVhdmVOZXh0VGljaycsICdsZWF2ZURvbmUnXVxuICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gICAgICBzZWxmW21dID0gXy5iaW5kKHNlbGZbbV0sIHNlbGYpXG4gICAgfSlcbn1cblxudmFyIHAgPSBUcmFuc2l0aW9uLnByb3RvdHlwZVxuXG4vKipcbiAqIFN0YXJ0IGFuIGVudGVyaW5nIHRyYW5zaXRpb24uXG4gKlxuICogMS4gZW50ZXIgdHJhbnNpdGlvbiB0cmlnZ2VyZWRcbiAqIDIuIGNhbGwgYmVmb3JlRW50ZXIgaG9va1xuICogMy4gYWRkIGVudGVyIGNsYXNzXG4gKiA0LiBpbnNlcnQvc2hvdyBlbGVtZW50XG4gKiA1LiBjYWxsIGVudGVyIGhvb2sgKHdpdGggcG9zc2libGUgZXhwbGljaXQganMgY2FsbGJhY2spXG4gKiA2LiByZWZsb3dcbiAqIDcuIGJhc2VkIG9uIHRyYW5zaXRpb24gdHlwZTpcbiAqICAgIC0gdHJhbnNpdGlvbjpcbiAqICAgICAgICByZW1vdmUgY2xhc3Mgbm93LCB3YWl0IGZvciB0cmFuc2l0aW9uZW5kLFxuICogICAgICAgIHRoZW4gZG9uZSBpZiB0aGVyZSdzIG5vIGV4cGxpY2l0IGpzIGNhbGxiYWNrLlxuICogICAgLSBhbmltYXRpb246XG4gKiAgICAgICAgd2FpdCBmb3IgYW5pbWF0aW9uZW5kLCByZW1vdmUgY2xhc3MsXG4gKiAgICAgICAgdGhlbiBkb25lIGlmIHRoZXJlJ3Mgbm8gZXhwbGljaXQganMgY2FsbGJhY2suXG4gKiAgICAtIG5vIGNzcyB0cmFuc2l0aW9uOlxuICogICAgICAgIGRvbmUgbm93IGlmIHRoZXJlJ3Mgbm8gZXhwbGljaXQganMgY2FsbGJhY2suXG4gKiA4LiB3YWl0IGZvciBlaXRoZXIgZG9uZSBvciBqcyBjYWxsYmFjaywgdGhlbiBjYWxsXG4gKiAgICBhZnRlckVudGVyIGhvb2suXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3AgLSBpbnNlcnQvc2hvdyB0aGUgZWxlbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICovXG5cbnAuZW50ZXIgPSBmdW5jdGlvbiAob3AsIGNiKSB7XG4gIHRoaXMuY2FuY2VsUGVuZGluZygpXG4gIHRoaXMuY2FsbEhvb2soJ2JlZm9yZUVudGVyJylcbiAgdGhpcy5jYiA9IGNiXG4gIGFkZENsYXNzKHRoaXMuZWwsIHRoaXMuZW50ZXJDbGFzcylcbiAgb3AoKVxuICB0aGlzLmVudGVyZWQgPSBmYWxzZVxuICB0aGlzLmNhbGxIb29rV2l0aENiKCdlbnRlcicpXG4gIGlmICh0aGlzLmVudGVyZWQpIHtcbiAgICByZXR1cm4gLy8gdXNlciBjYWxsZWQgZG9uZSBzeW5jaHJvbm91c2x5LlxuICB9XG4gIHRoaXMuY2FuY2VsID0gdGhpcy5ob29rcyAmJiB0aGlzLmhvb2tzLmVudGVyQ2FuY2VsbGVkXG4gIHF1ZXVlLnB1c2godGhpcy5lbnRlck5leHRUaWNrKVxufVxuXG4vKipcbiAqIFRoZSBcIm5leHRUaWNrXCIgcGhhc2Ugb2YgYW4gZW50ZXJpbmcgdHJhbnNpdGlvbiwgd2hpY2ggaXNcbiAqIHRvIGJlIHB1c2hlZCBpbnRvIGEgcXVldWUgYW5kIGV4ZWN1dGVkIGFmdGVyIGEgcmVmbG93IHNvXG4gKiB0aGF0IHJlbW92aW5nIHRoZSBjbGFzcyBjYW4gdHJpZ2dlciBhIENTUyB0cmFuc2l0aW9uLlxuICovXG5cbnAuZW50ZXJOZXh0VGljayA9IGZ1bmN0aW9uICgpIHtcblxuICAvLyBJbXBvcnRhbnQgaGFjazpcbiAgLy8gaW4gQ2hyb21lLCBpZiBhIGp1c3QtZW50ZXJlZCBlbGVtZW50IGlzIGFwcGxpZWQgdGhlXG4gIC8vIGxlYXZlIGNsYXNzIHdoaWxlIGl0cyBpbnRlcnBvbGF0ZWQgcHJvcGVydHkgc3RpbGwgaGFzXG4gIC8vIGEgdmVyeSBzbWFsbCB2YWx1ZSAod2l0aGluIG9uZSBmcmFtZSksIENocm9tZSB3aWxsXG4gIC8vIHNraXAgdGhlIGxlYXZlIHRyYW5zaXRpb24gZW50aXJlbHkgYW5kIG5vdCBmaXJpbmcgdGhlXG4gIC8vIHRyYW5zdGlvbmVuZCBldmVudC4gVGhlcmVmb3JlIHdlIG5lZWQgdG8gcHJvdGVjdGVkXG4gIC8vIGFnYWluc3Qgc3VjaCBjYXNlcyB1c2luZyBhIG9uZS1mcmFtZSB0aW1lb3V0LlxuICB0aGlzLmp1c3RFbnRlcmVkID0gdHJ1ZVxuICB2YXIgc2VsZiA9IHRoaXNcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5qdXN0RW50ZXJlZCA9IGZhbHNlXG4gIH0sIDE3KVxuXG4gIHZhciBlbnRlckRvbmUgPSB0aGlzLmVudGVyRG9uZVxuICB2YXIgdHlwZSA9IHRoaXMuZ2V0Q3NzVHJhbnNpdGlvblR5cGUodGhpcy5lbnRlckNsYXNzKVxuICBpZiAoIXRoaXMucGVuZGluZ0pzQ2IpIHtcbiAgICBpZiAodHlwZSA9PT0gVFlQRV9UUkFOU0lUSU9OKSB7XG4gICAgICAvLyB0cmlnZ2VyIHRyYW5zaXRpb24gYnkgcmVtb3ZpbmcgZW50ZXIgY2xhc3Mgbm93XG4gICAgICByZW1vdmVDbGFzcyh0aGlzLmVsLCB0aGlzLmVudGVyQ2xhc3MpXG4gICAgICB0aGlzLnNldHVwQ3NzQ2IodHJhbnNpdGlvbkVuZEV2ZW50LCBlbnRlckRvbmUpXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBUWVBFX0FOSU1BVElPTikge1xuICAgICAgdGhpcy5zZXR1cENzc0NiKGFuaW1hdGlvbkVuZEV2ZW50LCBlbnRlckRvbmUpXG4gICAgfSBlbHNlIHtcbiAgICAgIGVudGVyRG9uZSgpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09IFRZUEVfVFJBTlNJVElPTikge1xuICAgIHJlbW92ZUNsYXNzKHRoaXMuZWwsIHRoaXMuZW50ZXJDbGFzcylcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBcImNsZWFudXBcIiBwaGFzZSBvZiBhbiBlbnRlcmluZyB0cmFuc2l0aW9uLlxuICovXG5cbnAuZW50ZXJEb25lID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVudGVyZWQgPSB0cnVlXG4gIHRoaXMuY2FuY2VsID0gdGhpcy5wZW5kaW5nSnNDYiA9IG51bGxcbiAgcmVtb3ZlQ2xhc3ModGhpcy5lbCwgdGhpcy5lbnRlckNsYXNzKVxuICB0aGlzLmNhbGxIb29rKCdhZnRlckVudGVyJylcbiAgaWYgKHRoaXMuY2IpIHRoaXMuY2IoKVxufVxuXG4vKipcbiAqIFN0YXJ0IGEgbGVhdmluZyB0cmFuc2l0aW9uLlxuICpcbiAqIDEuIGxlYXZlIHRyYW5zaXRpb24gdHJpZ2dlcmVkLlxuICogMi4gY2FsbCBiZWZvcmVMZWF2ZSBob29rXG4gKiAzLiBhZGQgbGVhdmUgY2xhc3MgKHRyaWdnZXIgY3NzIHRyYW5zaXRpb24pXG4gKiA0LiBjYWxsIGxlYXZlIGhvb2sgKHdpdGggcG9zc2libGUgZXhwbGljaXQganMgY2FsbGJhY2spXG4gKiA1LiByZWZsb3cgaWYgbm8gZXhwbGljaXQganMgY2FsbGJhY2sgaXMgcHJvdmlkZWRcbiAqIDYuIGJhc2VkIG9uIHRyYW5zaXRpb24gdHlwZTpcbiAqICAgIC0gdHJhbnNpdGlvbiBvciBhbmltYXRpb246XG4gKiAgICAgICAgd2FpdCBmb3IgZW5kIGV2ZW50LCByZW1vdmUgY2xhc3MsIHRoZW4gZG9uZSBpZlxuICogICAgICAgIHRoZXJlJ3Mgbm8gZXhwbGljaXQganMgY2FsbGJhY2suXG4gKiAgICAtIG5vIGNzcyB0cmFuc2l0aW9uOlxuICogICAgICAgIGRvbmUgaWYgdGhlcmUncyBubyBleHBsaWNpdCBqcyBjYWxsYmFjay5cbiAqIDcuIHdhaXQgZm9yIGVpdGhlciBkb25lIG9yIGpzIGNhbGxiYWNrLCB0aGVuIGNhbGxcbiAqICAgIGFmdGVyTGVhdmUgaG9vay5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcCAtIHJlbW92ZS9oaWRlIHRoZSBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gKi9cblxucC5sZWF2ZSA9IGZ1bmN0aW9uIChvcCwgY2IpIHtcbiAgdGhpcy5jYW5jZWxQZW5kaW5nKClcbiAgdGhpcy5jYWxsSG9vaygnYmVmb3JlTGVhdmUnKVxuICB0aGlzLm9wID0gb3BcbiAgdGhpcy5jYiA9IGNiXG4gIGFkZENsYXNzKHRoaXMuZWwsIHRoaXMubGVhdmVDbGFzcylcbiAgdGhpcy5sZWZ0ID0gZmFsc2VcbiAgdGhpcy5jYWxsSG9va1dpdGhDYignbGVhdmUnKVxuICBpZiAodGhpcy5sZWZ0KSB7XG4gICAgcmV0dXJuIC8vIHVzZXIgY2FsbGVkIGRvbmUgc3luY2hyb25vdXNseS5cbiAgfVxuICB0aGlzLmNhbmNlbCA9IHRoaXMuaG9va3MgJiYgdGhpcy5ob29rcy5sZWF2ZUNhbmNlbGxlZFxuICAvLyBvbmx5IG5lZWQgdG8gaGFuZGxlIGxlYXZlRG9uZSBpZlxuICAvLyAxLiB0aGUgdHJhbnNpdGlvbiBpcyBhbHJlYWR5IGRvbmUgKHN5bmNocm9ub3VzbHkgY2FsbGVkXG4gIC8vICAgIGJ5IHRoZSB1c2VyLCB3aGljaCBjYXVzZXMgdGhpcy5vcCBzZXQgdG8gbnVsbClcbiAgLy8gMi4gdGhlcmUncyBubyBleHBsaWNpdCBqcyBjYWxsYmFja1xuICBpZiAodGhpcy5vcCAmJiAhdGhpcy5wZW5kaW5nSnNDYikge1xuICAgIC8vIGlmIGEgQ1NTIHRyYW5zaXRpb24gbGVhdmVzIGltbWVkaWF0ZWx5IGFmdGVyIGVudGVyLFxuICAgIC8vIHRoZSB0cmFuc2l0aW9uZW5kIGV2ZW50IG5ldmVyIGZpcmVzLiB0aGVyZWZvcmUgd2VcbiAgICAvLyBkZXRlY3Qgc3VjaCBjYXNlcyBhbmQgZW5kIHRoZSBsZWF2ZSBpbW1lZGlhdGVseS5cbiAgICBpZiAodGhpcy5qdXN0RW50ZXJlZCkge1xuICAgICAgdGhpcy5sZWF2ZURvbmUoKVxuICAgIH0gZWxzZSB7XG4gICAgICBxdWV1ZS5wdXNoKHRoaXMubGVhdmVOZXh0VGljaylcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgXCJuZXh0VGlja1wiIHBoYXNlIG9mIGEgbGVhdmluZyB0cmFuc2l0aW9uLlxuICovXG5cbnAubGVhdmVOZXh0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHR5cGUgPSB0aGlzLmdldENzc1RyYW5zaXRpb25UeXBlKHRoaXMubGVhdmVDbGFzcylcbiAgaWYgKHR5cGUpIHtcbiAgICB2YXIgZXZlbnQgPSB0eXBlID09PSBUWVBFX1RSQU5TSVRJT05cbiAgICAgID8gdHJhbnNpdGlvbkVuZEV2ZW50XG4gICAgICA6IGFuaW1hdGlvbkVuZEV2ZW50XG4gICAgdGhpcy5zZXR1cENzc0NiKGV2ZW50LCB0aGlzLmxlYXZlRG9uZSlcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxlYXZlRG9uZSgpXG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgXCJjbGVhbnVwXCIgcGhhc2Ugb2YgYSBsZWF2aW5nIHRyYW5zaXRpb24uXG4gKi9cblxucC5sZWF2ZURvbmUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMubGVmdCA9IHRydWVcbiAgdGhpcy5jYW5jZWwgPSB0aGlzLnBlbmRpbmdKc0NiID0gbnVsbFxuICB0aGlzLm9wKClcbiAgcmVtb3ZlQ2xhc3ModGhpcy5lbCwgdGhpcy5sZWF2ZUNsYXNzKVxuICB0aGlzLmNhbGxIb29rKCdhZnRlckxlYXZlJylcbiAgaWYgKHRoaXMuY2IpIHRoaXMuY2IoKVxuICB0aGlzLm9wID0gbnVsbFxufVxuXG4vKipcbiAqIENhbmNlbCBhbnkgcGVuZGluZyBjYWxsYmFja3MgZnJvbSBhIHByZXZpb3VzbHkgcnVubmluZ1xuICogYnV0IG5vdCBmaW5pc2hlZCB0cmFuc2l0aW9uLlxuICovXG5cbnAuY2FuY2VsUGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5vcCA9IHRoaXMuY2IgPSBudWxsXG4gIHZhciBoYXNQZW5kaW5nID0gZmFsc2VcbiAgaWYgKHRoaXMucGVuZGluZ0Nzc0NiKSB7XG4gICAgaGFzUGVuZGluZyA9IHRydWVcbiAgICBfLm9mZih0aGlzLmVsLCB0aGlzLnBlbmRpbmdDc3NFdmVudCwgdGhpcy5wZW5kaW5nQ3NzQ2IpXG4gICAgdGhpcy5wZW5kaW5nQ3NzRXZlbnQgPSB0aGlzLnBlbmRpbmdDc3NDYiA9IG51bGxcbiAgfVxuICBpZiAodGhpcy5wZW5kaW5nSnNDYikge1xuICAgIGhhc1BlbmRpbmcgPSB0cnVlXG4gICAgdGhpcy5wZW5kaW5nSnNDYi5jYW5jZWwoKVxuICAgIHRoaXMucGVuZGluZ0pzQ2IgPSBudWxsXG4gIH1cbiAgaWYgKGhhc1BlbmRpbmcpIHtcbiAgICByZW1vdmVDbGFzcyh0aGlzLmVsLCB0aGlzLmVudGVyQ2xhc3MpXG4gICAgcmVtb3ZlQ2xhc3ModGhpcy5lbCwgdGhpcy5sZWF2ZUNsYXNzKVxuICB9XG4gIGlmICh0aGlzLmNhbmNlbCkge1xuICAgIHRoaXMuY2FuY2VsLmNhbGwodGhpcy52bSwgdGhpcy5lbClcbiAgICB0aGlzLmNhbmNlbCA9IG51bGxcbiAgfVxufVxuXG4vKipcbiAqIENhbGwgYSB1c2VyLXByb3ZpZGVkIHN5bmNocm9ub3VzIGhvb2sgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuXG5wLmNhbGxIb29rID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgaWYgKHRoaXMuaG9va3MgJiYgdGhpcy5ob29rc1t0eXBlXSkge1xuICAgIHRoaXMuaG9va3NbdHlwZV0uY2FsbCh0aGlzLnZtLCB0aGlzLmVsKVxuICB9XG59XG5cbi8qKlxuICogQ2FsbCBhIHVzZXItcHJvdmlkZWQsIHBvdGVudGlhbGx5LWFzeW5jIGhvb2sgZnVuY3Rpb24uXG4gKiBXZSBjaGVjayBmb3IgdGhlIGxlbmd0aCBvZiBhcmd1bWVudHMgdG8gc2VlIGlmIHRoZSBob29rXG4gKiBleHBlY3RzIGEgYGRvbmVgIGNhbGxiYWNrLiBJZiB0cnVlLCB0aGUgdHJhbnNpdGlvbidzIGVuZFxuICogd2lsbCBiZSBkZXRlcm1pbmVkIGJ5IHdoZW4gdGhlIHVzZXIgY2FsbHMgdGhhdCBjYWxsYmFjaztcbiAqIG90aGVyd2lzZSwgdGhlIGVuZCBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBDU1MgdHJhbnNpdGlvbiBvclxuICogYW5pbWF0aW9uLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cblxucC5jYWxsSG9va1dpdGhDYiA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIHZhciBob29rID0gdGhpcy5ob29rcyAmJiB0aGlzLmhvb2tzW3R5cGVdXG4gIGlmIChob29rKSB7XG4gICAgaWYgKGhvb2subGVuZ3RoID4gMSkge1xuICAgICAgdGhpcy5wZW5kaW5nSnNDYiA9IF8uY2FuY2VsbGFibGUodGhpc1t0eXBlICsgJ0RvbmUnXSlcbiAgICB9XG4gICAgaG9vay5jYWxsKHRoaXMudm0sIHRoaXMuZWwsIHRoaXMucGVuZGluZ0pzQ2IpXG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgYW4gZWxlbWVudCdzIHRyYW5zaXRpb24gdHlwZSBiYXNlZCBvbiB0aGVcbiAqIGNhbGN1bGF0ZWQgc3R5bGVzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWVcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuXG5wLmdldENzc1RyYW5zaXRpb25UeXBlID0gZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgICF0cmFuc2l0aW9uRW5kRXZlbnQgfHxcbiAgICAvLyBza2lwIENTUyB0cmFuc2l0aW9ucyBpZiBwYWdlIGlzIG5vdCB2aXNpYmxlIC1cbiAgICAvLyB0aGlzIHNvbHZlcyB0aGUgaXNzdWUgb2YgdHJhbnNpdGlvbmVuZCBldmVudHMgbm90XG4gICAgLy8gZmlyaW5nIHVudGlsIHRoZSBwYWdlIGlzIHZpc2libGUgYWdhaW4uXG4gICAgLy8gcGFnZVZpc2liaWxpdHkgQVBJIGlzIHN1cHBvcnRlZCBpbiBJRTEwKywgc2FtZSBhc1xuICAgIC8vIENTUyB0cmFuc2l0aW9ucy5cbiAgICBkb2N1bWVudC5oaWRkZW4gfHxcbiAgICAvLyBleHBsaWNpdCBqcy1vbmx5IHRyYW5zaXRpb25cbiAgICAodGhpcy5ob29rcyAmJiB0aGlzLmhvb2tzLmNzcyA9PT0gZmFsc2UpIHx8XG4gICAgLy8gZWxlbWVudCBpcyBoaWRkZW5cbiAgICBpc0hpZGRlbih0aGlzLmVsKVxuICApIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdHlwZSA9IHRoaXMudHlwZUNhY2hlW2NsYXNzTmFtZV1cbiAgaWYgKHR5cGUpIHJldHVybiB0eXBlXG4gIHZhciBpbmxpbmVTdHlsZXMgPSB0aGlzLmVsLnN0eWxlXG4gIHZhciBjb21wdXRlZFN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZWwpXG4gIHZhciB0cmFuc0R1cmF0aW9uID1cbiAgICBpbmxpbmVTdHlsZXNbdHJhbnNEdXJhdGlvblByb3BdIHx8XG4gICAgY29tcHV0ZWRTdHlsZXNbdHJhbnNEdXJhdGlvblByb3BdXG4gIGlmICh0cmFuc0R1cmF0aW9uICYmIHRyYW5zRHVyYXRpb24gIT09ICcwcycpIHtcbiAgICB0eXBlID0gVFlQRV9UUkFOU0lUSU9OXG4gIH0gZWxzZSB7XG4gICAgdmFyIGFuaW1EdXJhdGlvbiA9XG4gICAgICBpbmxpbmVTdHlsZXNbYW5pbUR1cmF0aW9uUHJvcF0gfHxcbiAgICAgIGNvbXB1dGVkU3R5bGVzW2FuaW1EdXJhdGlvblByb3BdXG4gICAgaWYgKGFuaW1EdXJhdGlvbiAmJiBhbmltRHVyYXRpb24gIT09ICcwcycpIHtcbiAgICAgIHR5cGUgPSBUWVBFX0FOSU1BVElPTlxuICAgIH1cbiAgfVxuICBpZiAodHlwZSkge1xuICAgIHRoaXMudHlwZUNhY2hlW2NsYXNzTmFtZV0gPSB0eXBlXG4gIH1cbiAgcmV0dXJuIHR5cGVcbn1cblxuLyoqXG4gKiBTZXR1cCBhIENTUyB0cmFuc2l0aW9uZW5kL2FuaW1hdGlvbmVuZCBjYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKi9cblxucC5zZXR1cENzc0NiID0gZnVuY3Rpb24gKGV2ZW50LCBjYikge1xuICB0aGlzLnBlbmRpbmdDc3NFdmVudCA9IGV2ZW50XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgZWwgPSB0aGlzLmVsXG4gIHZhciBvbkVuZCA9IHRoaXMucGVuZGluZ0Nzc0NiID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS50YXJnZXQgPT09IGVsKSB7XG4gICAgICBfLm9mZihlbCwgZXZlbnQsIG9uRW5kKVxuICAgICAgc2VsZi5wZW5kaW5nQ3NzRXZlbnQgPSBzZWxmLnBlbmRpbmdDc3NDYiA9IG51bGxcbiAgICAgIGlmICghc2VsZi5wZW5kaW5nSnNDYiAmJiBjYikge1xuICAgICAgICBjYigpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIF8ub24oZWwsIGV2ZW50LCBvbkVuZClcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBlbGVtZW50IGlzIGhpZGRlbiAtIGluIHRoYXQgY2FzZSB3ZSBjYW4ganVzdFxuICogc2tpcCB0aGUgdHJhbnNpdGlvbiBhbGx0b2dldGhlci5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlzSGlkZGVuIChlbCkge1xuICByZXR1cm4gIShcbiAgICBlbC5vZmZzZXRXaWR0aCAmJlxuICAgIGVsLm9mZnNldEhlaWdodCAmJlxuICAgIGVsLmdldENsaWVudFJlY3RzKCkubGVuZ3RoXG4gIClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2l0aW9uXG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4vaW5kZXgnKVxuXG4vKipcbiAqIENoZWNrIGlmIGFuIGVsZW1lbnQgaXMgYSBjb21wb25lbnQsIGlmIHllcyByZXR1cm4gaXRzXG4gKiBjb21wb25lbnQgaWQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9XG4gKi9cblxuZXhwb3J0cy5jb21tb25UYWdSRSA9IC9eKGRpdnxwfHNwYW58aW1nfGF8YnxpfGJyfHVsfG9sfGxpfGgxfGgyfGgzfGg0fGg1fGg2fGNvZGV8cHJlfHRhYmxlfHRofHRkfHRyfGZvcm18bGFiZWx8aW5wdXR8c2VsZWN0fG9wdGlvbnxuYXZ8YXJ0aWNsZXxzZWN0aW9ufGhlYWRlcnxmb290ZXIpJC9cbmV4cG9ydHMuY2hlY2tDb21wb25lbnQgPSBmdW5jdGlvbiAoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHRhZyA9IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKVxuICB2YXIgaGFzQXR0cnMgPSBlbC5oYXNBdHRyaWJ1dGVzKClcbiAgaWYgKCFleHBvcnRzLmNvbW1vblRhZ1JFLnRlc3QodGFnKSAmJiB0YWcgIT09ICdjb21wb25lbnQnKSB7XG4gICAgaWYgKF8ucmVzb2x2ZUFzc2V0KG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSkge1xuICAgICAgcmV0dXJuIHsgaWQ6IHRhZyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpcyA9IGhhc0F0dHJzICYmIGdldElzQmluZGluZyhlbClcbiAgICAgIGlmIChpcykge1xuICAgICAgICByZXR1cm4gaXNcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdGFnLmluZGV4T2YoJy0nKSA+IC0xIHx8XG4gICAgICAgICAgKFxuICAgICAgICAgICAgL0hUTUxVbmtub3duRWxlbWVudC8udGVzdChlbC50b1N0cmluZygpKSAmJlxuICAgICAgICAgICAgLy8gQ2hyb21lIHJldHVybnMgdW5rbm93biBmb3Igc2V2ZXJhbCBIVE1MNSBlbGVtZW50cy5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD01NDA1MjZcbiAgICAgICAgICAgICEvXihkYXRhfHRpbWV8cnRjfHJiKSQvLnRlc3QodGFnKVxuICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgXy53YXJuKFxuICAgICAgICAgICAgJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSBkaWQgeW91ICcgK1xuICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PydcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaGFzQXR0cnMpIHtcbiAgICByZXR1cm4gZ2V0SXNCaW5kaW5nKGVsKVxuICB9XG59XG5cbi8qKlxuICogR2V0IFwiaXNcIiBiaW5kaW5nIGZyb20gYW4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIGdldElzQmluZGluZyAoZWwpIHtcbiAgLy8gZHluYW1pYyBzeW50YXhcbiAgdmFyIGV4cCA9IF8uYXR0cihlbCwgJ2lzJylcbiAgaWYgKGV4cCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHsgaWQ6IGV4cCB9XG4gIH0gZWxzZSB7XG4gICAgZXhwID0gXy5nZXRCaW5kQXR0cihlbCwgJ2lzJylcbiAgICBpZiAoZXhwICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB7IGlkOiBleHAsIGR5bmFtaWM6IHRydWUgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFNldCBhIHByb3AncyBpbml0aWFsIHZhbHVlIG9uIGEgdm0gYW5kIGl0cyBkYXRhIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cblxuZXhwb3J0cy5pbml0UHJvcCA9IGZ1bmN0aW9uICh2bSwgcHJvcCwgdmFsdWUpIHtcbiAgaWYgKGV4cG9ydHMuYXNzZXJ0UHJvcChwcm9wLCB2YWx1ZSkpIHtcbiAgICB2YXIga2V5ID0gcHJvcC5wYXRoXG4gICAgdm1ba2V5XSA9IHZtLl9kYXRhW2tleV0gPSB2YWx1ZVxuICB9XG59XG5cbi8qKlxuICogQXNzZXJ0IHdoZXRoZXIgYSBwcm9wIGlzIHZhbGlkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cblxuZXhwb3J0cy5hc3NlcnRQcm9wID0gZnVuY3Rpb24gKHByb3AsIHZhbHVlKSB7XG4gIC8vIGlmIGEgcHJvcCBpcyBub3QgcHJvdmlkZWQgYW5kIGlzIG5vdCByZXF1aXJlZCxcbiAgLy8gc2tpcCB0aGUgY2hlY2suXG4gIGlmIChwcm9wLnJhdyA9PT0gbnVsbCAmJiAhcHJvcC5yZXF1aXJlZCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgdmFyIG9wdGlvbnMgPSBwcm9wLm9wdGlvbnNcbiAgdmFyIHR5cGUgPSBvcHRpb25zLnR5cGVcbiAgdmFyIHZhbGlkID0gdHJ1ZVxuICB2YXIgZXhwZWN0ZWRUeXBlXG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT09IFN0cmluZykge1xuICAgICAgZXhwZWN0ZWRUeXBlID0gJ3N0cmluZydcbiAgICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSBleHBlY3RlZFR5cGVcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IE51bWJlcikge1xuICAgICAgZXhwZWN0ZWRUeXBlID0gJ251bWJlcidcbiAgICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJ1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gQm9vbGVhbikge1xuICAgICAgZXhwZWN0ZWRUeXBlID0gJ2Jvb2xlYW4nXG4gICAgICB2YWxpZCA9IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBGdW5jdGlvbikge1xuICAgICAgZXhwZWN0ZWRUeXBlID0gJ2Z1bmN0aW9uJ1xuICAgICAgdmFsaWQgPSB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbidcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IE9iamVjdCkge1xuICAgICAgZXhwZWN0ZWRUeXBlID0gJ29iamVjdCdcbiAgICAgIHZhbGlkID0gXy5pc1BsYWluT2JqZWN0KHZhbHVlKVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gQXJyYXkpIHtcbiAgICAgIGV4cGVjdGVkVHlwZSA9ICdhcnJheSdcbiAgICAgIHZhbGlkID0gXy5pc0FycmF5KHZhbHVlKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZVxuICAgIH1cbiAgfVxuICBpZiAoIXZhbGlkKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBfLndhcm4oXG4gICAgICAnSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgJyArXG4gICAgICBwcm9wLnBhdGggKyAnPVwiJyArIHByb3AucmF3ICsgJ1wiLicgK1xuICAgICAgJyBFeHBlY3RlZCAnICsgZm9ybWF0VHlwZShleHBlY3RlZFR5cGUpICtcbiAgICAgICcsIGdvdCAnICsgZm9ybWF0VmFsdWUodmFsdWUpICsgJy4nXG4gICAgKVxuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHZhciB2YWxpZGF0b3IgPSBvcHRpb25zLnZhbGlkYXRvclxuICBpZiAodmFsaWRhdG9yKSB7XG4gICAgaWYgKCF2YWxpZGF0b3IuY2FsbChudWxsLCB2YWx1ZSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgXy53YXJuKFxuICAgICAgICAnSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgJyArXG4gICAgICAgIHByb3AucGF0aCArICc9XCInICsgcHJvcC5yYXcgKyAnXCInXG4gICAgICApXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gZm9ybWF0VHlwZSAodmFsKSB7XG4gIHJldHVybiB2YWxcbiAgICA/IHZhbC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHZhbC5zbGljZSgxKVxuICAgIDogJ2N1c3RvbSB0eXBlJ1xufVxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZSAodmFsKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKS5zbGljZSg4LCAtMSlcbn1cbiIsIi8qKlxuICogRW5hYmxlIGRlYnVnIHV0aWxpdGllcy5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuXG4gIHZhciBjb25maWcgPSByZXF1aXJlKCcuLi9jb25maWcnKVxuICB2YXIgaGFzQ29uc29sZSA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJ1xuXG4gIC8qKlxuICAgKiBMb2cgYSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnXG4gICAqL1xuXG4gIGV4cG9ydHMubG9nID0gZnVuY3Rpb24gKG1zZykge1xuICAgIGlmIChoYXNDb25zb2xlICYmIGNvbmZpZy5kZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coJ1tWdWUgaW5mb106ICcgKyBtc2cpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdlJ3ZlIGdvdCBhIHByb2JsZW0gaGVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZ1xuICAgKi9cblxuICBleHBvcnRzLndhcm4gPSBmdW5jdGlvbiAobXNnLCBlKSB7XG4gICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50IHx8IGNvbmZpZy5kZWJ1ZykpIHtcbiAgICAgIGNvbnNvbGUud2FybignW1Z1ZSB3YXJuXTogJyArIG1zZylcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGNvbmZpZy5kZWJ1Zykge1xuICAgICAgICBjb25zb2xlLndhcm4oKGUgfHwgbmV3IEVycm9yKCdXYXJuaW5nIFN0YWNrIFRyYWNlJykpLnN0YWNrKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NlcnQgYXNzZXQgZXhpc3RzXG4gICAqL1xuXG4gIGV4cG9ydHMuYXNzZXJ0QXNzZXQgPSBmdW5jdGlvbiAodmFsLCB0eXBlLCBpZCkge1xuICAgIGlmICghdmFsKSB7XG4gICAgICBleHBvcnRzLndhcm4oJ0ZhaWxlZCB0byByZXNvbHZlICcgKyB0eXBlICsgJzogJyArIGlkKVxuICAgIH1cbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuL2luZGV4JylcbnZhciBjb25maWcgPSByZXF1aXJlKCcuLi9jb25maWcnKVxudmFyIHRyYW5zaXRpb24gPSByZXF1aXJlKCcuLi90cmFuc2l0aW9uJylcblxuLyoqXG4gKiBRdWVyeSBhbiBlbGVtZW50IHNlbGVjdG9yIGlmIGl0J3Mgbm90IGFuIGVsZW1lbnQgYWxyZWFkeS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fSBlbFxuICogQHJldHVybiB7RWxlbWVudH1cbiAqL1xuXG5leHBvcnRzLnF1ZXJ5ID0gZnVuY3Rpb24gKGVsKSB7XG4gIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHNlbGVjdG9yID0gZWxcbiAgICBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpXG4gICAgaWYgKCFlbCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBfLndhcm4oXG4gICAgICAgICdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgc2VsZWN0b3JcbiAgICAgIClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVsXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBub2RlIGlzIGluIHRoZSBkb2N1bWVudC5cbiAqIE5vdGU6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyBzaG91bGQgd29yayBoZXJlXG4gKiBidXQgYWx3YXlzIHJldHVybnMgZmFsc2UgZm9yIGNvbW1lbnQgbm9kZXMgaW4gcGhhbnRvbWpzLFxuICogbWFraW5nIHVuaXQgdGVzdHMgZGlmZmljdWx0LiBUaGlzIGlzIGZpeGVkIGJ5IGRvaW5nIHRoZVxuICogY29udGFpbnMoKSBjaGVjayBvbiB0aGUgbm9kZSdzIHBhcmVudE5vZGUgaW5zdGVhZCBvZlxuICogdGhlIG5vZGUgaXRzZWxmLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5leHBvcnRzLmluRG9jID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdmFyIGRvYyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudFxuICB2YXIgcGFyZW50ID0gbm9kZSAmJiBub2RlLnBhcmVudE5vZGVcbiAgcmV0dXJuIGRvYyA9PT0gbm9kZSB8fFxuICAgIGRvYyA9PT0gcGFyZW50IHx8XG4gICAgISEocGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSA9PT0gMSAmJiAoZG9jLmNvbnRhaW5zKHBhcmVudCkpKVxufVxuXG4vKipcbiAqIEdldCBhbmQgcmVtb3ZlIGFuIGF0dHJpYnV0ZSBmcm9tIGEgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyXG4gKi9cblxuZXhwb3J0cy5hdHRyID0gZnVuY3Rpb24gKG5vZGUsIGF0dHIpIHtcbiAgdmFyIHZhbCA9IG5vZGUuZ2V0QXR0cmlidXRlKGF0dHIpXG4gIGlmICh2YWwgIT09IG51bGwpIHtcbiAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyKVxuICB9XG4gIHJldHVybiB2YWxcbn1cblxuLyoqXG4gKiBHZXQgYW4gYXR0cmlidXRlIHdpdGggY29sb24gb3Igdi1iaW5kOiBwcmVmaXguXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7U3RyaW5nfG51bGx9XG4gKi9cblxuZXhwb3J0cy5nZXRCaW5kQXR0ciA9IGZ1bmN0aW9uIChub2RlLCBuYW1lKSB7XG4gIHZhciB2YWwgPSBleHBvcnRzLmF0dHIobm9kZSwgJzonICsgbmFtZSlcbiAgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgIHZhbCA9IGV4cG9ydHMuYXR0cihub2RlLCAndi1iaW5kOicgKyBuYW1lKVxuICB9XG4gIHJldHVybiB2YWxcbn1cblxuLyoqXG4gKiBJbnNlcnQgZWwgYmVmb3JlIHRhcmdldFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKi9cblxuZXhwb3J0cy5iZWZvcmUgPSBmdW5jdGlvbiAoZWwsIHRhcmdldCkge1xuICB0YXJnZXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWwsIHRhcmdldClcbn1cblxuLyoqXG4gKiBJbnNlcnQgZWwgYWZ0ZXIgdGFyZ2V0XG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAqL1xuXG5leHBvcnRzLmFmdGVyID0gZnVuY3Rpb24gKGVsLCB0YXJnZXQpIHtcbiAgaWYgKHRhcmdldC5uZXh0U2libGluZykge1xuICAgIGV4cG9ydHMuYmVmb3JlKGVsLCB0YXJnZXQubmV4dFNpYmxpbmcpXG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoZWwpXG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgZWwgZnJvbSBET01cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKi9cblxuZXhwb3J0cy5yZW1vdmUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbClcbn1cblxuLyoqXG4gKiBQcmVwZW5kIGVsIHRvIHRhcmdldFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKi9cblxuZXhwb3J0cy5wcmVwZW5kID0gZnVuY3Rpb24gKGVsLCB0YXJnZXQpIHtcbiAgaWYgKHRhcmdldC5maXJzdENoaWxkKSB7XG4gICAgZXhwb3J0cy5iZWZvcmUoZWwsIHRhcmdldC5maXJzdENoaWxkKVxuICB9IGVsc2Uge1xuICAgIHRhcmdldC5hcHBlbmRDaGlsZChlbClcbiAgfVxufVxuXG4vKipcbiAqIFJlcGxhY2UgdGFyZ2V0IHdpdGggZWxcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICovXG5cbmV4cG9ydHMucmVwbGFjZSA9IGZ1bmN0aW9uICh0YXJnZXQsIGVsKSB7XG4gIHZhciBwYXJlbnQgPSB0YXJnZXQucGFyZW50Tm9kZVxuICBpZiAocGFyZW50KSB7XG4gICAgcGFyZW50LnJlcGxhY2VDaGlsZChlbCwgdGFyZ2V0KVxuICB9XG59XG5cbi8qKlxuICogQWRkIGV2ZW50IGxpc3RlbmVyIHNob3J0aGFuZC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKi9cblxuZXhwb3J0cy5vbiA9IGZ1bmN0aW9uIChlbCwgZXZlbnQsIGNiKSB7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGNiKVxufVxuXG4vKipcbiAqIFJlbW92ZSBldmVudCBsaXN0ZW5lciBzaG9ydGhhbmQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICovXG5cbmV4cG9ydHMub2ZmID0gZnVuY3Rpb24gKGVsLCBldmVudCwgY2IpIHtcbiAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgY2IpXG59XG5cbi8qKlxuICogQWRkIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgSUUgJiBTVkdcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cm9uZ30gY2xzXG4gKi9cblxuZXhwb3J0cy5hZGRDbGFzcyA9IGZ1bmN0aW9uIChlbCwgY2xzKSB7XG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBlbC5jbGFzc0xpc3QuYWRkKGNscylcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gJyAnICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyAnICdcbiAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgSUUgJiBTVkdcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cm9uZ30gY2xzXG4gKi9cblxuZXhwb3J0cy5yZW1vdmVDbGFzcyA9IGZ1bmN0aW9uIChlbCwgY2xzKSB7XG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNscylcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gJyAnICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyAnICdcbiAgICB2YXIgdGFyID0gJyAnICsgY2xzICsgJyAnXG4gICAgd2hpbGUgKGN1ci5pbmRleE9mKHRhcikgPj0gMCkge1xuICAgICAgY3VyID0gY3VyLnJlcGxhY2UodGFyLCAnICcpXG4gICAgfVxuICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjdXIudHJpbSgpKVxuICB9XG4gIGlmICghZWwuY2xhc3NOYW1lKSB7XG4gICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpXG4gIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0IHJhdyBjb250ZW50IGluc2lkZSBhbiBlbGVtZW50IGludG8gYSB0ZW1wb3JhcnlcbiAqIGNvbnRhaW5lciBkaXZcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGFzRnJhZ21lbnRcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKi9cblxuZXhwb3J0cy5leHRyYWN0Q29udGVudCA9IGZ1bmN0aW9uIChlbCwgYXNGcmFnbWVudCkge1xuICB2YXIgY2hpbGRcbiAgdmFyIHJhd0NvbnRlbnRcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChcbiAgICBleHBvcnRzLmlzVGVtcGxhdGUoZWwpICYmXG4gICAgZWwuY29udGVudCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnRcbiAgKSB7XG4gICAgZWwgPSBlbC5jb250ZW50XG4gIH1cbiAgaWYgKGVsLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgIGV4cG9ydHMudHJpbU5vZGUoZWwpXG4gICAgcmF3Q29udGVudCA9IGFzRnJhZ21lbnRcbiAgICAgID8gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG4gICAgICA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgICB3aGlsZSAoY2hpbGQgPSBlbC5maXJzdENoaWxkKSB7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICAgICAgcmF3Q29udGVudC5hcHBlbmRDaGlsZChjaGlsZClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJhd0NvbnRlbnRcbn1cblxuLyoqXG4gKiBUcmltIHBvc3NpYmxlIGVtcHR5IGhlYWQvdGFpbCB0ZXh0Tm9kZXMgaW5zaWRlIGEgcGFyZW50LlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICovXG5cbmV4cG9ydHMudHJpbU5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICB0cmltKG5vZGUsIG5vZGUuZmlyc3RDaGlsZClcbiAgdHJpbShub2RlLCBub2RlLmxhc3RDaGlsZClcbn1cblxuZnVuY3Rpb24gdHJpbSAocGFyZW50LCBub2RlKSB7XG4gIGlmIChub2RlICYmIG5vZGUubm9kZVR5cGUgPT09IDMgJiYgIW5vZGUuZGF0YS50cmltKCkpIHtcbiAgICBwYXJlbnQucmVtb3ZlQ2hpbGQobm9kZSlcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGFuIGVsZW1lbnQgaXMgYSB0ZW1wbGF0ZSB0YWcuXG4gKiBOb3RlIGlmIHRoZSB0ZW1wbGF0ZSBhcHBlYXJzIGluc2lkZSBhbiBTVkcgaXRzIHRhZ05hbWVcbiAqIHdpbGwgYmUgaW4gbG93ZXJjYXNlLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqL1xuXG5leHBvcnRzLmlzVGVtcGxhdGUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgcmV0dXJuIGVsLnRhZ05hbWUgJiZcbiAgICBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd0ZW1wbGF0ZSdcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gXCJhbmNob3JcIiBmb3IgcGVyZm9ybWluZyBkb20gaW5zZXJ0aW9uL3JlbW92YWxzLlxuICogVGhpcyBpcyB1c2VkIGluIGEgbnVtYmVyIG9mIHNjZW5hcmlvczpcbiAqIC0gZnJhZ21lbnQgaW5zdGFuY2VcbiAqIC0gdi1odG1sXG4gKiAtIHYtaWZcbiAqIC0gdi1mb3JcbiAqIC0gY29tcG9uZW50XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbnRlbnRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcGVyc2lzdCAtIElFIHRyYXNoZXMgZW1wdHkgdGV4dE5vZGVzIG9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZU5vZGUodHJ1ZSksIHNvIGluIGNlcnRhaW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2VzIHRoZSBhbmNob3IgbmVlZHMgdG8gYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vbi1lbXB0eSB0byBiZSBwZXJzaXN0ZWQgaW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlcy5cbiAqIEByZXR1cm4ge0NvbW1lbnR8VGV4dH1cbiAqL1xuXG5leHBvcnRzLmNyZWF0ZUFuY2hvciA9IGZ1bmN0aW9uIChjb250ZW50LCBwZXJzaXN0KSB7XG4gIHJldHVybiBjb25maWcuZGVidWdcbiAgICA/IGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoY29udGVudClcbiAgICA6IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHBlcnNpc3QgPyAnICcgOiAnJylcbn1cblxuLyoqXG4gKiBGaW5kIGEgY29tcG9uZW50IHJlZiBhdHRyaWJ1dGUgdGhhdCBzdGFydHMgd2l0aCAkLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7U3RyaW5nfHVuZGVmaW5lZH1cbiAqL1xuXG52YXIgcmVmUkUgPSAvXnYtcmVmOi9cbmV4cG9ydHMuZmluZFJlZiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmIChub2RlLmhhc0F0dHJpYnV0ZXMoKSkge1xuICAgIHZhciBhdHRycyA9IG5vZGUuYXR0cmlidXRlc1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgbmFtZSA9IGF0dHJzW2ldLm5hbWVcbiAgICAgIGlmIChyZWZSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpXG4gICAgICAgIHJldHVybiBfLmNhbWVsaXplKG5hbWUucmVwbGFjZShyZWZSRSwgJycpKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE1hcCBhIGZ1bmN0aW9uIHRvIGEgcmFuZ2Ugb2Ygbm9kZXMgLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtOb2RlfSBlbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9wXG4gKi9cblxuZXhwb3J0cy5tYXBOb2RlUmFuZ2UgPSBmdW5jdGlvbiAobm9kZSwgZW5kLCBvcCkge1xuICB2YXIgbmV4dFxuICB3aGlsZSAobm9kZSAhPT0gZW5kKSB7XG4gICAgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmdcbiAgICBvcChub2RlKVxuICAgIG5vZGUgPSBuZXh0XG4gIH1cbiAgb3AoZW5kKVxufVxuXG4vKipcbiAqIFJlbW92ZSBhIHJhbmdlIG9mIG5vZGVzIHdpdGggdHJhbnNpdGlvbiwgc3RvcmVcbiAqIHRoZSBub2RlcyBpbiBhIGZyYWdtZW50IHdpdGggY29ycmVjdCBvcmRlcmluZyxcbiAqIGFuZCBjYWxsIGNhbGxiYWNrIHdoZW4gZG9uZS5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IHN0YXJ0XG4gKiBAcGFyYW0ge05vZGV9IGVuZFxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IGZyYWdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKi9cblxuZXhwb3J0cy5yZW1vdmVOb2RlUmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgdm0sIGZyYWcsIGNiKSB7XG4gIHZhciBkb25lID0gZmFsc2VcbiAgdmFyIHJlbW92ZWQgPSAwXG4gIHZhciBub2RlcyA9IFtdXG4gIGV4cG9ydHMubWFwTm9kZVJhbmdlKHN0YXJ0LCBlbmQsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKG5vZGUgPT09IGVuZCkgZG9uZSA9IHRydWVcbiAgICBub2Rlcy5wdXNoKG5vZGUpXG4gICAgdHJhbnNpdGlvbi5yZW1vdmUobm9kZSwgdm0sIG9uUmVtb3ZlZClcbiAgfSlcbiAgZnVuY3Rpb24gb25SZW1vdmVkICgpIHtcbiAgICByZW1vdmVkKytcbiAgICBpZiAoZG9uZSAmJiByZW1vdmVkID49IG5vZGVzLmxlbmd0aCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmcmFnLmFwcGVuZENoaWxkKG5vZGVzW2ldKVxuICAgICAgfVxuICAgICAgY2IgJiYgY2IoKVxuICAgIH1cbiAgfVxufVxuIiwiLy8gY2FuIHdlIHVzZSBfX3Byb3RvX18/XG5leHBvcnRzLmhhc1Byb3RvID0gJ19fcHJvdG9fXycgaW4ge31cblxuLy8gQnJvd3NlciBlbnZpcm9ubWVudCBzbmlmZmluZ1xudmFyIGluQnJvd3NlciA9IGV4cG9ydHMuaW5Ccm93c2VyID1cbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHdpbmRvdykgIT09ICdbb2JqZWN0IE9iamVjdF0nXG5cbmV4cG9ydHMuaXNJRTkgPVxuICBpbkJyb3dzZXIgJiZcbiAgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ21zaWUgOS4wJykgPiAwXG5cbmV4cG9ydHMuaXNBbmRyb2lkID1cbiAgaW5Ccm93c2VyICYmXG4gIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdhbmRyb2lkJykgPiAwXG5cbi8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcbmlmIChpbkJyb3dzZXIgJiYgIWV4cG9ydHMuaXNJRTkpIHtcbiAgdmFyIGlzV2Via2l0VHJhbnMgPVxuICAgIHdpbmRvdy5vbnRyYW5zaXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdHRyYW5zaXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICB2YXIgaXNXZWJraXRBbmltID1cbiAgICB3aW5kb3cub25hbmltYXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdGFuaW1hdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gIGV4cG9ydHMudHJhbnNpdGlvblByb3AgPSBpc1dlYmtpdFRyYW5zXG4gICAgPyAnV2Via2l0VHJhbnNpdGlvbidcbiAgICA6ICd0cmFuc2l0aW9uJ1xuICBleHBvcnRzLnRyYW5zaXRpb25FbmRFdmVudCA9IGlzV2Via2l0VHJhbnNcbiAgICA/ICd3ZWJraXRUcmFuc2l0aW9uRW5kJ1xuICAgIDogJ3RyYW5zaXRpb25lbmQnXG4gIGV4cG9ydHMuYW5pbWF0aW9uUHJvcCA9IGlzV2Via2l0QW5pbVxuICAgID8gJ1dlYmtpdEFuaW1hdGlvbidcbiAgICA6ICdhbmltYXRpb24nXG4gIGV4cG9ydHMuYW5pbWF0aW9uRW5kRXZlbnQgPSBpc1dlYmtpdEFuaW1cbiAgICA/ICd3ZWJraXRBbmltYXRpb25FbmQnXG4gICAgOiAnYW5pbWF0aW9uZW5kJ1xufVxuXG4vKipcbiAqIERlZmVyIGEgdGFzayB0byBleGVjdXRlIGl0IGFzeW5jaHJvbm91c2x5LiBJZGVhbGx5IHRoaXNcbiAqIHNob3VsZCBiZSBleGVjdXRlZCBhcyBhIG1pY3JvdGFzaywgc28gd2UgbGV2ZXJhZ2VcbiAqIE11dGF0aW9uT2JzZXJ2ZXIgaWYgaXQncyBhdmFpbGFibGUsIGFuZCBmYWxsYmFjayB0b1xuICogc2V0VGltZW91dCgwKS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHtPYmplY3R9IGN0eFxuICovXG5cbmV4cG9ydHMubmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgY2FsbGJhY2tzID0gW11cbiAgdmFyIHBlbmRpbmcgPSBmYWxzZVxuICB2YXIgdGltZXJGdW5jXG4gIGZ1bmN0aW9uIG5leHRUaWNrSGFuZGxlciAoKSB7XG4gICAgcGVuZGluZyA9IGZhbHNlXG4gICAgdmFyIGNvcGllcyA9IGNhbGxiYWNrcy5zbGljZSgwKVxuICAgIGNhbGxiYWNrcyA9IFtdXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3BpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvcGllc1tpXSgpXG4gICAgfVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGNvdW50ZXIgPSAxXG4gICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobmV4dFRpY2tIYW5kbGVyKVxuICAgIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNvdW50ZXIpXG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0ZXh0Tm9kZSwge1xuICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxuICAgIH0pXG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgY291bnRlciA9IChjb3VudGVyICsgMSkgJSAyXG4gICAgICB0ZXh0Tm9kZS5kYXRhID0gY291bnRlclxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aW1lckZ1bmMgPSBzZXRUaW1lb3V0XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIChjYiwgY3R4KSB7XG4gICAgdmFyIGZ1bmMgPSBjdHhcbiAgICAgID8gZnVuY3Rpb24gKCkgeyBjYi5jYWxsKGN0eCkgfVxuICAgICAgOiBjYlxuICAgIGNhbGxiYWNrcy5wdXNoKGZ1bmMpXG4gICAgaWYgKHBlbmRpbmcpIHJldHVyblxuICAgIHBlbmRpbmcgPSB0cnVlXG4gICAgdGltZXJGdW5jKG5leHRUaWNrSGFuZGxlciwgMClcbiAgfVxufSkoKVxuIiwidmFyIGxhbmcgPSByZXF1aXJlKCcuL2xhbmcnKVxudmFyIGV4dGVuZCA9IGxhbmcuZXh0ZW5kXG5cbmV4dGVuZChleHBvcnRzLCBsYW5nKVxuZXh0ZW5kKGV4cG9ydHMsIHJlcXVpcmUoJy4vZW52JykpXG5leHRlbmQoZXhwb3J0cywgcmVxdWlyZSgnLi9kb20nKSlcbmV4dGVuZChleHBvcnRzLCByZXF1aXJlKCcuL29wdGlvbnMnKSlcbmV4dGVuZChleHBvcnRzLCByZXF1aXJlKCcuL2NvbXBvbmVudCcpKVxuZXh0ZW5kKGV4cG9ydHMsIHJlcXVpcmUoJy4vZGVidWcnKSlcbiIsIi8qKlxuICogU2V0IGEgcHJvcGVydHkgb24gYW4gb2JqZWN0LiBBZGRzIHRoZSBuZXcgcHJvcGVydHkgYW5kXG4gKiB0cmlnZ2VycyBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlmIHRoZSBwcm9wZXJ0eSBkb2Vzbid0XG4gKiBhbHJlYWR5IGV4aXN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcHVibGljXG4gKi9cblxuZXhwb3J0cy5zZXQgPSBmdW5jdGlvbiBzZXQgKG9iaiwga2V5LCB2YWwpIHtcbiAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgb2JqW2tleV0gPSB2YWxcbiAgICByZXR1cm5cbiAgfVxuICBpZiAob2JqLl9pc1Z1ZSkge1xuICAgIHNldChvYmouX2RhdGEsIGtleSwgdmFsKVxuICAgIHJldHVyblxuICB9XG4gIHZhciBvYiA9IG9iai5fX29iX19cbiAgaWYgKCFvYikge1xuICAgIG9ialtrZXldID0gdmFsXG4gICAgcmV0dXJuXG4gIH1cbiAgb2IuY29udmVydChrZXksIHZhbClcbiAgb2IuZGVwLm5vdGlmeSgpXG4gIGlmIChvYi52bXMpIHtcbiAgICB2YXIgaSA9IG9iLnZtcy5sZW5ndGhcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YXIgdm0gPSBvYi52bXNbaV1cbiAgICAgIHZtLl9wcm94eShrZXkpXG4gICAgICB2bS5fZGlnZXN0KClcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEZWxldGUgYSBwcm9wZXJ0eSBhbmQgdHJpZ2dlciBjaGFuZ2UgaWYgbmVjZXNzYXJ5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqL1xuXG5leHBvcnRzLmRlbGV0ZSA9IGZ1bmN0aW9uIChvYmosIGtleSkge1xuICBpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgZGVsZXRlIG9ialtrZXldXG4gIHZhciBvYiA9IG9iai5fX29iX19cbiAgaWYgKCFvYikge1xuICAgIHJldHVyblxuICB9XG4gIG9iLmRlcC5ub3RpZnkoKVxuICBpZiAob2Iudm1zKSB7XG4gICAgdmFyIGkgPSBvYi52bXMubGVuZ3RoXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFyIHZtID0gb2Iudm1zW2ldXG4gICAgICB2bS5fdW5wcm94eShrZXkpXG4gICAgICB2bS5fZGlnZXN0KClcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBleHByZXNzaW9uIGlzIGEgbGl0ZXJhbCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbnZhciBsaXRlcmFsVmFsdWVSRSA9IC9eXFxzPyh0cnVlfGZhbHNlfFtcXGRcXC5dK3wnW14nXSonfFwiW15cIl0qXCIpXFxzPyQvXG5leHBvcnRzLmlzTGl0ZXJhbCA9IGZ1bmN0aW9uIChleHApIHtcbiAgcmV0dXJuIGxpdGVyYWxWYWx1ZVJFLnRlc3QoZXhwKVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgc3RyaW5nIHN0YXJ0cyB3aXRoICQgb3IgX1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZXhwb3J0cy5pc1Jlc2VydmVkID0gZnVuY3Rpb24gKHN0cikge1xuICB2YXIgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKVxuICByZXR1cm4gYyA9PT0gMHgyNCB8fCBjID09PSAweDVGXG59XG5cbi8qKlxuICogR3VhcmQgdGV4dCBvdXRwdXQsIG1ha2Ugc3VyZSB1bmRlZmluZWQgb3V0cHV0c1xuICogZW1wdHkgc3RyaW5nXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmV4cG9ydHMudG9TdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGxcbiAgICA/ICcnXG4gICAgOiB2YWx1ZS50b1N0cmluZygpXG59XG5cbi8qKlxuICogQ2hlY2sgYW5kIGNvbnZlcnQgcG9zc2libGUgbnVtZXJpYyBzdHJpbmdzIHRvIG51bWJlcnNcbiAqIGJlZm9yZSBzZXR0aW5nIGJhY2sgdG8gZGF0YVxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4geyp8TnVtYmVyfVxuICovXG5cbmV4cG9ydHMudG9OdW1iZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfSBlbHNlIHtcbiAgICB2YXIgcGFyc2VkID0gTnVtYmVyKHZhbHVlKVxuICAgIHJldHVybiBpc05hTihwYXJzZWQpXG4gICAgICA/IHZhbHVlXG4gICAgICA6IHBhcnNlZFxuICB9XG59XG5cbi8qKlxuICogQ29udmVydCBzdHJpbmcgYm9vbGVhbiBsaXRlcmFscyBpbnRvIHJlYWwgYm9vbGVhbnMuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7KnxCb29sZWFufVxuICovXG5cbmV4cG9ydHMudG9Cb29sZWFuID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gJ3RydWUnXG4gICAgPyB0cnVlXG4gICAgOiB2YWx1ZSA9PT0gJ2ZhbHNlJ1xuICAgICAgPyBmYWxzZVxuICAgICAgOiB2YWx1ZVxufVxuXG4vKipcbiAqIFN0cmlwIHF1b3RlcyBmcm9tIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nIHwgZmFsc2V9XG4gKi9cblxuZXhwb3J0cy5zdHJpcFF1b3RlcyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgdmFyIGEgPSBzdHIuY2hhckNvZGVBdCgwKVxuICB2YXIgYiA9IHN0ci5jaGFyQ29kZUF0KHN0ci5sZW5ndGggLSAxKVxuICByZXR1cm4gYSA9PT0gYiAmJiAoYSA9PT0gMHgyMiB8fCBhID09PSAweDI3KVxuICAgID8gc3RyLnNsaWNlKDEsIC0xKVxuICAgIDogc3RyXG59XG5cbi8qKlxuICogQ2FtZWxpemUgYSBoeXBoZW4tZGVsbWl0ZWQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG52YXIgY2FtZWxpemVSRSA9IC8tKFxcdykvZ1xuZXhwb3J0cy5jYW1lbGl6ZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIHRvVXBwZXIpXG59XG5cbmZ1bmN0aW9uIHRvVXBwZXIgKF8sIGMpIHtcbiAgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJ1xufVxuXG4vKipcbiAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbnZhciBoeXBoZW5hdGVSRSA9IC8oW2EtelxcZF0pKFtBLVpdKS9nXG5leHBvcnRzLmh5cGhlbmF0ZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnJDEtJDInKVxuICAgIC50b0xvd2VyQ2FzZSgpXG59XG5cbi8qKlxuICogQ29udmVydHMgaHlwaGVuL3VuZGVyc2NvcmUvc2xhc2ggZGVsaW1pdGVyZWQgbmFtZXMgaW50b1xuICogY2FtZWxpemVkIGNsYXNzTmFtZXMuXG4gKlxuICogZS5nLiBteS1jb21wb25lbnQgPT4gTXlDb21wb25lbnRcbiAqICAgICAgc29tZV9lbHNlICAgID0+IFNvbWVFbHNlXG4gKiAgICAgIHNvbWUvY29tcCAgICA9PiBTb21lQ29tcFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG52YXIgY2xhc3NpZnlSRSA9IC8oPzpefFstX1xcL10pKFxcdykvZ1xuZXhwb3J0cy5jbGFzc2lmeSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNsYXNzaWZ5UkUsIHRvVXBwZXIpXG59XG5cbi8qKlxuICogU2ltcGxlIGJpbmQsIGZhc3RlciB0aGFuIG5hdGl2ZVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5leHBvcnRzLmJpbmQgPSBmdW5jdGlvbiAoZm4sIGN0eCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICByZXR1cm4gbFxuICAgICAgPyBsID4gMVxuICAgICAgICA/IGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKVxuICAgICAgICA6IGZuLmNhbGwoY3R4LCBhKVxuICAgICAgOiBmbi5jYWxsKGN0eClcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgYW4gQXJyYXktbGlrZSBvYmplY3QgdG8gYSByZWFsIEFycmF5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXktbGlrZX0gbGlzdFxuICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydF0gLSBzdGFydCBpbmRleFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuZXhwb3J0cy50b0FycmF5ID0gZnVuY3Rpb24gKGxpc3QsIHN0YXJ0KSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMFxuICB2YXIgaSA9IGxpc3QubGVuZ3RoIC0gc3RhcnRcbiAgdmFyIHJldCA9IG5ldyBBcnJheShpKVxuICB3aGlsZSAoaS0tKSB7XG4gICAgcmV0W2ldID0gbGlzdFtpICsgc3RhcnRdXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKipcbiAqIE1peCBwcm9wZXJ0aWVzIGludG8gdGFyZ2V0IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdG9cbiAqIEBwYXJhbSB7T2JqZWN0fSBmcm9tXG4gKi9cblxuZXhwb3J0cy5leHRlbmQgPSBmdW5jdGlvbiAodG8sIGZyb20pIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcm9tKVxuICB2YXIgaSA9IGtleXMubGVuZ3RoXG4gIHdoaWxlIChpLS0pIHtcbiAgICB0b1trZXlzW2ldXSA9IGZyb21ba2V5c1tpXV1cbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBRdWljayBvYmplY3QgY2hlY2sgLSB0aGlzIGlzIHByaW1hcmlseSB1c2VkIHRvIHRlbGxcbiAqIE9iamVjdHMgZnJvbSBwcmltaXRpdmUgdmFsdWVzIHdoZW4gd2Uga25vdyB0aGUgdmFsdWVcbiAqIGlzIGEgSlNPTi1jb21wbGlhbnQgdHlwZS5cbiAqXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5leHBvcnRzLmlzT2JqZWN0ID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXG59XG5cbi8qKlxuICogU3RyaWN0IG9iamVjdCB0eXBlIGNoZWNrLiBPbmx5IHJldHVybnMgdHJ1ZVxuICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG52YXIgT0JKRUNUX1NUUklORyA9ICdbb2JqZWN0IE9iamVjdF0nXG5leHBvcnRzLmlzUGxhaW5PYmplY3QgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09IE9CSkVDVF9TVFJJTkdcbn1cblxuLyoqXG4gKiBBcnJheSB0eXBlIGNoZWNrLlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmV4cG9ydHMuaXNBcnJheSA9IEFycmF5LmlzQXJyYXlcblxuLyoqXG4gKiBEZWZpbmUgYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtlbnVtZXJhYmxlXVxuICovXG5cbmV4cG9ydHMuZGVmaW5lID0gZnVuY3Rpb24gKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgdmFsdWU6IHZhbCxcbiAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pXG59XG5cbi8qKlxuICogRGVib3VuY2UgYSBmdW5jdGlvbiBzbyBpdCBvbmx5IGdldHMgY2FsbGVkIGFmdGVyIHRoZVxuICogaW5wdXQgc3RvcHMgYXJyaXZpbmcgYWZ0ZXIgdGhlIGdpdmVuIHdhaXQgcGVyaW9kLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmNcbiAqIEBwYXJhbSB7TnVtYmVyfSB3YWl0XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gLSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0cy5kZWJvdW5jZSA9IGZ1bmN0aW9uIChmdW5jLCB3YWl0KSB7XG4gIHZhciB0aW1lb3V0LCBhcmdzLCBjb250ZXh0LCB0aW1lc3RhbXAsIHJlc3VsdFxuICB2YXIgbGF0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxhc3QgPSBEYXRlLm5vdygpIC0gdGltZXN0YW1wXG4gICAgaWYgKGxhc3QgPCB3YWl0ICYmIGxhc3QgPj0gMCkge1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aW1lb3V0ID0gbnVsbFxuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKVxuICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGxcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBjb250ZXh0ID0gdGhpc1xuICAgIGFyZ3MgPSBhcmd1bWVudHNcbiAgICB0aW1lc3RhbXAgPSBEYXRlLm5vdygpXG4gICAgaWYgKCF0aW1lb3V0KSB7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdClcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59XG5cbi8qKlxuICogTWFudWFsIGluZGV4T2YgYmVjYXVzZSBpdCdzIHNsaWdodGx5IGZhc3RlciB0aGFuXG4gKiBuYXRpdmUuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyXG4gKiBAcGFyYW0geyp9IG9ialxuICovXG5cbmV4cG9ydHMuaW5kZXhPZiA9IGZ1bmN0aW9uIChhcnIsIG9iaikge1xuICB2YXIgaSA9IGFyci5sZW5ndGhcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChhcnJbaV0gPT09IG9iaikgcmV0dXJuIGlcbiAgfVxuICByZXR1cm4gLTFcbn1cblxuLyoqXG4gKiBNYWtlIGEgY2FuY2VsbGFibGUgdmVyc2lvbiBvZiBhbiBhc3luYyBjYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZXhwb3J0cy5jYW5jZWxsYWJsZSA9IGZ1bmN0aW9uIChmbikge1xuICB2YXIgY2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgfVxuICB9XG4gIGNiLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjYi5jYW5jZWxsZWQgPSB0cnVlXG4gIH1cbiAgcmV0dXJuIGNiXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHZhbHVlcyBhcmUgbG9vc2VseSBlcXVhbCAtIHRoYXQgaXMsXG4gKiBpZiB0aGV5IGFyZSBwbGFpbiBvYmplY3RzLCBkbyB0aGV5IGhhdmUgdGhlIHNhbWUgc2hhcGU/XG4gKlxuICogQHBhcmFtIHsqfSBhXG4gKiBAcGFyYW0geyp9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZXhwb3J0cy5sb29zZUVxdWFsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgZXFlcWVxICovXG4gIHJldHVybiBhID09IGIgfHwgKFxuICAgIGV4cG9ydHMuaXNPYmplY3QoYSkgJiYgZXhwb3J0cy5pc09iamVjdChiKVxuICAgICAgPyBKU09OLnN0cmluZ2lmeShhKSA9PT0gSlNPTi5zdHJpbmdpZnkoYilcbiAgICAgIDogZmFsc2VcbiAgKVxuICAvKiBlc2xpbnQtZW5hYmxlIGVxZXFlcSAqL1xufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuL2luZGV4JylcbnZhciBjb25maWcgPSByZXF1aXJlKCcuLi9jb25maWcnKVxudmFyIGV4dGVuZCA9IF8uZXh0ZW5kXG5cbi8qKlxuICogT3B0aW9uIG92ZXJ3cml0aW5nIHN0cmF0ZWdpZXMgYXJlIGZ1bmN0aW9ucyB0aGF0IGhhbmRsZVxuICogaG93IHRvIG1lcmdlIGEgcGFyZW50IG9wdGlvbiB2YWx1ZSBhbmQgYSBjaGlsZCBvcHRpb25cbiAqIHZhbHVlIGludG8gdGhlIGZpbmFsIHZhbHVlLlxuICpcbiAqIEFsbCBzdHJhdGVneSBmdW5jdGlvbnMgZm9sbG93IHRoZSBzYW1lIHNpZ25hdHVyZTpcbiAqXG4gKiBAcGFyYW0geyp9IHBhcmVudFZhbFxuICogQHBhcmFtIHsqfSBjaGlsZFZhbFxuICogQHBhcmFtIHtWdWV9IFt2bV1cbiAqL1xuXG52YXIgc3RyYXRzID0gY29uZmlnLm9wdGlvbk1lcmdlU3RyYXRlZ2llcyA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuLyoqXG4gKiBIZWxwZXIgdGhhdCByZWN1cnNpdmVseSBtZXJnZXMgdHdvIGRhdGEgb2JqZWN0cyB0b2dldGhlci5cbiAqL1xuXG5mdW5jdGlvbiBtZXJnZURhdGEgKHRvLCBmcm9tKSB7XG4gIHZhciBrZXksIHRvVmFsLCBmcm9tVmFsXG4gIGZvciAoa2V5IGluIGZyb20pIHtcbiAgICB0b1ZhbCA9IHRvW2tleV1cbiAgICBmcm9tVmFsID0gZnJvbVtrZXldXG4gICAgaWYgKCF0by5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBfLnNldCh0bywga2V5LCBmcm9tVmFsKVxuICAgIH0gZWxzZSBpZiAoXy5pc09iamVjdCh0b1ZhbCkgJiYgXy5pc09iamVjdChmcm9tVmFsKSkge1xuICAgICAgbWVyZ2VEYXRhKHRvVmFsLCBmcm9tVmFsKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBEYXRhXG4gKi9cblxuc3RyYXRzLmRhdGEgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pIHtcbiAgaWYgKCF2bSkge1xuICAgIC8vIGluIGEgVnVlLmV4dGVuZCBtZXJnZSwgYm90aCBzaG91bGQgYmUgZnVuY3Rpb25zXG4gICAgaWYgKCFjaGlsZFZhbCkge1xuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICBpZiAodHlwZW9mIGNoaWxkVmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIF8ud2FybihcbiAgICAgICAgJ1RoZSBcImRhdGFcIiBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gJyArXG4gICAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xuICAgICAgICAnZGVmaW5pdGlvbnMuJ1xuICAgICAgKVxuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICBpZiAoIXBhcmVudFZhbCkge1xuICAgICAgcmV0dXJuIGNoaWxkVmFsXG4gICAgfVxuICAgIC8vIHdoZW4gcGFyZW50VmFsICYgY2hpbGRWYWwgYXJlIGJvdGggcHJlc2VudCxcbiAgICAvLyB3ZSBuZWVkIHRvIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgICAvLyBtZXJnZWQgcmVzdWx0IG9mIGJvdGggZnVuY3Rpb25zLi4uIG5vIG5lZWQgdG9cbiAgICAvLyBjaGVjayBpZiBwYXJlbnRWYWwgaXMgYSBmdW5jdGlvbiBoZXJlIGJlY2F1c2VcbiAgICAvLyBpdCBoYXMgdG8gYmUgYSBmdW5jdGlvbiB0byBwYXNzIHByZXZpb3VzIG1lcmdlcy5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuICgpIHtcbiAgICAgIHJldHVybiBtZXJnZURhdGEoXG4gICAgICAgIGNoaWxkVmFsLmNhbGwodGhpcyksXG4gICAgICAgIHBhcmVudFZhbC5jYWxsKHRoaXMpXG4gICAgICApXG4gICAgfVxuICB9IGVsc2UgaWYgKHBhcmVudFZhbCB8fCBjaGlsZFZhbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWRJbnN0YW5jZURhdGFGbiAoKSB7XG4gICAgICAvLyBpbnN0YW5jZSBtZXJnZVxuICAgICAgdmFyIGluc3RhbmNlRGF0YSA9IHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGNoaWxkVmFsLmNhbGwodm0pXG4gICAgICAgIDogY2hpbGRWYWxcbiAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBwYXJlbnRWYWwuY2FsbCh2bSlcbiAgICAgICAgOiB1bmRlZmluZWRcbiAgICAgIGlmIChpbnN0YW5jZURhdGEpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpbnN0YW5jZURhdGEsIGRlZmF1bHREYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRWxcbiAqL1xuXG5zdHJhdHMuZWwgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pIHtcbiAgaWYgKCF2bSAmJiBjaGlsZFZhbCAmJiB0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIF8ud2FybihcbiAgICAgICdUaGUgXCJlbFwiIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiAnICtcbiAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xuICAgICAgJ2RlZmluaXRpb25zLidcbiAgICApXG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHJldCA9IGNoaWxkVmFsIHx8IHBhcmVudFZhbFxuICAvLyBpbnZva2UgdGhlIGVsZW1lbnQgZmFjdG9yeSBpZiB0aGlzIGlzIGluc3RhbmNlIG1lcmdlXG4gIHJldHVybiB2bSAmJiB0eXBlb2YgcmV0ID09PSAnZnVuY3Rpb24nXG4gICAgPyByZXQuY2FsbCh2bSlcbiAgICA6IHJldFxufVxuXG4vKipcbiAqIEhvb2tzIGFuZCBwYXJhbSBhdHRyaWJ1dGVzIGFyZSBtZXJnZWQgYXMgYXJyYXlzLlxuICovXG5cbnN0cmF0cy5pbml0ID1cbnN0cmF0cy5jcmVhdGVkID1cbnN0cmF0cy5yZWFkeSA9XG5zdHJhdHMuYXR0YWNoZWQgPVxuc3RyYXRzLmRldGFjaGVkID1cbnN0cmF0cy5iZWZvcmVDb21waWxlID1cbnN0cmF0cy5jb21waWxlZCA9XG5zdHJhdHMuYmVmb3JlRGVzdHJveSA9XG5zdHJhdHMuZGVzdHJveWVkID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgcmV0dXJuIGNoaWxkVmFsXG4gICAgPyBwYXJlbnRWYWxcbiAgICAgID8gcGFyZW50VmFsLmNvbmNhdChjaGlsZFZhbClcbiAgICAgIDogXy5pc0FycmF5KGNoaWxkVmFsKVxuICAgICAgICA/IGNoaWxkVmFsXG4gICAgICAgIDogW2NoaWxkVmFsXVxuICAgIDogcGFyZW50VmFsXG59XG5cbi8qKlxuICogMC4xMSBkZXByZWNhdGlvbiB3YXJuaW5nXG4gKi9cblxuc3RyYXRzLnBhcmFtQXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBfLndhcm4oXG4gICAgJ1wicGFyYW1BdHRyaWJ1dGVzXCIgb3B0aW9uIGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gMC4xMi4gJyArXG4gICAgJ1VzZSBcInByb3BzXCIgaW5zdGVhZC4nXG4gIClcbn1cblxuLyoqXG4gKiBBc3NldHNcbiAqXG4gKiBXaGVuIGEgdm0gaXMgcHJlc2VudCAoaW5zdGFuY2UgY3JlYXRpb24pLCB3ZSBuZWVkIHRvIGRvXG4gKiBhIHRocmVlLXdheSBtZXJnZSBiZXR3ZWVuIGNvbnN0cnVjdG9yIG9wdGlvbnMsIGluc3RhbmNlXG4gKiBvcHRpb25zIGFuZCBwYXJlbnQgb3B0aW9ucy5cbiAqL1xuXG5mdW5jdGlvbiBtZXJnZUFzc2V0cyAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwpXG4gIHJldHVybiBjaGlsZFZhbFxuICAgID8gZXh0ZW5kKHJlcywgZ3VhcmRBcnJheUFzc2V0cyhjaGlsZFZhbCkpXG4gICAgOiByZXNcbn1cblxuY29uZmlnLl9hc3NldFR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgc3RyYXRzW3R5cGUgKyAncyddID0gbWVyZ2VBc3NldHNcbn0pXG5cbi8qKlxuICogRXZlbnRzICYgV2F0Y2hlcnMuXG4gKlxuICogRXZlbnRzICYgd2F0Y2hlcnMgaGFzaGVzIHNob3VsZCBub3Qgb3ZlcndyaXRlIG9uZVxuICogYW5vdGhlciwgc28gd2UgbWVyZ2UgdGhlbSBhcyBhcnJheXMuXG4gKi9cblxuc3RyYXRzLndhdGNoID1cbnN0cmF0cy5ldmVudHMgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICBpZiAoIWNoaWxkVmFsKSByZXR1cm4gcGFyZW50VmFsXG4gIGlmICghcGFyZW50VmFsKSByZXR1cm4gY2hpbGRWYWxcbiAgdmFyIHJldCA9IHt9XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbClcbiAgZm9yICh2YXIga2V5IGluIGNoaWxkVmFsKSB7XG4gICAgdmFyIHBhcmVudCA9IHJldFtrZXldXG4gICAgdmFyIGNoaWxkID0gY2hpbGRWYWxba2V5XVxuICAgIGlmIChwYXJlbnQgJiYgIV8uaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBwYXJlbnQgPSBbcGFyZW50XVxuICAgIH1cbiAgICByZXRba2V5XSA9IHBhcmVudFxuICAgICAgPyBwYXJlbnQuY29uY2F0KGNoaWxkKVxuICAgICAgOiBbY2hpbGRdXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKipcbiAqIE90aGVyIG9iamVjdCBoYXNoZXMuXG4gKi9cblxuc3RyYXRzLnByb3BzID1cbnN0cmF0cy5tZXRob2RzID1cbnN0cmF0cy5jb21wdXRlZCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIGlmICghY2hpbGRWYWwpIHJldHVybiBwYXJlbnRWYWxcbiAgaWYgKCFwYXJlbnRWYWwpIHJldHVybiBjaGlsZFZhbFxuICB2YXIgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpXG4gIGV4dGVuZChyZXQsIGNoaWxkVmFsKVxuICByZXR1cm4gcmV0XG59XG5cbi8qKlxuICogRGVmYXVsdCBzdHJhdGVneS5cbiAqL1xuXG52YXIgZGVmYXVsdFN0cmF0ID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgcmV0dXJuIGNoaWxkVmFsID09PSB1bmRlZmluZWRcbiAgICA/IHBhcmVudFZhbFxuICAgIDogY2hpbGRWYWxcbn1cblxuLyoqXG4gKiBNYWtlIHN1cmUgY29tcG9uZW50IG9wdGlvbnMgZ2V0IGNvbnZlcnRlZCB0byBhY3R1YWxcbiAqIGNvbnN0cnVjdG9ycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIGd1YXJkQ29tcG9uZW50cyAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5jb21wb25lbnRzKSB7XG4gICAgdmFyIGNvbXBvbmVudHMgPSBvcHRpb25zLmNvbXBvbmVudHMgPVxuICAgICAgZ3VhcmRBcnJheUFzc2V0cyhvcHRpb25zLmNvbXBvbmVudHMpXG4gICAgdmFyIGRlZlxuICAgIHZhciBpZHMgPSBPYmplY3Qua2V5cyhjb21wb25lbnRzKVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gaWRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGlkc1tpXVxuICAgICAgaWYgKF8uY29tbW9uVGFnUkUudGVzdChrZXkpKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgXy53YXJuKFxuICAgICAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgICAgICdpZDogJyArIGtleVxuICAgICAgICApXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBkZWYgPSBjb21wb25lbnRzW2tleV1cbiAgICAgIGlmIChfLmlzUGxhaW5PYmplY3QoZGVmKSkge1xuICAgICAgICBjb21wb25lbnRzW2tleV0gPSBfLlZ1ZS5leHRlbmQoZGVmKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZSBhbGwgcHJvcHMgb3B0aW9uIHN5bnRheCBhcmUgbm9ybWFsaXplZCBpbnRvIHRoZVxuICogT2JqZWN0LWJhc2VkIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIGd1YXJkUHJvcHMgKG9wdGlvbnMpIHtcbiAgdmFyIHByb3BzID0gb3B0aW9ucy5wcm9wc1xuICB2YXIgaVxuICBpZiAoXy5pc0FycmF5KHByb3BzKSkge1xuICAgIG9wdGlvbnMucHJvcHMgPSB7fVxuICAgIGkgPSBwcm9wcy5sZW5ndGhcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBvcHRpb25zLnByb3BzW3Byb3BzW2ldXSA9IG51bGxcbiAgICB9XG4gIH0gZWxzZSBpZiAoXy5pc1BsYWluT2JqZWN0KHByb3BzKSkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcHMpXG4gICAgaSA9IGtleXMubGVuZ3RoXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFyIHZhbCA9IHByb3BzW2tleXNbaV1dXG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcm9wc1trZXlzW2ldXSA9IHsgdHlwZTogdmFsIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHdWFyZCBhbiBBcnJheS1mb3JtYXQgYXNzZXRzIG9wdGlvbiBhbmQgY29udmVydGVkIGl0XG4gKiBpbnRvIHRoZSBrZXktdmFsdWUgT2JqZWN0IGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gYXNzZXRzXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gZ3VhcmRBcnJheUFzc2V0cyAoYXNzZXRzKSB7XG4gIGlmIChfLmlzQXJyYXkoYXNzZXRzKSkge1xuICAgIHZhciByZXMgPSB7fVxuICAgIHZhciBpID0gYXNzZXRzLmxlbmd0aFxuICAgIHZhciBhc3NldFxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGFzc2V0ID0gYXNzZXRzW2ldXG4gICAgICB2YXIgaWQgPSB0eXBlb2YgYXNzZXQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyAoKGFzc2V0Lm9wdGlvbnMgJiYgYXNzZXQub3B0aW9ucy5uYW1lKSB8fCBhc3NldC5pZClcbiAgICAgICAgOiAoYXNzZXQubmFtZSB8fCBhc3NldC5pZClcbiAgICAgIGlmICghaWQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBfLndhcm4oXG4gICAgICAgICAgJ0FycmF5LXN5bnRheCBhc3NldHMgbXVzdCBwcm92aWRlIGEgXCJuYW1lXCIgb3IgXCJpZFwiIGZpZWxkLidcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzW2lkXSA9IGFzc2V0XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxuICByZXR1cm4gYXNzZXRzXG59XG5cbi8qKlxuICogTWVyZ2UgdHdvIG9wdGlvbiBvYmplY3RzIGludG8gYSBuZXcgb25lLlxuICogQ29yZSB1dGlsaXR5IHVzZWQgaW4gYm90aCBpbnN0YW50aWF0aW9uIGFuZCBpbmhlcml0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyZW50XG4gKiBAcGFyYW0ge09iamVjdH0gY2hpbGRcbiAqIEBwYXJhbSB7VnVlfSBbdm1dIC0gaWYgdm0gaXMgcHJlc2VudCwgaW5kaWNhdGVzIHRoaXMgaXNcbiAqICAgICAgICAgICAgICAgICAgICAgYW4gaW5zdGFudGlhdGlvbiBtZXJnZS5cbiAqL1xuXG5leHBvcnRzLm1lcmdlT3B0aW9ucyA9IGZ1bmN0aW9uIG1lcmdlIChwYXJlbnQsIGNoaWxkLCB2bSkge1xuICBndWFyZENvbXBvbmVudHMoY2hpbGQpXG4gIGd1YXJkUHJvcHMoY2hpbGQpXG4gIHZhciBvcHRpb25zID0ge31cbiAgdmFyIGtleVxuICBpZiAoY2hpbGQubWl4aW5zKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBwYXJlbnQgPSBtZXJnZShwYXJlbnQsIGNoaWxkLm1peGluc1tpXSwgdm0pXG4gICAgfVxuICB9XG4gIGZvciAoa2V5IGluIHBhcmVudCkge1xuICAgIG1lcmdlRmllbGQoa2V5KVxuICB9XG4gIGZvciAoa2V5IGluIGNoaWxkKSB7XG4gICAgaWYgKCEocGFyZW50Lmhhc093blByb3BlcnR5KGtleSkpKSB7XG4gICAgICBtZXJnZUZpZWxkKGtleSlcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbWVyZ2VGaWVsZCAoa2V5KSB7XG4gICAgdmFyIHN0cmF0ID0gc3RyYXRzW2tleV0gfHwgZGVmYXVsdFN0cmF0XG4gICAgb3B0aW9uc1trZXldID0gc3RyYXQocGFyZW50W2tleV0sIGNoaWxkW2tleV0sIHZtLCBrZXkpXG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGFuIGFzc2V0LlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJlY2F1c2UgY2hpbGQgaW5zdGFuY2VzIG5lZWQgYWNjZXNzXG4gKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAqIEByZXR1cm4ge09iamVjdHxGdW5jdGlvbn1cbiAqL1xuXG5leHBvcnRzLnJlc29sdmVBc3NldCA9IGZ1bmN0aW9uIHJlc29sdmUgKG9wdGlvbnMsIHR5cGUsIGlkKSB7XG4gIHZhciBhc3NldHMgPSBvcHRpb25zW3R5cGVdXG4gIHZhciBjYW1lbGl6ZWRJZFxuICByZXR1cm4gYXNzZXRzW2lkXSB8fFxuICAgIC8vIGNhbWVsQ2FzZSBJRFxuICAgIGFzc2V0c1tjYW1lbGl6ZWRJZCA9IF8uY2FtZWxpemUoaWQpXSB8fFxuICAgIC8vIFBhc2NhbCBDYXNlIElEXG4gICAgYXNzZXRzW2NhbWVsaXplZElkLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgY2FtZWxpemVkSWQuc2xpY2UoMSldXG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4vdXRpbCcpXG52YXIgZXh0ZW5kID0gXy5leHRlbmRcblxuLyoqXG4gKiBUaGUgZXhwb3NlZCBWdWUgY29uc3RydWN0b3IuXG4gKlxuICogQVBJIGNvbnZlbnRpb25zOlxuICogLSBwdWJsaWMgQVBJIG1ldGhvZHMvcHJvcGVydGllcyBhcmUgcHJlZmlleGVkIHdpdGggYCRgXG4gKiAtIGludGVybmFsIG1ldGhvZHMvcHJvcGVydGllcyBhcmUgcHJlZml4ZWQgd2l0aCBgX2BcbiAqIC0gbm9uLXByZWZpeGVkIHByb3BlcnRpZXMgYXJlIGFzc3VtZWQgdG8gYmUgcHJveGllZCB1c2VyXG4gKiAgIGRhdGEuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gVnVlIChvcHRpb25zKSB7XG4gIHRoaXMuX2luaXQob3B0aW9ucylcbn1cblxuLyoqXG4gKiBNaXhpbiBnbG9iYWwgQVBJXG4gKi9cblxuZXh0ZW5kKFZ1ZSwgcmVxdWlyZSgnLi9hcGkvZ2xvYmFsJykpXG5cbi8qKlxuICogVnVlIGFuZCBldmVyeSBjb25zdHJ1Y3RvciB0aGF0IGV4dGVuZHMgVnVlIGhhcyBhblxuICogYXNzb2NpYXRlZCBvcHRpb25zIG9iamVjdCwgd2hpY2ggY2FuIGJlIGFjY2Vzc2VkIGR1cmluZ1xuICogY29tcGlsYXRpb24gc3RlcHMgYXMgYHRoaXMuY29uc3RydWN0b3Iub3B0aW9uc2AuXG4gKlxuICogVGhlc2UgY2FuIGJlIHNlZW4gYXMgdGhlIGRlZmF1bHQgb3B0aW9ucyBvZiBldmVyeVxuICogVnVlIGluc3RhbmNlLlxuICovXG5cblZ1ZS5vcHRpb25zID0ge1xuICByZXBsYWNlOiB0cnVlLFxuICBkaXJlY3RpdmVzOiByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvcHVibGljJyksXG4gIGVsZW1lbnREaXJlY3RpdmVzOiByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvZWxlbWVudCcpLFxuICBmaWx0ZXJzOiByZXF1aXJlKCcuL2ZpbHRlcnMnKSxcbiAgdHJhbnNpdGlvbnM6IHt9LFxuICBjb21wb25lbnRzOiB7fSxcbiAgcGFydGlhbHM6IHt9XG59XG5cbi8qKlxuICogQnVpbGQgdXAgdGhlIHByb3RvdHlwZVxuICovXG5cbnZhciBwID0gVnVlLnByb3RvdHlwZVxuXG4vKipcbiAqICRkYXRhIGhhcyBhIHNldHRlciB3aGljaCBkb2VzIGEgYnVuY2ggb2ZcbiAqIHRlYXJkb3duL3NldHVwIHdvcmtcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkocCwgJyRkYXRhJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVxuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIChuZXdEYXRhKSB7XG4gICAgaWYgKG5ld0RhdGEgIT09IHRoaXMuX2RhdGEpIHtcbiAgICAgIHRoaXMuX3NldERhdGEobmV3RGF0YSlcbiAgICB9XG4gIH1cbn0pXG5cbi8qKlxuICogTWl4aW4gaW50ZXJuYWwgaW5zdGFuY2UgbWV0aG9kc1xuICovXG5cbmV4dGVuZChwLCByZXF1aXJlKCcuL2luc3RhbmNlL2luaXQnKSlcbmV4dGVuZChwLCByZXF1aXJlKCcuL2luc3RhbmNlL2V2ZW50cycpKVxuZXh0ZW5kKHAsIHJlcXVpcmUoJy4vaW5zdGFuY2Uvc3RhdGUnKSlcbmV4dGVuZChwLCByZXF1aXJlKCcuL2luc3RhbmNlL2xpZmVjeWNsZScpKVxuZXh0ZW5kKHAsIHJlcXVpcmUoJy4vaW5zdGFuY2UvbWlzYycpKVxuXG4vKipcbiAqIE1peGluIHB1YmxpYyBBUEkgbWV0aG9kc1xuICovXG5cbmV4dGVuZChwLCByZXF1aXJlKCcuL2FwaS9kYXRhJykpXG5leHRlbmQocCwgcmVxdWlyZSgnLi9hcGkvZG9tJykpXG5leHRlbmQocCwgcmVxdWlyZSgnLi9hcGkvZXZlbnRzJykpXG5leHRlbmQocCwgcmVxdWlyZSgnLi9hcGkvbGlmZWN5Y2xlJykpXG5cblZ1ZS52ZXJzaW9uID0gJzEuMC40J1xubW9kdWxlLmV4cG9ydHMgPSBfLlZ1ZSA9IFZ1ZVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGlmIChfLmluQnJvd3NlciAmJiB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXykge1xuICAgIHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fLmVtaXQoJ2luaXQnLCBWdWUpXG4gIH1cbn1cbiIsInZhciBfID0gcmVxdWlyZSgnLi91dGlsJylcbnZhciBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpXG52YXIgRGVwID0gcmVxdWlyZSgnLi9vYnNlcnZlci9kZXAnKVxudmFyIGV4cFBhcnNlciA9IHJlcXVpcmUoJy4vcGFyc2Vycy9leHByZXNzaW9uJylcbnZhciBiYXRjaGVyID0gcmVxdWlyZSgnLi9iYXRjaGVyJylcbnZhciB1aWQgPSAwXG5cbi8qKlxuICogQSB3YXRjaGVyIHBhcnNlcyBhbiBleHByZXNzaW9uLCBjb2xsZWN0cyBkZXBlbmRlbmNpZXMsXG4gKiBhbmQgZmlyZXMgY2FsbGJhY2sgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBjaGFuZ2VzLlxuICogVGhpcyBpcyB1c2VkIGZvciBib3RoIHRoZSAkd2F0Y2goKSBhcGkgYW5kIGRpcmVjdGl2ZXMuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwcmVzc2lvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgICAgICAgICAgICAgICAgLSB7QXJyYXl9IGZpbHRlcnNcbiAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSB0d29XYXlcbiAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSBkZWVwXG4gKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gdXNlclxuICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IHN5bmNcbiAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSBsYXp5XG4gKiAgICAgICAgICAgICAgICAgLSB7RnVuY3Rpb259IFtwcmVQcm9jZXNzXVxuICogICAgICAgICAgICAgICAgIC0ge0Z1bmN0aW9ufSBbcG9zdFByb2Nlc3NdXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5mdW5jdGlvbiBXYXRjaGVyICh2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpIHtcbiAgLy8gbWl4IGluIG9wdGlvbnNcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBfLmV4dGVuZCh0aGlzLCBvcHRpb25zKVxuICB9XG4gIHZhciBpc0ZuID0gdHlwZW9mIGV4cE9yRm4gPT09ICdmdW5jdGlvbidcbiAgdGhpcy52bSA9IHZtXG4gIHZtLl93YXRjaGVycy5wdXNoKHRoaXMpXG4gIHRoaXMuZXhwcmVzc2lvbiA9IGlzRm4gPyBleHBPckZuLnRvU3RyaW5nKCkgOiBleHBPckZuXG4gIHRoaXMuY2IgPSBjYlxuICB0aGlzLmlkID0gKyt1aWQgLy8gdWlkIGZvciBiYXRjaGluZ1xuICB0aGlzLmFjdGl2ZSA9IHRydWVcbiAgdGhpcy5kaXJ0eSA9IHRoaXMubGF6eSAvLyBmb3IgbGF6eSB3YXRjaGVyc1xuICB0aGlzLmRlcHMgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gIHRoaXMubmV3RGVwcyA9IG51bGxcbiAgdGhpcy5wcmV2RXJyb3IgPSBudWxsIC8vIGZvciBhc3luYyBlcnJvciBzdGFja3NcbiAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyL3NldHRlclxuICBpZiAoaXNGbikge1xuICAgIHRoaXMuZ2V0dGVyID0gZXhwT3JGblxuICAgIHRoaXMuc2V0dGVyID0gdW5kZWZpbmVkXG4gIH0gZWxzZSB7XG4gICAgdmFyIHJlcyA9IGV4cFBhcnNlci5wYXJzZShleHBPckZuLCB0aGlzLnR3b1dheSlcbiAgICB0aGlzLmdldHRlciA9IHJlcy5nZXRcbiAgICB0aGlzLnNldHRlciA9IHJlcy5zZXRcbiAgfVxuICB0aGlzLnZhbHVlID0gdGhpcy5sYXp5XG4gICAgPyB1bmRlZmluZWRcbiAgICA6IHRoaXMuZ2V0KClcbiAgLy8gc3RhdGUgZm9yIGF2b2lkaW5nIGZhbHNlIHRyaWdnZXJzIGZvciBkZWVwIGFuZCBBcnJheVxuICAvLyB3YXRjaGVycyBkdXJpbmcgdm0uX2RpZ2VzdCgpXG4gIHRoaXMucXVldWVkID0gdGhpcy5zaGFsbG93ID0gZmFsc2Vcbn1cblxuLyoqXG4gKiBBZGQgYSBkZXBlbmRlbmN5IHRvIHRoaXMgZGlyZWN0aXZlLlxuICpcbiAqIEBwYXJhbSB7RGVwfSBkZXBcbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5hZGREZXAgPSBmdW5jdGlvbiAoZGVwKSB7XG4gIHZhciBpZCA9IGRlcC5pZFxuICBpZiAoIXRoaXMubmV3RGVwc1tpZF0pIHtcbiAgICB0aGlzLm5ld0RlcHNbaWRdID0gZGVwXG4gICAgaWYgKCF0aGlzLmRlcHNbaWRdKSB7XG4gICAgICB0aGlzLmRlcHNbaWRdID0gZGVwXG4gICAgICBkZXAuYWRkU3ViKHRoaXMpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIGdldHRlciwgYW5kIHJlLWNvbGxlY3QgZGVwZW5kZW5jaWVzLlxuICovXG5cbldhdGNoZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5iZWZvcmVHZXQoKVxuICB2YXIgc2NvcGUgPSB0aGlzLnNjb3BlIHx8IHRoaXMudm1cbiAgdmFyIHZhbHVlXG4gIHRyeSB7XG4gICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHNjb3BlLCBzY29wZSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIGNvbmZpZy53YXJuRXhwcmVzc2lvbkVycm9yc1xuICAgICkge1xuICAgICAgXy53YXJuKFxuICAgICAgICAnRXJyb3Igd2hlbiBldmFsdWF0aW5nIGV4cHJlc3Npb24gXCInICtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uICsgJ1wiLiAnICtcbiAgICAgICAgKGNvbmZpZy5kZWJ1Z1xuICAgICAgICAgID8gJydcbiAgICAgICAgICA6ICdUdXJuIG9uIGRlYnVnIG1vZGUgdG8gc2VlIHN0YWNrIHRyYWNlLidcbiAgICAgICAgKSwgZVxuICAgICAgKVxuICAgIH1cbiAgfVxuICAvLyBcInRvdWNoXCIgZXZlcnkgcHJvcGVydHkgc28gdGhleSBhcmUgYWxsIHRyYWNrZWQgYXNcbiAgLy8gZGVwZW5kZW5jaWVzIGZvciBkZWVwIHdhdGNoaW5nXG4gIGlmICh0aGlzLmRlZXApIHtcbiAgICB0cmF2ZXJzZSh2YWx1ZSlcbiAgfVxuICBpZiAodGhpcy5wcmVQcm9jZXNzKSB7XG4gICAgdmFsdWUgPSB0aGlzLnByZVByb2Nlc3ModmFsdWUpXG4gIH1cbiAgaWYgKHRoaXMuZmlsdGVycykge1xuICAgIHZhbHVlID0gc2NvcGUuX2FwcGx5RmlsdGVycyh2YWx1ZSwgbnVsbCwgdGhpcy5maWx0ZXJzLCBmYWxzZSlcbiAgfVxuICBpZiAodGhpcy5wb3N0UHJvY2Vzcykge1xuICAgIHZhbHVlID0gdGhpcy5wb3N0UHJvY2Vzcyh2YWx1ZSlcbiAgfVxuICB0aGlzLmFmdGVyR2V0KClcbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8qKlxuICogU2V0IHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIHdpdGggdGhlIHNldHRlci5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHZhciBzY29wZSA9IHRoaXMuc2NvcGUgfHwgdGhpcy52bVxuICBpZiAodGhpcy5maWx0ZXJzKSB7XG4gICAgdmFsdWUgPSBzY29wZS5fYXBwbHlGaWx0ZXJzKFxuICAgICAgdmFsdWUsIHRoaXMudmFsdWUsIHRoaXMuZmlsdGVycywgdHJ1ZSlcbiAgfVxuICB0cnkge1xuICAgIHRoaXMuc2V0dGVyLmNhbGwoc2NvcGUsIHNjb3BlLCB2YWx1ZSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIGNvbmZpZy53YXJuRXhwcmVzc2lvbkVycm9yc1xuICAgICkge1xuICAgICAgXy53YXJuKFxuICAgICAgICAnRXJyb3Igd2hlbiBldmFsdWF0aW5nIHNldHRlciBcIicgK1xuICAgICAgICB0aGlzLmV4cHJlc3Npb24gKyAnXCInLCBlXG4gICAgICApXG4gICAgfVxuICB9XG4gIC8vIHR3by13YXkgc3luYyBmb3Igdi1mb3IgYWxpYXNcbiAgdmFyIGZvckNvbnRleHQgPSBzY29wZS4kZm9yQ29udGV4dFxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChcbiAgICAgIGZvckNvbnRleHQgJiZcbiAgICAgIGZvckNvbnRleHQuZmlsdGVycyAmJlxuICAgICAgKG5ldyBSZWdFeHAoZm9yQ29udGV4dC5hbGlhcyArICdcXFxcYicpKS50ZXN0KHRoaXMuZXhwcmVzc2lvbilcbiAgICApIHtcbiAgICAgIF8ud2FybihcbiAgICAgICAgJ0l0IHNlZW1zIHlvdSBhcmUgdXNpbmcgdHdvLXdheSBiaW5kaW5nIG9uICcgK1xuICAgICAgICAnYSB2LWZvciBhbGlhcyAoJyArIHRoaXMuZXhwcmVzc2lvbiArICcpLCBhbmQgdGhlICcgK1xuICAgICAgICAndi1mb3IgaGFzIGZpbHRlcnMuIFRoaXMgd2lsbCBub3Qgd29yayBwcm9wZXJseS4gJyArXG4gICAgICAgICdFaXRoZXIgcmVtb3ZlIHRoZSBmaWx0ZXJzIG9yIHVzZSBhbiBhcnJheSBvZiAnICtcbiAgICAgICAgJ29iamVjdHMgYW5kIGJpbmQgdG8gb2JqZWN0IHByb3BlcnRpZXMgaW5zdGVhZC4nXG4gICAgICApXG4gICAgfVxuICB9XG4gIGlmIChcbiAgICBmb3JDb250ZXh0ICYmXG4gICAgZm9yQ29udGV4dC5hbGlhcyA9PT0gdGhpcy5leHByZXNzaW9uICYmXG4gICAgIWZvckNvbnRleHQuZmlsdGVyc1xuICApIHtcbiAgICBpZiAoc2NvcGUuJGtleSkgeyAvLyBvcmlnaW5hbCBpcyBhbiBvYmplY3RcbiAgICAgIGZvckNvbnRleHQucmF3VmFsdWVbc2NvcGUuJGtleV0gPSB2YWx1ZVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3JDb250ZXh0LnJhd1ZhbHVlLiRzZXQoc2NvcGUuJGluZGV4LCB2YWx1ZSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBQcmVwYXJlIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUuYmVmb3JlR2V0ID0gZnVuY3Rpb24gKCkge1xuICBEZXAudGFyZ2V0ID0gdGhpc1xuICB0aGlzLm5ld0RlcHMgPSBPYmplY3QuY3JlYXRlKG51bGwpXG59XG5cbi8qKlxuICogQ2xlYW4gdXAgZm9yIGRlcGVuZGVuY3kgY29sbGVjdGlvbi5cbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5hZnRlckdldCA9IGZ1bmN0aW9uICgpIHtcbiAgRGVwLnRhcmdldCA9IG51bGxcbiAgdmFyIGlkcyA9IE9iamVjdC5rZXlzKHRoaXMuZGVwcylcbiAgdmFyIGkgPSBpZHMubGVuZ3RoXG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgaWQgPSBpZHNbaV1cbiAgICBpZiAoIXRoaXMubmV3RGVwc1tpZF0pIHtcbiAgICAgIHRoaXMuZGVwc1tpZF0ucmVtb3ZlU3ViKHRoaXMpXG4gICAgfVxuICB9XG4gIHRoaXMuZGVwcyA9IHRoaXMubmV3RGVwc1xufVxuXG4vKipcbiAqIFN1YnNjcmliZXIgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgd2hlbiBhIGRlcGVuZGVuY3kgY2hhbmdlcy5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHNoYWxsb3dcbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoc2hhbGxvdykge1xuICBpZiAodGhpcy5sYXp5KSB7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWVcbiAgfSBlbHNlIGlmICh0aGlzLnN5bmMgfHwgIWNvbmZpZy5hc3luYykge1xuICAgIHRoaXMucnVuKClcbiAgfSBlbHNlIHtcbiAgICAvLyBpZiBxdWV1ZWQsIG9ubHkgb3ZlcndyaXRlIHNoYWxsb3cgd2l0aCBub24tc2hhbGxvdyxcbiAgICAvLyBidXQgbm90IHRoZSBvdGhlciB3YXkgYXJvdW5kLlxuICAgIHRoaXMuc2hhbGxvdyA9IHRoaXMucXVldWVkXG4gICAgICA/IHNoYWxsb3dcbiAgICAgICAgPyB0aGlzLnNoYWxsb3dcbiAgICAgICAgOiBmYWxzZVxuICAgICAgOiAhIXNoYWxsb3dcbiAgICB0aGlzLnF1ZXVlZCA9IHRydWVcbiAgICAvLyByZWNvcmQgYmVmb3JlLXB1c2ggZXJyb3Igc3RhY2sgaW4gZGVidWcgbW9kZVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5kZWJ1Zykge1xuICAgICAgdGhpcy5wcmV2RXJyb3IgPSBuZXcgRXJyb3IoJ1t2dWVdIGFzeW5jIHN0YWNrIHRyYWNlJylcbiAgICB9XG4gICAgYmF0Y2hlci5wdXNoKHRoaXMpXG4gIH1cbn1cblxuLyoqXG4gKiBCYXRjaGVyIGpvYiBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCBieSB0aGUgYmF0Y2hlci5cbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KClcbiAgICBpZiAoXG4gICAgICB2YWx1ZSAhPT0gdGhpcy52YWx1ZSB8fFxuICAgICAgLy8gRGVlcCB3YXRjaGVycyBhbmQgQXJyYXkgd2F0Y2hlcnMgc2hvdWxkIGZpcmUgZXZlblxuICAgICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxuICAgICAgLy8gaGF2ZSBtdXRhdGVkOyBidXQgb25seSBkbyBzbyBpZiB0aGlzIGlzIGFcbiAgICAgIC8vIG5vbi1zaGFsbG93IHVwZGF0ZSAoY2F1c2VkIGJ5IGEgdm0gZGlnZXN0KS5cbiAgICAgICgoXy5pc0FycmF5KHZhbHVlKSB8fCB0aGlzLmRlZXApICYmICF0aGlzLnNoYWxsb3cpXG4gICAgKSB7XG4gICAgICAvLyBzZXQgbmV3IHZhbHVlXG4gICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlXG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgICAgIC8vIGluIGRlYnVnICsgYXN5bmMgbW9kZSwgd2hlbiBhIHdhdGNoZXIgY2FsbGJhY2tzXG4gICAgICAvLyB0aHJvd3MsIHdlIGFsc28gdGhyb3cgdGhlIHNhdmVkIGJlZm9yZS1wdXNoIGVycm9yXG4gICAgICAvLyBzbyB0aGUgZnVsbCBjcm9zcy10aWNrIHN0YWNrIHRyYWNlIGlzIGF2YWlsYWJsZS5cbiAgICAgIHZhciBwcmV2RXJyb3IgPSB0aGlzLnByZXZFcnJvclxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgIGNvbmZpZy5kZWJ1ZyAmJiBwcmV2RXJyb3IpIHtcbiAgICAgICAgdGhpcy5wcmV2RXJyb3IgPSBudWxsXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSlcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIF8ubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgcHJldkVycm9yXG4gICAgICAgICAgfSwgMClcbiAgICAgICAgICB0aHJvdyBlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucXVldWVkID0gdGhpcy5zaGFsbG93ID0gZmFsc2VcbiAgfVxufVxuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSB2YWx1ZSBvZiB0aGUgd2F0Y2hlci5cbiAqIFRoaXMgb25seSBnZXRzIGNhbGxlZCBmb3IgbGF6eSB3YXRjaGVycy5cbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gYXZvaWQgb3ZlcndyaXRpbmcgYW5vdGhlciB3YXRjaGVyIHRoYXQgaXMgYmVpbmdcbiAgLy8gY29sbGVjdGVkLlxuICB2YXIgY3VycmVudCA9IERlcC50YXJnZXRcbiAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0KClcbiAgdGhpcy5kaXJ0eSA9IGZhbHNlXG4gIERlcC50YXJnZXQgPSBjdXJyZW50XG59XG5cbi8qKlxuICogRGVwZW5kIG9uIGFsbCBkZXBzIGNvbGxlY3RlZCBieSB0aGlzIHdhdGNoZXIuXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZGVwSWRzID0gT2JqZWN0LmtleXModGhpcy5kZXBzKVxuICB2YXIgaSA9IGRlcElkcy5sZW5ndGhcbiAgd2hpbGUgKGktLSkge1xuICAgIHRoaXMuZGVwc1tkZXBJZHNbaV1dLmRlcGVuZCgpXG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgc2VsZiBmcm9tIGFsbCBkZXBlbmRlbmNpZXMnIHN1YmNyaWJlciBsaXN0LlxuICovXG5cbldhdGNoZXIucHJvdG90eXBlLnRlYXJkb3duID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHZtJ3Mgd2F0Y2hlciBsaXN0XG4gICAgLy8gd2UgY2FuIHNraXAgdGhpcyBpZiB0aGUgdm0gaWYgYmVpbmcgZGVzdHJveWVkXG4gICAgLy8gd2hpY2ggY2FuIGltcHJvdmUgdGVhcmRvd24gcGVyZm9ybWFuY2UuXG4gICAgaWYgKCF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICB0aGlzLnZtLl93YXRjaGVycy4kcmVtb3ZlKHRoaXMpXG4gICAgfVxuICAgIHZhciBkZXBJZHMgPSBPYmplY3Qua2V5cyh0aGlzLmRlcHMpXG4gICAgdmFyIGkgPSBkZXBJZHMubGVuZ3RoXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcy5kZXBzW2RlcElkc1tpXV0ucmVtb3ZlU3ViKHRoaXMpXG4gICAgfVxuICAgIHRoaXMuYWN0aXZlID0gZmFsc2VcbiAgICB0aGlzLnZtID0gdGhpcy5jYiA9IHRoaXMudmFsdWUgPSBudWxsXG4gIH1cbn1cblxuLyoqXG4gKiBSZWNydXNpdmVseSB0cmF2ZXJzZSBhbiBvYmplY3QgdG8gZXZva2UgYWxsIGNvbnZlcnRlZFxuICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcbiAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXG4gKlxuICogQHBhcmFtIHsqfSB2YWxcbiAqL1xuXG5mdW5jdGlvbiB0cmF2ZXJzZSAodmFsKSB7XG4gIHZhciBpLCBrZXlzXG4gIGlmIChfLmlzQXJyYXkodmFsKSkge1xuICAgIGkgPSB2YWwubGVuZ3RoXG4gICAgd2hpbGUgKGktLSkgdHJhdmVyc2UodmFsW2ldKVxuICB9IGVsc2UgaWYgKF8uaXNPYmplY3QodmFsKSkge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpXG4gICAgaSA9IGtleXMubGVuZ3RoXG4gICAgd2hpbGUgKGktLSkgdHJhdmVyc2UodmFsW2tleXNbaV1dKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gV2F0Y2hlclxuIiwidmFyIGluc2VydGVkID0gZXhwb3J0cy5jYWNoZSA9IHt9XG5cbmV4cG9ydHMuaW5zZXJ0ID0gZnVuY3Rpb24gKGNzcykge1xuICBpZiAoaW5zZXJ0ZWRbY3NzXSkgcmV0dXJuXG4gIGluc2VydGVkW2Nzc10gPSB0cnVlXG5cbiAgdmFyIGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpXG4gIGVsZW0uc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvY3NzJylcblxuICBpZiAoJ3RleHRDb250ZW50JyBpbiBlbGVtKSB7XG4gICAgZWxlbS50ZXh0Q29udGVudCA9IGNzc1xuICB9IGVsc2Uge1xuICAgIGVsZW0uc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzXG4gIH1cblxuICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKGVsZW0pXG4gIHJldHVybiBlbGVtXG59XG4iLCIvLyBJbXBvcnQgcmVxdWlyZW1lbnRzIHVzaW5nIGJyb3dzZXJpZnlcbndpbmRvdy5WdWUgPSByZXF1aXJlKCd2dWUnKVxuVnVlLnVzZShyZXF1aXJlKCd2dWUtcmVzb3VyY2UnKSlcbndpbmRvdy5WdWVSb3V0ZXIgPSByZXF1aXJlKCd2dWUtcm91dGVyJylcblxuXG4vLyBJbnNlcnQgdnVlLXJvdXRlciBhbmQgdnVlLXJlc291cmNlIGludG8gVnVlXG5cbi8vIEltcG9ydCB0aGUgYWN0dWFsIHJvdXRlcywgYWxpYXNlcywgLi4uXG5pbXBvcnQgeyBjb25maWdSb3V0ZXIgfSBmcm9tICcuL3JvdXRlcydcblxuLy8gQ3JlYXRlIG91ciByb3V0ZXIgb2JqZWN0IGFuZCBzZXQgb3B0aW9ucyBvbiBpdFxuY29uc3Qgcm91dGVyID0gbmV3IFZ1ZVJvdXRlcih7XG5cdGhpc3Rvcnk6IHRydWVcbn0pXG5cbi8vIEluamVjdCB0aGUgcm91dGVzIGludG8gdGhlIFZ1ZVJvdXRlciBvYmplY3RcbmNvbmZpZ1JvdXRlcihyb3V0ZXIpXG5cbi8vIENvbmZpZ3VyZSB0aGUgYXBwbGljYXRpb25cbndpbmRvdy5jb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpXG5WdWUuY29uZmlnLmRlYnVnID0gdHJ1ZVxuVnVlLmh0dHAub3B0aW9ucy5yb290ID0gY29uZmlnLmFwaS5iYXNlX3VybDtcblxuLy8gQ29uZmlndXJlIG91ciBIVFRQIGNsaWVudFxudmFyIHJlc3QgPSByZXF1aXJlKCdyZXN0JylcbnZhciBwYXRoUHJlZml4ID0gcmVxdWlyZSgncmVzdC9pbnRlcmNlcHRvci9wYXRoUHJlZml4JylcbnZhciBtaW1lID0gcmVxdWlyZSgncmVzdC9pbnRlcmNlcHRvci9taW1lJylcbnZhciBkZWZhdWx0UmVxdWVzdCA9IHJlcXVpcmUoJ3Jlc3QvaW50ZXJjZXB0b3IvZGVmYXVsdFJlcXVlc3QnKVxudmFyIGVycm9yQ29kZSA9IHJlcXVpcmUoJ3Jlc3QvaW50ZXJjZXB0b3IvZXJyb3JDb2RlJylcbnZhciBpbnRlcmNlcHRvciA9IHJlcXVpcmUoJ3Jlc3QvaW50ZXJjZXB0b3InKVxudmFyIGp3dEF1dGggPSByZXF1aXJlKCcuL2ludGVyY2VwdG9ycy9qd3RBdXRoJylcblxudmFyIHNob3dkb3duICA9IHJlcXVpcmUoJ3Nob3dkb3duJyk7XG53aW5kb3cuY29udmVydGVyID0gbmV3IHNob3dkb3duLkNvbnZlcnRlcigpO1xuXG53aW5kb3cuY2xpZW50ID0gcmVzdC53cmFwKHBhdGhQcmVmaXgsIHsgcHJlZml4OiBjb25maWcuYXBpLmJhc2VfdXJsIH0pXG4gICAgICAgICAgICAgICAgICAgIC53cmFwKG1pbWUpXG4gICAgICAgICAgICAgICAgICAgIC53cmFwKGRlZmF1bHRSZXF1ZXN0LCBjb25maWcuYXBpLmRlZmF1bHRSZXF1ZXN0KVxuICAgICAgICAgICAgICAgICAgICAud3JhcChlcnJvckNvZGUsIHsgY29kZTogNDAwIH0pXG4gICAgICAgICAgICAgICAgICAgIC53cmFwKGp3dEF1dGgpO1xuXG4vLyBCb290c3RyYXAgdGhlIGFwcFxuVnVlLmNvbXBvbmVudCgnbmF2LWNvbXBvbmVudCcsIHJlcXVpcmUoJy4vY29tcGlsZWQvbmF2LnZ1ZScpKVxuVnVlLmNvbXBvbmVudCgnZm9vdGVyLWNvbXBvbmVudCcsIHJlcXVpcmUoJy4vY29tcGlsZWQvZm9vdGVyLnZ1ZScpKVxuVnVlLmNvbXBvbmVudCgncGFnaW5hdGlvbicsIHJlcXVpcmUoJ3Z1ZS1sYXJhdmVsLXBhZ2luYXRpb24nKSlcblxuY29uc3QgQXBwID0gVnVlLmV4dGVuZChyZXF1aXJlKCcuL2NvbXBpbGVkL2FwcC52dWUnKSlcbnJvdXRlci5zdGFydChBcHAsICcjYXBwJylcbndpbmRvdy5yb3V0ZXIgPSByb3V0ZXJcblxuXG5TdHJpbmcucHJvdG90eXBlLnRydW5jID0gU3RyaW5nLnByb3RvdHlwZS50cnVuYyB8fFxuICAgICAgZnVuY3Rpb24obil7XG4gICAgICAgICAgcmV0dXJuICh0aGlzLmxlbmd0aCA+IG4pID8gdGhpcy5zdWJzdHIoMCxuLTEpKycuLi4nIDogdGhpcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIHJlYWR5OiBmdW5jdGlvbiByZWFkeSgpIHtcblxuICAgIHRoaXMuJG9uKCd1c2VySGFzTG9nZ2VkT3V0JywgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5kZXN0cm95TG9naW4oKTtcbiAgICB9KTtcblxuICAgIHRoaXMuJG9uKCd1c2VySGFzTG9nZ2VkSW4nLCBmdW5jdGlvbiAodXNlcikge1xuICAgICAgdGhpcy5zZXRMb2dpbih1c2VyKTtcbiAgICB9KTtcblxuICAgIC8vIFRoZSBhcHAgaGFzIGp1c3QgYmVlbiBpbml0aWFsaXplZCwgY2hlY2sgaWYgd2UgY2FuIGdldCB0aGUgdXNlciBkYXRhIHdpdGggYW4gYWxyZWFkeSBleGlzdGluZyB0b2tlblxuICAgIHZhciB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdqd3QtdG9rZW4nKTtcbiAgICBpZiAodG9rZW4gIT09IG51bGwgJiYgdG9rZW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICBjbGllbnQoeyBwYXRoOiAnL3VzZXJzL21lJyB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAvLyBVc2VyIGhhcyBzdWNjZXNzZnVsbHkgbG9nZ2VkIGluIHVzaW5nIHRoZSB0b2tlbiBmcm9tIHN0b3JhZ2VcbiAgICAgICAgdGhhdC5zZXRMb2dpbihyZXNwb25zZS5lbnRpdHkudXNlcik7XG4gICAgICAgIC8vIGJyb2FkY2FzdCBhbiBldmVudCB0ZWxsaW5nIG91ciBjaGlsZHJlbiB0aGF0IHRoZSBkYXRhIGlzIHJlYWR5IGFuZCB2aWV3cyBjYW4gYmUgcmVuZGVyZWRcbiAgICAgICAgdGhhdC4kYnJvYWRjYXN0KCdkYXRhLWxvYWRlZCcpO1xuICAgICAgfSwgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIC8vIExvZ2luIHdpdGggb3VyIHRva2VuIGZhaWxlZCwgZG8gc29tZSBjbGVhbnVwIGFuZCByZWRpcmVjdCBpZiB3ZSdyZSBvbiBhbiBhdXRoZW50aWNhdGVkIHJvdXRlXG4gICAgICAgIHRoYXQuZGVzdHJveUxvZ2luKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdXNlcjogbnVsbCxcbiAgICAgIHRva2VuOiBudWxsLFxuICAgICAgYXV0aGVudGljYXRlZDogZmFsc2VcbiAgICB9O1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcblxuICAgIHNldExvZ2luOiBmdW5jdGlvbiBzZXRMb2dpbih1c2VyKSB7XG4gICAgICAvLyBTYXZlIGxvZ2luIGluZm8gaW4gb3VyIGRhdGEgYW5kIHNldCBoZWFkZXIgaW4gY2FzZSBpdCdzIG5vdCBzZXQgYWxyZWFkeVxuICAgICAgdGhpcy51c2VyID0gdXNlcjtcbiAgICAgIHRoaXMuYXV0aGVudGljYXRlZCA9IHRydWU7XG4gICAgICB0aGlzLnRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2p3dC10b2tlbicpO1xuICAgIH0sXG5cbiAgICBkZXN0cm95TG9naW46IGZ1bmN0aW9uIGRlc3Ryb3lMb2dpbih1c2VyKSB7XG4gICAgICAvLyBDbGVhbnVwIHdoZW4gdG9rZW4gd2FzIGludmFsaWQgb3VyIHVzZXIgaGFzIGxvZ2dlZCBvdXRcbiAgICAgIHRoaXMudXNlciA9IG51bGw7XG4gICAgICB0aGlzLnRva2VuID0gbnVsbDtcbiAgICAgIHRoaXMuYXV0aGVudGljYXRlZCA9IGZhbHNlO1xuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2p3dC10b2tlbicpO1xuICAgICAgaWYgKHRoaXMuJHJvdXRlLmF1dGgpIHRoaXMuJHJvdXRlLnJvdXRlci5nbygnL2F1dGgvbG9naW4nKTtcbiAgICB9XG4gIH1cblxufTtcbjsodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCI/IG1vZHVsZS5leHBvcnRzLm9wdGlvbnM6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IFwiXFxuPHJvdXRlci12aWV3Pjwvcm91dGVyLXZpZXc+XCJcbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiL1VzZXJzL21lU2luZ2gvU2l0ZXMvX19LaHVyYWZhdFMvTGFyYWdpc3Qub3JnL0hUTUwvcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9hcHAudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMudGVtcGxhdGUpXG4gIH1cbn0pKCl9IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGlua3M6IHtcbiAgICAgICAgZmFjZWJvb2s6ICcnLFxuICAgICAgICB0d2l0dGVyOiAnJyxcbiAgICAgICAgZ2l0aHViOiAnJ1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG47KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiPyBtb2R1bGUuZXhwb3J0cy5vcHRpb25zOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBcIlxcblxcbjxmb290ZXIgY2xhc3M9XFxcImZvb3RlclxcXCI+XFxuXFx0PGRpdiBjbGFzcz1cXFwiY29udGFpbmVyXFxcIiBzdHlsZT1cXFwiY29sb3I6ICM3Nzc7XFxcIj5cXG5cXHRcXHQ8IS0tIENvbXBhbnkgSW5mb3JtYXRpb24gLS0+XFxuXFx0XFx0PGRpdiBjbGFzcz1cXFwicHVsbC1sZWZ0XFxcIiBzdHlsZT1cXFwicGFkZGluZy10b3A6IDIycHg7XFxcIj5cXG5cXHRcXHRcXHRDb3B5cmlnaHQgwqkgMjAxNiA8YSBocmVmPVxcXCJodHRwOi8va2h1cmFmYXRzdHVkaW8uY29tL1xcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiPktodXJhZmF0IFN0dWRpbzwvYT4uIEFsbCByaWdodHMgcmVzZXJ2ZWQuIDwhLS0gLSA8YSB2LWxpbms9XFxcInsgcGF0aDogJy90ZXJtcyd9XFxcIj5UZXJtcyBPZiBTZXJ2aWNlPC9hPiAtLT5cXG5cXHRcXHRcXHQ8IS0tIE1hZGUgd2l0aCA8aSBjbGFzcz1cXFwiZmEgZmEtMnggZmEtaGVhcnRcXFwiPjwvaT4gYnkgPGEgaHJlZj1cXFwiI1xcXCI+TWFuZGVlcCBTaW5naDwvYT4gJiA8YSBocmVmPVxcXCIjXFxcIj5QaXl1c2ggQWdyYXdhbDwvYT4gLS0+XFxuXFx0XFx0PC9kaXY+XFxuXFx0XFx0PCEtLSBTb2NpYWwgSWNvbnMgLS0+XFxuXFx0XFx0PGRpdiBjbGFzcz1cXFwicHVsbC1yaWdodCBmb290ZXItc29jaWFsLWljb25zXFxcIj5cXG5cXHRcXHRcXHQ8YSBocmVmPVxcXCJodHRwOi8vZmFjZWJvb2suY29tL3t7IGxpbmtzLmZhY2Vib29rIH19XFxcIj5cXG5cXHRcXHRcXHRcXHQ8aSBjbGFzcz1cXFwiZmEgZmEtYnRuIGZhLWZhY2Vib29rLXNxdWFyZVxcXCI+PC9pPlxcblxcdFxcdFxcdDwvYT5cXG5cXHRcXHRcXHQ8YSBocmVmPVxcXCJodHRwOi8vdHdpdHRlci5jb20ve3sgbGlua3MudHdpdHRlciB9fVxcXCI+XFxuXFx0XFx0XFx0XFx0PGkgY2xhc3M9XFxcImZhIGZhLWJ0biBmYS10d2l0dGVyLXNxdWFyZVxcXCI+PC9pPlxcblxcdFxcdFxcdDwvYT5cXG5cXHRcXHRcXHQ8YSBocmVmPVxcXCJodHRwOi8vZ2l0aHViLmNvbS97eyBsaW5rcy5naXRodWIgfX1cXFwiPlxcblxcdFxcdFxcdFxcdDxpIGNsYXNzPVxcXCJmYSBmYS1naXRodWItc3F1YXJlXFxcIj48L2k+XFxuXFx0XFx0XFx0PC9hPlxcblxcdFxcdDwvZGl2PlxcblxcdFxcdDxkaXYgY2xhc3M9XFxcImNsZWFyZml4XFxcIj48L2Rpdj5cXG5cXHQ8L2Rpdj5cXG48L2Zvb3Rlcj5cXG5cIlxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCIvVXNlcnMvbWVTaW5naC9TaXRlcy9fX0todXJhZmF0Uy9MYXJhZ2lzdC5vcmcvSFRNTC9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBpbGVkL2Zvb3Rlci52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy50ZW1wbGF0ZSlcbiAgfVxufSkoKX0iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYXZUaXRsZTogJ1Z1ZS5qcydcbiAgICB9O1xuICB9XG59O1xuOyh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIj8gbW9kdWxlLmV4cG9ydHMub3B0aW9uczogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gXCJcXG5cXG48IS0tIE5hdmlnYXRpb24gLS0+XFxuPGhlYWRlciBjbGFzcz1cXFwidG9wLWJhciBuYXZiYXJcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjb250YWluZXJcXFwiIHN0eWxlPVxcXCJwYWRkaW5nOiA0cHg7XFxcIj5cXG4gICAgICAgIDxhIHYtbGluaz1cXFwie3BhdGg6ICcvJ31cXFwiIGNsYXNzPVxcXCJcXFwiPlxcbiAgICAgICAgICAgIDxpbWcgY2xhc3M9XFxcImxvZ29cXFwiIHNyYz1cXFwiLi4vLi4vaW1hZ2VzL2xvZ28yLnBuZ1xcXCIgYWx0PVxcXCJMYXJhZ2lzdFxcXCIgd2lkdGg9XFxcIjE2MHB4XFxcIj5cXG4gICAgICAgIDwvYT5cXG4gICAgICAgIDxuYXYgY2xhc3M9XFxcInB1bGwtcmlnaHRcXFwiPlxcbiAgICAgICAgICAgIDx1bD5cXG4gICAgICAgICAgICAgICAgPGxpPjxhIHYtbGluaz1cXFwie3BhdGg6ICcvJ31cXFwiPiBCcm93c2UgUGFja2FnZXM8L2E+PC9saT5cXG4gICAgICAgICAgICAgICAgPGxpPjxhIHYtbGluaz1cXFwie3BhdGg6ICcvc3VibWl0J31cXFwiPiBTdWJtaXQgQSBQYWNrYWdlPC9hPjwvbGk+XFxuICAgICAgICAgICAgICAgIDxsaT48YSB2LWxpbms9XFxcIntwYXRoOiAnL2Fib3V0J31cXFwiPiBBYm91dDwvYT48L2xpPlxcbiAgICAgICAgICAgICAgICA8bGk+PGEgdi1saW5rPVxcXCJ7cGF0aDogJy9zdXBwb3J0J31cXFwiPiBTdXBwb3J0PC9hPjwvbGk+XFxuICAgICAgICAgICAgPC91bD5cXG4gICAgICAgIDwvbmF2PlxcbiAgICA8L2Rpdj5cXG48L2hlYWRlcj5cXG5cXG5cXG5cIlxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCIvVXNlcnMvbWVTaW5naC9TaXRlcy9fX0todXJhZmF0Uy9MYXJhZ2lzdC5vcmcvSFRNTC9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBpbGVkL25hdi52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy50ZW1wbGF0ZSlcbiAgfVxufSkoKX0iLCJ2YXIgX192dWVpZnlfc3R5bGVfXyA9IHJlcXVpcmUoXCJ2dWVpZnktaW5zZXJ0LWNzc1wiKS5pbnNlcnQoXCJcXG4udGl0bGUge1xcbiAgICBjb2xvcjogIzk5OTtcXG4gICAgZm9udC13ZWlnaHQ6IDEwMDtcXG4gICAgZm9udC1mYW1pbHk6ICdMYXRvJywgSGVsdmV0aWNhLCBzYW5zLXNlcmlmO1xcbiAgICBmb250LXNpemU6IDYwcHg7XFxuICAgIG1hcmdpbi1ib3R0b206IDQwcHg7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgbWFyZ2luLXRvcDogMjAlO1xcbn1cXG4udGl0bGUgYSB7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICBtYXJnaW4tdG9wOiAyMHB4O1xcbn1cXG4udGl0bGUgYTpob3ZlciB7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG59XCIpXG47KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiPyBtb2R1bGUuZXhwb3J0cy5vcHRpb25zOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBcIlxcbjxkaXYgY2xhc3M9XFxcImNvbnRhaW5lci1mbHVpZFxcXCI+XFxuXFx0PGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtM1xcXCI+PC9kaXY+XFxuXFx0XFx0PGRpdiBjbGFzcz1cXFwiY29sLW1kLTYgdGl0bGVcXFwiPlxcblxcdFxcdFxcdFNvcnJ5LCB3ZSBjb3VsZG4ndCBmaW5kIHdoYXQgeW91IHdlcmUgbG9va2luZyBmb3IgOi0oPGJyPlxcblxcdFxcdFxcdDxhIGhyZWY9XFxcIi9cXFwiPkdvIGJhY2sgdG8gdGhlIGhvbWVwYWdlPC9hPlxcblxcdFxcdDwvZGl2PlxcblxcdFxcdDxkaXYgY2xhc3M9XFxcImNvbC1tZC0zXFxcIj48L2Rpdj5cXG5cXHQ8L2Rpdj5cXG48L2Rpdj5cIlxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCIvVXNlcnMvbWVTaW5naC9TaXRlcy9fX0todXJhZmF0Uy9MYXJhZ2lzdC5vcmcvSFRNTC9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBpbGVkL3BhZ2VzLzQwNC52dWVcIlxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKCkge1xuICAgIHJlcXVpcmUoXCJ2dWVpZnktaW5zZXJ0LWNzc1wiKS5jYWNoZVtcIlxcbi50aXRsZSB7XFxuICAgIGNvbG9yOiAjOTk5O1xcbiAgICBmb250LXdlaWdodDogMTAwO1xcbiAgICBmb250LWZhbWlseTogJ0xhdG8nLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWY7XFxuICAgIGZvbnQtc2l6ZTogNjBweDtcXG4gICAgbWFyZ2luLWJvdHRvbTogNDBweDtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgICBtYXJnaW4tdG9wOiAyMCU7XFxufVxcbi50aXRsZSBhIHtcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICAgIG1hcmdpbi10b3A6IDIwcHg7XFxufVxcbi50aXRsZSBhOmhvdmVyIHtcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbn1cIl0gPSBmYWxzZVxuICAgIGRvY3VtZW50LmhlYWQucmVtb3ZlQ2hpbGQoX192dWVpZnlfc3R5bGVfXylcbiAgfSlcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMudGVtcGxhdGUpXG4gIH1cbn0pKCl9IiwiOyh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIj8gbW9kdWxlLmV4cG9ydHMub3B0aW9uczogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gXCJcXG48bmF2LWNvbXBvbmVudD48L25hdi1jb21wb25lbnQ+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcImFib3V0XFxcIj5cXG5cXG4gICAgICAgIDxzZWN0aW9uIGNsYXNzPVxcXCJ3ZWxjb21lXFxcIj5cXG4gICAgICAgIFxcdDxkaXYgY2xhc3M9XFxcImNvbnRhaW5lclxcXCI+XFxuICAgICAgICBcXHRcXHQ8aDI+IEFib3V0IFVzPC9oMj5cXG4gICAgICAgIFxcdDwvZGl2PlxcbiAgICAgICAgPC9zZWN0aW9uPlxcblxcbiAgICAgICAgPHNlY3Rpb24gY2xhc3M9XFxcImNvbnRhaW5lciBjb250ZW50XFxcIj5cXHRcXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJibG9ja1xcXCI+XFxuICAgICAgICBcXHQgICAgPHA+XFxuICAgICAgICAgICAgICAgICAgICBMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCwgY29uc2VjdGV0dXIgYWRpcGlzaWNpbmcgZWxpdCwgc2VkIGRvIGVpdXNtb2QgdGVtcG9yIGluY2lkaWR1bnQgdXQgbGFib3JlIGV0IGRvbG9yZSBtYWduYSBhbGlxdWEuIFV0IGVuaW0gYWQgbWluaW0gdmVuaWFtLCBxdWlzIG5vc3RydWQgZXhlcmNpdGF0aW9uIHVsbGFtY28gbGFib3JpcyBuaXNpIHV0IGFsaXF1aXAgZXggZWEgY29tbW9kbyBjb25zZXF1YXQuIER1aXMgYXV0ZSBpcnVyZSBkb2xvciBpbiByZXByZWhlbmRlcml0IGluIHZvbHVwdGF0ZSB2ZWxpdCBlc3NlIGNpbGx1bSBkb2xvcmUgZXUgZnVnaWF0IG51bGxhIHBhcmlhdHVyLiBFeGNlcHRldXIgc2ludCBvY2NhZWNhdCBjdXBpZGF0YXQgbm9uIHByb2lkZW50LCBzdW50IGluIGN1bHBhIHF1aSBvZmZpY2lhIGRlc2VydW50IG1vbGxpdCBhbmltIGlkIGVzdCBsYWJvcnVtLlxcbiAgICAgICAgICAgICAgICA8L3A+XFxuICAgICAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwibWFrZXJzXFxcIj5cXG4gICAgICAgICAgICAgICAgPGgzIGNsYXNzPVxcXCJ0ZXh0LWNlbnRlclxcXCI+S2h1cmFmYXRpIE1ha2VyczwvaDM+XFxuICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTQgY29sLW1kLW9mZnNldC0yXFxcIj5cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJibG9jayBtYWtlciB0ZXh0LWNlbnRlclxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImF2YXRhclxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW1nIHNyYz1cXFwiL2ltYWdlcy9tYWtlcnMvbWFuZGVlcC5wbmdcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGg0Pk1hbmRlZXAgU2luZ2g8L2g0PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dWwgY2xhc3M9XFxcImxpc3QtaW5saW5lIHNvY2lhbFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGk+PGEgaHJlZj1cXFwiI1xcXCI+PGkgY2xhc3M9XFxcImZhIGZhLWxpbmtcXFwiPjwvaT48L2E+PC9saT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaT48YSBocmVmPVxcXCIjXFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtZ2l0aHViXFxcIj48L2k+PC9hPjwvbGk+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGk+PGEgaHJlZj1cXFwiI1xcXCI+PGkgY2xhc3M9XFxcImZhIGZhLWxpbmtlZGluXFxcIj48L2k+PC9hPjwvbGk+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGk+PGEgaHJlZj1cXFwiI1xcXCI+PGkgY2xhc3M9XFxcImZhIGZhLXR3aXR0ZXJcXFwiPjwvaT48L2E+PC9saT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC91bD5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTRcXFwiPlxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImJsb2NrIG1ha2VyIHRleHQtY2VudGVyXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiYXZhdGFyXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPVxcXCIvaW1hZ2VzL21ha2Vycy9waXl1c2gucG5nXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxoND5QaXl1c2ggQWdyYXdhbDwvaDQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx1bCBjbGFzcz1cXFwibGlzdC1pbmxpbmUgc29jaWFsXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaT48YSBocmVmPVxcXCIjXFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtbGlua1xcXCI+PC9pPjwvYT48L2xpPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpPjxhIGhyZWY9XFxcIiNcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1naXRodWJcXFwiPjwvaT48L2E+PC9saT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaT48YSBocmVmPVxcXCIjXFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtbGlua2VkaW5cXFwiPjwvaT48L2E+PC9saT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaT48YSBocmVmPVxcXCIjXFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtdHdpdHRlclxcXCI+PC9pPjwvYT48L2xpPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3VsPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9zZWN0aW9uPlxcblxcbjxmb290ZXItY29tcG9uZW50PjwvZm9vdGVyLWNvbXBvbmVudD5cXG48L2Rpdj5cIlxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCIvVXNlcnMvbWVTaW5naC9TaXRlcy9fX0todXJhZmF0Uy9MYXJhZ2lzdC5vcmcvSFRNTC9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBpbGVkL3BhZ2VzL2Fib3V0LnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLnRlbXBsYXRlKVxuICB9XG59KSgpfSIsIjsodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCI/IG1vZHVsZS5leHBvcnRzLm9wdGlvbnM6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IFwiXFxuPG5hdi1jb21wb25lbnQ+PC9uYXYtY29tcG9uZW50PlxcbjxkaXYgY2xhc3M9XFxcImNvbnRhaW5lciBhcHAtc2NyZWVuXFxcIj5cXG5cXHQ8IS0tIFRhYnMgLS0+XFxuXFx0PGRpdiBjbGFzcz1cXFwiY29sLW1kLTNcXFwiPlxcblxcdFxcdDxkaXYgY2xhc3M9XFxcInBhbmVsIHBhbmVsLWRlZmF1bHQgcGFuZWwtZmx1c2hcXFwiPlxcblxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcInBhbmVsLWhlYWRpbmdcXFwiPlxcblxcdFxcdFxcdFxcdEhvbWVcXG5cXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJwYW5lbC1ib2R5XFxcIj5cXG5cXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJhcHAtdGFic1xcXCI+XFxuXFx0XFx0XFx0XFx0XFx0PHVsIGNsYXNzPVxcXCJuYXYgYXBwLXRhYnMtc3RhY2tlZFxcXCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0PGxpIHYtaWY9XFxcIiEgJHJvb3QuYXV0aGVudGljYXRlZFxcXCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0PGEgdi1saW5rPVxcXCJ7IHBhdGg6ICcvYXV0aC9sb2dpbicgfVxcXCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PGkgY2xhc3M9XFxcImZhIGZhLWJ0biBmYS1mdyBmYS1zaWduLWluXFxcIj48L2k+Jm5ic3A7U2lnbiBpblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdDwvYT5cXG5cXHRcXHRcXHRcXHRcXHRcXHQ8L2xpPlxcblxcdFxcdFxcdFxcdFxcdFxcdDxsaSB2LWlmPVxcXCIhICRyb290LmF1dGhlbnRpY2F0ZWRcXFwiPlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdDxhIHYtbGluaz1cXFwieyBwYXRoOiAnL2F1dGgvcmVnaXN0ZXInIH1cXFwiPlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDxpIGNsYXNzPVxcXCJmYSBmYS1idG4gZmEtZncgZmEtY2hldnJvbi1jaXJjbGUtdXBcXFwiPjwvaT4mbmJzcDtSZWdpc3RlclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdDwvYT5cXG5cXHRcXHRcXHRcXHRcXHRcXHQ8L2xpPlxcblxcdFxcdFxcdFxcdFxcdFxcdDxsaSB2LWlmPVxcXCIkcm9vdC5hdXRoZW50aWNhdGVkXFxcIj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQ8YSB2LWxpbms9XFxcInsgcGF0aDogJy9hdXRoL3Byb2ZpbGUnIH1cXFwiPlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDxpIGNsYXNzPVxcXCJmYSBmYS1idG4gZmEtZncgZmEtdXNlclxcXCI+PC9pPiZuYnNwO015IFByb2ZpbGVcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQ8L2E+XFxuXFx0XFx0XFx0XFx0XFx0XFx0PC9saT5cXG5cXHRcXHRcXHRcXHRcXHQ8L3VsPlxcblxcdFxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdDwvZGl2PlxcblxcdDwvZGl2PlxcblxcdDwhLS0gVGFiIFBhbmVzIC0tPlxcblxcdDxkaXYgY2xhc3M9XFxcImNvbC1tZC05XFxcIj5cXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJ0YWItY29udGVudFxcXCI+XFxuXFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwidGFiLXBhbmVcXFwiPlxcblxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcInBhbmVsIHBhbmVsLWRlZmF1bHRcXFwiPlxcblxcdFxcdFxcdFxcdFxcdDxyb3V0ZXItdmlldz48L3JvdXRlci12aWV3PlxcblxcdFxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdFxcdDwvZGl2PjwhLS0gRW5kIHRhYiBwYW5lbCAtLT5cXG5cXHRcXHQ8L2Rpdj48IS0tIEVuZCB0YWIgY29udGVudCAtLT5cXG5cXHQ8L2Rpdj48IS0tIEVuZCB0YWIgcGFuZXMgY29sLW1kLTkgLS0+XFxuPC9kaXY+PCEtLSBFbmQgY29udGFpbmVyIC0tPlxcbjxmb290ZXItY29tcG9uZW50PjwvZm9vdGVyLWNvbXBvbmVudD5cIlxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCIvVXNlcnMvbWVTaW5naC9TaXRlcy9fX0todXJhZmF0Uy9MYXJhZ2lzdC5vcmcvSFRNTC9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBpbGVkL3BhZ2VzL2F1dGgudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMudGVtcGxhdGUpXG4gIH1cbn0pKCl9IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICB1c2VyOiB7XG4gICAgICAgIGVtYWlsOiBudWxsLFxuICAgICAgICBwYXNzd29yZDogbnVsbFxuICAgICAgfSxcbiAgICAgIG1lc3NhZ2VzOiBbXSxcbiAgICAgIGxvZ2dpbmdJbjogZmFsc2VcbiAgICB9O1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBhdHRlbXB0OiBmdW5jdGlvbiBhdHRlbXB0KGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHRoYXQubG9nZ2luZ0luID0gdHJ1ZTtcbiAgICAgIGNsaWVudCh7IHBhdGg6ICdsb2dpbicsIGVudGl0eTogdGhpcy51c2VyIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIHRoYXQuJGRpc3BhdGNoKCd1c2VySGFzRmV0Y2hlZFRva2VuJywgcmVzcG9uc2UudG9rZW4pO1xuICAgICAgICB0aGF0LmdldFVzZXJEYXRhKCk7XG4gICAgICB9LCBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgdGhhdC5tZXNzYWdlcyA9IFtdO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICYmIHJlc3BvbnNlLnN0YXR1cy5jb2RlID09PSA0MDEpIHRoYXQubWVzc2FnZXMucHVzaCh7IHR5cGU6ICdkYW5nZXInLCBtZXNzYWdlOiAnU29ycnksIHlvdSBwcm92aWRlZCBpbnZhbGlkIGNyZWRlbnRpYWxzJyB9KTtcbiAgICAgICAgdGhhdC5sb2dnaW5nSW4gPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBnZXRVc2VyRGF0YTogZnVuY3Rpb24gZ2V0VXNlckRhdGEoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICBjbGllbnQoeyBwYXRoOiAnL3VzZXJzL21lJyB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICB0aGF0LiRkaXNwYXRjaCgndXNlckhhc0xvZ2dlZEluJywgcmVzcG9uc2UuZW50aXR5LnVzZXIpO1xuICAgICAgICB0aGF0LiRyb3V0ZS5yb3V0ZXIuZ28oJy9hdXRoL3Byb2ZpbGUnKTtcbiAgICAgIH0sIGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgcm91dGU6IHtcbiAgICBhY3RpdmF0ZTogZnVuY3Rpb24gYWN0aXZhdGUodHJhbnNpdGlvbikge1xuICAgICAgdGhpcy4kZGlzcGF0Y2goJ3VzZXJIYXNMb2dnZWRPdXQnKTtcbiAgICAgIHRyYW5zaXRpb24ubmV4dCgpO1xuICAgIH1cbiAgfVxufTtcbjsodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCI/IG1vZHVsZS5leHBvcnRzLm9wdGlvbnM6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IFwiXFxuPGRpdiBjbGFzcz1cXFwicGFuZWwtaGVhZGluZ1xcXCI+XFxuICAgIFNpZ24gaW4gdG8geW91ciBhY2NvdW50XFxuPC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwicGFuZWwtYm9keVxcXCI+XFxuICAgIDxmb3JtIGNsYXNzPVxcXCJmb3JtLWhvcml6b250YWxcXFwiIHJvbGU9XFxcImZvcm1cXFwiIHYtb246c3VibWl0PVxcXCJhdHRlbXB0XFxcIj5cXG5cXG5cXHRcXHQ8ZGl2IGlkPVxcXCJhbGVydHNcXFwiIHYtaWY9XFxcIm1lc3NhZ2VzLmxlbmd0aCA+IDBcXFwiPlxcblxcdFxcdFxcdDxkaXYgdi1mb3I9XFxcIm1lc3NhZ2UgaW4gbWVzc2FnZXNcXFwiIGNsYXNzPVxcXCJhbGVydCBhbGVydC17eyBtZXNzYWdlLnR5cGUgfX0gYWxlcnQtZGlzbWlzc2libGVcXFwiIHJvbGU9XFxcImFsZXJ0XFxcIj5cXG5cXHRcXHRcXHRcXHR7eyBtZXNzYWdlLm1lc3NhZ2UgfX1cXG5cXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHQ8L2Rpdj5cXG5cXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG5cXHRcXHRcXHQ8bGFiZWwgY2xhc3M9XFxcImNvbC1tZC00IGNvbnRyb2wtbGFiZWxcXFwiPkUtTWFpbCBBZGRyZXNzPC9sYWJlbD5cXG5cXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtNlxcXCI+XFxuXFx0XFx0XFx0XFx0PGlucHV0IHR5cGU9XFxcImVtYWlsXFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiB2LW1vZGVsPVxcXCJ1c2VyLmVtYWlsXFxcIj5cXG5cXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHQ8L2Rpdj5cXG5cXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG5cXHRcXHRcXHQ8bGFiZWwgY2xhc3M9XFxcImNvbC1tZC00IGNvbnRyb2wtbGFiZWxcXFwiPlBhc3N3b3JkPC9sYWJlbD5cXG5cXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtNlxcXCI+XFxuXFx0XFx0XFx0XFx0PGlucHV0IHR5cGU9XFxcInBhc3N3b3JkXFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiB2LW1vZGVsPVxcXCJ1c2VyLnBhc3N3b3JkXFxcIj5cXG5cXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHQ8L2Rpdj5cXG5cXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG5cXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtNiBjb2wtbWQtb2Zmc2V0LTRcXFwiPlxcblxcdFxcdFxcdFxcdDxidXR0b24gdHlwZT1cXFwic3VibWl0XFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1wcmltYXJ5XFxcIiA6ZGlzYWJsZWQ9XFxcImxvZ2dpbmdJblxcXCI+XFxuXFx0XFx0XFx0XFx0XFx0PGkgY2xhc3M9XFxcImZhIGZhLWJ0biBmYS1zaWduLWluXFxcIj48L2k+TG9naW5cXG5cXHRcXHRcXHRcXHQ8L2J1dHRvbj5cXG5cXG5cXHRcXHRcXHRcXHQ8YSBjbGFzcz1cXFwiYnRuIGJ0bi1saW5rXFxcIiB2LWxpbms9XFxcInsgcGF0aDogJy9hdXRoL2ZvcmdvdCcgfVxcXCI+Rm9yZ290IFlvdXIgUGFzc3dvcmQ/PC9hPlxcblxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdDwvZGl2PlxcblxcdDwvZm9ybT5cXG48L2Rpdj5cXG5cIlxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCIvVXNlcnMvbWVTaW5naC9TaXRlcy9fX0todXJhZmF0Uy9MYXJhZ2lzdC5vcmcvSFRNTC9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBpbGVkL3BhZ2VzL2F1dGgvbG9naW4udnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMudGVtcGxhdGUpXG4gIH1cbn0pKCl9IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICByb3V0ZToge1xuICAgIGFjdGl2YXRlOiBmdW5jdGlvbiBhY3RpdmF0ZSh0cmFuc2l0aW9uKSB7XG4gICAgICB0aGlzLiRyb290LmF1dGhlbnRpY2F0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuJHJvb3QudXNlciA9IG51bGw7XG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgndXNlcicpO1xuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2p3dC10b2tlbicpO1xuICAgICAgdHJhbnNpdGlvbi5yZWRpcmVjdCgnLycpO1xuICAgIH1cbiAgfVxuXG59O1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCIvVXNlcnMvbWVTaW5naC9TaXRlcy9fX0todXJhZmF0Uy9MYXJhZ2lzdC5vcmcvSFRNTC9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBpbGVkL3BhZ2VzL2F1dGgvbG9nb3V0LnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLnRlbXBsYXRlKVxuICB9XG59KSgpfSIsIjsodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCI/IG1vZHVsZS5leHBvcnRzLm9wdGlvbnM6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IFwiXFxuPGRpdiBjbGFzcz1cXFwicGFuZWwtaGVhZGluZ1xcXCI+XFxuXFx0WW91ciBwcm9maWxlXFxuPC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwicGFuZWwtYm9keVxcXCI+XFxuXFx0PCEtLSA8YnV0dG9uIGNsYXNzPVxcXCJidG4gYnRuLXByaW1hcnlcXFwiIHYtb249XFxcImNsaWNrOiBmZXRjaFxcXCI+RmV0Y2g8L2J1dHRvbj4gLS0+XFxuXFx0PHRhYmxlIGNsYXNzPVxcXCJ0YWJsZSB0YWJsZS1ib3JkZXJlZFxcXCIgdi1pZj1cXFwiJHJvb3QudXNlclxcXCI+XFxuXFx0XFx0PHRib2R5Pjx0cj5cXG5cXHRcXHRcXHQ8dGg+VXNlciBJRDwvdGg+XFxuXFx0XFx0XFx0PHRoPk5hbWU8L3RoPlxcblxcdFxcdFxcdDx0aD5FbWFpbDwvdGg+XFxuXFx0XFx0PC90cj5cXG5cXHRcXHQ8dHI+XFxuXFx0XFx0XFx0PHRkPnt7ICRyb290LnVzZXIuaWQgfX08L3RkPlxcblxcdFxcdFxcdDx0ZD57eyAkcm9vdC51c2VyLm5hbWUgfX08L3RkPlxcblxcdFxcdFxcdDx0ZD57eyAkcm9vdC51c2VyLmVtYWlsIH19PC90ZD5cXG5cXHRcXHQ8L3RyPlxcblxcdDwvdGJvZHk+PC90YWJsZT5cXG48L2Rpdj5cIlxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCIvVXNlcnMvbWVTaW5naC9TaXRlcy9fX0todXJhZmF0Uy9MYXJhZ2lzdC5vcmcvSFRNTC9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBpbGVkL3BhZ2VzL2F1dGgvcHJvZmlsZS52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy50ZW1wbGF0ZSlcbiAgfVxufSkoKX0iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVzZXI6IHtcbiAgICAgICAgbmFtZTogbnVsbCxcbiAgICAgICAgZW1haWw6IG51bGwsXG4gICAgICAgIHBhc3N3b3JkOiBudWxsLFxuICAgICAgICBwYXNzd29yZF9jb25maXJtYXRpb246IG51bGxcbiAgICAgIH0sXG4gICAgICBtZXNzYWdlczogW10sXG4gICAgICByZWdpc3RlcmluZzogZmFsc2VcbiAgICB9O1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICByZWdpc3RlclVzZXI6IGZ1bmN0aW9uIHJlZ2lzdGVyVXNlcihlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB0aGF0LnJlZ2lzdGVyaW5nID0gdHJ1ZTtcbiAgICAgIGNsaWVudCh7IHBhdGg6ICcvcmVnaXN0ZXInLCBlbnRpdHk6IHRoaXMudXNlciB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICB0aGF0LmdldFVzZXJEYXRhKCk7XG4gICAgICB9LCBmdW5jdGlvbiAocmVzcG9uc2UsIHN0YXR1cykge1xuICAgICAgICB0aGF0Lm1lc3NhZ2VzID0gW107XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgJiYgcmVzcG9uc2Uuc3RhdHVzLmNvZGUgPT09IDQyMikge1xuICAgICAgICAgIHRoYXQubWVzc2FnZXMgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcmVzcG9uc2UuZW50aXR5KSB7XG4gICAgICAgICAgICB0aGF0Lm1lc3NhZ2VzLnB1c2goeyB0eXBlOiAnZGFuZ2VyJywgbWVzc2FnZTogcmVzcG9uc2UuZW50aXR5W2tleV0gfSk7XG4gICAgICAgICAgICB0aGF0LnJlZ2lzdGVyaW5nID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgZ2V0VXNlckRhdGE6IGZ1bmN0aW9uIGdldFVzZXJEYXRhKCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgY2xpZW50KHsgcGF0aDogJy91c2Vycy9tZScgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgdGhhdC4kZGlzcGF0Y2goJ3VzZXJIYXNMb2dnZWRJbicsIHJlc3BvbnNlLmVudGl0eS51c2VyKTtcbiAgICAgICAgdGhhdC4kcm91dGUucm91dGVyLmdvKCcvYXV0aC9wcm9maWxlJyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn07XG47KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiPyBtb2R1bGUuZXhwb3J0cy5vcHRpb25zOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBcIlxcbjxkaXYgY2xhc3M9XFxcInBhbmVsLWhlYWRpbmdcXFwiPlxcblxcdFJlZ2lzdGVyIGZvciBhbiBhY2NvdW50XFxuPC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwicGFuZWwtYm9keVxcXCI+XFxuXFx0PGZvcm0gY2xhc3M9XFxcImZvcm0taG9yaXpvbnRhbFxcXCIgcm9sZT1cXFwiZm9ybVxcXCIgdi1vbjpzdWJtaXQ9XFxcInJlZ2lzdGVyVXNlclxcXCI+XFxuXFxuXFx0XFx0PGRpdiBpZD1cXFwiYWxlcnRzXFxcIiB2LWlmPVxcXCJtZXNzYWdlcy5sZW5ndGggPiAwXFxcIj5cXG5cXHRcXHRcXHQ8ZGl2IHYtZm9yPVxcXCJtZXNzYWdlIGluIG1lc3NhZ2VzXFxcIiBjbGFzcz1cXFwiYWxlcnQgYWxlcnQte3sgbWVzc2FnZS50eXBlIH19IGFsZXJ0LWRpc21pc3NpYmxlXFxcIiByb2xlPVxcXCJhbGVydFxcXCI+XFxuXFx0XFx0XFx0XFx0e3sgbWVzc2FnZS5tZXNzYWdlIH19XFxuXFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0PC9kaXY+XFxuXFxuXFx0XFx0PGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxuXFx0XFx0XFx0PGxhYmVsIGNsYXNzPVxcXCJjb2wtbWQtNCBjb250cm9sLWxhYmVsXFxcIj5Zb3VyIG5hbWU8L2xhYmVsPlxcblxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcImNvbC1tZC02XFxcIj5cXG5cXHRcXHRcXHRcXHQ8aW5wdXQgdHlwZT1cXFwibmFtZVxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgdi1tb2RlbD1cXFwidXNlci5uYW1lXFxcIj5cXG5cXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHQ8L2Rpdj5cXG5cXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG5cXHRcXHRcXHQ8bGFiZWwgY2xhc3M9XFxcImNvbC1tZC00IGNvbnRyb2wtbGFiZWxcXFwiPkUtTWFpbCBBZGRyZXNzPC9sYWJlbD5cXG5cXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtNlxcXCI+XFxuXFx0XFx0XFx0XFx0PGlucHV0IHR5cGU9XFxcImVtYWlsXFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiB2LW1vZGVsPVxcXCJ1c2VyLmVtYWlsXFxcIj5cXG5cXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHQ8L2Rpdj5cXG5cXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG5cXHRcXHRcXHQ8bGFiZWwgY2xhc3M9XFxcImNvbC1tZC00IGNvbnRyb2wtbGFiZWxcXFwiPlBhc3N3b3JkPC9sYWJlbD5cXG5cXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtNlxcXCI+XFxuXFx0XFx0XFx0XFx0PGlucHV0IHR5cGU9XFxcInBhc3N3b3JkXFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiB2LW1vZGVsPVxcXCJ1c2VyLnBhc3N3b3JkXFxcIj5cXG5cXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHQ8L2Rpdj5cXG5cXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG5cXHRcXHRcXHQ8bGFiZWwgY2xhc3M9XFxcImNvbC1tZC00IGNvbnRyb2wtbGFiZWxcXFwiPkNvbmZpcm0gcGFzc3dvcmQ8L2xhYmVsPlxcblxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcImNvbC1tZC02XFxcIj5cXG5cXHRcXHRcXHRcXHQ8aW5wdXQgdHlwZT1cXFwicGFzc3dvcmRcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIHYtbW9kZWw9XFxcInVzZXIucGFzc3dvcmRfY29uZmlybWF0aW9uXFxcIj5cXG5cXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHQ8L2Rpdj5cXG5cXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG5cXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtNiBjb2wtbWQtb2Zmc2V0LTRcXFwiPlxcblxcdFxcdFxcdFxcdDxidXR0b24gdHlwZT1cXFwic3VibWl0XFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1wcmltYXJ5XFxcIiA6ZGlzYWJsZWQ9XFxcInJlZ2lzdGVyaW5nXFxcIj5cXG5cXHRcXHRcXHRcXHRcXHQ8aSBjbGFzcz1cXFwiZmEgZmEtYnRuIGZhLXNpZ24taW5cXFwiPjwvaT4gUmVnaXN0ZXJcXG5cXHRcXHRcXHRcXHQ8L2J1dHRvbj5cXG5cXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHQ8L2Rpdj5cXG5cXHQ8L2Zvcm0+XFxuPC9kaXY+XCJcbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiL1VzZXJzL21lU2luZ2gvU2l0ZXMvX19LaHVyYWZhdFMvTGFyYWdpc3Qub3JnL0hUTUwvcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9wYWdlcy9hdXRoL3JlZ2lzdGVyLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLnRlbXBsYXRlKVxuICB9XG59KSgpfSIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRvZzoge1xuICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgYWdlOiAnJ1xuICAgICAgfSxcbiAgICAgIG1lc3NhZ2VzOiBbXSxcbiAgICAgIGNyZWF0aW5nOiBmYWxzZVxuICAgIH07XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGNyZWF0ZURvZzogZnVuY3Rpb24gY3JlYXRlRG9nKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHRoYXQuY3JlYXRpbmcgPSB0cnVlO1xuICAgICAgY2xpZW50KHsgcGF0aDogJ2RvZ3MnLCBlbnRpdHk6IHRoaXMuZG9nIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlLCBzdGF0dXMpIHtcbiAgICAgICAgdGhhdC5kb2cubmFtZSA9ICcnO1xuICAgICAgICB0aGF0LmRvZy5hZ2UgPSAnJztcbiAgICAgICAgdGhhdC5tZXNzYWdlcyA9IFt7IHR5cGU6ICdzdWNjZXNzJywgbWVzc2FnZTogJ1dvb2Ygd29vZiEgWW91ciBkb2cgd2FzIGNyZWF0ZWQnIH1dO1xuICAgICAgICBWdWUubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCduYW1lSW5wdXQnKS5mb2N1cygpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhhdC5jcmVhdGluZyA9IGZhbHNlO1xuICAgICAgfSwgZnVuY3Rpb24gKHJlc3BvbnNlLCBzdGF0dXMpIHtcbiAgICAgICAgdGhhdC5tZXNzYWdlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcmVzcG9uc2UuZW50aXR5KSB7XG4gICAgICAgICAgdGhhdC5tZXNzYWdlcy5wdXNoKHsgdHlwZTogJ2RhbmdlcicsIG1lc3NhZ2U6IHJlc3BvbnNlLmVudGl0eVtrZXldIH0pO1xuICAgICAgICAgIHRoYXQuY3JlYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59O1xuOyh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIj8gbW9kdWxlLmV4cG9ydHMub3B0aW9uczogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gXCJcXG48ZGl2IGNsYXNzPVxcXCJwYW5lbC1oZWFkaW5nXFxcIj5cXG5cXHRNYWtlIGEgZG9nIVxcbjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcInBhbmVsLWJvZHlcXFwiPlxcblxcdDxkaXYgaWQ9XFxcImFsZXJ0c1xcXCIgdi1pZj1cXFwibWVzc2FnZXMubGVuZ3RoID4gMFxcXCI+XFxuXFx0XFx0PGRpdiB2LWZvcj1cXFwibWVzc2FnZSBpbiBtZXNzYWdlc1xcXCIgY2xhc3M9XFxcImFsZXJ0IGFsZXJ0LXt7IG1lc3NhZ2UudHlwZSB9fSBhbGVydC1kaXNtaXNzaWJsZVxcXCIgcm9sZT1cXFwiYWxlcnRcXFwiPlxcblxcdFxcdFxcdHt7IG1lc3NhZ2UubWVzc2FnZSB9fVxcblxcdFxcdDwvZGl2PlxcblxcdDwvZGl2PlxcblxcdDxmb3JtIGNsYXNzPVxcXCJmb3JtLWhvcml6b250YWxcXFwiIHJvbGU9XFxcImZvcm1cXFwiIHYtb246c3VibWl0PVxcXCJjcmVhdGVEb2dcXFwiPlxcblxcdFxcdDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcblxcdFxcdFxcdDxsYWJlbCBmb3I9XFxcIm5hbWVcXFwiIGNsYXNzPVxcXCJjb2wtc20tMiBjb2wtc20tb2Zmc2V0LTEgY29udHJvbC1sYWJlbFxcXCI+TmFtZSB5b3VyIGRvZzwvbGFiZWw+XFxuXFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiY29sLXNtLTVcXFwiPlxcblxcdFxcdFxcdFxcdDxpbnB1dCBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiByZXF1aXJlZD1cXFwicmVxdWlyZWRcXFwiIG5hbWU9XFxcIm5hbWVcXFwiIHR5cGU9XFxcInRleHRcXFwiIHYtbW9kZWw9XFxcImRvZy5uYW1lXFxcIiBpZD1cXFwibmFtZUlucHV0XFxcIj5cXG5cXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHQ8L2Rpdj5cXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG5cXHRcXHRcXHQ8bGFiZWwgZm9yPVxcXCJhZ2VcXFwiIGNsYXNzPVxcXCJjb2wtc20tMiBjb2wtc20tb2Zmc2V0LTEgY29udHJvbC1sYWJlbFxcXCI+V2hhdCdzIHRoZSBhZ2U/PC9sYWJlbD5cXG5cXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjb2wtc20tNVxcXCI+XFxuXFx0XFx0XFx0XFx0PGlucHV0IGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIHJlcXVpcmVkPVxcXCJyZXF1aXJlZFxcXCIgbmFtZT1cXFwiYWdlXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiB2LW1vZGVsPVxcXCJkb2cuYWdlXFxcIj5cXG5cXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHQ8L2Rpdj5cXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG5cXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjb2wtc20tNCBjb2wtc20tb2Zmc2V0LTNcXFwiPlxcblxcdFxcdFxcdFxcdDxidXR0b24gdHlwZT1cXFwic3VibWl0XFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1wcmltYXJ5XFxcIiA6ZGlzYWJsZWQ9XFxcImNyZWF0aW5nXFxcIj5cXG5cXHRcXHRcXHRcXHRcXHQ8aSBjbGFzcz1cXFwiZmEgZmEtYnRuIGZhLXNhdmVcXFwiPjwvaT5NYWtlIHRoZSBkb2chXFxuXFx0XFx0XFx0XFx0PC9idXR0b24+XFxuXFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0PC9kaXY+XFxuXFx0PC9mb3JtPlxcbjwvZGl2PlwiXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIi9Vc2Vycy9tZVNpbmdoL1NpdGVzL19fS2h1cmFmYXRTL0xhcmFnaXN0Lm9yZy9IVE1ML3Jlc291cmNlcy9hc3NldHMvanMvY29tcGlsZWQvcGFnZXMvZG9ncy9jcmVhdGUudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMudGVtcGxhdGUpXG4gIH1cbn0pKCl9IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBkb2dzOiBbXSxcbiAgICAgIG1lc3NhZ2VzOiBbXVxuICAgIH07XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIC8vIExldCdzIGZldGNoIHNvbWUgZG9nc1xuICAgIGZldGNoOiBmdW5jdGlvbiBmZXRjaChzdWNjZXNzSGFuZGxlcikge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgY2xpZW50KHsgcGF0aDogJy9kb2dzJyB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAvLyBMb29rIG1hISBQdXBwaWVzIVxuICAgICAgICB0aGF0LiRzZXQoJ2RvZ3MnLCByZXNwb25zZS5lbnRpdHkuZGF0YSk7XG4gICAgICAgIHN1Y2Nlc3NIYW5kbGVyKHJlc3BvbnNlLmVudGl0eS5kYXRhKTtcbiAgICAgIH0sIGZ1bmN0aW9uIChyZXNwb25zZSwgc3RhdHVzKSB7XG4gICAgICAgIGlmIChfLmNvbnRhaW5zKFs0MDEsIDUwMF0sIHN0YXR1cykpIHtcbiAgICAgICAgICB0aGF0LiRkaXNwYXRjaCgndXNlckhhc0xvZ2dlZE91dCcpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgZGVsZXRlRG9nOiBmdW5jdGlvbiBkZWxldGVEb2coaW5kZXgpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIGNsaWVudCh7IHBhdGg6ICcvZG9ncy8nICsgdGhpcy5kb2dzW2luZGV4XS5pZCwgbWV0aG9kOiAnREVMRVRFJyB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICB0aGF0LmRvZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgdGhhdC5tZXNzYWdlcyA9IFt7IHR5cGU6ICdzdWNjZXNzJywgbWVzc2FnZTogJ0dyZWF0LCBkb2cgcHVyZ2VkLicgfV07XG4gICAgICB9LCBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgdGhhdC5tZXNzYWdlcy5wdXNoKHsgdHlwZTogJ2RhbmdlcicsIG1lc3NhZ2U6ICdUaGVyZSB3YXMgYSBwcm9ibGVtIHJlbW92aW5nIHRoZSBkb2cnIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gIH0sXG5cbiAgcm91dGU6IHtcbiAgICAvLyBPb2gsIG9vaCwgYXJlIHRoZXJlIGFueSBuZXcgcHVwcGllcyB5ZXQ/XG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSh0cmFuc2l0aW9uKSB7XG4gICAgICB0aGlzLmZldGNoKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHRyYW5zaXRpb24ubmV4dCh7IGRvZ3M6IGRhdGEgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxufTtcbjsodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCI/IG1vZHVsZS5leHBvcnRzLm9wdGlvbnM6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IFwiXFxuPGRpdiBjbGFzcz1cXFwicGFuZWwtaGVhZGluZ1xcXCI+XFxuXFx0TGlzdCBvZiBkb2dzXFxuPC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwicGFuZWwtYm9keVxcXCIgdi1pZj1cXFwiJGxvYWRpbmdSb3V0ZURhdGFcXFwiPlxcblxcdExvYWRpbmcgZGF0YSB7eyBsb2FkaW5nUm91dGVEYXRhIH19XFxuPC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwicGFuZWwtYm9keVxcXCIgdi1pZj1cXFwibWVzc2FnZXMubGVuZ3RoID4gMFxcXCI+XFxuXFx0PGRpdiB2LWZvcj1cXFwibWVzc2FnZSBpbiBtZXNzYWdlc1xcXCIgY2xhc3M9XFxcImFsZXJ0IGFsZXJ0LXt7IG1lc3NhZ2UudHlwZSB9fSBhbGVydC1kaXNtaXNzaWJsZVxcXCIgcm9sZT1cXFwiYWxlcnRcXFwiPlxcblxcdFxcdHt7IG1lc3NhZ2UubWVzc2FnZSB9fVxcblxcdDwvZGl2PlxcbjwvZGl2PlxcblxcbjxkaXYgY2xhc3M9XFxcInBhbmVsLWJvZHlcXFwiIHYtaWY9XFxcImRvZ3MubGVuZ3RoID09IDBcXFwiPlxcblxcdFlvdSBoYXZlIG5vIGRvZ3MhXFxuPC9kaXY+XFxuXFxuPHRhYmxlIGNsYXNzPVxcXCJ0YWJsZVxcXCIgdi1pZj1cXFwiICEgJGxvYWRpbmdSb3V0ZURhdGEgJmFtcDsmYW1wOyBkb2dzLmxlbmd0aCA+IDBcXFwiPlxcblxcdDx0aGVhZD5cXG5cXHRcXHQ8dHI+XFxuXFx0XFx0XFx0PHRoPklEPC90aD5cXG5cXHRcXHRcXHQ8dGg+TmFtZTwvdGg+XFxuXFx0XFx0XFx0PHRoPkFnZTwvdGg+XFxuXFx0XFx0XFx0PHRoIHdpZHRoPVxcXCIxMjBweFxcXCI+QWN0aW9uczwvdGg+XFxuXFx0XFx0PC90cj5cXG5cXHQ8L3RoZWFkPlxcblxcdDx0Ym9keT5cXG5cXHRcXHQ8dHIgdi1mb3I9XFxcImRvZyBpbiBkb2dzXFxcIj5cXG5cXHRcXHRcXHQ8dGQ+e3sgZG9nLmlkIH19PC90ZD5cXG5cXHRcXHRcXHQ8dGQ+e3sgZG9nLm5hbWUgfX08L3RkPlxcblxcdFxcdFxcdDx0ZD57eyBkb2cuYWdlIH19PC90ZD5cXG5cXHRcXHRcXHQ8dGQ+XFxuXFx0XFx0XFx0XFx0PGEgY2xhc3M9XFxcImJ0biBidG4tcHJpbWFyeSBidG4teHNcXFwiIHYtbGluaz1cXFwieyBwYXRoOiAnL2RvZ3MvJytkb2cuaWQgfVxcXCI+RWRpdDwvYT5cXG5cXHRcXHRcXHRcXHQ8YSBjbGFzcz1cXFwiYnRuIGJ0bi1wcmltYXJ5IGJ0bi14c1xcXCIgdi1vbjpjbGljaz1cXFwiZGVsZXRlRG9nKCRpbmRleClcXFwiPkRlbGV0ZTwvYT5cXG5cXHRcXHRcXHQ8L3RkPlxcblxcdFxcdDwvdHI+XFxuXFx0PC90Ym9keT5cXG48L3RhYmxlPlwiXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIi9Vc2Vycy9tZVNpbmdoL1NpdGVzL19fS2h1cmFmYXRTL0xhcmFnaXN0Lm9yZy9IVE1ML3Jlc291cmNlcy9hc3NldHMvanMvY29tcGlsZWQvcGFnZXMvZG9ncy9pbmRleC52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy50ZW1wbGF0ZSlcbiAgfVxufSkoKX0iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRvZzoge1xuICAgICAgICBpZDogbnVsbCxcbiAgICAgICAgbmFtZTogbnVsbCxcbiAgICAgICAgYWdlOiBudWxsXG4gICAgICB9LFxuICAgICAgbWVzc2FnZXM6IFtdXG4gICAgfTtcbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgLy8gTGV0J3MgZmV0Y2ggdGhlIGRvZ1xuICAgIGZldGNoOiBmdW5jdGlvbiBmZXRjaChpZCwgc3VjY2Vzc0hhbmRsZXIpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIGNsaWVudCh7IHBhdGg6ICcvZG9ncy8nICsgaWQgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgdGhhdC4kc2V0KCdkb2cnLCByZXNwb25zZS5lbnRpdHkuZGF0YSk7XG4gICAgICAgIHN1Y2Nlc3NIYW5kbGVyKHJlc3BvbnNlLmVudGl0eS5kYXRhKTtcbiAgICAgIH0sIGZ1bmN0aW9uIChyZXNwb25zZSwgc3RhdHVzLCByZXF1ZXN0KSB7XG4gICAgICAgIC8vIEdvIHRlbGwgeW91ciBwYXJlbnRzIHRoYXQgeW91J3ZlIG1lc3NlZCB1cCBzb21laG93XG4gICAgICAgIGlmIChzdGF0dXMgPT09IDQwMSkge1xuICAgICAgICAgIHNlbGYuJGRpc3BhdGNoKCd1c2VySGFzTG9nZ2VkT3V0Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgdXBkYXRlRG9nOiBmdW5jdGlvbiB1cGRhdGVEb2coZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgY2xpZW50KHsgcGF0aDogJy9kb2dzLycgKyB0aGlzLmRvZy5pZCwgZW50aXR5OiB0aGlzLmRvZywgbWV0aG9kOiAnUFVUJyB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICBzZWxmLm1lc3NhZ2VzID0gW107XG4gICAgICAgIHNlbGYubWVzc2FnZXMucHVzaCh7IHR5cGU6ICdzdWNjZXNzJywgbWVzc2FnZTogJ1dvb2Ygd29vZiEgWW91ciBkb2cgd2FzIHVwZGF0ZWQnIH0pO1xuICAgICAgfSwgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIHNlbGYubWVzc2FnZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHJlc3BvbnNlLmVudGl0eSkge1xuICAgICAgICAgIHNlbGYubWVzc2FnZXMucHVzaCh7IHR5cGU6ICdkYW5nZXInLCBtZXNzYWdlOiByZXNwb25zZS5lbnRpdHlba2V5XSB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gIH0sXG5cbiAgcm91dGU6IHtcbiAgICAvLyBPb2gsIG9vaCwgYXJlIHRoZXJlIGFueSBuZXcgcHVwcGllcyB5ZXQ/XG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSh0cmFuc2l0aW9uKSB7XG4gICAgICB0aGlzLmZldGNoKHRoaXMuJHJvdXRlLnBhcmFtcy5pZCwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdHJhbnNpdGlvbi5uZXh0KHsgZG9nOiBkYXRhIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59O1xuOyh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIj8gbW9kdWxlLmV4cG9ydHMub3B0aW9uczogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gXCJcXG48ZGl2IGNsYXNzPVxcXCJwYW5lbC1oZWFkaW5nXFxcIj5cXG5cXHRFZGl0IGRvZ1xcbjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcInBhbmVsLWJvZHlcXFwiPlxcblxcdDxkaXYgaWQ9XFxcImFsZXJ0c1xcXCIgdi1pZj1cXFwibWVzc2FnZXMubGVuZ3RoID4gMFxcXCI+XFxuXFx0XFx0PGRpdiB2LWZvcj1cXFwibWVzc2FnZSBpbiBtZXNzYWdlc1xcXCIgY2xhc3M9XFxcImFsZXJ0IGFsZXJ0LXt7IG1lc3NhZ2UudHlwZSB9fSBhbGVydC1kaXNtaXNzaWJsZVxcXCIgcm9sZT1cXFwiYWxlcnRcXFwiPlxcblxcdFxcdFxcdHt7IG1lc3NhZ2UubWVzc2FnZSB9fVxcblxcdFxcdDwvZGl2PlxcblxcdDwvZGl2PlxcblxcdDxmb3JtIGNsYXNzPVxcXCJmb3JtLWhvcml6b250YWxcXFwiIHJvbGU9XFxcImZvcm1cXFwiIHYtb246c3VibWl0PVxcXCJ1cGRhdGVEb2dcXFwiPlxcblxcdDxmaWVsZHNldCBkaXNhYmxlZD1cXFwiXFxcIj5cXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG5cXHRcXHRcXHQ8bGFiZWwgZm9yPVxcXCJuYW1lXFxcIiBjbGFzcz1cXFwiY29sLXNtLTIgY29sLXNtLW9mZnNldC0xIGNvbnRyb2wtbGFiZWxcXFwiPkRvZyBJRDwvbGFiZWw+XFxuXFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiY29sLXNtLTVcXFwiPlxcblxcdFxcdFxcdFxcdDxpbnB1dCBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiByZXF1aXJlZD1cXFwicmVxdWlyZWRcXFwiIG5hbWU9XFxcIm5hbWVcXFwiIHR5cGU9XFxcInRleHRcXFwiIHYtbW9kZWw9XFxcImRvZy5pZFxcXCI+XFxuXFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0PC9kaXY+XFxuXFx0PC9maWVsZHNldD5cXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG5cXHRcXHRcXHQ8bGFiZWwgZm9yPVxcXCJuYW1lXFxcIiBjbGFzcz1cXFwiY29sLXNtLTIgY29sLXNtLW9mZnNldC0xIGNvbnRyb2wtbGFiZWxcXFwiPk5hbWUgeW91ciBkb2c8L2xhYmVsPlxcblxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcImNvbC1zbS01XFxcIj5cXG5cXHRcXHRcXHRcXHQ8aW5wdXQgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgcmVxdWlyZWQ9XFxcInJlcXVpcmVkXFxcIiBuYW1lPVxcXCJuYW1lXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiB2LW1vZGVsPVxcXCJkb2cubmFtZVxcXCI+XFxuXFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0PC9kaXY+XFxuXFx0XFx0PGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxuXFx0XFx0XFx0PGxhYmVsIGZvcj1cXFwiYWdlXFxcIiBjbGFzcz1cXFwiY29sLXNtLTIgY29sLXNtLW9mZnNldC0xIGNvbnRyb2wtbGFiZWxcXFwiPldoYXQncyB0aGUgYWdlPzwvbGFiZWw+XFxuXFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiY29sLXNtLTVcXFwiPlxcblxcdFxcdFxcdFxcdDxpbnB1dCBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiByZXF1aXJlZD1cXFwicmVxdWlyZWRcXFwiIG5hbWU9XFxcImFnZVxcXCIgdHlwZT1cXFwidGV4dFxcXCIgdi1tb2RlbD1cXFwiZG9nLmFnZVxcXCI+XFxuXFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0PC9kaXY+XFxuXFx0XFx0PGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxuXFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiY29sLXNtLTQgY29sLXNtLW9mZnNldC0zXFxcIj5cXG5cXHRcXHRcXHRcXHQ8YnV0dG9uIHR5cGU9XFxcInN1Ym1pdFxcXCIgY2xhc3M9XFxcImJ0biBidG4tcHJpbWFyeVxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLWJ0biBmYS1zYXZlXFxcIj48L2k+VXBkYXRlIHRoZSBkb2chPC9idXR0b24+XFxuXFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0PC9kaXY+XFxuXFx0PC9mb3JtPlxcbjwvZGl2PlxcblwiXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIi9Vc2Vycy9tZVNpbmdoL1NpdGVzL19fS2h1cmFmYXRTL0xhcmFnaXN0Lm9yZy9IVE1ML3Jlc291cmNlcy9hc3NldHMvanMvY29tcGlsZWQvcGFnZXMvZG9ncy9zaG93LnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLnRlbXBsYXRlKVxuICB9XG59KSgpfSIsIi8qKlxuICogQ3JlYXRlZCBieSBQaXl1c2ggQWdyYXdhbCBvbiAyMy8wNC8xNi5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2lzdHM6IFtdLFxuXG4gICAgICAgICAgICBxOiBcIlwiLFxuICAgICAgICAgICAgY2F0ZWdvcmllczogW10sXG5cbiAgICAgICAgICAgIGFkZHRpb25hbDogXCJcIixcbiAgICAgICAgICAgIHNvcnRlZEFzOiBcIk1vc3QgRG93bmxvYWRlZFwiLFxuICAgICAgICAgICAgc29ydGJ5OiBcIiZzb3J0Ynk9bWRcIixcblxuICAgICAgICAgICAgcGFnaW5hdGlvbjoge1xuICAgICAgICAgICAgICAgIHRvdGFsOiAxMjAsXG4gICAgICAgICAgICAgICAgcGVyX3BhZ2U6IDEyLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRfcGFnZTogMSxcbiAgICAgICAgICAgICAgICB0b3RhbF9wYWdlczogMTBcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgICAgICB0aGlzLmZldGNoR2lzdHMoKTtcbiAgICAgICAgdGhpcy5nZXRDYXRlZ29yaWVzKCk7XG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgZmV0Y2hHaXN0czogZnVuY3Rpb24gZmV0Y2hHaXN0cygpIHtcblxuICAgICAgICAgICAgaWYgKHRoaXMucS5sZW5ndGggPCAzICYmIHRoaXMucS5sZW5ndGggPiAwKSByZXR1cm47XG5cbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIC8vIEdFVCByZXF1ZXN0XG4gICAgICAgICAgICBjbGllbnQoeyBwYXRoOiAnLz9xPScgKyB0aGlzLnEgKyB0aGlzLmFkZHRpb25hbCArIHRoaXMuc29ydGJ5ICsgJyZwYWdlPScgKyB0aGlzLnBhZ2luYXRpb24uY3VycmVudF9wYWdlIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5lbnRpdHkubWV0YS5wYWdpbmF0aW9uLnRvdGFsID4gMCkgdGhhdC5naXN0cyA9IHJlc3BvbnNlLmVudGl0eS5kYXRhO1xuXG4gICAgICAgICAgICAgICAgdGhhdC5wYWdpbmF0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICB0b3RhbDogcmVzcG9uc2UuZW50aXR5Lm1ldGEucGFnaW5hdGlvbi50b3RhbCxcbiAgICAgICAgICAgICAgICAgICAgcGVyX3BhZ2U6IHJlc3BvbnNlLmVudGl0eS5tZXRhLnBhZ2luYXRpb24ucGVyX3BhZ2UsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfcGFnZTogcmVzcG9uc2UuZW50aXR5Lm1ldGEucGFnaW5hdGlvbi5jdXJyZW50X3BhZ2UsXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsX3BhZ2VzOiByZXNwb25zZS5lbnRpdHkubWV0YS5wYWdpbmF0aW9uLnRvdGFsX3BhZ2VzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIC8vIGVycm9yIGNhbGxiYWNrXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRDYXRlZ29yaWVzOiBmdW5jdGlvbiBnZXRDYXRlZ29yaWVzKCkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgY2xpZW50KHsgcGF0aDogJy9jYXRlZ29yaWVzJyB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuZW50aXR5LmRhdGEuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGl0ZW0ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrZWQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaXRlbS5pZFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB0aGF0LmNhdGVnb3JpZXMucHVzaCh0ZW1wKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIC8vIGVycm9yIGNhbGxiYWNrXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZWxlY3RDYXRlZ29yeTogZnVuY3Rpb24gc2VsZWN0Q2F0ZWdvcnkoY2F0ZWdvcnkpIHtcblxuICAgICAgICAgICAgdGhpcy5wYWdpbmF0aW9uLmN1cnJlbnRfcGFnZSA9IDE7XG5cbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gJyc7XG4gICAgICAgICAgICB0aGlzLmNhdGVnb3JpZXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmNsaWNrZWQgPT0gMSkgY3VycmVudCA9IGl0ZW07XG5cbiAgICAgICAgICAgICAgICBpdGVtLmNsaWNrZWQgPSAwO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50LmlkICE9PSBjYXRlZ29yeS5pZCkgY2F0ZWdvcnkuY2xpY2tlZCA9IDE7XG5cbiAgICAgICAgICAgIGlmIChjYXRlZ29yeS5jbGlja2VkID09IDEpIHRoaXMuYWRkdGlvbmFsID0gJyZjaWQ9JyArIGNhdGVnb3J5LmlkO2Vsc2UgdGhpcy5hZGR0aW9uYWwgPSAnJztcblxuICAgICAgICAgICAgdGhpcy5mZXRjaEdpc3RzKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc29ydDogZnVuY3Rpb24gc29ydCh0eXBlLCBjdXJyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnBhZ2luYXRpb24uY3VycmVudF9wYWdlID0gMTtcbiAgICAgICAgICAgIHRoaXMuc29ydGJ5ID0gXCImc29ydGJ5PVwiICsgdHlwZTtcbiAgICAgICAgICAgIHRoaXMuc29ydGVkQXMgPSBjdXJyZW50O1xuICAgICAgICAgICAgdGhpcy5mZXRjaEdpc3RzKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXV0aG9yOiBmdW5jdGlvbiBhdXRob3IobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5hbWUuc3BsaXQoJy8nKVswXTtcbiAgICAgICAgfSxcblxuICAgICAgICBcInBhY2thZ2VcIjogZnVuY3Rpb24gX3BhY2thZ2UobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5hbWUuc3BsaXQoJy8nKVsxXTtcbiAgICAgICAgfVxuICAgIH1cblxufTtcblxuVnVlLnRyYW5zaXRpb24oJ3NsaWRlSW4nLCB7XG4gICAgZW50ZXJDbGFzczogJ3NsaWRlSW5VcCcsXG4gICAgbGVhdmVDbGFzczogJ3NsaWRlT3V0RG93bidcbn0pO1xuOyh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIj8gbW9kdWxlLmV4cG9ydHMub3B0aW9uczogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gXCJcXG4gICAgPG5hdi1jb21wb25lbnQ+PC9uYXYtY29tcG9uZW50PlxcblxcblxcdDxzZWN0aW9uIGNsYXNzPVxcXCJ3ZWxjb21lXFxcIj5cXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjb250YWluZXJcXFwiPlxcblxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuXFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiY29sLW1kLTMgY29sLW1kLW9mZnNldC0xXFxcIj5cXG5cXHRcXHRcXHRcXHRcXHQ8aW1nIHNyYz1cXFwiL2ltYWdlcy9sYXJhdmVsLnBuZ1xcXCIgc3R5bGU9XFxcIndpZHRoOiAxMDAlO1xcXCI+XFxuXFx0XFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiY29sLW1kLThcXFwiPlxcblxcdFxcdFxcdFxcdFxcdDxoMj48Yj5MYXJhZ2lzdDwvYj4gaXMgYSA8Yj5jb21tdW5pdHktc3VwcG9ydGVkIGNhdGFsb2c8L2I+IG9mIGxhcmF2ZWwgcGFja2FnZXMgYW5kIGxpYnJhcmllcyBjdXJhdGVkIGJ5IDxiPktodXJhZmF0aSBHYW5nPC9iPjwvaDI+XFxuXFx0XFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0PC9kaXY+XFxuXFx0PC9zZWN0aW9uPlxcblxcbiAgICA8c2VjdGlvbiBjbGFzcz1cXFwicHJvbW9cXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29udGFpbmVyXFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtMTAgY29sLW1kLW9mZnNldC0xXFxcIj5cXG4gICAgICAgICAgICA8aDM+XFxuICAgICAgICAgICAgICAgIFdhbnQgcmVhbC10aW1lIHN1cHBvcnQgZm9yIHRoZXNlIGxhcmF2ZWwgcGFja2FnZXM/XFxuICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ0biBidG4tbGFyYSBwdWxsLXJpZ2h0XFxcIj4gR2V0IFN1cHBvcnQgPC9idXR0b24+XFxuICAgICAgICAgICAgPC9oMz5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L3NlY3Rpb24+XFxuXFxuXFx0PHNlY3Rpb24gY2xhc3M9XFxcInBhY2thZ2VzXFxcIj5cXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjb250YWluZXJcXFwiPlxcblxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNhdGVnb3JpZXNcXFwiPlxcbiAgICAgICAgICAgICAgICA8dWwgY2xhc3M9XFxcImxpc3QtaW5saW5lXFxcIj4gXFxuICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgPGxpIHYtZm9yPVxcXCJjYXRlZ29yeSBpbiBjYXRlZ29yaWVzXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8YSB2LWJpbmQ6Y2xhc3M9XFxcInsnYWN0aXZlJzogY2F0ZWdvcnkuY2xpY2tlZCB9XFxcIiB2LW9uOmNsaWNrPVxcXCJzZWxlY3RDYXRlZ29yeShjYXRlZ29yeSlcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3tjYXRlZ29yeS5uYW1lfX0gXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtdGltZXNcXFwiIHYtc2hvdz1cXFwiY2F0ZWdvcnkuY2xpY2tlZFxcXCI+PC9pPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICAgICAgICAgIDwvbGk+XFxuXFxuICAgICAgICAgICAgICAgIDwvdWw+XFxuICAgICAgICAgICAgPC9kaXY+XFxuXFxuXFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiaW5wdXQtZ3JvdXAgaW5wdXQtZ3JvdXAtbGcgc2VhcmNoXFxcIj5cXG5cXHRcXHRcXHRcXHQ8aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgaWQ9XFxcInNlYXJjaElucHV0XFxcIiB2LW1vZGVsPVxcXCJxXFxcIiB2LW9uOmtleXVwPVxcXCJmZXRjaEdpc3RzKClcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIHBsYWNlaG9sZGVyPVxcXCJTZWFyY2ggdGhlIGJlc3QgbGFyYXZlbCBwYWNrYWdlcyBieSBlbnRlcmluZyAzIG9yIG1vcmUgY2hhcmFjdGVyc1xcXCI+XFxuXFx0XFx0XFx0ICBcXHQ8ZGl2IGNsYXNzPVxcXCJpbnB1dC1ncm91cC1idG5cXFwiPlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0IG5vLW91dGxpbmVcXFwiIGRhdGEtdG9nZ2xlPVxcXCJkcm9wZG93blxcXCIgYXJpYS1oYXNwb3B1cD1cXFwidHJ1ZVxcXCIgYXJpYS1leHBhbmRlZD1cXFwiZmFsc2VcXFwiPlxcblxcdFxcdFxcdFxcdCAgICBcXHRcXHR7eyBzb3J0ZWRBcyB9fSA8c3BhbiBjbGFzcz1cXFwiY2FyZXRcXFwiPjwvc3Bhbj5cXG5cXHRcXHRcXHRcXHQgIFxcdFxcdDwvYnV0dG9uPlxcblxcdFxcdFxcdFxcdFxcblxcdFxcdFxcdFxcdCAgXFx0XFx0PHVsIGNsYXNzPVxcXCJkcm9wZG93bi1tZW51IGNsaWNrLXBvaW50ZXJcXFwiPlxcblxcdFxcdFxcdFxcdCAgICBcXHRcXHQ8bGk+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YSB2LW9uOmNsaWNrPVxcXCJzb3J0KCdtZCcsJ01vc3QgRG93bmxvYWRlZCcpXFxcIj4gXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTW9zdCBEb3dubG9hZGVkXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2E+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhIHYtb246Y2xpY2s9XFxcInNvcnQoJ21wJywnTW9zdCBQb3B1bGFyJylcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1vc3QgUG9wdWxhclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2xpPlxcblxcdFxcdFxcdFxcdCAgICBcXHRcXHQ8bGk+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YSB2LW9uOmNsaWNrPVxcXCJzb3J0KCdydScsJ1JlY2VudGx5IFVwZGF0ZWQnKVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVjZW50bHkgVXBkYXRlZFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2xpPlxcblxcdFxcdFxcdFxcdCAgXFx0XFx0PC91bD5cXG5cXHRcXHRcXHRcXHQgIFxcdFxcblxcdFxcdFxcdCAgXFx0PC9kaXY+XFxuXFx0XFx0XFx0PC9kaXY+XFxuXFxuICAgICAgICAgICAgPGJyPlxcblxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgIFxcdFxcdCAgICA8ZGl2IGNsYXNzPVxcXCJwYWNrYWdlIGNvbC1tZC02XFxcIiB2LWZvcj1cXFwiZ2lzdCBpbiBnaXN0c1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ3cmFwcGVyXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJsYXRlc3RcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtZncgZmEtY29kZS1mb3JrXFxcIj48L2k+Jm5ic3A7IFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj57eyBnaXN0LnZlcnNpb24gfX08L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgIFxcdCAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImluZm9cXFwiPlxcbiAgICBcXHQgICAgICAgICAgICAgICAgPGgzPjxhIHYtbGluaz1cXFwieyBuYW1lOiAndmlldycsIHBhcmFtczoge3VzZXI6YXV0aG9yKGdpc3QubmFtZSksIG5hbWU6IHBhY2thZ2UoZ2lzdC5uYW1lKX19XFxcIj57eyBnaXN0Lm5hbWUudHJ1bmMoMzIpIH19PC9hPjwvaDM+XFxuICAgIFxcdCAgICAgICAgICAgICAgICA8cD57eyBnaXN0LmRlc2NyaXB0aW9uLnRydW5jKDEyMCkgfX08L3A+XFxuICAgIFxcdCAgICAgICAgICAgIDwvZGl2PlxcbiAgICBcXHQgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJtZXRhXFxcIj5cXG4gICAgXFx0ICAgICAgICAgICAgXFx0PHVsIGNsYXNzPVxcXCJsaXN0LXVuc3R5bGVkXFxcIj5cXG4gICAgXFx0ICAgICAgICAgICAgXFx0XFx0PGxpPlxcbiAgICBcXHQgICAgICAgICAgICBcXHRcXHRcXHQ8aSBjbGFzcz1cXFwiZmEgZmEtZncgZmEtZG93bmxvYWRcXFwiPjwvaT4mbmJzcDsgXFxuICAgIFxcdCAgICAgICAgICAgIFxcdFxcdFxcdDxzcGFuPnt7IGdpc3QuZG93bmxvYWRzX3RvdGFsIH19PC9zcGFuPlxcbiAgICBcXHQgICAgICAgICAgICBcXHRcXHQ8L2xpPlxcbiAgICBcXHQgICAgICAgICAgICBcXHRcXHQ8bGk+XFxuICAgIFxcdCAgICAgICAgICAgIFxcdFxcdFxcdDxpIGNsYXNzPVxcXCJmYSBmYS1mdyBmYS1oZWFydFxcXCI+PC9pPiZuYnNwOyBcXG4gICAgXFx0ICAgICAgICAgICAgXFx0XFx0XFx0PHNwYW4+e3sgZ2lzdC5mYXZvcml0ZXMgfX08L3NwYW4+XFxuICAgIFxcdCAgICAgICAgICAgIFxcdFxcdDwvbGk+XFxuICAgIFxcdCAgICAgICAgICAgIFxcdDwvdWw+XFxuICAgIFxcdCAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwibWV0YS1pbmZvXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cXFwicHVsbC1yaWdodFxcXCI+PHNtYWxsPnVwZGF0ZWQgb246IHt7IGdpc3QubGFzdF91cGRhdGVkIH19PC9zbWFsbD48L3A+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHVsIGNsYXNzPVxcXCJsaXN0LWlubGluZVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaT48aSBjbGFzcz1cXFwiZmEgZmEtZncgZmEtYmFyc1xcXCI+PC9pPjwvbGk+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaSB2LWZvcj1cXFwiY2F0IGluIGdpc3QuY2F0ZWdvcmllc1xcXCI+e3tjYXQubmFtZX19PC9saT5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3VsPlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgXFx0XFx0ICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgIDwvZGl2PlxcblxcdFxcdDwvZGl2PlxcblxcdDwvc2VjdGlvbj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwiY29udGFpbmVyXFxcIj5cXG4gICAgICAgIDxwYWdpbmF0aW9uIDpwYWdpbmF0aW9uPVxcXCJwYWdpbmF0aW9uXFxcIiBzaXplPVxcXCJwYWdpbmF0aW9uLW1kXFxcIiBjbGFzcz1cXFwidGV4dC1jZW50ZXJcXFwiIDpjYWxsYmFjaz1cXFwiZmV0Y2hHaXN0c1xcXCI+PC9wYWdpbmF0aW9uPlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGZvb3Rlci1jb21wb25lbnQ+PC9mb290ZXItY29tcG9uZW50PlxcblwiXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIi9Vc2Vycy9tZVNpbmdoL1NpdGVzL19fS2h1cmFmYXRTL0xhcmFnaXN0Lm9yZy9IVE1ML3Jlc291cmNlcy9hc3NldHMvanMvY29tcGlsZWQvcGFnZXMvaG9tZS52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy50ZW1wbGF0ZSlcbiAgfVxufSkoKX0iLCI7KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiPyBtb2R1bGUuZXhwb3J0cy5vcHRpb25zOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBcIlxcbjxkaXYgY2xhc3M9XFxcInBhbmVsLWhlYWRpbmdcXFwiPlxcblxcdEFib3V0IHVzXFxuPC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwicGFuZWwtYm9keVxcXCI+XFxuXFx0VGhpcyBpcyBhIHNhbXBsZSB3ZWJwYWdlIHRoYXQgYXV0aGVudGljYXRlcyBhZ2FpbnN0IGEgTGFyYXZlbCBBUEkgYW5kIGdldHMgdGhlIG9ibGlnYXRvcnkgZG9ncy5cXG48L2Rpdj5cIlxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCIvVXNlcnMvbWVTaW5naC9TaXRlcy9fX0todXJhZmF0Uy9MYXJhZ2lzdC5vcmcvSFRNTC9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBpbGVkL3BhZ2VzL2hvbWUvYWJvdXQudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMudGVtcGxhdGUpXG4gIH1cbn0pKCl9IiwiOyh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIj8gbW9kdWxlLmV4cG9ydHMub3B0aW9uczogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gXCJcXG48ZGl2IGNsYXNzPVxcXCJwYW5lbC1oZWFkaW5nXFxcIj5cXG5cXHRIb21lcGFnZSBkZWZhdWx0XFxuPC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwicGFuZWwtYm9keVxcXCI+XFxuXFx0U2VsZWN0IGFuIGFjdGlvbiB0byB5b3VyIGxlZnQuIFRoaXMgcGFnZSBzZXJ2ZXMgYXMgYSBkZW1vIGZvciB0aGUgJ2RlZmF1bHQnIHJvdXRlIGluIGEgVnVlIHN1YlJvdXRlLlxcbjwvZGl2PlwiXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIi9Vc2Vycy9tZVNpbmdoL1NpdGVzL19fS2h1cmFmYXRTL0xhcmFnaXN0Lm9yZy9IVE1ML3Jlc291cmNlcy9hc3NldHMvanMvY29tcGlsZWQvcGFnZXMvaG9tZS9ob21lLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLnRlbXBsYXRlKVxuICB9XG59KSgpfSIsIjsodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCI/IG1vZHVsZS5leHBvcnRzLm9wdGlvbnM6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IFwiXFxuPGRpdiBjbGFzcz1cXFwicGFuZWwtaGVhZGluZ1xcXCI+XFxuXFx0V2VsY29tZVxcbjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcInBhbmVsLWJvZHlcXFwiPlxcblxcdEhlcmUgZ29lcyB0aGUgd2VsY29tZSBwYWdlXFxuPC9kaXY+XCJcbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiL1VzZXJzL21lU2luZ2gvU2l0ZXMvX19LaHVyYWZhdFMvTGFyYWdpc3Qub3JnL0hUTUwvcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9wYWdlcy9ob21lL3dlbGNvbWUudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMudGVtcGxhdGUpXG4gIH1cbn0pKCl9IiwiLyoqXG4gKiBDcmVhdGVkIGJ5IFBpeXVzaCBBZ3Jhd2FsIG9uIDIzLzA0LzE2LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2lzdHM6IFtdLFxuICAgICAgICAgICAgcTogJycsXG4gICAgICAgICAgICBub3RGb3VuZDogZmFsc2UsXG4gICAgICAgICAgICBzdWJtaXR0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgc2VsZWN0ZWRHaXN0OiB7XG5cbiAgICAgICAgICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgICAgICAgICBmaXJzdF9uYW1lOiAnJyxcbiAgICAgICAgICAgICAgICBlbWFpbDogJycsXG4gICAgICAgICAgICAgICAgY2F0ZWdvcnlfaWQ6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcjogXCJcIixcbiAgICAgICAgICAgIGVycm9yczoge1xuICAgICAgICAgICAgICAgIGZpcnN0X25hbWU6IFwiXCIsXG4gICAgICAgICAgICAgICAgZW1haWw6IFwiXCIsXG4gICAgICAgICAgICAgICAgY2F0ZWdvcnlfaWQ6IFwiXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYXRlZ29yaWVzOiBbXSxcbiAgICAgICAgICAgIGdpc3RzVW5kZXJSZXZpZXc6IFtdXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XG4gICAgICAgIHRoaXMuZ2V0Q2F0ZWdvcmllcygpO1xuICAgICAgICB0aGlzLmdldFVuZGVyUmV2aWV3cygpO1xuICAgIH0sXG5cbiAgICBtZXRob2RzOiB7XG4gICAgICAgIHNlYXJjaDogZnVuY3Rpb24gc2VhcmNoKCkge1xuICAgICAgICAgICAgdGhpcy5ub3RGb3VuZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5xLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldFVuZGVyUmV2aWV3cygpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gR0VUIHJlcXVlc3RcblxuICAgICAgICAgICAgdGhpcy5naXN0c1VuZGVyUmV2aWV3ID0gW107XG5cbiAgICAgICAgICAgIHRoaXMuJGh0dHAoeyB1cmw6ICdodHRwczovL3BhY2thZ2lzdC5vcmcvc2VhcmNoLmpzb24/cT0nICsgdGhpcy5xLCBtZXRob2Q6ICdHRVQnIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuZGF0YS50b3RhbCA+IDApIHRoaXMuZ2lzdHMgPSByZXNwb25zZS5kYXRhLnJlc3VsdHM7ZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm90Rm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdpc3RzID0gW107XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgLy8gZXJyb3IgY2FsbGJhY2tcbiAgICAgICAgICAgIH0pLmJpbmQodGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2VsZWN0R2lzdDogZnVuY3Rpb24gc2VsZWN0R2lzdChnaXN0KSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkR2lzdC5uYW1lID0gZ2lzdC5uYW1lO1xuICAgICAgICAgICAgdGhpcy5lcnJvciA9IFwiXCI7XG4gICAgICAgICAgICB0aGlzLmVycm9ycyA9IHtcbiAgICAgICAgICAgICAgICBmaXJzdF9uYW1lOiBcIlwiLFxuICAgICAgICAgICAgICAgIGVtYWlsOiBcIlwiLFxuICAgICAgICAgICAgICAgIGNhdGVnb3J5X2lkOiBcIlwiXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5zdWJtaXR0ZWQgPSBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRDYXRlZ29yaWVzOiBmdW5jdGlvbiBnZXRDYXRlZ29yaWVzKCkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgY2xpZW50KHsgcGF0aDogJy9jYXRlZ29yaWVzJyB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLmVudGl0eS5kYXRhLmZvckVhY2goZnVuY3Rpb24gKGNhdGVnb3J5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuY2F0ZWdvcmllcy5wdXNoKGNhdGVnb3J5KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHN1Ym1pdFBhY2thZ2U6IGZ1bmN0aW9uIHN1Ym1pdFBhY2thZ2UoKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yID0gXCJcIjtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzID0ge1xuICAgICAgICAgICAgICAgIGZpcnN0X25hbWU6IFwiXCIsXG4gICAgICAgICAgICAgICAgZW1haWw6IFwiXCIsXG4gICAgICAgICAgICAgICAgY2F0ZWdvcnlfaWQ6IFwiXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICBjbGllbnQoeyBwYXRoOiAnL3N1Ym1pdCcsIGVudGl0eTogdGhpcy5zZWxlY3RlZEdpc3QgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICB0aGF0LnN1Ym1pdHRlZCA9IHRydWU7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cy5jb2RlID09IDQwMCkgdGhhdC5lcnJvciA9IHJlc3BvbnNlLmVudGl0eS5tZXNzYWdlO2Vsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cy5jb2RlID49IDUwMCkgdGhhdC5lcnJvciA9IFwiU29tZSB1bmtub3duIGVycm9yIG9jY3VycmVkLiBQbGVhc2UgdHJ5IGFnYWluIGxhdGVyXCI7ZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzLmNvZGUgPSA0MjIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5lcnJvcnMuZmlyc3RfbmFtZSA9IHJlc3BvbnNlLmVudGl0eS5lcnJvcnMuZmlyc3RfbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5lcnJvcnMuZW1haWwgPSByZXNwb25zZS5lbnRpdHkuZXJyb3JzLmVtYWlsO1xuICAgICAgICAgICAgICAgICAgICB0aGF0LmVycm9ycy5jYXRlZ29yeV9pZCA9IHJlc3BvbnNlLmVudGl0eS5lcnJvcnMuY2F0ZWdvcnlfaWQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoYXQuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRVbmRlclJldmlld3M6IGZ1bmN0aW9uIGdldFVuZGVyUmV2aWV3cygpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZ2lzdHMgPSBbXTtcbiAgICAgICAgICAgIGNsaWVudCh7IHBhdGg6ICcvdW5kZXItcmV2aWV3JyB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHRoYXQuZ2lzdHNVbmRlclJldmlldyA9IHJlc3BvbnNlLmVudGl0eS5kYXRhO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgIH1cblxufTtcbjsodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCI/IG1vZHVsZS5leHBvcnRzLm9wdGlvbnM6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IFwiXFxuPG5hdi1jb21wb25lbnQ+PC9uYXYtY29tcG9uZW50PlxcbjxzZWN0aW9uIGNsYXNzPVxcXCJ3ZWxjb21lXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiY29udGFpbmVyXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTMgY29sLW1kLW9mZnNldC0xXFxcIj5cXG4gICAgICAgICAgICAgICAgPGltZyBzcmM9XFxcIi9pbWFnZXMvcGFja2FnaXN0LnBuZ1xcXCIgc3R5bGU9XFxcIndpZHRoOiA3MCU7bWFyZ2luLWxlZnQ6IDE1JTtcXFwiPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC04XFxcIj5cXG4gICAgICAgICAgICAgICAgPGgyPlNlYXJjaCA8Yj5QYWNrYWdpc3Qub3JnPC9iPiBmb3IgbGFyYXZlbCBwYWNrYWdlcyBhbmQgc3VibWl0IHRoZW0gdG8gdXMuPC9oMj5cXG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcInRleHRcXFwiIGlkPVxcXCJzZWFyY2hJbnB1dFxcXCIgdi1tb2RlbD1cXFwicVxcXCIgdi1vbjprZXl1cD1cXFwic2VhcmNoKClcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2wgaW5wdXQtbGdcXFwiIHBsYWNlaG9sZGVyPVxcXCJTZWFyY2ggcGFja2FnaXN0Lm9yZyBieSBlbnRlcmluZyAzIG9yIG1vcmUgY2hhcmFjdGVyc1xcXCIgc3R5bGU9XFxcIm1hcmdpbi10b3A6IDMwcHg7XFxcIj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG48L3NlY3Rpb24+XFxuPGRpdiBjbGFzcz1cXFwibWFpbi1jb250YWluZXJcXFwiPlxcbiAgICA8c2VjdGlvbiBjbGFzcz1cXFwicGFja2FnZXNcXFwiIHN0eWxlPVxcXCJwYWRkaW5nLXRvcDogNTBweDtcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29udGFpbmVyXFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtOCBjb2wtbWQtb2Zmc2V0LTIgY29sLXNtLTEwIGNvbC1zbS1vZmZzZXQtMSB0ZXh0LWNlbnRlclxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8aDMgaWQ9XFxcImJyYW5kLXRpdGxlXFxcIiB2LWlmPVxcXCIhcVxcXCI+TGF0ZXN0IHN1Ym1pdHRlZCBwYWNrYWdlcyBieSBvdXIgY29tbXVuaXR5PC9oMz5cXG4gICAgICAgICAgICAgICAgICAgIDxoMyBpZD1cXFwiYnJhbmQtdGl0bGVcXFwiIHYtaWY9XFxcInFcXFwiPlNlYXJjaCByZXN1bHRzIGZvcjogPHNwYW4+e3sgcSB8IGNhcGl0YWxpemUgfX08L3NwYW4+PC9oMz5cXG4gICAgICAgICAgICAgICAgICAgIDxicj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLWxnLTEyXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8IS0tIC8uY29sLWxnLTYgLS0+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDwhLS0gLy5yb3cgLS0+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtc20tMTIgdGV4dC1jZW50ZXJcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGJyPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiYWxlcnQgYWxlcnQtZGFuZ2VyXFxcIiB2LXNob3c9XFxcIm5vdEZvdW5kXFxcIj5Ob3RoaW5nIGZvdW5kISBQbGVhc2UgdHJ5IHNlYXJjaGluZyB3aXRoIGRpZmZlcmVudCBrZXl3b3JkPC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb250YWluZXJcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuXFxuICAgICAgICAgICAgICAgIDwhLS0gVW5kZXIgcmV2aWV3IHBhY2thZ2VzIC0tPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJwYWNrYWdlIGNvbC1tZC02XFxcIiB2LWZvcj1cXFwiZ2lzdCBpbiBnaXN0c1VuZGVyUmV2aWV3XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIndyYXBwZXIgc3VibWl0LXdyYXBwZXJcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImluZm9cXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aDM+PGEgdGl0bGU9XFxcInt7Z2lzdC5uYW1lfX1cXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7e2dpc3QubmFtZS50cnVuYygzMil9fVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2gzPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cD57e2dpc3QuZGVzY3JpcHRpb24udHJ1bmMoMTIwKX19PC9wPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIm1ldGFcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dWwgY2xhc3M9XFxcImxpc3QtdW5zdHlsZWRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1mdyBmYS1kb3dubG9hZFxcXCI+PC9pPiZuYnNwO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPnt7IGdpc3QuZG93bmxvYWRzX3RvdGFsIH19PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtZncgZmEtaGVhcnRcXFwiPjwvaT4mbmJzcDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj57eyBnaXN0LmZhdm9yaXRlcyB9fTwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdWw+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPCEtLSA8ZGl2IGNsYXNzPVxcXCJzdWJtaXQgcHVsbC1yaWdodFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIGRhdGEtdG9nZ2xlPVxcXCJtb2RhbFxcXCIgdi1vbjpjbGljaz1cXFwic2VsZWN0R2lzdChnaXN0KVxcXCIgZGF0YS10YXJnZXQ9XFxcIiNzdWJtaXRNb2RhbFxcXCI+IFN1Ym1pdHRlZCBieTogIDwvYT5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4gLS0+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwibWV0YS1pbmZvXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XFxcInB1bGwtcmlnaHRcXFwiPjxzbWFsbD5zdWJtaXR0ZWQgYnk6IHt7Z2lzdC51c2VyfX08L3NtYWxsPjwvcD5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgICAgICAgICAgPCEtLSAuLyBVbmRlciByZXZpZXcgcGFja2FnZXMgLS0+XFxuXFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInBhY2thZ2UgY29sLW1kLTZcXFwiIHYtZm9yPVxcXCJnaXN0IGluIGdpc3RzXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIndyYXBwZXIgc3VibWl0LXdyYXBwZXJcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImluZm9cXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aDM+PGEgdGl0bGU9XFxcInt7Z2lzdC5uYW1lfX1cXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7e2dpc3QubmFtZS50cnVuYygzMil9fVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2gzPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cD57e2dpc3QuZGVzY3JpcHRpb24udHJ1bmMoMTIwKX19PC9wPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIm1ldGFcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dWwgY2xhc3M9XFxcImxpc3QtdW5zdHlsZWRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1mdyBmYS1kb3dubG9hZFxcXCI+PC9pPiZuYnNwO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPnt7IGdpc3QuZG93bmxvYWRzIH19PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtZncgZmEtaGVhcnRcXFwiPjwvaT4mbmJzcDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj57eyBnaXN0LmZhdmVycyB9fTwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdWw+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwic3VibWl0IHB1bGwtcmlnaHRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVxcXCIjXFxcIiBkYXRhLXRvZ2dsZT1cXFwibW9kYWxcXFwiIHYtb246Y2xpY2s9XFxcInNlbGVjdEdpc3QoZ2lzdClcXFwiIGRhdGEtdGFyZ2V0PVxcXCIjc3VibWl0TW9kYWxcXFwiPiBTdWJtaXQgPC9hPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwhLS0gPGRpdiBjbGFzcz1cXFwibWV0YS1pbmZvXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XFxcInB1bGwtcmlnaHRcXFwiPjxzbWFsbD5zdWJtaXR0ZWQgYnk6IE1hbmRlZXAgU2luZ2g8L3NtYWxsPjwvcD5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4gLS0+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9zZWN0aW9uPlxcbjwvZGl2Plxcbjxmb290ZXItY29tcG9uZW50PjwvZm9vdGVyLWNvbXBvbmVudD5cXG48ZGl2IGNsYXNzPVxcXCJtb2RhbCBmYWRlIGluXFxcIiBpZD1cXFwic3VibWl0TW9kYWxcXFwiIHRhYmluZGV4PVxcXCItMVxcXCIgcm9sZT1cXFwiZGlhbG9nXFxcIiBhcmlhLWxhYmVsbGVkYnk9XFxcIm15TW9kYWxMYWJlbFxcXCIgYXJpYS1oaWRkZW49XFxcImZhbHNlXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwibW9kYWwtZGlhbG9nXFxcIiByb2xlPVxcXCJkb2N1bWVudFxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJtb2RhbC1jb250ZW50XFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJtb2RhbC1oZWFkZXJcXFwiPlxcbiAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImNsb3NlXFxcIiBkYXRhLWRpc21pc3M9XFxcIm1vZGFsXFxcIiBhcmlhLWxhYmVsPVxcXCJDbG9zZVxcXCI+PHNwYW4gYXJpYS1oaWRkZW49XFxcInRydWVcXFwiPsOXPC9zcGFuPjwvYnV0dG9uPlxcbiAgICAgICAgICAgICAgICA8aDQgY2xhc3M9XFxcIm1vZGFsLXRpdGxlXFxcIiBpZD1cXFwibXlNb2RhbExhYmVsXFxcIj5TdWJtaXQgUGFja2FnZTwvaDQ+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwibW9kYWwtYm9keVxcXCI+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImFsZXJ0IGFsZXJ0LWRhbmdlclxcXCIgaWQ9XFxcIm1vZGFsRXJyb3JcXFwiIHYtc2hvdz1cXFwiZXJyb3JcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAge3t7ZXJyb3J9fX1cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImFsZXJ0IGFsZXJ0LXN1Y2Nlc3NcXFwiIGlkPVxcXCJtb2RhbFN1Y2Nlc3NcXFwiIHYtc2hvdz1cXFwic3VibWl0dGVkXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIFlvdXIgc3VibWlzc2lvbiBoYXMgYmVlbiBzYXZlZCBhbmQgd2lsbCBiZSByZXZpZXdlZCBieSBvdXIgdGVhbS5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDxmb3JtIGNsYXNzPVxcXCJmb3JtLWhvcml6b250YWxcXFwiIHYtc2hvdz1cXFwiIXN1Ym1pdHRlZFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8ZmllbGRzZXQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPCEtLSBUZXh0IGlucHV0LS0+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cXFwiY29sLW1kLTQgY29udHJvbC1sYWJlbFxcXCIgZm9yPVxcXCJuYW1lXFxcIj5OYW1lPC9sYWJlbD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTZcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IGlkPVxcXCJuYW1lXFxcIiBuYW1lPVxcXCJuYW1lXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBwbGFjZWhvbGRlcj1cXFwiXFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sIGlucHV0LW1kXFxcIiBkaXNhYmxlZD1cXFwiXFxcIiByZXF1aXJlZD1cXFwiXFxcIiB2LW1vZGVsPVxcXCJzZWxlY3RlZEdpc3QubmFtZVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwhLS0gVGV4dCBpbnB1dC0tPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiIHYtYmluZDpjbGFzcz1cXFwieydoYXMtZXJyb3InOiBlcnJvcnMuZmlyc3RfbmFtZX1cXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XFxcImNvbC1tZC00IGNvbnRyb2wtbGFiZWxcXFwiIGZvcj1cXFwiZmlyc3RfbmFtZVxcXCI+Rmlyc3QgTmFtZTwvbGFiZWw+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC02XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBpZD1cXFwiZmlyc3RfbmFtZVxcXCIgbmFtZT1cXFwiZmlyc3RfbmFtZVxcXCIgdHlwZT1cXFwidGV4dFxcXCIgcGxhY2Vob2xkZXI9XFxcIlxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbCBpbnB1dC1tZFxcXCIgcmVxdWlyZWQ9XFxcIlxcXCIgdi1tb2RlbD1cXFwic2VsZWN0ZWRHaXN0LmZpcnN0X25hbWVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImhlbHAtYmxvY2tcXFwiIHYtc2hvdz1cXFwiZXJyb3JzLmZpcnN0X25hbWVcXFwiPnt7IGVycm9ycy5maXJzdF9uYW1lWzBdIH19PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8IS0tIFRleHQgaW5wdXQtLT5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIiB2LWJpbmQ6Y2xhc3M9XFxcInsnaGFzLWVycm9yJzogZXJyb3JzLmVtYWlsfVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cXFwiY29sLW1kLTQgY29udHJvbC1sYWJlbFxcXCIgZm9yPVxcXCJlbWFpbFxcXCI+RW1haWw8L2xhYmVsPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtNlxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgaWQ9XFxcImVtYWlsXFxcIiBuYW1lPVxcXCJlbWFpbFxcXCIgdHlwZT1cXFwidGV4dFxcXCIgcGxhY2Vob2xkZXI9XFxcIlxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbCBpbnB1dC1tZFxcXCIgcmVxdWlyZWQ9XFxcIlxcXCIgdi1tb2RlbD1cXFwic2VsZWN0ZWRHaXN0LmVtYWlsXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJoZWxwLWJsb2NrXFxcIiB2LXNob3c9XFxcImVycm9ycy5lbWFpbFxcXCI+e3sgZXJyb3JzLmVtYWlsWzBdIH19PC9zcGFuPlxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8IS0tIFNlbGVjdCBCYXNpYyAtLT5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIiB2LWJpbmQ6Y2xhc3M9XFxcInsnaGFzLWVycm9yJzogZXJyb3JzLmNhdGVnb3J5X2lkfVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cXFwiY29sLW1kLTQgY29udHJvbC1sYWJlbFxcXCIgZm9yPVxcXCJjYXRlZ29yeV9pZFxcXCI+U2VsZWN0IENhdGVnb3J5PC9sYWJlbD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTZcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNlbGVjdCBpZD1cXFwiY2F0ZWdvcnlfaWRcXFwiIG5hbWU9XFxcImNhdGVnb3J5X2lkXFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiB2LW1vZGVsPVxcXCJzZWxlY3RlZEdpc3QuY2F0ZWdvcnlfaWRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdi1mb3I9XFxcImNhdGVnb3J5IGluIGNhdGVnb3JpZXNcXFwiIHZhbHVlPVxcXCJ7e2NhdGVnb3J5LmlkfX1cXFwiPnt7Y2F0ZWdvcnkubmFtZX19PC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NlbGVjdD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJoZWxwLWJsb2NrXFxcIiB2LXNob3c9XFxcImVycm9ycy5jYXRlZ29yeV9pZFxcXCI+e3sgZXJyb3JzLmNhdGVnb3J5X2lkWzBdIH19PC9zcGFuPlxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDwvZmllbGRzZXQ+XFxuICAgICAgICAgICAgICAgIDwvZm9ybT5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJtb2RhbC1mb290ZXJcXFwiPlxcbiAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdFxcXCIgZGF0YS1kaXNtaXNzPVxcXCJtb2RhbFxcXCI+Q2xvc2U8L2J1dHRvbj5cXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLXByaW1hcnlcXFwiIHYtb246Y2xpY2s9XFxcInN1Ym1pdFBhY2thZ2UoKVxcXCIgaWQ9XFxcIm1vZGFsU3VibWl0XFxcIiB2LXNob3c9XFxcIiFzdWJtaXR0ZWRcXFwiPlN1Ym1pdDwvYnV0dG9uPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbjwvZGl2PlxcblwiXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIi9Vc2Vycy9tZVNpbmdoL1NpdGVzL19fS2h1cmFmYXRTL0xhcmFnaXN0Lm9yZy9IVE1ML3Jlc291cmNlcy9hc3NldHMvanMvY29tcGlsZWQvcGFnZXMvc3VibWl0LnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLnRlbXBsYXRlKVxuICB9XG59KSgpfSIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0ZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c3Vic2NyaWJlcjoge1xuXHRcdFx0XHRlbWFpbF9hZGRyZXNzOiBcIlwiLFxuXHRcdFx0XHRzdGF0dXM6IFwic3Vic2NyaWJlZFwiXG5cdFx0XHR9XG5cdFx0fTtcblx0fSxcblxuXHRtZXRob2RzOiB7XG5cdFx0c2VuZEVtYWlsOiBmdW5jdGlvbiBzZW5kRW1haWwoKSB7XG5cblx0XHRcdGNsaWVudCh7IHBhdGg6ICcvc3Vic2NyaWJlcnMnLCBlbnRpdHk6IHRoaXMuc3Vic2NyaWJlciB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge30pO1xuXHRcdH1cblx0fVxuXG59O1xuOyh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIj8gbW9kdWxlLmV4cG9ydHMub3B0aW9uczogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gXCJcXG48bmF2LWNvbXBvbmVudD48L25hdi1jb21wb25lbnQ+XFxuXFxuPGRpdiBjbGFzcz1cXFwic3VwcG9ydFxcXCI+XFxuICAgIDxzZWN0aW9uIGNsYXNzPVxcXCJ3ZWxjb21lXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbnRhaW5lclxcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTIgY29sLW1kLW9mZnNldC0xXFxcIj5cXG4gICAgICAgICAgICAgICAgXFx0PGkgY2xhc3M9XFxcImZhIGZhLWxpZmUtcmluZ1xcXCIgc3R5bGU9XFxcImZvbnQtc2l6ZTogMTUwcHg7IGNvbG9yOiNmZmZcXFwiPjwvaT5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC04XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxoMj5HZXQgc3VwcG9ydCBmb3Igb3VyIGxhcmF2ZWwgcGFja2FnZXM8L2gyPlxcbiAgICAgICAgICAgICAgICAgICAgPGZvcm0gYWN0aW9uPVxcXCIjXFxcIiB2LW9uOnN1Ym1pdD1cXFwic2VuZEVtYWlsKClcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImlucHV0LWdyb3VwXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcImVtYWlsXFxcIiBpZD1cXFwic2VhcmNoSW5wdXRcXFwiIHYtbW9kZWw9XFxcInN1YnNjcmliZXIuZW1haWxcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2wgaW5wdXQtbGdcXFwiIHBsYWNlaG9sZGVyPVxcXCJFbnRlciB5b3VyIGVtYWlsXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImlucHV0LWdyb3VwLWJ0blxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XFxcInN1Ym1pdFxcXCIgY2xhc3M9XFxcImJ0biBidG4tY3VzdG9tIGJ0bi1sZ1xcXCI+U3Vic2NyaWJlITwvYnV0dG9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8L2Zvcm0+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvc2VjdGlvbj5cXG5cXG4gICAgPHNlY3Rpb24gY2xhc3M9XFxcImNvbnRhaW5lciBjb250ZW50XFxcIj4gXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJibG9ja1xcXCI+XFxuICAgICAgICAgICAgPHA+XFxuICAgICAgICAgICAgICAgIExvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0LCBjb25zZWN0ZXR1ciBhZGlwaXNpY2luZyBlbGl0LCBzZWQgZG8gZWl1c21vZCB0ZW1wb3IgaW5jaWRpZHVudCB1dCBsYWJvcmUgZXQgZG9sb3JlIG1hZ25hIGFsaXF1YS4gVXQgZW5pbSBhZCBtaW5pbSB2ZW5pYW0sIHF1aXMgbm9zdHJ1ZCBleGVyY2l0YXRpb24gdWxsYW1jbyBsYWJvcmlzIG5pc2kgdXQgYWxpcXVpcCBleCBlYSBjb21tb2RvIGNvbnNlcXVhdC4gRHVpcyBhdXRlIGlydXJlIGRvbG9yIGluIHJlcHJlaGVuZGVyaXQgaW4gdm9sdXB0YXRlIHZlbGl0IGVzc2UgY2lsbHVtIGRvbG9yZSBldSBmdWdpYXQgbnVsbGEgcGFyaWF0dXIuIEV4Y2VwdGV1ciBzaW50IG9jY2FlY2F0IGN1cGlkYXRhdCBub24gcHJvaWRlbnQsIHN1bnQgaW4gY3VscGEgcXVpIG9mZmljaWEgZGVzZXJ1bnQgbW9sbGl0IGFuaW0gaWQgZXN0IGxhYm9ydW0uXFxuICAgICAgICAgICAgPC9wPlxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvc2VjdGlvbj5cXG5cXG48L2Rpdj5cXG5cXG48Zm9vdGVyLWNvbXBvbmVudD48L2Zvb3Rlci1jb21wb25lbnQ+XFxuXCJcbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiL1VzZXJzL21lU2luZ2gvU2l0ZXMvX19LaHVyYWZhdFMvTGFyYWdpc3Qub3JnL0hUTUwvcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21waWxlZC9wYWdlcy9zdXBwb3J0LnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLnRlbXBsYXRlKVxuICB9XG59KSgpfSIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdpc3Q6IFtdLFxuICAgICAgICAgICAgdXNlcjogdGhpcy4kcm91dGUucGFyYW1zLnVzZXIsXG4gICAgICAgICAgICBuYW1lOiB0aGlzLiRyb3V0ZS5wYXJhbXMubmFtZSxcbiAgICAgICAgICAgIHJlYWRtZTogJycsXG4gICAgICAgICAgICB2ZXJzaW9uX2lkOiAnJyxcbiAgICAgICAgICAgIHZlcnNpb246IFtdLFxuICAgICAgICAgICAgdmVyc2lvbnNMaXN0UHVsbGVkOiAwLFxuICAgICAgICAgICAgcmVhZG1lUHVsbGVkOiAwLFxuICAgICAgICAgICAgdmVyc2lvblB1bGxlZDogMCxcbiAgICAgICAgICAgIHNlbGVjdGVkVmVyc2lvbjogW11cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcbiAgICAgICAgdGhpcy5mZXRjaEdpc3QoKTtcbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuICAgICAgICBmZXRjaEdpc3Q6IGZ1bmN0aW9uIGZldGNoR2lzdCgpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgY2xpZW50KHsgcGF0aDogJy9wYWNrYWdlcy8nICsgdGhpcy51c2VyICsgJy8nICsgdGhpcy5uYW1lIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5naXN0ID0gcmVzcG9uc2UuZW50aXR5LmRhdGFbJ3BhY2thZ2UnXTtcbiAgICAgICAgICAgICAgICB0aGF0LnZlcnNpb25faWQgPSB0aGF0Lmdpc3QudmVyc2lvbjtcbiAgICAgICAgICAgICAgICB0aGF0LnNlbGVjdGVkVmVyc2lvbiA9IHRoYXQuZ2lzdC5sYXRlc3Q7XG4gICAgICAgICAgICAgICAgdGhhdC5zZWxlY3RlZFZlcnNpb24ucmVxdWlyZV9kZXYgPSB0aGF0Lmdpc3QubGF0ZXN0WydyZXF1aXJlLWRldiddO1xuICAgICAgICAgICAgICAgIHRoYXQuZ2V0cmVhZG1lKHRoYXQudmVyc2lvbl9pZCk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3JSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdlcnJvcicpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdmVyc2lvbnNMaXN0OiBmdW5jdGlvbiB2ZXJzaW9uc0xpc3QoKSB7fSxcblxuICAgICAgICBnZXRyZWFkbWU6IGZ1bmN0aW9uIGdldHJlYWRtZSh2ZXJzaW9uKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vQ3JlYXRpbmcgZHVtbXkgYSBlbGVtZW50IHRvIHBhcnNlIHJlcG9zaXRvcnkgdXJsXG4gICAgICAgICAgICB2YXIgdXJsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICAgICAgdXJsLmhyZWYgPSB0aGlzLmdpc3QucmVwb3NpdG9yeTtcblxuICAgICAgICAgICAgaWYgKHVybC5ob3N0bmFtZSA9PSAnZ2l0aHViLmNvbScpIHZhciBob3N0ID0gXCJodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb217cmVwb30vXCI7ZWxzZSBpZiAodXJsLmhvc3RuYW1lID09ICdiaXRidWNrZXQub3JnJykgdmFyIGhvc3QgPSBcImh0dHBzOi8vYml0YnVja2V0Lm9yZ3tyZXBvfS9yYXcvXCI7XG5cbiAgICAgICAgICAgIHZhciBwYXRobmFtZSA9IHVybC5wYXRobmFtZS5yZXBsYWNlKCcuZ2l0JywgJycpO1xuICAgICAgICAgICAgaG9zdCA9IGhvc3QucmVwbGFjZSgne3JlcG99JywgcGF0aG5hbWUpO1xuXG4gICAgICAgICAgICB0aGlzLiRodHRwKHsgdXJsOiBob3N0ICsgdmVyc2lvbiArICcvcmVhZG1lLm1kJyB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHRoYXQucmVhZG1lID0gY29udmVydGVyLm1ha2VIdG1sKHJlc3BvbnNlLmRhdGEpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRodHRwKHsgdXJsOiBob3N0ICsgdmVyc2lvbiArICcvUkVBRE1FLm1kJyB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGF0LnJlYWRtZSA9IGNvbnZlcnRlci5tYWtlSHRtbChyZXNwb25zZS5kYXRhKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNlbGVjdFZlcnNpb246IGZ1bmN0aW9uIHNlbGVjdFZlcnNpb24oKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnNlbGVjdGVkVmVyc2lvbik7XG5cbiAgICAgICAgICAgIHRoaXMuZ2V0cmVhZG1lKHRoaXMuc2VsZWN0ZWRWZXJzaW9uLnZlcnNpb24pO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFZlcnNpb24ucmVxdWlyZV9kZXYgPSB0aGF0LnNlbGVjdGVkVmVyc2lvbi5sYXRlc3RbJ3JlcXVpcmUtZGV2J107XG4gICAgICAgIH1cblxuICAgIH1cbn07XG47KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiPyBtb2R1bGUuZXhwb3J0cy5vcHRpb25zOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBcIlxcblxcbjxuYXYtY29tcG9uZW50PjwvbmF2LWNvbXBvbmVudD5cXG4gICAgXFxuICAgIDxkaXYgY2xhc3M9XFxcInBhY2thZ2VcXFwiPlxcblxcbiAgICAgICAgPHNlY3Rpb24gY2xhc3M9XFxcIndlbGNvbWVcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbnRhaW5lclxcXCI+XFxuICAgICAgICAgICAgICAgIDxoMj5cXG4gICAgICAgICAgICAgICAgICAgIHt7IHNlbGVjdGVkVmVyc2lvbi5uYW1lIH19IFxcbiAgICAgICAgICAgICAgICAgICAgPHNtYWxsIGNsYXNzPVxcXCJsYXRlc3RcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1mdyBmYS1jb2RlLWZvcmtcXFwiPjwvaT5cXG4gICAgICAgICAgICAgICAgICAgICAgICB7eyBzZWxlY3RlZFZlcnNpb24udmVyc2lvbiB9fVxcbiAgICAgICAgICAgICAgICAgICAgPC9zbWFsbD5cXG4gICAgICAgICAgICAgICAgPC9oMj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY2F0c1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8dWwgY2xhc3M9XFxcImxpc3QtaW5saW5lIHB1bGwtcmlnaHRcXFwiIHYtc2hvdz1cXFwic2VsZWN0ZWRWZXJzaW9uLmxpY2Vuc2VzWzBdXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8bGk+PGkgY2xhc3M9XFxcImZhIGZhLWZ3IGZhLWNvcHlyaWdodFxcXCI+PC9pPjwvbGk+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpIHYtZm9yPVxcXCJsaWNlbnNlIGluIHNlbGVjdGVkVmVyc2lvbi5saWNlbnNlc1xcXCI+e3tsaWNlbnNlfX08L2xpPlxcbiAgICAgICAgICAgICAgICAgICAgPC91bD5cXG4gICAgICAgICAgICAgICAgICAgIDx1bCBjbGFzcz1cXFwibGlzdC1pbmxpbmVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaT48aSBjbGFzcz1cXFwiZmEgZmEtZncgZmEtYmFyc1xcXCI+PC9pPjwvbGk+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpIHYtZm9yPVxcXCJjYXQgaW4gZ2lzdC5jYXRlZ29yaWVzXFxcIj57e2NhdC5uYW1lfX08L2xpPlxcbiAgICAgICAgICAgICAgICAgICAgPC91bD5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L3NlY3Rpb24+XFxuXFxuICAgICAgICA8c2VjdGlvbiBjbGFzcz1cXFwiY29udGVudFxcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29udGFpbmVyXFxcIj5cXG5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj4gPCEtLSAgVE9QIFJPVyAgLS0+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtOFxcXCI+XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaW5zdGFsbFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1mdyBmYS1kb3dubG9hZFxcXCI+PC9pPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Y29kZT5jb21wb3NlciByZXF1aXJlIHt7IHNlbGVjdGVkVmVyc2lvbi5uYW1lIH19PC9jb2RlPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImRlc2NyaXB0aW9uIGJsb2NrXFxcIiB2LXNob3c9XFxcImdpc3QuZGVzY3JpcHRpb25cXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8IS0tIDxkaXYgY2xhc3M9XFxcInBhZ2UtaGVhZGVyXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxoMz5EZXNjcmlwdGlvbjwvaDM+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PiAtLT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHA+e3tzZWxlY3RlZFZlcnNpb24uZGVzY3JpcHRpb259fTwvcD5cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHVsIGNsYXNzPVxcXCJsaXN0LWlubGluZSB0YWdzXFxcIiB2LXNob3c9XFxcInNlbGVjdGVkVmVyc2lvbi5rZXl3b3Jkc1swXVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGk+PGkgY2xhc3M9XFxcImZhIGZhLWZ3IGZhLXRhZ3NcXFwiPjwvaT48L2xpPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpIHYtZm9yPVxcXCJrZXl3b3JkIGluIHNlbGVjdGVkVmVyc2lvbi5rZXl3b3Jkc1xcXCI+I3t7a2V5d29yZH19PC9saT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC91bD5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG5cXG5cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgPCEtLSAgVEhJUkQgUk9XICAtLT5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJibG9ja1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInJlYWRtZVxcXCIgdi1iaW5kOmNsYXNzPVxcXCJ7J3JlYWRtZS1saW1pdCc6ICFyZWFkbWVQdWxsZWR9XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7eyByZWFkbWUgfX19XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJwdWxsLW92ZXJcXFwiIHYtc2hvdz1cXFwiIXJlYWRtZVB1bGxlZFxcXCIgdi1vbjpjbGljaz1cXFwicmVhZG1lUHVsbGVkPTFcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1jYXJldC1kb3duXFxcIj48L2k+PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPCEtLSAgVEhJUkQgUk9XICAtLT5cXG5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTQgZGV0YWlsc1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiYmxvY2tcXFwiPlxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGVtcGxhdGUgdi1pZj1cXFwic2VsZWN0ZWRWZXJzaW9uLmF1dGhvcnMubGVuZ3RoID4gMVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dWwgY2xhc3M9XFxcImxpc3QtaW5saW5lIGF1dGhvcnNcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaSB2LWZvcj1cXFwiYXV0aG9yIGluIHNlbGVjdGVkVmVyc2lvbi5hdXRob3JzXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9XFxcIi8vd3d3LmdyYXZhdGFyLmNvbS9hdmF0YXIve3sgYXV0aG9yLmVtYWlsX2hhc2h9fT9zPTEwMFxcXCIgYWx0PVxcXCJ7eyBhdXRob3IubmFtZSB9fVxcXCIgdGl0bGU9XFxcInt7IGF1dGhvci5uYW1lIH19XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGg0Pnt7IGF1dGhvci5uYW1lIH19PC9oND5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC91bD5cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxocj5cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInN0YXRzXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtNlxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aDM+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLWRvd25sb2FkXFxcIj48L2k+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3sgZ2lzdC5kb3dubG9hZHNfdG90YWx9fVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9oMz5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC02XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxoMz5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtaGVhcnRcXFwiPjwvaT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7eyBnaXN0LmZhdm9yaXRlcyB9fVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9oMz5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90ZW1wbGF0ZT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlIHYtaWY9XFxcInNlbGVjdGVkVmVyc2lvbi5hdXRob3JzLmxlbmd0aCA9PSAxXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTZcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dWwgY2xhc3M9XFxcImxpc3QtaW5saW5lIGF1dGhvcnMtYWx0XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaSB2LWZvcj1cXFwiYXV0aG9yIGluIGdpc3QuYXV0aG9yc1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9XFxcIi8vd3d3LmdyYXZhdGFyLmNvbS9hdmF0YXIve3sgYXV0aG9yLmVtYWlsX2hhc2h9fT9zPTEyMFxcXCIgYWx0PVxcXCJ7eyBhdXRob3IubmFtZSB9fVxcXCIgdGl0bGU9XFxcInt7IGF1dGhvci5uYW1lIH19XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aDQ+e3sgYXV0aG9yLm5hbWUgfX08L2g0PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC91bD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtNlxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInN0YXRzLWFsdFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJib3hcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1kb3dubG9hZFxcXCI+PC9pPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxoMz57eyBnaXN0LmRvd25sb2Fkc190b3RhbCB9fTwvaDM+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImJveFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLWhlYXJ0XFxcIj48L2k+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGgzPnt7IGdpc3QuZmF2b3JpdGVzIH19PC9oMz5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RlbXBsYXRlPlxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJidG5zIGJ0bi1ncm91cCBidG4tZ3JvdXAtanVzdGlmaWVkXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcInt7IGdpc3QucmVwb3NpdG9yeSB9fVxcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHQgcmVwb3NpdG9yeVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVmlldyBTb3VyY2VcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcInt7IGdpc3QuaG9tZXBhZ2UgfX1cXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0IGhvbWVwYWdlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWaXNpdCBIb21lcGFnZVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICA8IS0tIDxkaXYgY2xhc3M9XFxcImJsb2NrXFxcIiB2LWJpbmQ6Y2xhc3M9XFxcInsndmVyc2lvbi1zZWxlY3RvcicgOiB2ZXJzaW9uc0xpc3RQdWxsZWQhPTF9XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHVsPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpIHYtZm9yPVxcXCJ2ZXJzaW9uIGluIGdpc3QudmVyc2lvbnNcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIiNcXFwiPnt7dmVyc2lvbi52ZXJzaW9ufX08L2E+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3VsPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJwdWxsLW92ZXJcXFwiIHYtc2hvdz1cXFwiIXZlcnNpb25zTGlzdFB1bGxlZFxcXCIgdi1vbjpjbGljaz1cXFwidmVyc2lvbnNMaXN0UHVsbGVkPTFcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1jYXJldC1kb3duXFxcIj48L2k+PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+IC0tPlxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInZlcnNpb24gYmxvY2tcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJcXFwiIHYtYmluZDpjbGFzcz1cXFwieyd2ZXJzaW9uLWxpbWl0JzogIXZlcnNpb25QdWxsZWR9XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzZWxlY3Qgdi1tb2RlbD1cXFwic2VsZWN0ZWRWZXJzaW9uXFxcIiB2LW9uOmNoYW5nZT1cXFwic2VsZWN0VmVyc2lvblxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2LWZvcj1cXFwidmVyc2lvbiBpbiBnaXN0LnZlcnNpb25zXFxcIiB2LWJpbmQ6dmFsdWU9XFxcInZlcnNpb25cXFwiPnt7dmVyc2lvbi52ZXJzaW9ufX08L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHA+e3sgdmVyc2lvbi50aW1lIH19PC9wPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aHI+XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IHYtc2hvdz1cXFwic2VsZWN0ZWRWZXJzaW9uLnJlcXVpcmVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxoND5yZXF1aXJlczwvaDQ+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHVsPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGkgdi1mb3I9XFxcIihwYWNrYWdlLCBudW1iZXIpIGluIHNlbGVjdGVkVmVyc2lvbi5yZXF1aXJlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcImh0dHBzOi8vcGFja2FnaXN0Lm9yZy9wYWNrYWdlcy97eyBwYWNrYWdlIH19XFxcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCI+e3sgcGFja2FnZSB9fTwvYT46IHt7bnVtYmVyfX1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3VsPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IHYtc2hvdz1cXFwic2VsZWN0ZWRWZXJzaW9uLnJlcXVpcmVfZGV2XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aDQ+cmVxdWlyZXMgKGRldik8L2g0PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx1bD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpIHYtZm9yPVxcXCIocGFja2FnZSwgbnVtYmVyKSBpbiBzZWxlY3RlZFZlcnNpb24ucmVxdWlyZV9kZXZcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiaHR0cHM6Ly9wYWNrYWdpc3Qub3JnL3BhY2thZ2VzL3t7IHBhY2thZ2UgfX1cXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIj57eyBwYWNrYWdlIH19PC9hPjoge3tudW1iZXJ9fVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdWw+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgdi1zaG93PVxcXCJzZWxlY3RlZFZlcnNpb24uc3VnZ2VzdFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGg0PnN1Z2dlc3RzPC9oND5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dWw+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaSB2LWZvcj1cXFwiKHBhY2thZ2UsIG51bWJlcikgaW4gc2VsZWN0ZWRWZXJzaW9uLnN1Z2dlc3RcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiaHR0cHM6Ly9wYWNrYWdpc3Qub3JnL3BhY2thZ2VzL3t7IHBhY2thZ2UgfX1cXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIj57eyBwYWNrYWdlIH19PC9hPjoge3tudW1iZXJ9fVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdWw+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgdi1zaG93PVxcXCJzZWxlY3RlZFZlcnNpb24ucHJvdmlkZXNcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxoND5wcm92aWRlczwvaDQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHVsPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGkgdi1mb3I9XFxcIihwYWNrYWdlLCBudW1iZXIpIGluIHNlbGVjdGVkVmVyc2lvbi5wcm92aWRlc1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7eyBwYWNrYWdlIH19OiB7e251bWJlcn19XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC91bD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiB2LXNob3c9XFxcInNlbGVjdGVkVmVyc2lvbi5jb25mbGljdHNcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxoND5jb25mbGljdHM8L2g0PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx1bD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpIHYtZm9yPVxcXCIocGFja2FnZSwgbnVtYmVyKSBpbiBzZWxlY3RlZFZlcnNpb24uY29uZmxpY3RzXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7IHBhY2thZ2UgfX06IHt7bnVtYmVyfX1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3VsPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IHYtc2hvdz1cXFwic2VsZWN0ZWRWZXJzaW9uLnJlcGxhY2VzXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aDQ+cmVwbGFjZXM8L2g0PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx1bD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpIHYtZm9yPVxcXCIocGFja2FnZSwgbnVtYmVyKSBpbiBzZWxlY3RlZFZlcnNpb24ucmVwbGFjZXNcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3sgcGFja2FnZSB9fToge3tudW1iZXJ9fVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdWw+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInB1bGwtb3ZlclxcXCIgdi1zaG93PVxcXCIhdmVyc2lvblB1bGxlZFxcXCIgdi1vbjpjbGljaz1cXFwidmVyc2lvblB1bGxlZD0xXFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtY2FyZXQtZG93blxcXCI+PC9pPjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PjwhLS0gIHZlcnNpb24gYmxvY2sgIC0tPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvZGl2PiA8IS0tICBTRUNPTkQgUk9XICAtLT5cXG5cXG5cXG4gICAgICAgICAgICAgICBcXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvc2VjdGlvbj5cXG5cXG4gICAgPC9kaXY+XFxuXFxuPGZvb3Rlci1jb21wb25lbnQ+PC9mb290ZXItY29tcG9uZW50PlxcblwiXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIi9Vc2Vycy9tZVNpbmdoL1NpdGVzL19fS2h1cmFmYXRTL0xhcmFnaXN0Lm9yZy9IVE1ML3Jlc291cmNlcy9hc3NldHMvanMvY29tcGlsZWQvcGFnZXMvdmlldy52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy50ZW1wbGF0ZSlcbiAgfVxufSkoKX0iLCJ2YXIgY29uZmlnID0ge1xuICBlbnY6ICdkZXZlbG9wbWVudCcsXG4gIGFwaToge1xuICAgIGJhc2VfdXJsOiAnaHR0cDovL2ludGVybmFsLWFwaS5sYXJhZ2lzdC5vcmcvdjEnLFxuICAgIGRlZmF1bHRSZXF1ZXN0OiB7XG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdYLVJlcXVlc3RlZC1XaXRoJzogJ3Jlc3QuanMnLFxuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBzb2NpYWw6IHtcbiAgICBmYWNlYm9vazogJycsXG4gICAgdHdpdHRlcjogJycsXG4gICAgZ2l0aHViOiAna2h1cmFmYXQnXG4gIH0sXG4gIGRlYnVnOiB0cnVlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29uZmlnXG4iLCJ2YXIgZW52ID0gcHJvY2Vzcy5lbnYuQVBQX0VOViB8fCAnZGV2ZWxvcG1lbnQnXG5cbnZhciBjb25maWcgPSB7XG4gIGRldmVsb3BtZW50OiByZXF1aXJlKCcuL2RldmVsb3BtZW50LmNvbmZpZycpLFxuICBwcm9kdWN0aW9uOiByZXF1aXJlKCcuL3Byb2R1Y3Rpb24uY29uZmlnJyksXG4gIHN0YWdpbmc6IHJlcXVpcmUoJy4vc3RhZ2luZy5jb25maWcnKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbmZpZ1tlbnZdXG4iLCJ2YXIgY29uZmlnID0ge1xuICBlbnY6ICdwcm9kdWN0aW9uJyxcbiAgYXBpOiB7XG4gICAgYmFzZV91cmw6ICdodHRwOi8vaW50ZXJuYWwtYXBpLmxhcmFnaXN0Lm9yZy92MScsXG4gICAgZGVmYXVsdFJlcXVlc3Q6IHtcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ1gtUmVxdWVzdGVkLVdpdGgnOiAncmVzdC5qcycsXG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHNvY2lhbDoge1xuICAgIGZhY2Vib29rOiAnJyxcbiAgICB0d2l0dGVyOiAnJyxcbiAgICBnaXRodWI6ICcnXG4gIH0sXG4gIGRlYnVnOiBmYWxzZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbmZpZ1xuIiwidmFyIGNvbmZpZyA9IHtcbiAgZW52OiAnc3RhZ2luZycsXG4gIGFwaToge1xuICAgIGJhc2VfdXJsOiAnaHR0cDovL2ludGVybmFsLWFwaS5sYXJhZ2lzdC5vcmcvdjEnLFxuICAgIGRlZmF1bHRSZXF1ZXN0OiB7XG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdYLVJlcXVlc3RlZC1XaXRoJzogJ3Jlc3QuanMnLFxuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBzb2NpYWw6IHtcbiAgICBmYWNlYm9vazogJycsXG4gICAgdHdpdHRlcjogJycsXG4gICAgZ2l0aHViOiAnJ1xuICB9LFxuICBkZWJ1ZzogdHJ1ZVxufVxubW9kdWxlLmV4cG9ydHMgPSBjb25maWdcbiIsIihmdW5jdGlvbiAoZGVmaW5lKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHRkZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUpIHtcblxuXHRcdHZhciBpbnRlcmNlcHRvcjtcblxuXHRcdGludGVyY2VwdG9yID0gcmVxdWlyZSgncmVzdC9pbnRlcmNlcHRvcicpO1xuXG5cdFx0LyoqXG5cdFx0ICogQXV0aGVudGljYXRlcyB0aGUgcmVxdWVzdCB1c2luZyBKV1QgQXV0aGVudGljYXRpb25cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7Q2xpZW50fSBbY2xpZW50XSBjbGllbnQgdG8gd3JhcFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcblx0XHQgKlxuXHRcdCAqIEByZXR1cm5zIHtDbGllbnR9XG5cdFx0ICovXG5cdFx0cmV0dXJuIGludGVyY2VwdG9yKHtcblx0XHRcdHJlcXVlc3Q6IGZ1bmN0aW9uIChyZXF1ZXN0LCBjb25maWcpIHtcblx0XHRcdFx0dmFyIHRva2VuLCBoZWFkZXJzO1xuXG5cdFx0XHRcdHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2p3dC10b2tlbicpO1xuXHRcdFx0XHRoZWFkZXJzID0gcmVxdWVzdC5oZWFkZXJzIHx8IChyZXF1ZXN0LmhlYWRlcnMgPSB7fSk7XG5cblx0XHRcdFx0aWYgKCB0b2tlbiAhPT0gbnVsbCAmJiB0b2tlbiAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0XHRoZWFkZXJzLkF1dGhvcml6YXRpb24gPSB0b2tlbjtcblx0XHRcdFx0fVxuXG5cdFx0ICAgIFx0cmV0dXJuIHJlcXVlc3Q7XG5cdFx0XHR9LFxuXHRcdFx0cmVzcG9uc2U6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHRcdFx0XHRpZiAocmVzcG9uc2Uuc3RhdHVzICYmIHJlc3BvbnNlLnN0YXR1cy5jb2RlID09IDQwMSkge1xuXHRcdFx0XHRcdGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdqd3QtdG9rZW4nKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocmVzcG9uc2UuaGVhZGVycyAmJiByZXNwb25zZS5oZWFkZXJzLkF1dGhvcml6YXRpb24pIHtcblx0XHRcdFx0XHRsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnand0LXRva2VuJywgcmVzcG9uc2UuaGVhZGVycy5BdXRob3JpemF0aW9uKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChyZXNwb25zZS5lbnRpdHkgJiYgcmVzcG9uc2UuZW50aXR5LnRva2VuICYmIHJlc3BvbnNlLmVudGl0eS50b2tlbi5sZW5ndGggPiAxMCkge1xuXHRcdFx0XHRcdGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdqd3QtdG9rZW4nLCAnQmVhcmVyICcgKyByZXNwb25zZS5lbnRpdHkudG9rZW4pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiByZXNwb25zZTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHR9KTtcblxufShcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24gKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUpOyB9XG5cdC8vIEJvaWxlcnBsYXRlIGZvciBBTUQgYW5kIE5vZGVcbikpOyIsIm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIGNvbmZpZ1JvdXRlcjogZnVuY3Rpb24gKHJvdXRlcikge1xuXG4gICAgcm91dGVyLm1hcCh7XG4gICAgICAnL2F1dGgnOiB7XG4gICAgICAgIGNvbXBvbmVudDogcmVxdWlyZSgnLi9jb21waWxlZC9wYWdlcy9hdXRoLnZ1ZScpLFxuICAgICAgICBzdWJSb3V0ZXM6IHtcbiAgICAgICAgICAnL2xvZ2luJzoge1xuICAgICAgICAgICAgY29tcG9uZW50OiByZXF1aXJlKCcuL2NvbXBpbGVkL3BhZ2VzL2F1dGgvbG9naW4udnVlJyksXG4gICAgICAgICAgICBndWVzdDogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgJy9yZWdpc3Rlcic6IHtcbiAgICAgICAgICAgIGNvbXBvbmVudDogcmVxdWlyZSgnLi9jb21waWxlZC9wYWdlcy9hdXRoL3JlZ2lzdGVyLnZ1ZScpLFxuICAgICAgICAgICAgZ3Vlc3Q6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgICcvcHJvZmlsZSc6IHtcbiAgICAgICAgICAgIGNvbXBvbmVudDogcmVxdWlyZSgnLi9jb21waWxlZC9wYWdlcy9hdXRoL3Byb2ZpbGUudnVlJyksXG4gICAgICAgICAgICBhdXRoOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICAnL2xvZ291dCc6IHtcbiAgICAgICAgICAgIGNvbXBvbmVudDogcmVxdWlyZSgnLi9jb21waWxlZC9wYWdlcy9hdXRoL2xvZ291dC52dWUnKSxcbiAgICAgICAgICAgIGF1dGg6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAnL2hvbWUnOiB7XG4gICAgICAgIGNvbXBvbmVudDogcmVxdWlyZSgnLi9jb21waWxlZC9wYWdlcy9ob21lLnZ1ZScpLFxuICAgICAgICBzdWJSb3V0ZXM6IHtcbiAgICAgICAgICAnLyc6IHtcbiAgICAgICAgICAgIGNvbXBvbmVudDogcmVxdWlyZSgnLi9jb21waWxlZC9wYWdlcy9ob21lL2hvbWUudnVlJylcbiAgICAgICAgICB9LFxuICAgICAgICAgICcvd2VsY29tZSc6IHtcbiAgICAgICAgICAgIGNvbXBvbmVudDogcmVxdWlyZSgnLi9jb21waWxlZC9wYWdlcy9ob21lL3dlbGNvbWUudnVlJylcbiAgICAgICAgICB9LFxuICAgICAgICAgICcvYWJvdXQnOiB7XG4gICAgICAgICAgICBjb21wb25lbnQ6IHJlcXVpcmUoJy4vY29tcGlsZWQvcGFnZXMvaG9tZS9hYm91dC52dWUnKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICcvc3VibWl0Jzoge1xuICAgICAgICBjb21wb25lbnQ6IHJlcXVpcmUoJy4vY29tcGlsZWQvcGFnZXMvc3VibWl0LnZ1ZScpLFxuICAgICAgICBzdWJSb3V0ZXM6IHtcbiAgICAgICAgICAnLyc6IHtcbiAgICAgICAgICAgIGNvbXBvbmVudDogcmVxdWlyZSgnLi9jb21waWxlZC9wYWdlcy9kb2dzL2luZGV4LnZ1ZScpXG4gICAgICAgICAgfSxcbiAgICAgICAgICAnLzppZCc6IHtcbiAgICAgICAgICAgIGNvbXBvbmVudDogcmVxdWlyZSgnLi9jb21waWxlZC9wYWdlcy9kb2dzL3Nob3cudnVlJylcbiAgICAgICAgICB9LFxuICAgICAgICAgICcvY3JlYXRlJzoge1xuICAgICAgICAgICAgY29tcG9uZW50OiByZXF1aXJlKCcuL2NvbXBpbGVkL3BhZ2VzL2RvZ3MvY3JlYXRlLnZ1ZScpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgJy9wYWNrYWdlcy86dXNlci86bmFtZSc6IHtcbiAgICAgICAgbmFtZTondmlldycsXG4gICAgICAgIGNvbXBvbmVudDogcmVxdWlyZSgnLi9jb21waWxlZC9wYWdlcy92aWV3LnZ1ZScpXG4gICAgICB9LFxuICAgICAgJy9hYm91dCc6IHtcbiAgICAgICAgbmFtZTonYWJvdXQnLFxuICAgICAgICBjb21wb25lbnQ6IHJlcXVpcmUoJy4vY29tcGlsZWQvcGFnZXMvYWJvdXQudnVlJylcbiAgICAgIH0sXG4gICAgICAnL3N1cHBvcnQnOiB7XG4gICAgICAgIG5hbWU6J2Fib3V0JyxcbiAgICAgICAgY29tcG9uZW50OiByZXF1aXJlKCcuL2NvbXBpbGVkL3BhZ2VzL3N1cHBvcnQudnVlJylcbiAgICAgIH0sXG4gICAgICAnKic6IHtcbiAgICAgICAgY29tcG9uZW50OiByZXF1aXJlKCcuL2NvbXBpbGVkL3BhZ2VzLzQwNC52dWUnKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByb3V0ZXIuYWxpYXMoe1xuICAgICAgJyc6ICcvaG9tZScsXG4gICAgICAnL2F1dGgnOiAnL2F1dGgvbG9naW4nXG4gICAgfSlcblxuICAgIHJvdXRlci5iZWZvcmVFYWNoKGZ1bmN0aW9uICh0cmFuc2l0aW9uKSB7XG5cbiAgICAgIHZhciB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdqd3QtdG9rZW4nKVxuICAgICAgaWYgKHRyYW5zaXRpb24udG8uYXV0aCkge1xuICAgICAgICBpZiAoIXRva2VuIHx8IHRva2VuID09PSBudWxsKSB7XG4gICAgICAgICAgdHJhbnNpdGlvbi5yZWRpcmVjdCgnL2F1dGgvbG9naW4nKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHJhbnNpdGlvbi50by5ndWVzdCkge1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICB0cmFuc2l0aW9uLnJlZGlyZWN0KCcvJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdHJhbnNpdGlvbi5uZXh0KClcbiAgICB9KVxuICB9XG59XG4iXX0=\n"],"file":"app.js","sourceRoot":"/source/"}